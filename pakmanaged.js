var global = Function("return this;")();
/*!
  * Ender: open module JavaScript framework (client-lib)
  * copyright Dustin Diaz & Jacob Thornton 2011 (@ded @fat)
  * http://ender.no.de
  * License MIT
  */
!function (context) {

  // a global object for node.js module compatiblity
  // ============================================

  context['global'] = context

  // Implements simple module system
  // losely based on CommonJS Modules spec v1.1.1
  // ============================================

  var modules = {}
    , old = context.$

  function require (identifier) {
    // modules can be required from ender's build system, or found on the window
    var module = modules[identifier] || window[identifier]
    if (!module) throw new Error("Requested module '" + identifier + "' has not been defined.")
    return module
  }

  function provide (name, what) {
    return (modules[name] = what)
  }

  context['provide'] = provide
  context['require'] = require

  function aug(o, o2) {
    for (var k in o2) k != 'noConflict' && k != '_VERSION' && (o[k] = o2[k])
    return o
  }

  function boosh(s, r, els) {
    // string || node || nodelist || window
    if (typeof s == 'string' || s.nodeName || (s.length && 'item' in s) || s == window) {
      els = ender._select(s, r)
      els.selector = s
    } else els = isFinite(s.length) ? s : [s]
    return aug(els, boosh)
  }

  function ender(s, r) {
    return boosh(s, r)
  }

  aug(ender, {
      _VERSION: '0.3.6'
    , fn: boosh // for easy compat to jQuery plugins
    , ender: function (o, chain) {
        aug(chain ? boosh : ender, o)
      }
    , _select: function (s, r) {
        return (r || document).querySelectorAll(s)
      }
  })

  aug(boosh, {
    forEach: function (fn, scope, i) {
      // opt out of native forEach so we can intentionally call our own scope
      // defaulting to the current item and be able to return self
      for (i = 0, l = this.length; i < l; ++i) i in this && fn.call(scope || this[i], this[i], i, this)
      // return self for chaining
      return this
    },
    $: ender // handy reference to self
  })

  ender.noConflict = function () {
    context.$ = old
    return this
  }

  if (typeof module !== 'undefined' && module.exports) module.exports = ender
  // use subscript notation as extern for Closure compilation
  context['ender'] = context['$'] = context['ender'] || ender

}(this);
// pakmanager:align-text
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * align-text <https://github.com/jonschlinkert/align-text>
     *
     * Copyright (c) 2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var typeOf = require('kind-of');
    var repeat = require('repeat-string');
    var longest = require('longest');
    
    module.exports = function alignText(val, fn) {
      var lines, type = typeOf(val);
    
      if (type === 'array') {
        lines = val;
      } else if (type === 'string') {
        lines = val.split(/[\r\n]/);
      } else {
        throw new TypeError('align-text expects a string or array.');
      }
    
      var len = lines.length;
      var max = longest(lines);
      var res = [], i = 0;
    
      while (len--) {
        var line = lines[i++];
        var diff = typeof fn === 'function'
          ? fn(line.length, max.length, line, lines, i)
          : typeof fn === 'number' ? fn : 0;
    
        if (typeOf(diff) === 'number') {
          res.push(repeat(' ', diff) + line);
        } else if (typeOf(diff) === 'object') {
          var result = repeat(diff.character || ' ', diff.indent || 0);
          res.push((diff.prefix || '') + result + line);
        }
      }
    
      if (type === 'array') return res;
      return res.join('\n');
    };
    
  provide("align-text", module.exports);
}(global));

// pakmanager:kind-of
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var toString = Object.prototype.toString;
    
    /**
     * Get the native `typeof` a value.
     *
     * @param  {*} `val`
     * @return {*} Native javascript type
     */
    
    module.exports = function kindOf(val) {
      if (val === undefined) {
        return 'undefined';
      }
      if (val === null) {
        return 'null';
      }
      if (val === true || val === false || val instanceof Boolean) {
        return 'boolean';
      }
      if (typeof val !== 'object') {
        return typeof val;
      }
      if (Array.isArray(val)) {
        return 'array';
      }
    
      var type = toString.call(val);
    
      if (val instanceof RegExp || type === '[object RegExp]') {
        return 'regexp';
      }
      if (val instanceof Date || type === '[object Date]') {
        return 'date';
      }
      if (type === '[object Function]') {
        return 'function';
      }
      if (type === '[object Arguments]') {
        return 'arguments';
      }
      if (typeof Buffer !== 'undefined' && Buffer.isBuffer(val)) {
        return 'buffer';
      }
      return type.slice(8, -1).toLowerCase();
    };
    
  provide("kind-of", module.exports);
}(global));

// pakmanager:longest
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * longest <https://github.com/jonschlinkert/longest>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    module.exports = function(arr) {
      if (!arr) {
        return null;
      }
    
      var len = arr.length;
      if (!len) {
        return null;
      }
    
      var c = 0;
      var i = 0;
      var ele;
      var elen;
      var res;
    
      for (; i < len; i++) {
        ele = arr[i].toString();
        elen = ele.length;
    
        if (elen > c) {
          res = ele;
          c = elen;
        }
      }
    
      return res;
    };
    
  provide("longest", module.exports);
}(global));

// pakmanager:repeat-string
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * repeat-string <https://github.com/jonschlinkert/repeat-string>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    /**
     * Expose `repeat`
     */
    
    module.exports = repeat;
    
    /**
     * Repeat the given `string` the specified `number`
     * of times.
     *
     * **Example:**
     *
     * ```js
     * var repeat =  require('repeat-string');
     * repeat('A', 5);
     * //=> AAAAA
     * ```
     *
     * @param {String} `string` The string to repeat
     * @param {Number} `number` The number of times to repeat the string
     * @return {String} Repeated string
     * @api public
     */
    
    function repeat(str, num) {
      if (typeof str !== 'string') {
        throw new TypeError('repeat-string expects a string.');
      }
    
      if (num === 1) return str;
      if (num === 2) return str + str;
    
      var max = str.length * num;
      if (cache !== str || typeof cache === 'undefined') {
        cache = str;
        res = '';
      }
    
      while (max > res.length && num > 0) {
        if (num & 1) {
          res += str;
        }
    
        num >>= 1;
        if (!num) break;
        str += str;
      }
    
      return res.substr(0, max);
    }
    
    /**
     * Results cache
     */
    
    var res = '';
    var cache;
    
  provide("repeat-string", module.exports);
}(global));

// pakmanager:is-number
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * is-number <https://github.com/jonschlinkert/is-number>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var typeOf = require('kind-of');
    
    module.exports = function isNumber(num) {
      var type = typeOf(num);
      if (type !== 'number' && type !== 'string') {
        return false;
      }
      var n = +num;
      return (n - n + 1) >= 0 && num !== '';
    };
    
  provide("is-number", module.exports);
}(global));

// pakmanager:isobject
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * isobject <https://github.com/jonschlinkert/isobject>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    module.exports = function isObject(o) {
      return o != null && typeof o === 'object'
        && !Array.isArray(o);
    };
  provide("isobject", module.exports);
}(global));

// pakmanager:randomatic
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * randomatic <https://github.com/jonschlinkert/randomatic>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License (MIT)
     *
     * Many changes have been made, but this was originally
     * inspired by <http://stackoverflow.com/a/10727155/1267639>
     */
    
    'use strict';
    
    var isNumber = require('is-number');
    var typeOf = require('kind-of');
    
    /**
     * Expose `randomatic`
     */
    
    module.exports = randomatic;
    
    /**
     * Available mask characters
     */
    
    var type = {
      lower: 'abcdefghijklmnopqrstuvwxyz',
      upper: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
      number: '0123456789',
      special: '~!@#$%^&()_+-={}[];\',.'
    };
    
    type.all = type.lower + type.upper + type.number;
    
    /**
     * Generate random character sequences of a specified `length`,
     * based on the given `pattern`.
     *
     * @param {String} `pattern` The pattern to use for generating the random string.
     * @param {String} `length` The length of the string to generate.
     * @param {String} `options`
     * @return {String}
     * @api public
     */
    
    function randomatic(pattern, length, options) {
      if (typeof pattern === 'undefined') {
        throw new Error('randomatic expects a string or number.');
      }
    
      var custom = false;
      if (arguments.length === 1) {
        if (typeof pattern === 'string') {
          length = pattern.length;
    
        } else if (isNumber(pattern)) {
          options = {}; length = pattern; pattern = '*';
        }
      }
    
      if(typeOf(length) === 'object' && length.hasOwnProperty('chars')) {
        options = length;
        pattern = options.chars;
        length = pattern.length;
        custom = true;
      }
    
      var opts = options || {};
      var mask = '';
      var res = '';
    
      // Characters to be used
      if (pattern.indexOf('?') !== -1) mask += opts.chars;
      if (pattern.indexOf('a') !== -1) mask += type.lower;
      if (pattern.indexOf('A') !== -1) mask += type.upper;
      if (pattern.indexOf('0') !== -1) mask += type.number;
      if (pattern.indexOf('!') !== -1) mask += type.special;
      if (pattern.indexOf('*') !== -1) mask += type.all;
      if (custom) mask += pattern;
    
      while (length--) {
        res += mask.charAt(parseInt(Math.random() * mask.length));
      }
    
      return res;
    };
    
  provide("randomatic", module.exports);
}(global));

// pakmanager:repeat-element
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * repeat-element <https://github.com/jonschlinkert/repeat-element>
     *
     * Copyright (c) 2015 Jon Schlinkert.
     * Licensed under the MIT license.
     */
    
    'use strict';
    
    module.exports = function repeat(ele, num) {
      var arr = new Array(num);
    
      for (var i = 0; i < num; i++) {
        arr[i] = ele;
      }
    
      return arr;
    };
    
  provide("repeat-element", module.exports);
}(global));

// pakmanager:is-glob
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * is-glob <https://github.com/jonschlinkert/is-glob>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    module.exports = function isGlob(str) {
      return typeof str === 'string'
        && /[@!*+{}?(|)[\]]/.test(str);
    };
  provide("is-glob", module.exports);
}(global));

// pakmanager:center-align
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * center-align <https://github.com/jonschlinkert/center-align>
     *
     * Copycenter (c) 2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var align = require('align-text');
    
    module.exports = function centerAlign(val) {
      return align(val, function (len, longest) {
        return Math.floor((longest - len) / 2);
      });
    };
    
  provide("center-align", module.exports);
}(global));

// pakmanager:right-align
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * right-align <https://github.com/jonschlinkert/right-align>
     *
     * Copyright (c) 2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var align = require('align-text');
    
    module.exports = function rightAlign(val) {
      return align(val, function (len, longest) {
        return longest - len;
      });
    };
    
  provide("right-align", module.exports);
}(global));

// pakmanager:wordwrap
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var wordwrap = module.exports = function (start, stop, params) {
        if (typeof start === 'object') {
            params = start;
            start = params.start;
            stop = params.stop;
        }
        
        if (typeof stop === 'object') {
            params = stop;
            start = start || params.start;
            stop = undefined;
        }
        
        if (!stop) {
            stop = start;
            start = 0;
        }
        
        if (!params) params = {};
        var mode = params.mode || 'soft';
        var re = mode === 'hard' ? /\b/ : /(\S+\s+)/;
        
        return function (text) {
            var chunks = text.toString()
                .split(re)
                .reduce(function (acc, x) {
                    if (mode === 'hard') {
                        for (var i = 0; i < x.length; i += stop - start) {
                            acc.push(x.slice(i, i + stop - start));
                        }
                    }
                    else acc.push(x)
                    return acc;
                }, [])
            ;
            
            return chunks.reduce(function (lines, rawChunk) {
                if (rawChunk === '') return lines;
                
                var chunk = rawChunk.replace(/\t/g, '    ');
                
                var i = lines.length - 1;
                if (lines[i].length + chunk.length > stop) {
                    lines[i] = lines[i].replace(/\s+$/, '');
                    
                    chunk.split(/\n/).forEach(function (c) {
                        lines.push(
                            new Array(start + 1).join(' ')
                            + c.replace(/^\s+/, '')
                        );
                    });
                }
                else if (chunk.match(/\n/)) {
                    var xs = chunk.split(/\n/);
                    lines[i] += xs.shift();
                    xs.forEach(function (c) {
                        lines.push(
                            new Array(start + 1).join(' ')
                            + c.replace(/^\s+/, '')
                        );
                    });
                }
                else {
                    lines[i] += chunk;
                }
                
                return lines;
            }, [ new Array(start + 1).join(' ') ]).join('\n');
        };
    };
    
    wordwrap.soft = wordwrap;
    
    wordwrap.hard = function (start, stop) {
        return wordwrap(start, stop, { mode : 'hard' });
    };
    
  provide("wordwrap", module.exports);
}(global));

// pakmanager:fill-range
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * fill-range <https://github.com/jonschlinkert/fill-range>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var isObject = require('isobject');
    var isNumber = require('is-number');
    var randomize = require('randomatic');
    var repeatStr = require('repeat-string');
    var repeat = require('repeat-element');
    
    /**
     * Expose `fillRange`
     */
    
    module.exports = fillRange;
    
    /**
     * Return a range of numbers or letters.
     *
     * @param  {String} `a` Start of the range
     * @param  {String} `b` End of the range
     * @param  {String} `step` Increment or decrement to use.
     * @param  {Function} `fn` Custom function to modify each element in the range.
     * @return {Array}
     */
    
    function fillRange(a, b, step, options, fn) {
      if (a == null || b == null) {
        throw new Error('fill-range expects the first and second args to be strings.');
      }
    
      if (typeof step === 'function') {
        fn = step; options = {}; step = null;
      }
    
      if (typeof options === 'function') {
        fn = options; options = {};
      }
    
      if (isObject(step)) {
        options = step; step = '';
      }
    
      var expand, regex = false, sep = '';
      var opts = options || {};
    
      if (typeof opts.silent === 'undefined') {
        opts.silent = true;
      }
    
      step = step || opts.step;
    
      // store a ref to unmodified arg
      var origA = a, origB = b;
    
      b = (b.toString() === '-0') ? 0 : b;
    
      if (opts.optimize || opts.makeRe) {
        step = step ? (step += '~') : step;
        expand = true;
        regex = true;
        sep = '~';
      }
    
      // handle special step characters
      if (typeof step === 'string') {
        var match = stepRe().exec(step);
    
        if (match) {
          var i = match.index;
          var m = match[0];
    
          // repeat string
          if (m === '+') {
            return repeat(a, b);
    
          // randomize a, `b` times
          } else if (m === '?') {
            return [randomize(a, b)];
    
          // expand right, no regex reduction
          } else if (m === '>') {
            step = step.substr(0, i) + step.substr(i + 1);
            expand = true;
    
          // expand to an array, or if valid create a reduced
          // string for a regex logic `or`
          } else if (m === '|') {
            step = step.substr(0, i) + step.substr(i + 1);
            expand = true;
            regex = true;
            sep = m;
    
          // expand to an array, or if valid create a reduced
          // string for a regex range
          } else if (m === '~') {
            step = step.substr(0, i) + step.substr(i + 1);
            expand = true;
            regex = true;
            sep = m;
          }
        } else if (!isNumber(step)) {
          if (!opts.silent) {
            throw new TypeError('fill-range: invalid step.');
          }
          return null;
        }
      }
    
      if (/[.&*()[\]^%$#@!]/.test(a) || /[.&*()[\]^%$#@!]/.test(b)) {
        if (!opts.silent) {
          throw new RangeError('fill-range: invalid range arguments.');
        }
        return null;
      }
    
      // has neither a letter nor number, or has both letters and numbers
      // this needs to be after the step logic
      if (!noAlphaNum(a) || !noAlphaNum(b) || hasBoth(a) || hasBoth(b)) {
        if (!opts.silent) {
          throw new RangeError('fill-range: invalid range arguments.');
        }
        return null;
      }
    
      // validate arguments
      var isNumA = isNumber(zeros(a));
      var isNumB = isNumber(zeros(b));
    
      if ((!isNumA && isNumB) || (isNumA && !isNumB)) {
        if (!opts.silent) {
          throw new TypeError('fill-range: first range argument is incompatible with second.');
        }
        return null;
      }
    
      // by this point both are the same, so we
      // can use A to check going forward.
      var isNum = isNumA;
      var num = formatStep(step);
    
      // is the range alphabetical? or numeric?
      if (isNum) {
        // if numeric, coerce to an integer
        a = +a; b = +b;
      } else {
        // otherwise, get the charCode to expand alpha ranges
        a = a.charCodeAt(0);
        b = b.charCodeAt(0);
      }
    
      // is the pattern descending?
      var isDescending = a > b;
    
      // don't create a character class if the args are < 0
      if (a < 0 || b < 0) {
        expand = false;
        regex = false;
      }
    
      // detect padding
      var padding = isPadded(origA, origB);
      var res, pad, arr = [];
      var ii = 0;
    
      // character classes, ranges and logical `or`
      if (regex) {
        if (shouldExpand(a, b, num, isNum, padding, opts)) {
          // make sure the correct separator is used
          if (sep === '|' || sep === '~') {
            sep = detectSeparator(a, b, num, isNum, isDescending);
          }
          return wrap([origA, origB], sep, opts);
        }
      }
    
      while (isDescending ? (a >= b) : (a <= b)) {
        if (padding && isNum) {
          pad = padding(a);
        }
    
        // custom function
        if (typeof fn === 'function') {
          res = fn(a, isNum, pad, ii++);
    
        // letters
        } else if (!isNum) {
          if (regex && isInvalidChar(a)) {
            res = null;
          } else {
            res = String.fromCharCode(a);
          }
    
        // numbers
        } else {
          res = formatPadding(a, pad);
        }
    
        // add result to the array, filtering any nulled values
        if (res !== null) arr.push(res);
    
        // increment or decrement
        if (isDescending) {
          a -= num;
        } else {
          a += num;
        }
      }
    
      // now that the array is expanded, we need to handle regex
      // character classes, ranges or logical `or` that wasn't
      // already handled before the loop
      if ((regex || expand) && !opts.noexpand) {
        // make sure the correct separator is used
        if (sep === '|' || sep === '~') {
          sep = detectSeparator(a, b, num, isNum, isDescending);
        }
        if (arr.length === 1 || a < 0 || b < 0) { return arr; }
        return wrap(arr, sep, opts);
      }
    
      return arr;
    }
    
    /**
     * Wrap the string with the correct regex
     * syntax.
     */
    
    function wrap(arr, sep, opts) {
      if (sep === '~') { sep = '-'; }
      var str = arr.join(sep);
      var pre = opts && opts.regexPrefix;
    
      // regex logical `or`
      if (sep === '|') {
        str = pre ? pre + str : str;
        str = '(' + str + ')';
      }
    
      // regex character class
      if (sep === '-') {
        str = (pre && pre === '^')
          ? pre + str
          : str;
        str = '[' + str + ']';
      }
      return [str];
    }
    
    /**
     * Check for invalid characters
     */
    
    function isCharClass(a, b, step, isNum, isDescending) {
      if (isDescending) { return false; }
      if (isNum) { return a <= 9 && b <= 9; }
      if (a < b) { return step === 1; }
      return false;
    }
    
    /**
     * Detect the correct separator to use
     */
    
    function shouldExpand(a, b, num, isNum, padding, opts) {
      if (isNum && (a > 9 || b > 9)) { return false; }
      return !padding && num === 1 && a < b;
    }
    
    /**
     * Detect the correct separator to use
     */
    
    function detectSeparator(a, b, step, isNum, isDescending) {
      var isChar = isCharClass(a, b, step, isNum, isDescending);
      if (!isChar) {
        return '|';
      }
      return '~';
    }
    
    /**
     * Correctly format the step based on type
     */
    
    function formatStep(step) {
      return Math.abs(step >> 0) || 1;
    }
    
    /**
     * Format padding, taking leading `-` into account
     */
    
    function formatPadding(ch, pad) {
      var res = pad ? pad + ch : ch;
      if (pad && ch.toString().charAt(0) === '-') {
        res = '-' + pad + ch.toString().substr(1);
      }
      return res.toString();
    }
    
    /**
     * Check for invalid characters
     */
    
    function isInvalidChar(str) {
      var ch = toStr(str);
      return ch === '\\'
        || ch === '['
        || ch === ']'
        || ch === '^'
        || ch === '('
        || ch === ')'
        || ch === '`';
    }
    
    /**
     * Convert to a string from a charCode
     */
    
    function toStr(ch) {
      return String.fromCharCode(ch);
    }
    
    
    /**
     * Step regex
     */
    
    function stepRe() {
      return /\?|>|\||\+|\~/g;
    }
    
    /**
     * Return true if `val` has either a letter
     * or a number
     */
    
    function noAlphaNum(val) {
      return /[a-z0-9]/i.test(val);
    }
    
    /**
     * Return true if `val` has both a letter and
     * a number (invalid)
     */
    
    function hasBoth(val) {
      return /[a-z][0-9]|[0-9][a-z]/i.test(val);
    }
    
    /**
     * Normalize zeros for checks
     */
    
    function zeros(val) {
      if (/^-*0+$/.test(val.toString())) {
        return '0';
      }
      return val;
    }
    
    /**
     * Return true if `val` has leading zeros,
     * or a similar valid pattern.
     */
    
    function hasZeros(val) {
      return /[^.]\.|^-*0+[0-9]/.test(val);
    }
    
    /**
     * If the string is padded, returns a curried function with
     * the a cached padding string, or `false` if no padding.
     *
     * @param  {*} `origA` String or number.
     * @return {String|Boolean}
     */
    
    function isPadded(origA, origB) {
      if (hasZeros(origA) || hasZeros(origB)) {
        var alen = length(origA);
        var blen = length(origB);
    
        var len = alen >= blen
          ? alen
          : blen;
    
        return function (a) {
          return repeatStr('0', len - length(a));
        };
      }
      return false;
    }
    
    /**
     * Get the string length of `val`
     */
    
    function length(val) {
      return val.toString().length;
    }
    
  provide("fill-range", module.exports);
}(global));

// pakmanager:for-in
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * for-in <https://github.com/jonschlinkert/for-in>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    module.exports = function forIn(o, fn, thisArg) {
      for (var key in o) {
        if (fn.call(thisArg, o[key], key, o) === false) {
          break;
        }
      }
    };
  provide("for-in", module.exports);
}(global));

// pakmanager:glob-parent
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var path = require('path');
    var isglob = require('is-glob');
    
    module.exports = function globParent(str) {
    	while (isglob(str)) str = path.dirname(str);
    	return str;
    };
    
  provide("glob-parent", module.exports);
}(global));

// pakmanager:is-primitive
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * is-primitive <https://github.com/jonschlinkert/is-primitive>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    // see http://jsperf.com/testing-value-is-primitive/7
    module.exports = function isPrimitive(value) {
      return value == null || (typeof value !== 'function' && typeof value !== 'object');
    };
    
  provide("is-primitive", module.exports);
}(global));

// pakmanager:amdefine
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /** vim: et:ts=4:sw=4:sts=4
     * @license amdefine 0.1.0 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
     * Available via the MIT or new BSD license.
     * see: http://github.com/jrburke/amdefine for details
     */
    
    /*jslint node: true */
    /*global module, process */
    'use strict';
    
    /**
     * Creates a define for node.
     * @param {Object} module the "module" object that is defined by Node for the
     * current module.
     * @param {Function} [requireFn]. Node's require function for the current module.
     * It only needs to be passed in Node versions before 0.5, when module.require
     * did not exist.
     * @returns {Function} a define function that is usable for the current node
     * module.
     */
    function amdefine(module, requireFn) {
        'use strict';
        var defineCache = {},
            loaderCache = {},
            alreadyCalled = false,
            path = require('path'),
            makeRequire, stringRequire;
    
        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; ary[i]; i+= 1) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                        //End of the line. Keep at least one non-dot
                        //path segment at the front so it can be mapped
                        //correctly to disk. Otherwise, there is likely
                        //no path mapping for a path starting with '..'.
                        //This can still fail, but catches the most reasonable
                        //uses of ..
                        break;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }
    
        function normalize(name, baseName) {
            var baseParts;
    
            //Adjust any relative paths.
            if (name && name.charAt(0) === '.') {
                //If have a base name, try to normalize against it,
                //otherwise, assume it is a top-level require that will
                //be relative to baseUrl in the end.
                if (baseName) {
                    baseParts = baseName.split('/');
                    baseParts = baseParts.slice(0, baseParts.length - 1);
                    baseParts = baseParts.concat(name.split('/'));
                    trimDots(baseParts);
                    name = baseParts.join('/');
                }
            }
    
            return name;
        }
    
        /**
         * Create the normalize() function passed to a loader plugin's
         * normalize method.
         */
        function makeNormalize(relName) {
            return function (name) {
                return normalize(name, relName);
            };
        }
    
        function makeLoad(id) {
            function load(value) {
                loaderCache[id] = value;
            }
    
            load.fromText = function (id, text) {
                //This one is difficult because the text can/probably uses
                //define, and any relative paths and requires should be relative
                //to that id was it would be found on disk. But this would require
                //bootstrapping a module/require fairly deeply from node core.
                //Not sure how best to go about that yet.
                throw new Error('amdefine does not implement load.fromText');
            };
    
            return load;
        }
    
        makeRequire = function (systemRequire, exports, module, relId) {
            function amdRequire(deps, callback) {
                if (typeof deps === 'string') {
                    //Synchronous, single module require('')
                    return stringRequire(systemRequire, exports, module, deps, relId);
                } else {
                    //Array of dependencies with a callback.
    
                    //Convert the dependencies to modules.
                    deps = deps.map(function (depName) {
                        return stringRequire(systemRequire, exports, module, depName, relId);
                    });
    
                    //Wait for next tick to call back the require call.
                    process.nextTick(function () {
                        callback.apply(null, deps);
                    });
                }
            }
    
            amdRequire.toUrl = function (filePath) {
                if (filePath.indexOf('.') === 0) {
                    return normalize(filePath, path.dirname(module.filename));
                } else {
                    return filePath;
                }
            };
    
            return amdRequire;
        };
    
        //Favor explicit value, passed in if the module wants to support Node 0.4.
        requireFn = requireFn || function req() {
            return module.require.apply(module, arguments);
        };
    
        function runFactory(id, deps, factory) {
            var r, e, m, result;
    
            if (id) {
                e = loaderCache[id] = {};
                m = {
                    id: id,
                    uri: __filename,
                    exports: e
                };
                r = makeRequire(requireFn, e, m, id);
            } else {
                //Only support one define call per file
                if (alreadyCalled) {
                    throw new Error('amdefine with no module ID cannot be called more than once per file.');
                }
                alreadyCalled = true;
    
                //Use the real variables from node
                //Use module.exports for exports, since
                //the exports in here is amdefine exports.
                e = module.exports;
                m = module;
                r = makeRequire(requireFn, e, m, module.id);
            }
    
            //If there are dependencies, they are strings, so need
            //to convert them to dependency values.
            if (deps) {
                deps = deps.map(function (depName) {
                    return r(depName);
                });
            }
    
            //Call the factory with the right dependencies.
            if (typeof factory === 'function') {
                result = factory.apply(m.exports, deps);
            } else {
                result = factory;
            }
    
            if (result !== undefined) {
                m.exports = result;
                if (id) {
                    loaderCache[id] = m.exports;
                }
            }
        }
    
        stringRequire = function (systemRequire, exports, module, id, relId) {
            //Split the ID by a ! so that
            var index = id.indexOf('!'),
                originalId = id,
                prefix, plugin;
    
            if (index === -1) {
                id = normalize(id, relId);
    
                //Straight module lookup. If it is one of the special dependencies,
                //deal with it, otherwise, delegate to node.
                if (id === 'require') {
                    return makeRequire(systemRequire, exports, module, relId);
                } else if (id === 'exports') {
                    return exports;
                } else if (id === 'module') {
                    return module;
                } else if (loaderCache.hasOwnProperty(id)) {
                    return loaderCache[id];
                } else if (defineCache[id]) {
                    runFactory.apply(null, defineCache[id]);
                    return loaderCache[id];
                } else {
                    if(systemRequire) {
                        return systemRequire(originalId);
                    } else {
                        throw new Error('No module with ID: ' + id);
                    }
                }
            } else {
                //There is a plugin in play.
                prefix = id.substring(0, index);
                id = id.substring(index + 1, id.length);
    
                plugin = stringRequire(systemRequire, exports, module, prefix, relId);
    
                if (plugin.normalize) {
                    id = plugin.normalize(id, makeNormalize(relId));
                } else {
                    //Normalize the ID normally.
                    id = normalize(id, relId);
                }
    
                if (loaderCache[id]) {
                    return loaderCache[id];
                } else {
                    plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});
    
                    return loaderCache[id];
                }
            }
        };
    
        //Create a define function specific to the module asking for amdefine.
        function define(id, deps, factory) {
            if (Array.isArray(id)) {
                factory = deps;
                deps = id;
                id = undefined;
            } else if (typeof id !== 'string') {
                factory = id;
                id = deps = undefined;
            }
    
            if (deps && !Array.isArray(deps)) {
                factory = deps;
                deps = undefined;
            }
    
            if (!deps) {
                deps = ['require', 'exports', 'module'];
            }
    
            //Set up properties for this module. If an ID, then use
            //internal cache. If no ID, then use the external variables
            //for this node module.
            if (id) {
                //Put the module in deep freeze until there is a
                //require call for it.
                defineCache[id] = [id, deps, factory];
            } else {
                runFactory(id, deps, factory);
            }
        }
    
        //define.require, which has access to all the values in the
        //cache. Useful for AMD modules that all have IDs in the file,
        //but need to finally export a value to node based on one of those
        //IDs.
        define.require = function (id) {
            if (loaderCache[id]) {
                return loaderCache[id];
            }
    
            if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            }
        };
    
        define.amd = {};
    
        return define;
    }
    
    module.exports = amdefine;
    
  provide("amdefine", module.exports);
}(global));

// pakmanager:source-map-url
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2014 Simon Lydell
    // X11 (“MIT”) Licensed. (See LICENSE.)
    
    void (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(factory)
      } else if (typeof exports === "object") {
        module.exports = factory()
      } else {
        root.sourceMappingURL = factory()
      }
    }(this, function() {
    
      var innerRegex = /[#@] sourceMappingURL=([^\s'"]*)/
    
      var regex = RegExp(
        "(?:" +
          "/\\*" +
          "(?:\\s*\r?\n(?://)?)?" +
          "(?:" + innerRegex.source + ")" +
          "\\s*" +
          "\\*/" +
          "|" +
          "//(?:" + innerRegex.source + ")" +
        ")" +
        "\\s*$"
      )
    
      return {
    
        regex: regex,
        _innerRegex: innerRegex,
    
        getFrom: function(code) {
          var match = code.match(regex)
          return (match ? match[1] || match[2] || "" : null)
        },
    
        existsIn: function(code) {
          return regex.test(code)
        },
    
        removeFrom: function(code) {
          return code.replace(regex, "")
        },
    
        insertBefore: function(code, string) {
          var match = code.match(regex)
          if (match) {
            return code.slice(0, match.index) + string + code.slice(match.index)
          } else {
            return code + string
          }
        }
      }
    
    }));
    
  provide("source-map-url", module.exports);
}(global));

// pakmanager:urix
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2014 Simon Lydell
    // X11 (“MIT”) Licensed. (See LICENSE.)
    
    var path = require("path")
    
    "use strict"
    
    function urix(aPath) {
      if (path.sep === "\\") {
        return aPath
          .replace(/\\/g, "/")
          .replace(/^[a-z]:\/?/i, "/")
      }
      return aPath
    }
    
    module.exports = urix
    
  provide("urix", module.exports);
}(global));

// pakmanager:resolve-url
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2014 Simon Lydell
    // X11 (“MIT”) Licensed. (See LICENSE.)
    
    void (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(factory)
      } else if (typeof exports === "object") {
        module.exports = factory()
      } else {
        root.resolveUrl = factory()
      }
    }(this, function() {
    
      function resolveUrl(/* ...urls */) {
        var numUrls = arguments.length
    
        if (numUrls === 0) {
          throw new Error("resolveUrl requires at least one argument; got none.")
        }
    
        var base = document.createElement("base")
        base.href = arguments[0]
    
        if (numUrls === 1) {
          return base.href
        }
    
        var head = document.getElementsByTagName("head")[0]
        head.insertBefore(base, head.firstChild)
    
        var a = document.createElement("a")
        var resolved
    
        for (var index = 1; index < numUrls; index++) {
          a.href = arguments[index]
          resolved = a.href
          base.href = resolved
        }
    
        head.removeChild(base)
    
        return resolved
      }
    
      return resolveUrl
    
    }));
    
  provide("resolve-url", module.exports);
}(global));

// pakmanager:camelcase
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function (str) {
    	str = str.trim();
    
    	if (str.length === 1 || !(/[_.\- ]+/).test(str) ) {
    		if (str[0] === str[0].toLowerCase() && str.slice(1) !== str.slice(1).toLowerCase()) {
    			return str;
    		}
    
    		return str.toLowerCase();
    	}
    
    	return str
    	.replace(/^[_.\- ]+/, '')
    	.toLowerCase()
    	.replace(/[_.\- ]+(\w|$)/g, function (m, p1) {
    		return p1.toUpperCase();
    	});
    };
    
  provide("camelcase", module.exports);
}(global));

// pakmanager:cliui
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var wrap = require('wordwrap'),
      align = {
        right: require('right-align'),
        center: require('center-align')
      },
      top = 0,
      right = 1,
      bottom = 2,
      left = 3
    
    function UI (opts) {
      this.width = opts.width
      this.wrap = opts.wrap
      this.rows = []
    }
    
    UI.prototype.span = function () {
      var cols = this.div.apply(this, arguments)
      cols.span = true
    }
    
    UI.prototype.div = function () {
      if (arguments.length === 0) this.div('')
      if (this.wrap && this._shouldApplyLayoutDSL.apply(this, arguments)) {
        return this._applyLayoutDSL(arguments[0])
      }
    
      var cols = []
    
      for (var i = 0, arg; (arg = arguments[i]) !== undefined; i++) {
        if (typeof arg === 'string') cols.push(this._colFromString(arg))
        else cols.push(arg)
      }
    
      this.rows.push(cols)
      return cols
    }
    
    UI.prototype._shouldApplyLayoutDSL = function () {
      return arguments.length === 1 && typeof arguments[0] === 'string' &&
        /[\t\n]/.test(arguments[0])
    }
    
    UI.prototype._applyLayoutDSL = function (str) {
      var _this = this,
        rows = str.split('\n'),
        leftColumnWidth = 0
    
      // simple heuristic for layout, make sure the
      // second column lines up along the left-hand.
      // don't allow the first column to take up more
      // than 50% of the screen.
      rows.forEach(function (row) {
        var columns = row.split('\t')
        if (columns.length > 1 && columns[0].length > leftColumnWidth) {
          leftColumnWidth = Math.min(
            Math.floor(_this.width * 0.5),
            columns[0].length
          )
        }
      })
    
      // generate a table:
      //  replacing ' ' with padding calculations.
      //  using the algorithmically generated width.
      rows.forEach(function (row) {
        var columns = row.split('\t')
        _this.div.apply(_this, columns.map(function (r, i) {
          return {
            text: r.trim(),
            padding: [0, r.match(/\s*$/)[0].length, 0, r.match(/^\s*/)[0].length],
            width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined
          }
        }))
      })
    
      return this.rows[this.rows.length - 1]
    }
    
    UI.prototype._colFromString = function (str) {
      return {
        text: str
      }
    }
    
    UI.prototype.toString = function () {
      var _this = this,
        lines = []
    
      _this.rows.forEach(function (row, i) {
        _this.rowToString(row, lines)
      })
    
      // don't display any lines with the
      // hidden flag set.
      lines = lines.filter(function (line) {
        return !line.hidden
      })
    
      return lines.map(function (line) {
        return line.text
      }).join('\n')
    }
    
    UI.prototype.rowToString = function (row, lines) {
      var _this = this,
        paddingLeft,
        rrows = this._rasterize(row),
        str = '',
        ts,
        width,
        wrapWidth
    
      rrows.forEach(function (rrow, r) {
        str = ''
        rrow.forEach(function (col, c) {
          ts = '' // temporary string used during alignment/padding.
          width = row[c].width // the width with padding.
          wrapWidth = _this._negatePadding(row[c]) // the width without padding.
    
          for (var i = 0; i < Math.max(wrapWidth, col.length); i++) {
            ts += col.charAt(i) || ' '
          }
    
          // align the string within its column.
          if (row[c].align && row[c].align !== 'left' && _this.wrap) {
            ts = align[row[c].align](ts.trim() + '\n' + new Array(wrapWidth + 1).join(' '))
              .split('\n')[0]
            if (ts.length < wrapWidth) ts += new Array(width - ts.length).join(' ')
          }
    
          // add left/right padding and print string.
          paddingLeft = (row[c].padding || [0, 0, 0, 0])[left]
          if (paddingLeft) str += new Array(row[c].padding[left] + 1).join(' ')
          str += ts
          if (row[c].padding && row[c].padding[right]) str += new Array(row[c].padding[right] + 1).join(' ')
    
          // if prior row is span, try to render the
          // current row on the prior line.
          if (r === 0 && lines.length > 0) {
            str = _this._renderInline(str, lines[lines.length - 1], paddingLeft)
          }
        })
    
        // remove trailing whitespace.
        lines.push({
          text: str.replace(/ +$/, ''),
          span: row.span
        })
      })
    
      return lines
    }
    
    // if the full 'source' can render in
    // the target line, do so.
    UI.prototype._renderInline = function (source, previousLine, paddingLeft) {
      var target = previousLine.text,
        str = ''
    
      if (!previousLine.span) return source
    
      // if we're not applying wrapping logic,
      // just always append to the span.
      if (!this.wrap) {
        previousLine.hidden = true
        return target + source
      }
    
      for (var i = 0, tc, sc; i < Math.max(source.length, target.length); i++) {
        tc = target.charAt(i) || ' '
        sc = source.charAt(i) || ' '
        // we tried to overwrite a character in the other string.
        if (tc !== ' ' && sc !== ' ') return source
        // there is not enough whitespace to maintain padding.
        if (sc !== ' ' && i < paddingLeft + target.length) return source
        // :thumbsup:
        if (tc === ' ') str += sc
        else str += tc
      }
    
      previousLine.hidden = true
    
      return str
    }
    
    UI.prototype._rasterize = function (row) {
      var _this = this,
        i,
        rrow,
        rrows = [],
        widths = this._columnWidths(row),
        wrapped
    
      // word wrap all columns, and create
      // a data-structure that is easy to rasterize.
      row.forEach(function (col, c) {
        // leave room for left and right padding.
        col.width = widths[c]
        if (_this.wrap) wrapped = wrap.hard(_this._negatePadding(col))(col.text).split('\n')
        else wrapped = col.text.split('\n')
    
        // add top and bottom padding.
        if (col.padding) {
          for (i = 0; i < (col.padding[top] || 0); i++) wrapped.unshift('')
          for (i = 0; i < (col.padding[bottom] || 0); i++) wrapped.push('')
        }
    
        wrapped.forEach(function (str, r) {
          if (!rrows[r]) rrows.push([])
    
          rrow = rrows[r]
    
          for (var i = 0; i < c; i++) {
            if (rrow[i] === undefined) rrow.push('')
          }
          rrow.push(str)
        })
      })
    
      return rrows
    }
    
    UI.prototype._negatePadding = function (col) {
      var wrapWidth = col.width
      if (col.padding) wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0)
      return wrapWidth
    }
    
    UI.prototype._columnWidths = function (row) {
      var _this = this,
        widths = [],
        unset = row.length,
        unsetWidth,
        remainingWidth = this.width
    
      // column widths can be set in config.
      row.forEach(function (col, i) {
        if (col.width) {
          unset--
          widths[i] = col.width
          remainingWidth -= col.width
        } else {
          widths[i] = undefined
        }
      })
    
      // any unset widths should be calculated.
      if (unset) unsetWidth = Math.floor(remainingWidth / unset)
      widths.forEach(function (w, i) {
        if (!_this.wrap) widths[i] = row[i].width || row[i].text.length
        else if (w === undefined) widths[i] = Math.max(unsetWidth, _minWidth(row[i]))
      })
    
      return widths
    }
    
    // calculates the minimum width of
    // a column, based on padding preferences.
    function _minWidth (col) {
      var padding = col.padding || []
    
      return 1 + (padding[left] || 0) + (padding[right] || 0)
    }
    
    module.exports = function (opts) {
      opts = opts || {}
    
      return new UI({
        width: (opts || {}).width || 80,
        wrap: typeof opts.wrap === 'boolean' ? opts.wrap : true
      })
    }
    
  provide("cliui", module.exports);
}(global));

// pakmanager:decamelize
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function (str, sep) {
    	if (typeof str !== 'string') {
    		throw new TypeError('Expected a string');
    	}
    
    	return str.replace(/([a-z\d])([A-Z])/g, '$1' + (sep || '_') + '$2').toLowerCase();
    };
    
  provide("decamelize", module.exports);
}(global));

// pakmanager:window-size
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * window-size
     * https://github.com/jonschlinkert/window-size
     *
     * Copyright (c) 2014 Jon Schlinkert
     * Licensed under the MIT license.
     */
    
    const tty = require('tty')
    
    module.exports = (function() {
      var width;
      var height;
    
      if(tty.isatty(1) && tty.isatty(2)) {
        if(process.stdout.getWindowSize) {
          width = process.stdout.getWindowSize(1)[0];
          height = process.stdout.getWindowSize(1)[1];
        } else if (tty.getWindowSize) {
          width = tty.getWindowSize()[1];
          height = tty.getWindowSize()[0];
        } else if (process.stdout.columns && process.stdout.rows) {
          height = process.stdout.columns;
          width = process.stdout.rows;
        }
      } else {
        new Error('Error: could not get window size with tty or process.stdout');
      }
      return {
        height: height,
        width: width
      }
    })();
  provide("window-size", module.exports);
}(global));

// pakmanager:array-slice
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * array-slice <https://github.com/jonschlinkert/array-slice>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    module.exports = function slice(arr, start, end) {
      var len = arr.length >>> 0;
      var range = [];
    
      start = idx(arr, start);
      end = idx(arr, end, len);
    
      while (start < end) {
        range.push(arr[start++]);
      }
      return range;
    };
    
    
    function idx(arr, pos, end) {
      var len = arr.length >>> 0;
    
      if (pos == null) {
        pos = end || 0;
      } else if (pos < 0) {
        pos = Math.max(len + pos, 0);
      } else {
        pos = Math.min(pos, len);
      }
    
      return pos;
    }
  provide("array-slice", module.exports);
}(global));

// pakmanager:expand-range
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * expand-range <https://github.com/jonschlinkert/expand-range>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT license.
     */
    
    'use strict';
    
    var fill = require('fill-range');
    
    module.exports = function expandRange(str, options, fn) {
      if (typeof str !== 'string') {
        throw new TypeError('expand-range expects a string.');
      }
    
      if (typeof options === 'function') {
        fn = options;
        options = {};
      }
    
      if (typeof options === 'boolean') {
        options = {};
        options.makeRe = true;
      }
    
      // create arguments to pass to fill-range
      var opts = options || {};
      var args = str.split('..');
      var len = args.length;
      if (len > 3) { return str; }
    
      // if only one argument, it can't expand so return it
      if (len === 1) { return args; }
    
      // if `true`, tell fill-range to regexify the string
      if (typeof fn === 'boolean' && fn === true) {
        opts.makeRe = true;
      }
    
      args.push(opts);
      return fill.apply(fill, args.concat(fn));
    };
    
  provide("expand-range", module.exports);
}(global));

// pakmanager:preserve
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * preserve <https://github.com/jonschlinkert/preserve>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT license.
     */
    
    'use strict';
    
    /**
     * Replace tokens in `str` with a temporary, heuristic placeholder.
     *
     * ```js
     * tokens.before('{a\\,b}');
     * //=> '{__ID1__}'
     * ```
     *
     * @param  {String} `str`
     * @return {String} String with placeholders.
     * @api public
     */
    
    exports.before = function before(str, re) {
      return str.replace(re, function (match) {
        var id = randomize();
        cache[id] = match;
        return '__ID' + id + '__';
      });
    };
    
    /**
     * Replace placeholders in `str` with original tokens.
     *
     * ```js
     * tokens.after('{__ID1__}');
     * //=> '{a\\,b}'
     * ```
     *
     * @param  {String} `str` String with placeholders
     * @return {String} `str` String with original tokens.
     * @api public
     */
    
    exports.after = function after(str) {
      return str.replace(/__ID(.{5})__/g, function (_, id) {
        return cache[id];
      });
    };
    
    function randomize() {
      return Math.random().toString().slice(2, 7);
    }
    
    var cache = {};
  provide("preserve", module.exports);
}(global));

// pakmanager:ms
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Helpers.
     */
    
    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    
    /**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} options
     * @return {String|Number}
     * @api public
     */
    
    module.exports = function(val, options){
      options = options || {};
      if ('string' == typeof val) return parse(val);
      return options.long
        ? long(val)
        : short(val);
    };
    
    /**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */
    
    function parse(str) {
      str = '' + str;
      if (str.length > 10000) return;
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) return;
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y;
        case 'days':
        case 'day':
        case 'd':
          return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;
      }
    }
    
    /**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */
    
    function short(ms) {
      if (ms >= d) return Math.round(ms / d) + 'd';
      if (ms >= h) return Math.round(ms / h) + 'h';
      if (ms >= m) return Math.round(ms / m) + 'm';
      if (ms >= s) return Math.round(ms / s) + 's';
      return ms + 'ms';
    }
    
    /**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */
    
    function long(ms) {
      return plural(ms, d, 'day')
        || plural(ms, h, 'hour')
        || plural(ms, m, 'minute')
        || plural(ms, s, 'second')
        || ms + ' ms';
    }
    
    /**
     * Pluralization helper.
     */
    
    function plural(ms, n, name) {
      if (ms < n) return;
      if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
      return Math.ceil(ms / n) + ' ' + name + 's';
    }
    
  provide("ms", module.exports);
}(global));

// pakmanager:for-own
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * for-own <https://github.com/jonschlinkert/for-own>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var forIn = require('for-in');
    var hasOwn = Object.prototype.hasOwnProperty;
    
    module.exports = function forOwn(o, fn, thisArg) {
      forIn(o, function (val, key) {
        if (hasOwn.call(o, key)) {
          return fn.call(thisArg, o[key], key, o);
        }
      });
    };
    
  provide("for-own", module.exports);
}(global));

// pakmanager:glob-base
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * glob-base <https://github.com/jonschlinkert/glob-base>
     *
     * Copyright (c) 2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var path = require('path');
    var parent = require('glob-parent');
    
    module.exports = function globBase(pattern) {
      if (typeof pattern !== 'string') {
        throw new TypeError('glob-base expects a string.');
      }
    
      var res = {};
      res.base = parent(pattern);
      res.isGlob = res.base !== pattern;
    
      if (res.base !== '.') {
        res.glob = pattern.substr(res.base.length);
        if (res.glob.charAt(0) === '/') {
          res.glob = res.glob.substr(1);
        }
      } else {
        res.glob = pattern;
      }
    
      if (!res.isGlob) {
        res.base = dirname(pattern);
        res.glob = res.base !== '.'
          ? pattern.substr(res.base.length)
          : pattern;
      }
    
      if (res.glob.substr(0, 2) === './') {
        res.glob = res.glob.substr(2);
      }
      if (res.glob.charAt(0) === '/') {
        res.glob = res.glob.substr(1);
      }
      return res;
    };
    
    function dirname(glob) {
      if (glob.slice(-1) === '/') return glob;
      return path.dirname(glob);
    }
    
  provide("glob-base", module.exports);
}(global));

// pakmanager:is-dotfile
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * is-dotfile <https://github.com/regexps/is-dotfile>
     *
     * Copyright (c) 2015 Jon Schlinkert, contributors.
     * Licensed under the MIT license.
     */
    
    module.exports = function(str) {
      if (str.charCodeAt(0) === 46 /* . */ && str.indexOf('/', 1) === -1) {
        return true;
      }
    
      var last = str.lastIndexOf('/');
      return last !== -1 ? str.charCodeAt(last + 1) === 46  /* . */ : false;
    };
    
  provide("is-dotfile", module.exports);
}(global));

// pakmanager:is-extglob
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * is-extglob <https://github.com/jonschlinkert/is-extglob>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    module.exports = function isExtglob(str) {
      return typeof str === 'string'
        && /[@?!+*]\(/.test(str);
    };
    
  provide("is-extglob", module.exports);
}(global));

// pakmanager:is-equal-shallow
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * is-equal-shallow <https://github.com/jonschlinkert/is-equal-shallow>
     *
     * Copyright (c) 2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var isPrimitive = require('is-primitive');
    
    module.exports = function isEqual(a, b) {
      if (!a && !b) { return true; }
      if (!a && b || a && !b) { return false; }
    
      var numKeysA = 0, numKeysB = 0, key;
      for (key in b) {
        numKeysB++;
        if (!isPrimitive(b[key]) || !a.hasOwnProperty(key) || (a[key] !== b[key])) {
          return false;
        }
      }
      for (key in a) {
        numKeysA++;
      }
      return numKeysA === numKeysB;
    };
    
  provide("is-equal-shallow", module.exports);
}(global));

// pakmanager:balanced-match
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = balanced;
    function balanced(a, b, str) {
      var bal = 0;
      var m = {};
      var ended = false;
    
      for (var i = 0; i < str.length; i++) {
        if (a == str.substr(i, a.length)) {
          if (!('start' in m)) m.start = i;
          bal++;
        }
        else if (b == str.substr(i, b.length) && 'start' in m) {
          ended = true;
          bal--;
          if (!bal) {
            m.end = i;
            m.pre = str.substr(0, m.start);
            m.body = (m.end - m.start > 1)
              ? str.substring(m.start + a.length, m.end)
              : '';
            m.post = str.slice(m.end + b.length);
            return m;
          }
        }
      }
    
      // if we opened more than we closed, find the one we closed
      if (bal && ended) {
        var start = m.start + a.length;
        m = balanced(a, b, str.substr(start));
        if (m) {
          m.start += start;
          m.end += start;
          m.pre = str.slice(0, start) + m.pre;
        }
        return m;
      }
    }
    
  provide("balanced-match", module.exports);
}(global));

// pakmanager:concat-map
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function (xs, fn) {
        var res = [];
        for (var i = 0; i < xs.length; i++) {
            var x = fn(xs[i], i);
            if (isArray(x)) res.push.apply(res, x);
            else res.push(x);
        }
        return res;
    };
    
    var isArray = Array.isArray || function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]';
    };
    
  provide("concat-map", module.exports);
}(global));

// pakmanager:crc/lib/create
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.7.1
    module.exports = function(model, calc) {
      var fn;
      fn = function(buf, previous) {
        return calc(buf, previous) >>> 0;
      };
      fn.signed = calc;
      fn.unsigned = fn;
      fn.model = model;
      return fn;
    };
    
  provide("crc/lib/create", module.exports);
}(global));

// pakmanager:crc/lib/crc1
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.7.1
    var Buffer, create;
    
    Buffer = require('buffer').Buffer;
    
    create =  require('crc/lib/create');
    
    module.exports = create('crc1', function(buf, previous) {
      var accum, byte, crc, _i, _len;
      if (!Buffer.isBuffer(buf)) {
        buf = Buffer(buf);
      }
      crc = ~~previous;
      accum = 0;
      for (_i = 0, _len = buf.length; _i < _len; _i++) {
        byte = buf[_i];
        accum += byte;
      }
      crc += accum % 256;
      return crc % 256;
    });
    
  provide("crc/lib/crc1", module.exports);
}(global));

// pakmanager:crc/lib/crc8
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.7.1
    var Buffer, TABLE, create;
    
    Buffer = require('buffer').Buffer;
    
    create =  require('crc/lib/create');
    
    TABLE = [0x00, 0x07, 0x0e, 0x09, 0x1c, 0x1b, 0x12, 0x15, 0x38, 0x3f, 0x36, 0x31, 0x24, 0x23, 0x2a, 0x2d, 0x70, 0x77, 0x7e, 0x79, 0x6c, 0x6b, 0x62, 0x65, 0x48, 0x4f, 0x46, 0x41, 0x54, 0x53, 0x5a, 0x5d, 0xe0, 0xe7, 0xee, 0xe9, 0xfc, 0xfb, 0xf2, 0xf5, 0xd8, 0xdf, 0xd6, 0xd1, 0xc4, 0xc3, 0xca, 0xcd, 0x90, 0x97, 0x9e, 0x99, 0x8c, 0x8b, 0x82, 0x85, 0xa8, 0xaf, 0xa6, 0xa1, 0xb4, 0xb3, 0xba, 0xbd, 0xc7, 0xc0, 0xc9, 0xce, 0xdb, 0xdc, 0xd5, 0xd2, 0xff, 0xf8, 0xf1, 0xf6, 0xe3, 0xe4, 0xed, 0xea, 0xb7, 0xb0, 0xb9, 0xbe, 0xab, 0xac, 0xa5, 0xa2, 0x8f, 0x88, 0x81, 0x86, 0x93, 0x94, 0x9d, 0x9a, 0x27, 0x20, 0x29, 0x2e, 0x3b, 0x3c, 0x35, 0x32, 0x1f, 0x18, 0x11, 0x16, 0x03, 0x04, 0x0d, 0x0a, 0x57, 0x50, 0x59, 0x5e, 0x4b, 0x4c, 0x45, 0x42, 0x6f, 0x68, 0x61, 0x66, 0x73, 0x74, 0x7d, 0x7a, 0x89, 0x8e, 0x87, 0x80, 0x95, 0x92, 0x9b, 0x9c, 0xb1, 0xb6, 0xbf, 0xb8, 0xad, 0xaa, 0xa3, 0xa4, 0xf9, 0xfe, 0xf7, 0xf0, 0xe5, 0xe2, 0xeb, 0xec, 0xc1, 0xc6, 0xcf, 0xc8, 0xdd, 0xda, 0xd3, 0xd4, 0x69, 0x6e, 0x67, 0x60, 0x75, 0x72, 0x7b, 0x7c, 0x51, 0x56, 0x5f, 0x58, 0x4d, 0x4a, 0x43, 0x44, 0x19, 0x1e, 0x17, 0x10, 0x05, 0x02, 0x0b, 0x0c, 0x21, 0x26, 0x2f, 0x28, 0x3d, 0x3a, 0x33, 0x34, 0x4e, 0x49, 0x40, 0x47, 0x52, 0x55, 0x5c, 0x5b, 0x76, 0x71, 0x78, 0x7f, 0x6a, 0x6d, 0x64, 0x63, 0x3e, 0x39, 0x30, 0x37, 0x22, 0x25, 0x2c, 0x2b, 0x06, 0x01, 0x08, 0x0f, 0x1a, 0x1d, 0x14, 0x13, 0xae, 0xa9, 0xa0, 0xa7, 0xb2, 0xb5, 0xbc, 0xbb, 0x96, 0x91, 0x98, 0x9f, 0x8a, 0x8d, 0x84, 0x83, 0xde, 0xd9, 0xd0, 0xd7, 0xc2, 0xc5, 0xcc, 0xcb, 0xe6, 0xe1, 0xe8, 0xef, 0xfa, 0xfd, 0xf4, 0xf3];
    
    if (typeof Int32Array !== 'undefined') {
      TABLE = new Int32Array(TABLE);
    }
    
    module.exports = create('crc-8', function(buf, previous) {
      var byte, crc, _i, _len;
      if (!Buffer.isBuffer(buf)) {
        buf = Buffer(buf);
      }
      crc = ~~previous;
      for (_i = 0, _len = buf.length; _i < _len; _i++) {
        byte = buf[_i];
        crc = TABLE[(crc ^ byte) & 0xff] & 0xff;
      }
      return crc;
    });
    
  provide("crc/lib/crc8", module.exports);
}(global));

// pakmanager:crc/lib/crc8_1wire
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.7.1
    var Buffer, TABLE, create;
    
    Buffer = require('buffer').Buffer;
    
    create =  require('crc/lib/create');
    
    TABLE = [0x00, 0x5e, 0xbc, 0xe2, 0x61, 0x3f, 0xdd, 0x83, 0xc2, 0x9c, 0x7e, 0x20, 0xa3, 0xfd, 0x1f, 0x41, 0x9d, 0xc3, 0x21, 0x7f, 0xfc, 0xa2, 0x40, 0x1e, 0x5f, 0x01, 0xe3, 0xbd, 0x3e, 0x60, 0x82, 0xdc, 0x23, 0x7d, 0x9f, 0xc1, 0x42, 0x1c, 0xfe, 0xa0, 0xe1, 0xbf, 0x5d, 0x03, 0x80, 0xde, 0x3c, 0x62, 0xbe, 0xe0, 0x02, 0x5c, 0xdf, 0x81, 0x63, 0x3d, 0x7c, 0x22, 0xc0, 0x9e, 0x1d, 0x43, 0xa1, 0xff, 0x46, 0x18, 0xfa, 0xa4, 0x27, 0x79, 0x9b, 0xc5, 0x84, 0xda, 0x38, 0x66, 0xe5, 0xbb, 0x59, 0x07, 0xdb, 0x85, 0x67, 0x39, 0xba, 0xe4, 0x06, 0x58, 0x19, 0x47, 0xa5, 0xfb, 0x78, 0x26, 0xc4, 0x9a, 0x65, 0x3b, 0xd9, 0x87, 0x04, 0x5a, 0xb8, 0xe6, 0xa7, 0xf9, 0x1b, 0x45, 0xc6, 0x98, 0x7a, 0x24, 0xf8, 0xa6, 0x44, 0x1a, 0x99, 0xc7, 0x25, 0x7b, 0x3a, 0x64, 0x86, 0xd8, 0x5b, 0x05, 0xe7, 0xb9, 0x8c, 0xd2, 0x30, 0x6e, 0xed, 0xb3, 0x51, 0x0f, 0x4e, 0x10, 0xf2, 0xac, 0x2f, 0x71, 0x93, 0xcd, 0x11, 0x4f, 0xad, 0xf3, 0x70, 0x2e, 0xcc, 0x92, 0xd3, 0x8d, 0x6f, 0x31, 0xb2, 0xec, 0x0e, 0x50, 0xaf, 0xf1, 0x13, 0x4d, 0xce, 0x90, 0x72, 0x2c, 0x6d, 0x33, 0xd1, 0x8f, 0x0c, 0x52, 0xb0, 0xee, 0x32, 0x6c, 0x8e, 0xd0, 0x53, 0x0d, 0xef, 0xb1, 0xf0, 0xae, 0x4c, 0x12, 0x91, 0xcf, 0x2d, 0x73, 0xca, 0x94, 0x76, 0x28, 0xab, 0xf5, 0x17, 0x49, 0x08, 0x56, 0xb4, 0xea, 0x69, 0x37, 0xd5, 0x8b, 0x57, 0x09, 0xeb, 0xb5, 0x36, 0x68, 0x8a, 0xd4, 0x95, 0xcb, 0x29, 0x77, 0xf4, 0xaa, 0x48, 0x16, 0xe9, 0xb7, 0x55, 0x0b, 0x88, 0xd6, 0x34, 0x6a, 0x2b, 0x75, 0x97, 0xc9, 0x4a, 0x14, 0xf6, 0xa8, 0x74, 0x2a, 0xc8, 0x96, 0x15, 0x4b, 0xa9, 0xf7, 0xb6, 0xe8, 0x0a, 0x54, 0xd7, 0x89, 0x6b, 0x35];
    
    if (typeof Int32Array !== 'undefined') {
      TABLE = new Int32Array(TABLE);
    }
    
    module.exports = create('dallas-1-wire', function(buf, previous) {
      var byte, crc, _i, _len;
      if (!Buffer.isBuffer(buf)) {
        buf = Buffer(buf);
      }
      crc = ~~previous;
      for (_i = 0, _len = buf.length; _i < _len; _i++) {
        byte = buf[_i];
        crc = TABLE[(crc ^ byte) & 0xff] & 0xff;
      }
      return crc;
    });
    
  provide("crc/lib/crc8_1wire", module.exports);
}(global));

// pakmanager:crc/lib/crc16
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.7.1
    var Buffer, TABLE, create;
    
    Buffer = require('buffer').Buffer;
    
    create =  require('crc/lib/create');
    
    TABLE = [0x0000, 0xc0c1, 0xc181, 0x0140, 0xc301, 0x03c0, 0x0280, 0xc241, 0xc601, 0x06c0, 0x0780, 0xc741, 0x0500, 0xc5c1, 0xc481, 0x0440, 0xcc01, 0x0cc0, 0x0d80, 0xcd41, 0x0f00, 0xcfc1, 0xce81, 0x0e40, 0x0a00, 0xcac1, 0xcb81, 0x0b40, 0xc901, 0x09c0, 0x0880, 0xc841, 0xd801, 0x18c0, 0x1980, 0xd941, 0x1b00, 0xdbc1, 0xda81, 0x1a40, 0x1e00, 0xdec1, 0xdf81, 0x1f40, 0xdd01, 0x1dc0, 0x1c80, 0xdc41, 0x1400, 0xd4c1, 0xd581, 0x1540, 0xd701, 0x17c0, 0x1680, 0xd641, 0xd201, 0x12c0, 0x1380, 0xd341, 0x1100, 0xd1c1, 0xd081, 0x1040, 0xf001, 0x30c0, 0x3180, 0xf141, 0x3300, 0xf3c1, 0xf281, 0x3240, 0x3600, 0xf6c1, 0xf781, 0x3740, 0xf501, 0x35c0, 0x3480, 0xf441, 0x3c00, 0xfcc1, 0xfd81, 0x3d40, 0xff01, 0x3fc0, 0x3e80, 0xfe41, 0xfa01, 0x3ac0, 0x3b80, 0xfb41, 0x3900, 0xf9c1, 0xf881, 0x3840, 0x2800, 0xe8c1, 0xe981, 0x2940, 0xeb01, 0x2bc0, 0x2a80, 0xea41, 0xee01, 0x2ec0, 0x2f80, 0xef41, 0x2d00, 0xedc1, 0xec81, 0x2c40, 0xe401, 0x24c0, 0x2580, 0xe541, 0x2700, 0xe7c1, 0xe681, 0x2640, 0x2200, 0xe2c1, 0xe381, 0x2340, 0xe101, 0x21c0, 0x2080, 0xe041, 0xa001, 0x60c0, 0x6180, 0xa141, 0x6300, 0xa3c1, 0xa281, 0x6240, 0x6600, 0xa6c1, 0xa781, 0x6740, 0xa501, 0x65c0, 0x6480, 0xa441, 0x6c00, 0xacc1, 0xad81, 0x6d40, 0xaf01, 0x6fc0, 0x6e80, 0xae41, 0xaa01, 0x6ac0, 0x6b80, 0xab41, 0x6900, 0xa9c1, 0xa881, 0x6840, 0x7800, 0xb8c1, 0xb981, 0x7940, 0xbb01, 0x7bc0, 0x7a80, 0xba41, 0xbe01, 0x7ec0, 0x7f80, 0xbf41, 0x7d00, 0xbdc1, 0xbc81, 0x7c40, 0xb401, 0x74c0, 0x7580, 0xb541, 0x7700, 0xb7c1, 0xb681, 0x7640, 0x7200, 0xb2c1, 0xb381, 0x7340, 0xb101, 0x71c0, 0x7080, 0xb041, 0x5000, 0x90c1, 0x9181, 0x5140, 0x9301, 0x53c0, 0x5280, 0x9241, 0x9601, 0x56c0, 0x5780, 0x9741, 0x5500, 0x95c1, 0x9481, 0x5440, 0x9c01, 0x5cc0, 0x5d80, 0x9d41, 0x5f00, 0x9fc1, 0x9e81, 0x5e40, 0x5a00, 0x9ac1, 0x9b81, 0x5b40, 0x9901, 0x59c0, 0x5880, 0x9841, 0x8801, 0x48c0, 0x4980, 0x8941, 0x4b00, 0x8bc1, 0x8a81, 0x4a40, 0x4e00, 0x8ec1, 0x8f81, 0x4f40, 0x8d01, 0x4dc0, 0x4c80, 0x8c41, 0x4400, 0x84c1, 0x8581, 0x4540, 0x8701, 0x47c0, 0x4680, 0x8641, 0x8201, 0x42c0, 0x4380, 0x8341, 0x4100, 0x81c1, 0x8081, 0x4040];
    
    if (typeof Int32Array !== 'undefined') {
      TABLE = new Int32Array(TABLE);
    }
    
    module.exports = create('crc-16', function(buf, previous) {
      var byte, crc, _i, _len;
      if (!Buffer.isBuffer(buf)) {
        buf = Buffer(buf);
      }
      crc = ~~previous;
      for (_i = 0, _len = buf.length; _i < _len; _i++) {
        byte = buf[_i];
        crc = (TABLE[(crc ^ byte) & 0xff] ^ (crc >> 8)) & 0xffff;
      }
      return crc;
    });
    
  provide("crc/lib/crc16", module.exports);
}(global));

// pakmanager:crc/lib/crc16_ccitt
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.7.1
    var Buffer, TABLE, create;
    
    Buffer = require('buffer').Buffer;
    
    create =  require('crc/lib/create');
    
    TABLE = [0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7, 0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef, 0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6, 0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de, 0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485, 0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d, 0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4, 0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc, 0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823, 0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b, 0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12, 0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a, 0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41, 0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49, 0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70, 0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78, 0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f, 0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067, 0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e, 0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256, 0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d, 0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405, 0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c, 0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634, 0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab, 0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3, 0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a, 0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92, 0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9, 0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1, 0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8, 0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0];
    
    if (typeof Int32Array !== 'undefined') {
      TABLE = new Int32Array(TABLE);
    }
    
    module.exports = create('ccitt', function(buf, previous) {
      var byte, crc, _i, _len;
      if (!Buffer.isBuffer(buf)) {
        buf = Buffer(buf);
      }
      crc = previous != null ? ~~previous : 0xffff;
      for (_i = 0, _len = buf.length; _i < _len; _i++) {
        byte = buf[_i];
        crc = (TABLE[((crc >> 8) ^ byte) & 0xff] ^ (crc << 8)) & 0xffff;
      }
      return crc;
    });
    
  provide("crc/lib/crc16_ccitt", module.exports);
}(global));

// pakmanager:crc/lib/crc16_modbus
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.7.1
    var Buffer, TABLE, create;
    
    Buffer = require('buffer').Buffer;
    
    create =  require('crc/lib/create');
    
    TABLE = [0x0000, 0xc0c1, 0xc181, 0x0140, 0xc301, 0x03c0, 0x0280, 0xc241, 0xc601, 0x06c0, 0x0780, 0xc741, 0x0500, 0xc5c1, 0xc481, 0x0440, 0xcc01, 0x0cc0, 0x0d80, 0xcd41, 0x0f00, 0xcfc1, 0xce81, 0x0e40, 0x0a00, 0xcac1, 0xcb81, 0x0b40, 0xc901, 0x09c0, 0x0880, 0xc841, 0xd801, 0x18c0, 0x1980, 0xd941, 0x1b00, 0xdbc1, 0xda81, 0x1a40, 0x1e00, 0xdec1, 0xdf81, 0x1f40, 0xdd01, 0x1dc0, 0x1c80, 0xdc41, 0x1400, 0xd4c1, 0xd581, 0x1540, 0xd701, 0x17c0, 0x1680, 0xd641, 0xd201, 0x12c0, 0x1380, 0xd341, 0x1100, 0xd1c1, 0xd081, 0x1040, 0xf001, 0x30c0, 0x3180, 0xf141, 0x3300, 0xf3c1, 0xf281, 0x3240, 0x3600, 0xf6c1, 0xf781, 0x3740, 0xf501, 0x35c0, 0x3480, 0xf441, 0x3c00, 0xfcc1, 0xfd81, 0x3d40, 0xff01, 0x3fc0, 0x3e80, 0xfe41, 0xfa01, 0x3ac0, 0x3b80, 0xfb41, 0x3900, 0xf9c1, 0xf881, 0x3840, 0x2800, 0xe8c1, 0xe981, 0x2940, 0xeb01, 0x2bc0, 0x2a80, 0xea41, 0xee01, 0x2ec0, 0x2f80, 0xef41, 0x2d00, 0xedc1, 0xec81, 0x2c40, 0xe401, 0x24c0, 0x2580, 0xe541, 0x2700, 0xe7c1, 0xe681, 0x2640, 0x2200, 0xe2c1, 0xe381, 0x2340, 0xe101, 0x21c0, 0x2080, 0xe041, 0xa001, 0x60c0, 0x6180, 0xa141, 0x6300, 0xa3c1, 0xa281, 0x6240, 0x6600, 0xa6c1, 0xa781, 0x6740, 0xa501, 0x65c0, 0x6480, 0xa441, 0x6c00, 0xacc1, 0xad81, 0x6d40, 0xaf01, 0x6fc0, 0x6e80, 0xae41, 0xaa01, 0x6ac0, 0x6b80, 0xab41, 0x6900, 0xa9c1, 0xa881, 0x6840, 0x7800, 0xb8c1, 0xb981, 0x7940, 0xbb01, 0x7bc0, 0x7a80, 0xba41, 0xbe01, 0x7ec0, 0x7f80, 0xbf41, 0x7d00, 0xbdc1, 0xbc81, 0x7c40, 0xb401, 0x74c0, 0x7580, 0xb541, 0x7700, 0xb7c1, 0xb681, 0x7640, 0x7200, 0xb2c1, 0xb381, 0x7340, 0xb101, 0x71c0, 0x7080, 0xb041, 0x5000, 0x90c1, 0x9181, 0x5140, 0x9301, 0x53c0, 0x5280, 0x9241, 0x9601, 0x56c0, 0x5780, 0x9741, 0x5500, 0x95c1, 0x9481, 0x5440, 0x9c01, 0x5cc0, 0x5d80, 0x9d41, 0x5f00, 0x9fc1, 0x9e81, 0x5e40, 0x5a00, 0x9ac1, 0x9b81, 0x5b40, 0x9901, 0x59c0, 0x5880, 0x9841, 0x8801, 0x48c0, 0x4980, 0x8941, 0x4b00, 0x8bc1, 0x8a81, 0x4a40, 0x4e00, 0x8ec1, 0x8f81, 0x4f40, 0x8d01, 0x4dc0, 0x4c80, 0x8c41, 0x4400, 0x84c1, 0x8581, 0x4540, 0x8701, 0x47c0, 0x4680, 0x8641, 0x8201, 0x42c0, 0x4380, 0x8341, 0x4100, 0x81c1, 0x8081, 0x4040];
    
    if (typeof Int32Array !== 'undefined') {
      TABLE = new Int32Array(TABLE);
    }
    
    module.exports = create('crc-16-modbus', function(buf, previous) {
      var byte, crc, _i, _len;
      if (!Buffer.isBuffer(buf)) {
        buf = Buffer(buf);
      }
      crc = previous != null ? ~~previous : 0xffff;
      for (_i = 0, _len = buf.length; _i < _len; _i++) {
        byte = buf[_i];
        crc = (TABLE[(crc ^ byte) & 0xff] ^ (crc >> 8)) & 0xffff;
      }
      return crc;
    });
    
  provide("crc/lib/crc16_modbus", module.exports);
}(global));

// pakmanager:crc/lib/crc24
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.7.1
    var Buffer, TABLE, create;
    
    Buffer = require('buffer').Buffer;
    
    create =  require('crc/lib/create');
    
    TABLE = [0x000000, 0x864cfb, 0x8ad50d, 0x0c99f6, 0x93e6e1, 0x15aa1a, 0x1933ec, 0x9f7f17, 0xa18139, 0x27cdc2, 0x2b5434, 0xad18cf, 0x3267d8, 0xb42b23, 0xb8b2d5, 0x3efe2e, 0xc54e89, 0x430272, 0x4f9b84, 0xc9d77f, 0x56a868, 0xd0e493, 0xdc7d65, 0x5a319e, 0x64cfb0, 0xe2834b, 0xee1abd, 0x685646, 0xf72951, 0x7165aa, 0x7dfc5c, 0xfbb0a7, 0x0cd1e9, 0x8a9d12, 0x8604e4, 0x00481f, 0x9f3708, 0x197bf3, 0x15e205, 0x93aefe, 0xad50d0, 0x2b1c2b, 0x2785dd, 0xa1c926, 0x3eb631, 0xb8faca, 0xb4633c, 0x322fc7, 0xc99f60, 0x4fd39b, 0x434a6d, 0xc50696, 0x5a7981, 0xdc357a, 0xd0ac8c, 0x56e077, 0x681e59, 0xee52a2, 0xe2cb54, 0x6487af, 0xfbf8b8, 0x7db443, 0x712db5, 0xf7614e, 0x19a3d2, 0x9fef29, 0x9376df, 0x153a24, 0x8a4533, 0x0c09c8, 0x00903e, 0x86dcc5, 0xb822eb, 0x3e6e10, 0x32f7e6, 0xb4bb1d, 0x2bc40a, 0xad88f1, 0xa11107, 0x275dfc, 0xdced5b, 0x5aa1a0, 0x563856, 0xd074ad, 0x4f0bba, 0xc94741, 0xc5deb7, 0x43924c, 0x7d6c62, 0xfb2099, 0xf7b96f, 0x71f594, 0xee8a83, 0x68c678, 0x645f8e, 0xe21375, 0x15723b, 0x933ec0, 0x9fa736, 0x19ebcd, 0x8694da, 0x00d821, 0x0c41d7, 0x8a0d2c, 0xb4f302, 0x32bff9, 0x3e260f, 0xb86af4, 0x2715e3, 0xa15918, 0xadc0ee, 0x2b8c15, 0xd03cb2, 0x567049, 0x5ae9bf, 0xdca544, 0x43da53, 0xc596a8, 0xc90f5e, 0x4f43a5, 0x71bd8b, 0xf7f170, 0xfb6886, 0x7d247d, 0xe25b6a, 0x641791, 0x688e67, 0xeec29c, 0x3347a4, 0xb50b5f, 0xb992a9, 0x3fde52, 0xa0a145, 0x26edbe, 0x2a7448, 0xac38b3, 0x92c69d, 0x148a66, 0x181390, 0x9e5f6b, 0x01207c, 0x876c87, 0x8bf571, 0x0db98a, 0xf6092d, 0x7045d6, 0x7cdc20, 0xfa90db, 0x65efcc, 0xe3a337, 0xef3ac1, 0x69763a, 0x578814, 0xd1c4ef, 0xdd5d19, 0x5b11e2, 0xc46ef5, 0x42220e, 0x4ebbf8, 0xc8f703, 0x3f964d, 0xb9dab6, 0xb54340, 0x330fbb, 0xac70ac, 0x2a3c57, 0x26a5a1, 0xa0e95a, 0x9e1774, 0x185b8f, 0x14c279, 0x928e82, 0x0df195, 0x8bbd6e, 0x872498, 0x016863, 0xfad8c4, 0x7c943f, 0x700dc9, 0xf64132, 0x693e25, 0xef72de, 0xe3eb28, 0x65a7d3, 0x5b59fd, 0xdd1506, 0xd18cf0, 0x57c00b, 0xc8bf1c, 0x4ef3e7, 0x426a11, 0xc426ea, 0x2ae476, 0xaca88d, 0xa0317b, 0x267d80, 0xb90297, 0x3f4e6c, 0x33d79a, 0xb59b61, 0x8b654f, 0x0d29b4, 0x01b042, 0x87fcb9, 0x1883ae, 0x9ecf55, 0x9256a3, 0x141a58, 0xefaaff, 0x69e604, 0x657ff2, 0xe33309, 0x7c4c1e, 0xfa00e5, 0xf69913, 0x70d5e8, 0x4e2bc6, 0xc8673d, 0xc4fecb, 0x42b230, 0xddcd27, 0x5b81dc, 0x57182a, 0xd154d1, 0x26359f, 0xa07964, 0xace092, 0x2aac69, 0xb5d37e, 0x339f85, 0x3f0673, 0xb94a88, 0x87b4a6, 0x01f85d, 0x0d61ab, 0x8b2d50, 0x145247, 0x921ebc, 0x9e874a, 0x18cbb1, 0xe37b16, 0x6537ed, 0x69ae1b, 0xefe2e0, 0x709df7, 0xf6d10c, 0xfa48fa, 0x7c0401, 0x42fa2f, 0xc4b6d4, 0xc82f22, 0x4e63d9, 0xd11cce, 0x575035, 0x5bc9c3, 0xdd8538];
    
    if (typeof Int32Array !== 'undefined') {
      TABLE = new Int32Array(TABLE);
    }
    
    module.exports = create('crc-24', function(buf, previous) {
      var byte, crc, _i, _len;
      if (!Buffer.isBuffer(buf)) {
        buf = Buffer(buf);
      }
      crc = previous != null ? ~~previous : 0xb704ce;
      for (_i = 0, _len = buf.length; _i < _len; _i++) {
        byte = buf[_i];
        crc = (TABLE[((crc >> 16) ^ byte) & 0xff] ^ (crc << 8)) & 0xffffff;
      }
      return crc;
    });
    
  provide("crc/lib/crc24", module.exports);
}(global));

// pakmanager:crc/lib/crc32
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.7.1
    var Buffer, TABLE, create;
    
    Buffer = require('buffer').Buffer;
    
    create =  require('crc/lib/create');
    
    TABLE = [0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d];
    
    if (typeof Int32Array !== 'undefined') {
      TABLE = new Int32Array(TABLE);
    }
    
    module.exports = create('crc-32', function(buf, previous) {
      var byte, crc, _i, _len;
      if (!Buffer.isBuffer(buf)) {
        buf = Buffer(buf);
      }
      crc = previous === 0 ? 0 : ~~previous ^ -1;
      for (_i = 0, _len = buf.length; _i < _len; _i++) {
        byte = buf[_i];
        crc = TABLE[(crc ^ byte) & 0xff] ^ (crc >>> 8);
      }
      return crc ^ -1;
    });
    
  provide("crc/lib/crc32", module.exports);
}(global));

// pakmanager:crc
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.7.1
    module.exports = {
      crc1:  require('crc/lib/crc1'),
      crc8:  require('crc/lib/crc8'),
      crc81wire:  require('crc/lib/crc8_1wire'),
      crc16:  require('crc/lib/crc16'),
      crc16ccitt:  require('crc/lib/crc16_ccitt'),
      crc16modbus:  require('crc/lib/crc16_modbus'),
      crc24:  require('crc/lib/crc24'),
      crc32:  require('crc/lib/crc32')
    };
    
  provide("crc", module.exports);
}(global));

// pakmanager:ee-first
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    module.exports = function first(stuff, done) {
      if (!Array.isArray(stuff))
        throw new TypeError('arg must be an array of [ee, events...] arrays')
    
      var cleanups = []
    
      for (var i = 0; i < stuff.length; i++) {
        var arr = stuff[i]
    
        if (!Array.isArray(arr) || arr.length < 2)
          throw new TypeError('each array member must be [ee, events...]')
    
        var ee = arr[0]
    
        for (var j = 1; j < arr.length; j++) {
          var event = arr[j]
          var fn = listener(event, callback)
    
          // listen to the event
          ee.on(event, fn)
          // push this listener to the list of cleanups
          cleanups.push({
            ee: ee,
            event: event,
            fn: fn,
          })
        }
      }
    
      function callback() {
        cleanup()
        done.apply(null, arguments)
      }
    
      function cleanup() {
        var x
        for (var i = 0; i < cleanups.length; i++) {
          x = cleanups[i]
          x.ee.removeListener(x.event, x.fn)
        }
      }
    
      function thunk(fn) {
        done = fn
      }
    
      thunk.cancel = cleanup
    
      return thunk
    }
    
    function listener(event, done) {
      return function onevent(arg1) {
        var args = new Array(arguments.length)
        var ee = this
        var err = event === 'error'
          ? arg1
          : null
    
        // copy args to prevent arguments escaping scope
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i]
        }
    
        done(err, ee, event, args)
      }
    }
    
  provide("ee-first", module.exports);
}(global));

// pakmanager:wrappy
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Returns a wrapper function that returns a wrapped callback
    // The wrapper function should do some stuff, and return a
    // presumably different callback function.
    // This makes sure that own properties are retained, so that
    // decorations and such are not lost along the way.
    module.exports = wrappy
    function wrappy (fn, cb) {
      if (fn && cb) return wrappy(fn)(cb)
    
      if (typeof fn !== 'function')
        throw new TypeError('need wrapper function')
    
      Object.keys(fn).forEach(function (k) {
        wrapper[k] = fn[k]
      })
    
      return wrapper
    
      function wrapper() {
        var args = new Array(arguments.length)
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i]
        }
        var ret = fn.apply(this, args)
        var cb = args[args.length-1]
        if (typeof ret === 'function' && ret !== cb) {
          Object.keys(cb).forEach(function (k) {
            ret[k] = cb[k]
          })
        }
        return ret
      }
    }
    
  provide("wrappy", module.exports);
}(global));

// pakmanager:acorn
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.acorn = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
    
    
    // The main exported interface (under `self.acorn` when in the
    // browser) is a `parse` function that takes a code string and
    // returns an abstract syntax tree as specified by [Mozilla parser
    // API][api].
    //
    // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
    
    "use strict";
    
    exports.parse = parse;
    
    // This function tries to parse a single expression at a given
    // offset in a string. Useful for parsing mixed-language formats
    // that embed JavaScript expressions.
    
    exports.parseExpressionAt = parseExpressionAt;
    
    // Acorn is organized as a tokenizer and a recursive-descent parser.
    // The `tokenize` export provides an interface to the tokenizer.
    
    exports.tokenizer = tokenizer;
    exports.__esModule = true;
    // Acorn is a tiny, fast JavaScript parser written in JavaScript.
    //
    // Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
    // various contributors and released under an MIT license.
    //
    // Git repositories for Acorn are available at
    //
    //     http://marijnhaverbeke.nl/git/acorn
    //     https://github.com/marijnh/acorn.git
    //
    // Please use the [github bug tracker][ghbt] to report issues.
    //
    // [ghbt]: https://github.com/marijnh/acorn/issues
    //
    // This file defines the main parser interface. The library also comes
    // with a [error-tolerant parser][dammit] and an
    // [abstract syntax tree walker][walk], defined in other files.
    //
    // [dammit]: acorn_loose.js
    // [walk]: util/walk.js
    
    var _state = _dereq_("./state");
    
    var Parser = _state.Parser;
    
    var _options = _dereq_("./options");
    
    var getOptions = _options.getOptions;
    
    _dereq_("./parseutil");
    
    _dereq_("./statement");
    
    _dereq_("./lval");
    
    _dereq_("./expression");
    
    exports.Parser = _state.Parser;
    exports.plugins = _state.plugins;
    exports.defaultOptions = _options.defaultOptions;
    
    var _location = _dereq_("./location");
    
    exports.SourceLocation = _location.SourceLocation;
    exports.getLineInfo = _location.getLineInfo;
    exports.Node = _dereq_("./node").Node;
    
    var _tokentype = _dereq_("./tokentype");
    
    exports.TokenType = _tokentype.TokenType;
    exports.tokTypes = _tokentype.types;
    
    var _tokencontext = _dereq_("./tokencontext");
    
    exports.TokContext = _tokencontext.TokContext;
    exports.tokContexts = _tokencontext.types;
    
    var _identifier = _dereq_("./identifier");
    
    exports.isIdentifierChar = _identifier.isIdentifierChar;
    exports.isIdentifierStart = _identifier.isIdentifierStart;
    exports.Token = _dereq_("./tokenize").Token;
    
    var _whitespace = _dereq_("./whitespace");
    
    exports.isNewLine = _whitespace.isNewLine;
    exports.lineBreak = _whitespace.lineBreak;
    exports.lineBreakG = _whitespace.lineBreakG;
    var version = "1.1.0";exports.version = version;
    
    function parse(input, options) {
      var p = parser(options, input);
      var startPos = p.pos,
          startLoc = p.options.locations && p.curPosition();
      p.nextToken();
      return p.parseTopLevel(p.options.program || p.startNodeAt(startPos, startLoc));
    }
    
    function parseExpressionAt(input, pos, options) {
      var p = parser(options, input, pos);
      p.nextToken();
      return p.parseExpression();
    }
    
    function tokenizer(input, options) {
      return parser(options, input);
    }
    
    function parser(options, input) {
      return new Parser(getOptions(options), String(input));
    }
    
    },{"./expression":2,"./identifier":3,"./location":4,"./lval":5,"./node":6,"./options":7,"./parseutil":8,"./state":9,"./statement":10,"./tokencontext":11,"./tokenize":12,"./tokentype":13,"./whitespace":15}],2:[function(_dereq_,module,exports){
    // A recursive descent parser operates by defining functions for all
    // syntactic elements, and recursively calling those, each function
    // advancing the input stream and returning an AST node. Precedence
    // of constructs (for example, the fact that `!x[1]` means `!(x[1])`
    // instead of `(!x)[1]` is handled by the fact that the parser
    // function that parses unary prefix operators is called first, and
    // in turn calls the function that parses `[]` subscripts — that
    // way, it'll receive the node for `x[1]` already parsed, and wraps
    // *that* in the unary operator node.
    //
    // Acorn uses an [operator precedence parser][opp] to handle binary
    // operator precedence, because it is much more compact than using
    // the technique outlined above, which uses different, nesting
    // functions to specify precedence, for all of the ten binary
    // precedence levels that JavaScript defines.
    //
    // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser
    
    "use strict";
    
    var tt = _dereq_("./tokentype").types;
    
    var Parser = _dereq_("./state").Parser;
    
    var reservedWords = _dereq_("./identifier").reservedWords;
    
    var has = _dereq_("./util").has;
    
    var pp = Parser.prototype;
    
    // Check if property name clashes with already added.
    // Object/class getters and setters are not allowed to clash —
    // either with each other or with an init property — and in
    // strict mode, init properties are also not allowed to be repeated.
    
    pp.checkPropClash = function (prop, propHash) {
      if (this.options.ecmaVersion >= 6) return;
      var key = prop.key,
          name = undefined;
      switch (key.type) {
        case "Identifier":
          name = key.name;break;
        case "Literal":
          name = String(key.value);break;
        default:
          return;
      }
      var kind = prop.kind || "init",
          other = undefined;
      if (has(propHash, name)) {
        other = propHash[name];
        var isGetSet = kind !== "init";
        if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) this.raise(key.start, "Redefinition of property");
      } else {
        other = propHash[name] = {
          init: false,
          get: false,
          set: false
        };
      }
      other[kind] = true;
    };
    
    // ### Expression parsing
    
    // These nest, from the most general expression type at the top to
    // 'atomic', nondivisible expression types at the bottom. Most of
    // the functions will simply let the function(s) below them parse,
    // and, *if* the syntactic construct they handle is present, wrap
    // the AST node that the inner parser gave them in another node.
    
    // Parse a full expression. The optional arguments are used to
    // forbid the `in` operator (in for loops initalization expressions)
    // and provide reference for storing '=' operator inside shorthand
    // property assignment in contexts where both object expression
    // and object pattern might appear (so it's possible to raise
    // delayed syntax error at correct position).
    
    pp.parseExpression = function (noIn, refShorthandDefaultPos) {
      var startPos = this.start,
          startLoc = this.startLoc;
      var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);
      if (this.type === tt.comma) {
        var node = this.startNodeAt(startPos, startLoc);
        node.expressions = [expr];
        while (this.eat(tt.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos));
        return this.finishNode(node, "SequenceExpression");
      }
      return expr;
    };
    
    // Parse an assignment expression. This includes applications of
    // operators like `+=`.
    
    pp.parseMaybeAssign = function (noIn, refShorthandDefaultPos, afterLeftParse) {
      if (this.type == tt._yield && this.inGenerator) return this.parseYield();
    
      var failOnShorthandAssign = undefined;
      if (!refShorthandDefaultPos) {
        refShorthandDefaultPos = { start: 0 };
        failOnShorthandAssign = true;
      } else {
        failOnShorthandAssign = false;
      }
      var startPos = this.start,
          startLoc = this.startLoc;
      if (this.type == tt.parenL || this.type == tt.name) this.potentialArrowAt = this.start;
      var left = this.parseMaybeConditional(noIn, refShorthandDefaultPos);
      if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
      if (this.type.isAssign) {
        var node = this.startNodeAt(startPos, startLoc);
        node.operator = this.value;
        node.left = this.type === tt.eq ? this.toAssignable(left) : left;
        refShorthandDefaultPos.start = 0; // reset because shorthand default was used correctly
        this.checkLVal(left);
        this.next();
        node.right = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "AssignmentExpression");
      } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {
        this.unexpected(refShorthandDefaultPos.start);
      }
      return left;
    };
    
    // Parse a ternary conditional (`?:`) operator.
    
    pp.parseMaybeConditional = function (noIn, refShorthandDefaultPos) {
      var startPos = this.start,
          startLoc = this.startLoc;
      var expr = this.parseExprOps(noIn, refShorthandDefaultPos);
      if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
      if (this.eat(tt.question)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssign();
        this.expect(tt.colon);
        node.alternate = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "ConditionalExpression");
      }
      return expr;
    };
    
    // Start the precedence parser.
    
    pp.parseExprOps = function (noIn, refShorthandDefaultPos) {
      var startPos = this.start,
          startLoc = this.startLoc;
      var expr = this.parseMaybeUnary(refShorthandDefaultPos);
      if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
      return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
    };
    
    // Parse binary operators with the operator precedence parsing
    // algorithm. `left` is the left-hand side of the operator.
    // `minPrec` provides context that allows the function to stop and
    // defer further parser to one of its callers when it encounters an
    // operator that has a lower precedence than the set it is parsing.
    
    pp.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
      var prec = this.type.binop;
      if (prec != null && (!noIn || this.type !== tt._in)) {
        if (prec > minPrec) {
          var node = this.startNodeAt(leftStartPos, leftStartLoc);
          node.left = left;
          node.operator = this.value;
          var op = this.type;
          this.next();
          var startPos = this.start,
              startLoc = this.startLoc;
          node.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec, noIn);
          this.finishNode(node, op === tt.logicalOR || op === tt.logicalAND ? "LogicalExpression" : "BinaryExpression");
          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
        }
      }
      return left;
    };
    
    // Parse unary operators, both prefix and postfix.
    
    pp.parseMaybeUnary = function (refShorthandDefaultPos) {
      if (this.type.prefix) {
        var node = this.startNode(),
            update = this.type === tt.incDec;
        node.operator = this.value;
        node.prefix = true;
        this.next();
        node.argument = this.parseMaybeUnary();
        if (refShorthandDefaultPos && refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start);
        if (update) this.checkLVal(node.argument);else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") this.raise(node.start, "Deleting local variable in strict mode");
        return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
      }
      var startPos = this.start,
          startLoc = this.startLoc;
      var expr = this.parseExprSubscripts(refShorthandDefaultPos);
      if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
      while (this.type.postfix && !this.canInsertSemicolon()) {
        var node = this.startNodeAt(startPos, startLoc);
        node.operator = this.value;
        node.prefix = false;
        node.argument = expr;
        this.checkLVal(expr);
        this.next();
        expr = this.finishNode(node, "UpdateExpression");
      }
      return expr;
    };
    
    // Parse call, dot, and `[]`-subscript expressions.
    
    pp.parseExprSubscripts = function (refShorthandDefaultPos) {
      var startPos = this.start,
          startLoc = this.startLoc;
      var expr = this.parseExprAtom(refShorthandDefaultPos);
      if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
      return this.parseSubscripts(expr, startPos, startLoc);
    };
    
    pp.parseSubscripts = function (base, startPos, startLoc, noCalls) {
      for (;;) {
        if (this.eat(tt.dot)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          node.property = this.parseIdent(true);
          node.computed = false;
          base = this.finishNode(node, "MemberExpression");
        } else if (this.eat(tt.bracketL)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          node.property = this.parseExpression();
          node.computed = true;
          this.expect(tt.bracketR);
          base = this.finishNode(node, "MemberExpression");
        } else if (!noCalls && this.eat(tt.parenL)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          node.arguments = this.parseExprList(tt.parenR, false);
          base = this.finishNode(node, "CallExpression");
        } else if (this.type === tt.backQuote) {
          var node = this.startNodeAt(startPos, startLoc);
          node.tag = base;
          node.quasi = this.parseTemplate();
          base = this.finishNode(node, "TaggedTemplateExpression");
        } else {
          return base;
        }
      }
    };
    
    // Parse an atomic expression — either a single token that is an
    // expression, an expression started by a keyword like `function` or
    // `new`, or an expression wrapped in punctuation like `()`, `[]`,
    // or `{}`.
    
    pp.parseExprAtom = function (refShorthandDefaultPos) {
      var node = undefined,
          canBeArrow = this.potentialArrowAt == this.start;
      switch (this.type) {
        case tt._this:
        case tt._super:
          var type = this.type === tt._this ? "ThisExpression" : "Super";
          node = this.startNode();
          this.next();
          return this.finishNode(node, type);
    
        case tt._yield:
          if (this.inGenerator) this.unexpected();
    
        case tt.name:
          var startPos = this.start,
              startLoc = this.startLoc;
          var id = this.parseIdent(this.type !== tt.name);
          if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id]);
          return id;
    
        case tt.regexp:
          var value = this.value;
          node = this.parseLiteral(value.value);
          node.regex = { pattern: value.pattern, flags: value.flags };
          return node;
    
        case tt.num:case tt.string:
          return this.parseLiteral(this.value);
    
        case tt._null:case tt._true:case tt._false:
          node = this.startNode();
          node.value = this.type === tt._null ? null : this.type === tt._true;
          node.raw = this.type.keyword;
          this.next();
          return this.finishNode(node, "Literal");
    
        case tt.parenL:
          return this.parseParenAndDistinguishExpression(canBeArrow);
    
        case tt.bracketL:
          node = this.startNode();
          this.next();
          // check whether this is array comprehension or regular array
          if (this.options.ecmaVersion >= 7 && this.type === tt._for) {
            return this.parseComprehension(node, false);
          }
          node.elements = this.parseExprList(tt.bracketR, true, true, refShorthandDefaultPos);
          return this.finishNode(node, "ArrayExpression");
    
        case tt.braceL:
          return this.parseObj(false, refShorthandDefaultPos);
    
        case tt._function:
          node = this.startNode();
          this.next();
          return this.parseFunction(node, false);
    
        case tt._class:
          return this.parseClass(this.startNode(), false);
    
        case tt._new:
          return this.parseNew();
    
        case tt.backQuote:
          return this.parseTemplate();
    
        default:
          this.unexpected();
      }
    };
    
    pp.parseLiteral = function (value) {
      var node = this.startNode();
      node.value = value;
      node.raw = this.input.slice(this.start, this.end);
      this.next();
      return this.finishNode(node, "Literal");
    };
    
    pp.parseParenExpression = function () {
      this.expect(tt.parenL);
      var val = this.parseExpression();
      this.expect(tt.parenR);
      return val;
    };
    
    pp.parseParenAndDistinguishExpression = function (canBeArrow) {
      var startPos = this.start,
          startLoc = this.startLoc,
          val = undefined;
      if (this.options.ecmaVersion >= 6) {
        this.next();
    
        if (this.options.ecmaVersion >= 7 && this.type === tt._for) {
          return this.parseComprehension(this.startNodeAt(startPos, startLoc), true);
        }
    
        var innerStartPos = this.start,
            innerStartLoc = this.startLoc;
        var exprList = [],
            first = true;
        var refShorthandDefaultPos = { start: 0 },
            spreadStart = undefined,
            innerParenStart = undefined;
        while (this.type !== tt.parenR) {
          first ? first = false : this.expect(tt.comma);
          if (this.type === tt.ellipsis) {
            spreadStart = this.start;
            exprList.push(this.parseParenItem(this.parseRest()));
            break;
          } else {
            if (this.type === tt.parenL && !innerParenStart) {
              innerParenStart = this.start;
            }
            exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem));
          }
        }
        var innerEndPos = this.start,
            innerEndLoc = this.startLoc;
        this.expect(tt.parenR);
    
        if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {
          if (innerParenStart) this.unexpected(innerParenStart);
          return this.parseParenArrowList(startPos, startLoc, exprList);
        }
    
        if (!exprList.length) this.unexpected(this.lastTokStart);
        if (spreadStart) this.unexpected(spreadStart);
        if (refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start);
    
        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartPos, innerStartLoc);
          val.expressions = exprList;
          this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
        } else {
          val = exprList[0];
        }
      } else {
        val = this.parseParenExpression();
      }
    
      if (this.options.preserveParens) {
        var par = this.startNodeAt(startPos, startLoc);
        par.expression = val;
        return this.finishNode(par, "ParenthesizedExpression");
      } else {
        return val;
      }
    };
    
    pp.parseParenItem = function (item) {
      return item;
    };
    
    pp.parseParenArrowList = function (startPos, startLoc, exprList) {
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
    };
    
    // New's precedence is slightly tricky. It must allow its argument
    // to be a `[]` or dot subscript expression, but not a call — at
    // least, not without wrapping it in parentheses. Thus, it uses the
    
    var empty = [];
    
    pp.parseNew = function () {
      var node = this.startNode();
      var meta = this.parseIdent(true);
      if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {
        node.meta = meta;
        node.property = this.parseIdent(true);
        if (node.property.name !== "target") this.raise(node.property.start, "The only valid meta property for new is new.target");
        return this.finishNode(node, "MetaProperty");
      }
      var startPos = this.start,
          startLoc = this.startLoc;
      node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
      if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, false);else node.arguments = empty;
      return this.finishNode(node, "NewExpression");
    };
    
    // Parse template expression.
    
    pp.parseTemplateElement = function () {
      var elem = this.startNode();
      elem.value = {
        raw: this.input.slice(this.start, this.end),
        cooked: this.value
      };
      this.next();
      elem.tail = this.type === tt.backQuote;
      return this.finishNode(elem, "TemplateElement");
    };
    
    pp.parseTemplate = function () {
      var node = this.startNode();
      this.next();
      node.expressions = [];
      var curElt = this.parseTemplateElement();
      node.quasis = [curElt];
      while (!curElt.tail) {
        this.expect(tt.dollarBraceL);
        node.expressions.push(this.parseExpression());
        this.expect(tt.braceR);
        node.quasis.push(curElt = this.parseTemplateElement());
      }
      this.next();
      return this.finishNode(node, "TemplateLiteral");
    };
    
    // Parse an object literal or binding pattern.
    
    pp.parseObj = function (isPattern, refShorthandDefaultPos) {
      var node = this.startNode(),
          first = true,
          propHash = {};
      node.properties = [];
      this.next();
      while (!this.eat(tt.braceR)) {
        if (!first) {
          this.expect(tt.comma);
          if (this.afterTrailingComma(tt.braceR)) break;
        } else first = false;
    
        var prop = this.startNode(),
            isGenerator = undefined,
            startPos = undefined,
            startLoc = undefined;
        if (this.options.ecmaVersion >= 6) {
          prop.method = false;
          prop.shorthand = false;
          if (isPattern || refShorthandDefaultPos) {
            startPos = this.start;
            startLoc = this.startLoc;
          }
          if (!isPattern) isGenerator = this.eat(tt.star);
        }
        this.parsePropertyName(prop);
        this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refShorthandDefaultPos);
        this.checkPropClash(prop, propHash);
        node.properties.push(this.finishNode(prop, "Property"));
      }
      return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
    };
    
    pp.parsePropertyValue = function (prop, isPattern, isGenerator, startPos, startLoc, refShorthandDefaultPos) {
      if (this.eat(tt.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refShorthandDefaultPos);
        prop.kind = "init";
      } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {
        if (isPattern) this.unexpected();
        prop.kind = "init";
        prop.method = true;
        prop.value = this.parseMethod(isGenerator);
      } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type != tt.comma && this.type != tt.braceR)) {
        if (isGenerator || isPattern) this.unexpected();
        prop.kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
      } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
        prop.kind = "init";
        if (isPattern) {
          if (this.isKeyword(prop.key.name) || this.strict && (reservedWords.strictBind(prop.key.name) || reservedWords.strict(prop.key.name)) || !this.options.allowReserved && this.isReservedWord(prop.key.name)) this.raise(prop.key.start, "Binding " + prop.key.name);
          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
        } else if (this.type === tt.eq && refShorthandDefaultPos) {
          if (!refShorthandDefaultPos.start) refShorthandDefaultPos.start = this.start;
          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
        } else {
          prop.value = prop.key;
        }
        prop.shorthand = true;
      } else this.unexpected();
    };
    
    pp.parsePropertyName = function (prop) {
      if (this.options.ecmaVersion >= 6) {
        if (this.eat(tt.bracketL)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssign();
          this.expect(tt.bracketR);
          return;
        } else {
          prop.computed = false;
        }
      }
      prop.key = this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(true);
    };
    
    // Initialize empty function node.
    
    pp.initFunction = function (node) {
      node.id = null;
      if (this.options.ecmaVersion >= 6) {
        node.generator = false;
        node.expression = false;
      }
    };
    
    // Parse object or class method.
    
    pp.parseMethod = function (isGenerator) {
      var node = this.startNode();
      this.initFunction(node);
      this.expect(tt.parenL);
      node.params = this.parseBindingList(tt.parenR, false, false);
      var allowExpressionBody = undefined;
      if (this.options.ecmaVersion >= 6) {
        node.generator = isGenerator;
        allowExpressionBody = true;
      } else {
        allowExpressionBody = false;
      }
      this.parseFunctionBody(node, allowExpressionBody);
      return this.finishNode(node, "FunctionExpression");
    };
    
    // Parse arrow function expression with given parameters.
    
    pp.parseArrowExpression = function (node, params) {
      this.initFunction(node);
      node.params = this.toAssignableList(params, true);
      this.parseFunctionBody(node, true);
      return this.finishNode(node, "ArrowFunctionExpression");
    };
    
    // Parse function body and check parameters.
    
    pp.parseFunctionBody = function (node, allowExpression) {
      var isExpression = allowExpression && this.type !== tt.braceL;
    
      if (isExpression) {
        node.body = this.parseMaybeAssign();
        node.expression = true;
      } else {
        // Start a new scope with regard to labels and the `inFunction`
        // flag (restore them to their old value afterwards).
        var oldInFunc = this.inFunction,
            oldInGen = this.inGenerator,
            oldLabels = this.labels;
        this.inFunction = true;this.inGenerator = node.generator;this.labels = [];
        node.body = this.parseBlock(true);
        node.expression = false;
        this.inFunction = oldInFunc;this.inGenerator = oldInGen;this.labels = oldLabels;
      }
    
      // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.
      if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {
        var nameHash = {},
            oldStrict = this.strict;
        this.strict = true;
        if (node.id) this.checkLVal(node.id, true);
        for (var i = 0; i < node.params.length; i++) {
          this.checkLVal(node.params[i], true, nameHash);
        }this.strict = oldStrict;
      }
    };
    
    // Parses a comma-separated list of expressions, and returns them as
    // an array. `close` is the token type that ends the list, and
    // `allowEmpty` can be turned on to allow subsequent commas with
    // nothing in between them to be parsed as `null` (which is needed
    // for array literals).
    
    pp.parseExprList = function (close, allowTrailingComma, allowEmpty, refShorthandDefaultPos) {
      var elts = [],
          first = true;
      while (!this.eat(close)) {
        if (!first) {
          this.expect(tt.comma);
          if (allowTrailingComma && this.afterTrailingComma(close)) break;
        } else first = false;
    
        if (allowEmpty && this.type === tt.comma) {
          elts.push(null);
        } else {
          if (this.type === tt.ellipsis) elts.push(this.parseSpread(refShorthandDefaultPos));else elts.push(this.parseMaybeAssign(false, refShorthandDefaultPos));
        }
      }
      return elts;
    };
    
    // Parse the next token as an identifier. If `liberal` is true (used
    // when parsing properties), it will also convert keywords into
    // identifiers.
    
    pp.parseIdent = function (liberal) {
      var node = this.startNode();
      if (liberal && this.options.allowReserved == "never") liberal = false;
      if (this.type === tt.name) {
        if (!liberal && (!this.options.allowReserved && this.isReservedWord(this.value) || this.strict && reservedWords.strict(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf("\\") == -1))) this.raise(this.start, "The keyword '" + this.value + "' is reserved");
        node.name = this.value;
      } else if (liberal && this.type.keyword) {
        node.name = this.type.keyword;
      } else {
        this.unexpected();
      }
      this.next();
      return this.finishNode(node, "Identifier");
    };
    
    // Parses yield expression inside generator.
    
    pp.parseYield = function () {
      var node = this.startNode();
      this.next();
      if (this.type == tt.semi || this.canInsertSemicolon() || this.type != tt.star && !this.type.startsExpr) {
        node.delegate = false;
        node.argument = null;
      } else {
        node.delegate = this.eat(tt.star);
        node.argument = this.parseMaybeAssign();
      }
      return this.finishNode(node, "YieldExpression");
    };
    
    // Parses array and generator comprehensions.
    
    pp.parseComprehension = function (node, isGenerator) {
      node.blocks = [];
      while (this.type === tt._for) {
        var block = this.startNode();
        this.next();
        this.expect(tt.parenL);
        block.left = this.parseBindingAtom();
        this.checkLVal(block.left, true);
        this.expectContextual("of");
        block.right = this.parseExpression();
        this.expect(tt.parenR);
        node.blocks.push(this.finishNode(block, "ComprehensionBlock"));
      }
      node.filter = this.eat(tt._if) ? this.parseParenExpression() : null;
      node.body = this.parseExpression();
      this.expect(isGenerator ? tt.parenR : tt.bracketR);
      node.generator = isGenerator;
      return this.finishNode(node, "ComprehensionExpression");
    };
    
    },{"./identifier":3,"./state":9,"./tokentype":13,"./util":14}],3:[function(_dereq_,module,exports){
    
    
    // Test whether a given character code starts an identifier.
    
    "use strict";
    
    exports.isIdentifierStart = isIdentifierStart;
    
    // Test whether a given character is part of an identifier.
    
    exports.isIdentifierChar = isIdentifierChar;
    exports.__esModule = true;
    // This is a trick taken from Esprima. It turns out that, on
    // non-Chrome browsers, to check whether a string is in a set, a
    // predicate containing a big ugly `switch` statement is faster than
    // a regular expression, and on Chrome the two are about on par.
    // This function uses `eval` (non-lexical) to produce such a
    // predicate from a space-separated string of words.
    //
    // It starts by sorting the words by length.
    
    function makePredicate(words) {
      words = words.split(" ");
      var f = "",
          cats = [];
      out: for (var i = 0; i < words.length; ++i) {
        for (var j = 0; j < cats.length; ++j) {
          if (cats[j][0].length == words[i].length) {
            cats[j].push(words[i]);
            continue out;
          }
        }cats.push([words[i]]);
      }
      function compareTo(arr) {
        if (arr.length == 1) {
          return f += "return str === " + JSON.stringify(arr[0]) + ";";
        }f += "switch(str){";
        for (var i = 0; i < arr.length; ++i) {
          f += "case " + JSON.stringify(arr[i]) + ":";
        }f += "return true}return false;";
      }
    
      // When there are more than three length categories, an outer
      // switch first dispatches on the lengths, to save on comparisons.
    
      if (cats.length > 3) {
        cats.sort(function (a, b) {
          return b.length - a.length;
        });
        f += "switch(str.length){";
        for (var i = 0; i < cats.length; ++i) {
          var cat = cats[i];
          f += "case " + cat[0].length + ":";
          compareTo(cat);
        }
        f += "}"
    
        // Otherwise, simply generate a flat `switch` statement.
    
        ;
      } else {
        compareTo(words);
      }
      return new Function("str", f);
    }
    
    // Reserved word lists for various dialects of the language
    
    var reservedWords = {
      3: makePredicate("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile"),
      5: makePredicate("class enum extends super const export import"),
      6: makePredicate("enum await"),
      strict: makePredicate("implements interface let package private protected public static yield"),
      strictBind: makePredicate("eval arguments")
    };
    
    exports.reservedWords = reservedWords;
    // And the keywords
    
    var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
    
    var keywords = {
      5: makePredicate(ecma5AndLessKeywords),
      6: makePredicate(ecma5AndLessKeywords + " let const class extends export import yield super")
    };
    
    exports.keywords = keywords;
    // ## Character categories
    
    // Big ugly regular expressions that match characters in the
    // whitespace, identifier, and identifier-start categories. These
    // are only applied when a character is found to actually have a
    // code point above 128.
    // Generated by `tools/generate-identifier-regex.js`.
    
    var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠ-ࢲऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘౙౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൠൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᧁ-ᧇᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞭꞰꞱꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭟꭤꭥꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
    var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣤ-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఃా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഁ-ഃാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ංඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ູົຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏ᦰ-ᧀᧈᧉ᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭ᳲ-᳴᳸᳹᷀-᷵᷼-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-꣄꣐-꣙꣠-꣱꤀-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︭︳︴﹍-﹏０-９＿";
    
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    
    // These are a run-length and offset encoded representation of the
    // >0xffff code points that are a valid part of identifiers. The
    // offset starts at 0x10000, and each pair of numbers represents an
    // offset to the next range, and then a size of the range. They were
    // generated by tools/generate-identifier-regex.js
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 99, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 98, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 955, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 38, 17, 2, 24, 133, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 32, 4, 287, 47, 21, 1, 2, 0, 185, 46, 82, 47, 21, 0, 60, 42, 502, 63, 32, 0, 449, 56, 1288, 920, 104, 110, 2962, 1070, 13266, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 16481, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 1340, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 16355, 541];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 16, 9, 83, 11, 168, 11, 6, 9, 8, 2, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 316, 19, 13, 9, 214, 6, 3, 8, 112, 16, 16, 9, 82, 12, 9, 9, 535, 9, 20855, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 4305, 6, 792618, 239];
    
    // This has a complexity linear to the value of the code. The
    // assumption is that looking up astral identifier characters is
    // rare.
    function isInAstralSet(code, set) {
      var pos = 65536;
      for (var i = 0; i < set.length; i += 2) {
        pos += set[i];
        if (pos > code) {
          return false;
        }pos += set[i + 1];
        if (pos >= code) {
          return true;
        }
      }
    }
    function isIdentifierStart(code, astral) {
      if (code < 65) {
        return code === 36;
      }if (code < 91) {
        return true;
      }if (code < 97) {
        return code === 95;
      }if (code < 123) {
        return true;
      }if (code <= 65535) {
        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
      }if (astral === false) {
        return false;
      }return isInAstralSet(code, astralIdentifierStartCodes);
    }
    
    function isIdentifierChar(code, astral) {
      if (code < 48) {
        return code === 36;
      }if (code < 58) {
        return true;
      }if (code < 65) {
        return false;
      }if (code < 91) {
        return true;
      }if (code < 97) {
        return code === 95;
      }if (code < 123) {
        return true;
      }if (code <= 65535) {
        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
      }if (astral === false) {
        return false;
      }return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    
    },{}],4:[function(_dereq_,module,exports){
    "use strict";
    
    var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
    
    // The `getLineInfo` function is mostly useful when the
    // `locations` option is off (for performance reasons) and you
    // want to find the line/column position for a given character
    // offset. `input` should be the code string that the offset refers
    // into.
    
    exports.getLineInfo = getLineInfo;
    exports.__esModule = true;
    
    var Parser = _dereq_("./state").Parser;
    
    var lineBreakG = _dereq_("./whitespace").lineBreakG;
    
    // These are used when `options.locations` is on, for the
    // `startLoc` and `endLoc` properties.
    
    var Position = exports.Position = (function () {
      function Position(line, col) {
        _classCallCheck(this, Position);
    
        this.line = line;
        this.column = col;
      }
    
      Position.prototype.offset = function offset(n) {
        return new Position(this.line, this.column + n);
      };
    
      return Position;
    })();
    
    var SourceLocation = exports.SourceLocation = function SourceLocation(p, start, end) {
      _classCallCheck(this, SourceLocation);
    
      this.start = start;
      this.end = end;
      if (p.sourceFile !== null) this.source = p.sourceFile;
    };
    
    function getLineInfo(input, offset) {
      for (var line = 1, cur = 0;;) {
        lineBreakG.lastIndex = cur;
        var match = lineBreakG.exec(input);
        if (match && match.index < offset) {
          ++line;
          cur = match.index + match[0].length;
        } else {
          return new Position(line, offset - cur);
        }
      }
    }
    
    var pp = Parser.prototype;
    
    // This function is used to raise exceptions on parse errors. It
    // takes an offset integer (into the current `input`) to indicate
    // the location of the error, attaches the position to the end
    // of the error message, and then raises a `SyntaxError` with that
    // message.
    
    pp.raise = function (pos, message) {
      var loc = getLineInfo(this.input, pos);
      message += " (" + loc.line + ":" + loc.column + ")";
      var err = new SyntaxError(message);
      err.pos = pos;err.loc = loc;err.raisedAt = this.pos;
      throw err;
    };
    
    pp.curPosition = function () {
      return new Position(this.curLine, this.pos - this.lineStart);
    };
    
    },{"./state":9,"./whitespace":15}],5:[function(_dereq_,module,exports){
    "use strict";
    
    var tt = _dereq_("./tokentype").types;
    
    var Parser = _dereq_("./state").Parser;
    
    var reservedWords = _dereq_("./identifier").reservedWords;
    
    var has = _dereq_("./util").has;
    
    var pp = Parser.prototype;
    
    // Convert existing expression atom to assignable pattern
    // if possible.
    
    pp.toAssignable = function (node, isBinding) {
      if (this.options.ecmaVersion >= 6 && node) {
        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
            break;
    
          case "ObjectExpression":
            node.type = "ObjectPattern";
            for (var i = 0; i < node.properties.length; i++) {
              var prop = node.properties[i];
              if (prop.kind !== "init") this.raise(prop.key.start, "Object pattern can't contain getter or setter");
              this.toAssignable(prop.value, isBinding);
            }
            break;
    
          case "ArrayExpression":
            node.type = "ArrayPattern";
            this.toAssignableList(node.elements, isBinding);
            break;
    
          case "AssignmentExpression":
            if (node.operator === "=") {
              node.type = "AssignmentPattern";
            } else {
              this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
            }
            break;
    
          case "ParenthesizedExpression":
            node.expression = this.toAssignable(node.expression, isBinding);
            break;
    
          case "MemberExpression":
            if (!isBinding) break;
    
          default:
            this.raise(node.start, "Assigning to rvalue");
        }
      }
      return node;
    };
    
    // Convert list of expression atoms to binding list.
    
    pp.toAssignableList = function (exprList, isBinding) {
      var end = exprList.length;
      if (end) {
        var last = exprList[end - 1];
        if (last && last.type == "RestElement") {
          --end;
        } else if (last && last.type == "SpreadElement") {
          last.type = "RestElement";
          var arg = last.argument;
          this.toAssignable(arg, isBinding);
          if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") this.unexpected(arg.start);
          --end;
        }
      }
      for (var i = 0; i < end; i++) {
        var elt = exprList[i];
        if (elt) this.toAssignable(elt, isBinding);
      }
      return exprList;
    };
    
    // Parses spread element.
    
    pp.parseSpread = function (refShorthandDefaultPos) {
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeAssign(refShorthandDefaultPos);
      return this.finishNode(node, "SpreadElement");
    };
    
    pp.parseRest = function () {
      var node = this.startNode();
      this.next();
      node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected();
      return this.finishNode(node, "RestElement");
    };
    
    // Parses lvalue (assignable) atom.
    
    pp.parseBindingAtom = function () {
      if (this.options.ecmaVersion < 6) return this.parseIdent();
      switch (this.type) {
        case tt.name:
          return this.parseIdent();
    
        case tt.bracketL:
          var node = this.startNode();
          this.next();
          node.elements = this.parseBindingList(tt.bracketR, true, true);
          return this.finishNode(node, "ArrayPattern");
    
        case tt.braceL:
          return this.parseObj(true);
    
        default:
          this.unexpected();
      }
    };
    
    pp.parseBindingList = function (close, allowEmpty, allowTrailingComma) {
      var elts = [],
          first = true;
      while (!this.eat(close)) {
        if (first) first = false;else this.expect(tt.comma);
        if (allowEmpty && this.type === tt.comma) {
          elts.push(null);
        } else if (allowTrailingComma && this.afterTrailingComma(close)) {
          break;
        } else if (this.type === tt.ellipsis) {
          var rest = this.parseRest();
          this.parseBindingListItem(rest);
          elts.push(rest);
          this.expect(close);
          break;
        } else {
          var elem = this.parseMaybeDefault(this.start, this.startLoc);
          this.parseBindingListItem(elem);
          elts.push(elem);
        }
      }
      return elts;
    };
    
    pp.parseBindingListItem = function (param) {
      return param;
    };
    
    // Parses assignment pattern around given atom if possible.
    
    pp.parseMaybeDefault = function (startPos, startLoc, left) {
      left = left || this.parseBindingAtom();
      if (!this.eat(tt.eq)) return left;
      var node = this.startNodeAt(startPos, startLoc);
      node.operator = "=";
      node.left = left;
      node.right = this.parseMaybeAssign();
      return this.finishNode(node, "AssignmentPattern");
    };
    
    // Verify that a node is an lval — something that can be assigned
    // to.
    
    pp.checkLVal = function (expr, isBinding, checkClashes) {
      switch (expr.type) {
        case "Identifier":
          if (this.strict && (reservedWords.strictBind(expr.name) || reservedWords.strict(expr.name))) this.raise(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
          if (checkClashes) {
            if (has(checkClashes, expr.name)) this.raise(expr.start, "Argument name clash in strict mode");
            checkClashes[expr.name] = true;
          }
          break;
    
        case "MemberExpression":
          if (isBinding) this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
          break;
    
        case "ObjectPattern":
          for (var i = 0; i < expr.properties.length; i++) {
            this.checkLVal(expr.properties[i].value, isBinding, checkClashes);
          }break;
    
        case "ArrayPattern":
          for (var i = 0; i < expr.elements.length; i++) {
            var elem = expr.elements[i];
            if (elem) this.checkLVal(elem, isBinding, checkClashes);
          }
          break;
    
        case "AssignmentPattern":
          this.checkLVal(expr.left, isBinding, checkClashes);
          break;
    
        case "RestElement":
          this.checkLVal(expr.argument, isBinding, checkClashes);
          break;
    
        case "ParenthesizedExpression":
          this.checkLVal(expr.expression, isBinding, checkClashes);
          break;
    
        default:
          this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " rvalue");
      }
    };
    
    },{"./identifier":3,"./state":9,"./tokentype":13,"./util":14}],6:[function(_dereq_,module,exports){
    "use strict";
    
    var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
    
    exports.__esModule = true;
    
    var Parser = _dereq_("./state").Parser;
    
    var SourceLocation = _dereq_("./location").SourceLocation;
    
    // Start an AST node, attaching a start offset.
    
    var pp = Parser.prototype;
    
    var Node = exports.Node = function Node() {
      _classCallCheck(this, Node);
    };
    
    pp.startNode = function () {
      var node = new Node();
      node.start = this.start;
      if (this.options.locations) node.loc = new SourceLocation(this, this.startLoc);
      if (this.options.directSourceFile) node.sourceFile = this.options.directSourceFile;
      if (this.options.ranges) node.range = [this.start, 0];
      return node;
    };
    
    pp.startNodeAt = function (pos, loc) {
      var node = new Node();
      node.start = pos;
      if (this.options.locations) node.loc = new SourceLocation(this, loc);
      if (this.options.directSourceFile) node.sourceFile = this.options.directSourceFile;
      if (this.options.ranges) node.range = [pos, 0];
      return node;
    };
    
    // Finish an AST node, adding `type` and `end` properties.
    
    pp.finishNode = function (node, type) {
      node.type = type;
      node.end = this.lastTokEnd;
      if (this.options.locations) node.loc.end = this.lastTokEndLoc;
      if (this.options.ranges) node.range[1] = this.lastTokEnd;
      return node;
    };
    
    // Finish node at given position
    
    pp.finishNodeAt = function (node, type, pos, loc) {
      node.type = type;
      node.end = pos;
      if (this.options.locations) node.loc.end = loc;
      if (this.options.ranges) node.range[1] = pos;
      return node;
    };
    
    },{"./location":4,"./state":9}],7:[function(_dereq_,module,exports){
    
    
    // Interpret and default an options object
    
    "use strict";
    
    exports.getOptions = getOptions;
    exports.__esModule = true;
    
    var _util = _dereq_("./util");
    
    var has = _util.has;
    var isArray = _util.isArray;
    
    var SourceLocation = _dereq_("./location").SourceLocation;
    
    // A second optional argument can be given to further configure
    // the parser process. These options are recognized:
    
    var defaultOptions = {
      // `ecmaVersion` indicates the ECMAScript version to parse. Must
      // be either 3, or 5, or 6. This influences support for strict
      // mode, the set of reserved words, support for getters and
      // setters and other features.
      ecmaVersion: 5,
      // Source type ("script" or "module") for different semantics
      sourceType: "script",
      // `onInsertedSemicolon` can be a callback that will be called
      // when a semicolon is automatically inserted. It will be passed
      // th position of the comma as an offset, and if `locations` is
      // enabled, it is given the location as a `{line, column}` object
      // as second argument.
      onInsertedSemicolon: null,
      // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
      // trailing commas.
      onTrailingComma: null,
      // By default, reserved words are not enforced. Disable
      // `allowReserved` to enforce them. When this option has the
      // value "never", reserved words and keywords can also not be
      // used as property names.
      allowReserved: true,
      // When enabled, a return at the top level is not considered an
      // error.
      allowReturnOutsideFunction: false,
      // When enabled, import/export statements are not constrained to
      // appearing at the top of the program.
      allowImportExportEverywhere: false,
      // When enabled, hashbang directive in the beginning of file
      // is allowed and treated as a line comment.
      allowHashBang: false,
      // When `locations` is on, `loc` properties holding objects with
      // `start` and `end` properties in `{line, column}` form (with
      // line being 1-based and column 0-based) will be attached to the
      // nodes.
      locations: false,
      // A function can be passed as `onToken` option, which will
      // cause Acorn to call that function with object in the same
      // format as tokenize() returns. Note that you are not
      // allowed to call the parser from the callback—that will
      // corrupt its internal state.
      onToken: null,
      // A function can be passed as `onComment` option, which will
      // cause Acorn to call that function with `(block, text, start,
      // end)` parameters whenever a comment is skipped. `block` is a
      // boolean indicating whether this is a block (`/* */`) comment,
      // `text` is the content of the comment, and `start` and `end` are
      // character offsets that denote the start and end of the comment.
      // When the `locations` option is on, two more parameters are
      // passed, the full `{line, column}` locations of the start and
      // end of the comments. Note that you are not allowed to call the
      // parser from the callback—that will corrupt its internal state.
      onComment: null,
      // Nodes have their start and end characters offsets recorded in
      // `start` and `end` properties (directly on the node, rather than
      // the `loc` object, which holds line/column data. To also add a
      // [semi-standardized][range] `range` property holding a `[start,
      // end]` array with the same numbers, set the `ranges` option to
      // `true`.
      //
      // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
      ranges: false,
      // It is possible to parse multiple files into a single AST by
      // passing the tree produced by parsing the first file as
      // `program` option in subsequent parses. This will add the
      // toplevel forms of the parsed file to the `Program` (top) node
      // of an existing parse tree.
      program: null,
      // When `locations` is on, you can pass this to record the source
      // file in every node's `loc` object.
      sourceFile: null,
      // This value, if given, is stored in every node, whether
      // `locations` is on or off.
      directSourceFile: null,
      // When enabled, parenthesized expressions are represented by
      // (non-standard) ParenthesizedExpression nodes
      preserveParens: false,
      plugins: {}
    };exports.defaultOptions = defaultOptions;
    
    function getOptions(opts) {
      var options = {};
      for (var opt in defaultOptions) {
        options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];
      }if (isArray(options.onToken)) {
        (function () {
          var tokens = options.onToken;
          options.onToken = function (token) {
            return tokens.push(token);
          };
        })();
      }
      if (isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);
    
      return options;
    }
    
    function pushComment(options, array) {
      return function (block, text, start, end, startLoc, endLoc) {
        var comment = {
          type: block ? "Block" : "Line",
          value: text,
          start: start,
          end: end
        };
        if (options.locations) comment.loc = new SourceLocation(this, startLoc, endLoc);
        if (options.ranges) comment.range = [start, end];
        array.push(comment);
      };
    }
    
    },{"./location":4,"./util":14}],8:[function(_dereq_,module,exports){
    "use strict";
    
    var tt = _dereq_("./tokentype").types;
    
    var Parser = _dereq_("./state").Parser;
    
    var lineBreak = _dereq_("./whitespace").lineBreak;
    
    var pp = Parser.prototype;
    
    // ## Parser utilities
    
    // Test whether a statement node is the string literal `"use strict"`.
    
    pp.isUseStrict = function (stmt) {
      return this.options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.value === "use strict";
    };
    
    // Predicate that tests whether the next token is of the given
    // type, and if yes, consumes it as a side effect.
    
    pp.eat = function (type) {
      if (this.type === type) {
        this.next();
        return true;
      } else {
        return false;
      }
    };
    
    // Tests whether parsed token is a contextual keyword.
    
    pp.isContextual = function (name) {
      return this.type === tt.name && this.value === name;
    };
    
    // Consumes contextual keyword if possible.
    
    pp.eatContextual = function (name) {
      return this.value === name && this.eat(tt.name);
    };
    
    // Asserts that following token is given contextual keyword.
    
    pp.expectContextual = function (name) {
      if (!this.eatContextual(name)) this.unexpected();
    };
    
    // Test whether a semicolon can be inserted at the current position.
    
    pp.canInsertSemicolon = function () {
      return this.type === tt.eof || this.type === tt.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    };
    
    pp.insertSemicolon = function () {
      if (this.canInsertSemicolon()) {
        if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
        return true;
      }
    };
    
    // Consume a semicolon, or, failing that, see if we are allowed to
    // pretend that there is a semicolon at this position.
    
    pp.semicolon = function () {
      if (!this.eat(tt.semi) && !this.insertSemicolon()) this.unexpected();
    };
    
    pp.afterTrailingComma = function (tokType) {
      if (this.type == tokType) {
        if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
        this.next();
        return true;
      }
    };
    
    // Expect a token of a given type. If found, consume it, otherwise,
    // raise an unexpected token error.
    
    pp.expect = function (type) {
      this.eat(type) || this.unexpected();
    };
    
    // Raise an unexpected token error.
    
    pp.unexpected = function (pos) {
      this.raise(pos != null ? pos : this.start, "Unexpected token");
    };
    
    },{"./state":9,"./tokentype":13,"./whitespace":15}],9:[function(_dereq_,module,exports){
    "use strict";
    
    exports.Parser = Parser;
    exports.__esModule = true;
    
    var _identifier = _dereq_("./identifier");
    
    var reservedWords = _identifier.reservedWords;
    var keywords = _identifier.keywords;
    
    var _tokentype = _dereq_("./tokentype");
    
    var tt = _tokentype.types;
    var lineBreak = _tokentype.lineBreak;
    
    function Parser(options, input, startPos) {
      this.options = options;
      this.loadPlugins(this.options.plugins);
      this.sourceFile = this.options.sourceFile || null;
      this.isKeyword = keywords[this.options.ecmaVersion >= 6 ? 6 : 5];
      this.isReservedWord = reservedWords[this.options.ecmaVersion];
      this.input = input;
    
      // Set up token state
    
      // The current position of the tokenizer in the input.
      if (startPos) {
        this.pos = startPos;
        this.lineStart = Math.max(0, this.input.lastIndexOf("\n", startPos));
        this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
      } else {
        this.pos = this.lineStart = 0;
        this.curLine = 1;
      }
    
      // Properties of the current token:
      // Its type
      this.type = tt.eof;
      // For tokens that include more information than their type, the value
      this.value = null;
      // Its start and end offset
      this.start = this.end = this.pos;
      // And, if locations are used, the {line, column} object
      // corresponding to those offsets
      this.startLoc = this.endLoc = null;
    
      // Position information for the previous token
      this.lastTokEndLoc = this.lastTokStartLoc = null;
      this.lastTokStart = this.lastTokEnd = this.pos;
    
      // The context stack is used to superficially track syntactic
      // context to predict whether a regular expression is allowed in a
      // given position.
      this.context = this.initialContext();
      this.exprAllowed = true;
    
      // Figure out if it's a module code.
      this.strict = this.inModule = this.options.sourceType === "module";
    
      // Used to signify the start of a potential arrow function
      this.potentialArrowAt = -1;
    
      // Flags to track whether we are in a function, a generator.
      this.inFunction = this.inGenerator = false;
      // Labels in scope.
      this.labels = [];
    
      // If enabled, skip leading hashbang line.
      if (this.pos === 0 && this.options.allowHashBang && this.input.slice(0, 2) === "#!") this.skipLineComment(2);
    }
    
    Parser.prototype.extend = function (name, f) {
      this[name] = f(this[name]);
    };
    
    // Registered plugins
    
    var plugins = {};
    
    exports.plugins = plugins;
    Parser.prototype.loadPlugins = function (plugins) {
      for (var _name in plugins) {
        var plugin = exports.plugins[_name];
        if (!plugin) throw new Error("Plugin '" + _name + "' not found");
        plugin(this, plugins[_name]);
      }
    };
    
    },{"./identifier":3,"./tokentype":13}],10:[function(_dereq_,module,exports){
    "use strict";
    
    var tt = _dereq_("./tokentype").types;
    
    var Parser = _dereq_("./state").Parser;
    
    var lineBreak = _dereq_("./whitespace").lineBreak;
    
    var pp = Parser.prototype;
    
    // ### Statement parsing
    
    // Parse a program. Initializes the parser, reads any number of
    // statements, and wraps them in a Program node.  Optionally takes a
    // `program` argument.  If present, the statements will be appended
    // to its body instead of creating a new node.
    
    pp.parseTopLevel = function (node) {
      var first = true;
      if (!node.body) node.body = [];
      while (this.type !== tt.eof) {
        var stmt = this.parseStatement(true, true);
        node.body.push(stmt);
        if (first && this.isUseStrict(stmt)) this.setStrict(true);
        first = false;
      }
      this.next();
      if (this.options.ecmaVersion >= 6) {
        node.sourceType = this.options.sourceType;
      }
      return this.finishNode(node, "Program");
    };
    
    var loopLabel = { kind: "loop" },
        switchLabel = { kind: "switch" };
    
    // Parse a single statement.
    //
    // If expecting a statement and finding a slash operator, parse a
    // regular expression literal. This is to handle cases like
    // `if (foo) /blah/.exec(foo)`, where looking at the previous token
    // does not help.
    
    pp.parseStatement = function (declaration, topLevel) {
      var starttype = this.type,
          node = this.startNode();
    
      // Most types of statements are recognized by the keyword they
      // start with. Many are trivial to parse, some require a bit of
      // complexity.
    
      switch (starttype) {
        case tt._break:case tt._continue:
          return this.parseBreakContinueStatement(node, starttype.keyword);
        case tt._debugger:
          return this.parseDebuggerStatement(node);
        case tt._do:
          return this.parseDoStatement(node);
        case tt._for:
          return this.parseForStatement(node);
        case tt._function:
          if (!declaration && this.options.ecmaVersion >= 6) this.unexpected();
          return this.parseFunctionStatement(node);
        case tt._class:
          if (!declaration) this.unexpected();
          return this.parseClass(node, true);
        case tt._if:
          return this.parseIfStatement(node);
        case tt._return:
          return this.parseReturnStatement(node);
        case tt._switch:
          return this.parseSwitchStatement(node);
        case tt._throw:
          return this.parseThrowStatement(node);
        case tt._try:
          return this.parseTryStatement(node);
        case tt._let:case tt._const:
          if (!declaration) this.unexpected(); // NOTE: falls through to _var
        case tt._var:
          return this.parseVarStatement(node, starttype);
        case tt._while:
          return this.parseWhileStatement(node);
        case tt._with:
          return this.parseWithStatement(node);
        case tt.braceL:
          return this.parseBlock();
        case tt.semi:
          return this.parseEmptyStatement(node);
        case tt._export:
        case tt._import:
          if (!this.options.allowImportExportEverywhere) {
            if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
            if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
          }
          return starttype === tt._import ? this.parseImport(node) : this.parseExport(node);
    
        // If the statement does not start with a statement keyword or a
        // brace, it's an ExpressionStatement or LabeledStatement. We
        // simply start parsing an expression, and afterwards, if the
        // next token is a colon and the expression was a simple
        // Identifier node, we switch to interpreting it as a label.
        default:
          var maybeName = this.value,
              expr = this.parseExpression();
          if (starttype === tt.name && expr.type === "Identifier" && this.eat(tt.colon)) return this.parseLabeledStatement(node, maybeName, expr);else return this.parseExpressionStatement(node, expr);
      }
    };
    
    pp.parseBreakContinueStatement = function (node, keyword) {
      var isBreak = keyword == "break";
      this.next();
      if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null;else if (this.type !== tt.name) this.unexpected();else {
        node.label = this.parseIdent();
        this.semicolon();
      }
    
      // Verify that there is an actual destination to break or
      // continue to.
      for (var i = 0; i < this.labels.length; ++i) {
        var lab = this.labels[i];
        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
          if (node.label && isBreak) break;
        }
      }
      if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    };
    
    pp.parseDebuggerStatement = function (node) {
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement");
    };
    
    pp.parseDoStatement = function (node) {
      this.next();
      this.labels.push(loopLabel);
      node.body = this.parseStatement(false);
      this.labels.pop();
      this.expect(tt._while);
      node.test = this.parseParenExpression();
      if (this.options.ecmaVersion >= 6) this.eat(tt.semi);else this.semicolon();
      return this.finishNode(node, "DoWhileStatement");
    };
    
    // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
    // loop is non-trivial. Basically, we have to parse the init `var`
    // statement or expression, disallowing the `in` operator (see
    // the second parameter to `parseExpression`), and then check
    // whether the next token is `in` or `of`. When there is no init
    // part (semicolon immediately after the opening parenthesis), it
    // is a regular `for` loop.
    
    pp.parseForStatement = function (node) {
      this.next();
      this.labels.push(loopLabel);
      this.expect(tt.parenL);
      if (this.type === tt.semi) return this.parseFor(node, null);
      if (this.type === tt._var || this.type === tt._let || this.type === tt._const) {
        var _init = this.startNode(),
            varKind = this.type;
        this.next();
        this.parseVar(_init, true, varKind);
        this.finishNode(_init, "VariableDeclaration");
        if ((this.type === tt._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && _init.declarations.length === 1 && !(varKind !== tt._var && _init.declarations[0].init)) return this.parseForIn(node, _init);
        return this.parseFor(node, _init);
      }
      var refShorthandDefaultPos = { start: 0 };
      var init = this.parseExpression(true, refShorthandDefaultPos);
      if (this.type === tt._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
        this.toAssignable(init);
        this.checkLVal(init);
        return this.parseForIn(node, init);
      } else if (refShorthandDefaultPos.start) {
        this.unexpected(refShorthandDefaultPos.start);
      }
      return this.parseFor(node, init);
    };
    
    pp.parseFunctionStatement = function (node) {
      this.next();
      return this.parseFunction(node, true);
    };
    
    pp.parseIfStatement = function (node) {
      this.next();
      node.test = this.parseParenExpression();
      node.consequent = this.parseStatement(false);
      node.alternate = this.eat(tt._else) ? this.parseStatement(false) : null;
      return this.finishNode(node, "IfStatement");
    };
    
    pp.parseReturnStatement = function (node) {
      if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
      this.next();
    
      // In `return` (and `break`/`continue`), the keywords with
      // optional arguments, we eagerly look for a semicolon or the
      // possibility to insert one.
    
      if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null;else {
        node.argument = this.parseExpression();this.semicolon();
      }
      return this.finishNode(node, "ReturnStatement");
    };
    
    pp.parseSwitchStatement = function (node) {
      this.next();
      node.discriminant = this.parseParenExpression();
      node.cases = [];
      this.expect(tt.braceL);
      this.labels.push(switchLabel);
    
      // Statements under must be grouped (by label) in SwitchCase
      // nodes. `cur` is used to keep the node that we are currently
      // adding statements to.
    
      for (var cur, sawDefault; this.type != tt.braceR;) {
        if (this.type === tt._case || this.type === tt._default) {
          var isCase = this.type === tt._case;
          if (cur) this.finishNode(cur, "SwitchCase");
          node.cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) this.raise(this.lastTokStart, "Multiple default clauses");
            sawDefault = true;
            cur.test = null;
          }
          this.expect(tt.colon);
        } else {
          if (!cur) this.unexpected();
          cur.consequent.push(this.parseStatement(true));
        }
      }
      if (cur) this.finishNode(cur, "SwitchCase");
      this.next(); // Closing brace
      this.labels.pop();
      return this.finishNode(node, "SwitchStatement");
    };
    
    pp.parseThrowStatement = function (node) {
      this.next();
      if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement");
    };
    
    // Reused empty array added for node fields that are always empty.
    
    var empty = [];
    
    pp.parseTryStatement = function (node) {
      this.next();
      node.block = this.parseBlock();
      node.handler = null;
      if (this.type === tt._catch) {
        var clause = this.startNode();
        this.next();
        this.expect(tt.parenL);
        clause.param = this.parseBindingAtom();
        this.checkLVal(clause.param, true);
        this.expect(tt.parenR);
        clause.guard = null;
        clause.body = this.parseBlock();
        node.handler = this.finishNode(clause, "CatchClause");
      }
      node.guardedHandlers = empty;
      node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null;
      if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
      return this.finishNode(node, "TryStatement");
    };
    
    pp.parseVarStatement = function (node, kind) {
      this.next();
      this.parseVar(node, false, kind);
      this.semicolon();
      return this.finishNode(node, "VariableDeclaration");
    };
    
    pp.parseWhileStatement = function (node) {
      this.next();
      node.test = this.parseParenExpression();
      this.labels.push(loopLabel);
      node.body = this.parseStatement(false);
      this.labels.pop();
      return this.finishNode(node, "WhileStatement");
    };
    
    pp.parseWithStatement = function (node) {
      if (this.strict) this.raise(this.start, "'with' in strict mode");
      this.next();
      node.object = this.parseParenExpression();
      node.body = this.parseStatement(false);
      return this.finishNode(node, "WithStatement");
    };
    
    pp.parseEmptyStatement = function (node) {
      this.next();
      return this.finishNode(node, "EmptyStatement");
    };
    
    pp.parseLabeledStatement = function (node, maybeName, expr) {
      for (var i = 0; i < this.labels.length; ++i) {
        if (this.labels[i].name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
      }var kind = this.type.isLoop ? "loop" : this.type === tt._switch ? "switch" : null;
      this.labels.push({ name: maybeName, kind: kind });
      node.body = this.parseStatement(true);
      this.labels.pop();
      node.label = expr;
      return this.finishNode(node, "LabeledStatement");
    };
    
    pp.parseExpressionStatement = function (node, expr) {
      node.expression = expr;
      this.semicolon();
      return this.finishNode(node, "ExpressionStatement");
    };
    
    // Parse a semicolon-enclosed block of statements, handling `"use
    // strict"` declarations when `allowStrict` is true (used for
    // function bodies).
    
    pp.parseBlock = function (allowStrict) {
      var node = this.startNode(),
          first = true,
          oldStrict = undefined;
      node.body = [];
      this.expect(tt.braceL);
      while (!this.eat(tt.braceR)) {
        var stmt = this.parseStatement(true);
        node.body.push(stmt);
        if (first && allowStrict && this.isUseStrict(stmt)) {
          oldStrict = this.strict;
          this.setStrict(this.strict = true);
        }
        first = false;
      }
      if (oldStrict === false) this.setStrict(false);
      return this.finishNode(node, "BlockStatement");
    };
    
    // Parse a regular `for` loop. The disambiguation code in
    // `parseStatement` will already have parsed the init statement or
    // expression.
    
    pp.parseFor = function (node, init) {
      node.init = init;
      this.expect(tt.semi);
      node.test = this.type === tt.semi ? null : this.parseExpression();
      this.expect(tt.semi);
      node.update = this.type === tt.parenR ? null : this.parseExpression();
      this.expect(tt.parenR);
      node.body = this.parseStatement(false);
      this.labels.pop();
      return this.finishNode(node, "ForStatement");
    };
    
    // Parse a `for`/`in` and `for`/`of` loop, which are almost
    // same from parser's perspective.
    
    pp.parseForIn = function (node, init) {
      var type = this.type === tt._in ? "ForInStatement" : "ForOfStatement";
      this.next();
      node.left = init;
      node.right = this.parseExpression();
      this.expect(tt.parenR);
      node.body = this.parseStatement(false);
      this.labels.pop();
      return this.finishNode(node, type);
    };
    
    // Parse a list of variable declarations.
    
    pp.parseVar = function (node, isFor, kind) {
      node.declarations = [];
      node.kind = kind.keyword;
      for (;;) {
        var decl = this.startNode();
        this.parseVarId(decl);
        if (this.eat(tt.eq)) {
          decl.init = this.parseMaybeAssign(isFor);
        } else if (kind === tt._const && !(this.type === tt._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          this.unexpected();
        } else if (decl.id.type != "Identifier" && !(isFor && (this.type === tt._in || this.isContextual("of")))) {
          this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
        } else {
          decl.init = null;
        }
        node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(tt.comma)) break;
      }
      return node;
    };
    
    pp.parseVarId = function (decl) {
      decl.id = this.parseBindingAtom();
      this.checkLVal(decl.id, true);
    };
    
    // Parse a function declaration or literal (depending on the
    // `isStatement` parameter).
    
    pp.parseFunction = function (node, isStatement, allowExpressionBody) {
      this.initFunction(node);
      if (this.options.ecmaVersion >= 6) node.generator = this.eat(tt.star);
      if (isStatement || this.type === tt.name) node.id = this.parseIdent();
      this.parseFunctionParams(node);
      this.parseFunctionBody(node, allowExpressionBody);
      return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
    };
    
    pp.parseFunctionParams = function (node) {
      this.expect(tt.parenL);
      node.params = this.parseBindingList(tt.parenR, false, false);
    };
    
    // Parse a class declaration or literal (depending on the
    // `isStatement` parameter).
    
    pp.parseClass = function (node, isStatement) {
      this.next();
      this.parseClassId(node, isStatement);
      this.parseClassSuper(node);
      var classBody = this.startNode();
      classBody.body = [];
      this.expect(tt.braceL);
      while (!this.eat(tt.braceR)) {
        if (this.eat(tt.semi)) continue;
        var method = this.startNode();
        var isGenerator = this.eat(tt.star);
        this.parsePropertyName(method);
        if (this.type !== tt.parenL && !method.computed && method.key.type === "Identifier" && method.key.name === "static") {
          if (isGenerator) this.unexpected();
          method["static"] = true;
          isGenerator = this.eat(tt.star);
          this.parsePropertyName(method);
        } else {
          method["static"] = false;
        }
        method.kind = "method";
        if (!method.computed && !isGenerator) {
          if (method.key.type === "Identifier") {
            if (this.type !== tt.parenL && (method.key.name === "get" || method.key.name === "set")) {
              method.kind = method.key.name;
              this.parsePropertyName(method);
            } else if (!method["static"] && method.key.name === "constructor") {
              method.kind = "constructor";
            }
          } else if (!method["static"] && method.key.type === "Literal" && method.key.value === "constructor") {
            method.kind = "constructor";
          }
        }
        this.parseClassMethod(classBody, method, isGenerator);
      }
      node.body = this.finishNode(classBody, "ClassBody");
      return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    };
    
    pp.parseClassMethod = function (classBody, method, isGenerator) {
      method.value = this.parseMethod(isGenerator);
      classBody.body.push(this.finishNode(method, "MethodDefinition"));
    };
    
    pp.parseClassId = function (node, isStatement) {
      node.id = this.type === tt.name ? this.parseIdent() : isStatement ? this.unexpected() : null;
    };
    
    pp.parseClassSuper = function (node) {
      node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null;
    };
    
    // Parses module export declaration.
    
    pp.parseExport = function (node) {
      this.next();
      // export * from '...'
      if (this.eat(tt.star)) {
        this.expectContextual("from");
        node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration");
      }
      if (this.eat(tt._default)) {
        // export default ...
        var expr = this.parseMaybeAssign();
        var needsSemi = true;
        if (expr.type == "FunctionExpression" || expr.type == "ClassExpression") {
          needsSemi = false;
          if (expr.id) {
            expr.type = expr.type == "FunctionExpression" ? "FunctionDeclaration" : "ClassDeclaration";
          }
        }
        node.declaration = expr;
        if (needsSemi) this.semicolon();
        return this.finishNode(node, "ExportDefaultDeclaration");
      }
      // export var|const|let|function|class ...
      if (this.shouldParseExportStatement()) {
        node.declaration = this.parseStatement(true);
        node.specifiers = [];
        node.source = null;
      } else {
        // export { x, y as z } [from '...']
        node.declaration = null;
        node.specifiers = this.parseExportSpecifiers();
        if (this.eatContextual("from")) {
          node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();
        } else {
          node.source = null;
        }
        this.semicolon();
      }
      return this.finishNode(node, "ExportNamedDeclaration");
    };
    
    pp.shouldParseExportStatement = function () {
      return this.type.keyword;
    };
    
    // Parses a comma-separated list of module exports.
    
    pp.parseExportSpecifiers = function () {
      var nodes = [],
          first = true;
      // export { x, y as z } [from '...']
      this.expect(tt.braceL);
      while (!this.eat(tt.braceR)) {
        if (!first) {
          this.expect(tt.comma);
          if (this.afterTrailingComma(tt.braceR)) break;
        } else first = false;
    
        var node = this.startNode();
        node.local = this.parseIdent(this.type === tt._default);
        node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
        nodes.push(this.finishNode(node, "ExportSpecifier"));
      }
      return nodes;
    };
    
    // Parses import declaration.
    
    pp.parseImport = function (node) {
      this.next();
      // import '...'
      if (this.type === tt.string) {
        node.specifiers = empty;
        node.source = this.parseExprAtom();
        node.kind = "";
      } else {
        node.specifiers = this.parseImportSpecifiers();
        this.expectContextual("from");
        node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();
      }
      this.semicolon();
      return this.finishNode(node, "ImportDeclaration");
    };
    
    // Parses a comma-separated list of module imports.
    
    pp.parseImportSpecifiers = function () {
      var nodes = [],
          first = true;
      if (this.type === tt.name) {
        // import defaultObj, { x, y as z } from '...'
        var node = this.startNode();
        node.local = this.parseIdent();
        this.checkLVal(node.local, true);
        nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
        if (!this.eat(tt.comma)) return nodes;
      }
      if (this.type === tt.star) {
        var node = this.startNode();
        this.next();
        this.expectContextual("as");
        node.local = this.parseIdent();
        this.checkLVal(node.local, true);
        nodes.push(this.finishNode(node, "ImportNamespaceSpecifier"));
        return nodes;
      }
      this.expect(tt.braceL);
      while (!this.eat(tt.braceR)) {
        if (!first) {
          this.expect(tt.comma);
          if (this.afterTrailingComma(tt.braceR)) break;
        } else first = false;
    
        var node = this.startNode();
        node.imported = this.parseIdent(true);
        node.local = this.eatContextual("as") ? this.parseIdent() : node.imported;
        this.checkLVal(node.local, true);
        nodes.push(this.finishNode(node, "ImportSpecifier"));
      }
      return nodes;
    };
    
    },{"./state":9,"./tokentype":13,"./whitespace":15}],11:[function(_dereq_,module,exports){
    "use strict";
    
    var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
    
    exports.__esModule = true;
    // The algorithm used to determine whether a regexp can appear at a
    // given point in the program is loosely based on sweet.js' approach.
    // See https://github.com/mozilla/sweet.js/wiki/design
    
    var Parser = _dereq_("./state").Parser;
    
    var tt = _dereq_("./tokentype").types;
    
    var lineBreak = _dereq_("./whitespace").lineBreak;
    
    var TokContext = exports.TokContext = function TokContext(token, isExpr, preserveSpace, override) {
      _classCallCheck(this, TokContext);
    
      this.token = token;
      this.isExpr = isExpr;
      this.preserveSpace = preserveSpace;
      this.override = override;
    };
    
    var types = {
      b_stat: new TokContext("{", false),
      b_expr: new TokContext("{", true),
      b_tmpl: new TokContext("${", true),
      p_stat: new TokContext("(", false),
      p_expr: new TokContext("(", true),
      q_tmpl: new TokContext("`", true, true, function (p) {
        return p.readTmplToken();
      }),
      f_expr: new TokContext("function", true)
    };
    
    exports.types = types;
    var pp = Parser.prototype;
    
    pp.initialContext = function () {
      return [types.b_stat];
    };
    
    pp.braceIsBlock = function (prevType) {
      var parent = undefined;
      if (prevType === tt.colon && (parent = this.curContext()).token == "{") return !parent.isExpr;
      if (prevType === tt._return) return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      if (prevType === tt._else || prevType === tt.semi || prevType === tt.eof) return true;
      if (prevType == tt.braceL) return this.curContext() === types.b_stat;
      return !this.exprAllowed;
    };
    
    pp.updateContext = function (prevType) {
      var update = undefined,
          type = this.type;
      if (type.keyword && prevType == tt.dot) this.exprAllowed = false;else if (update = type.updateContext) update.call(this, prevType);else this.exprAllowed = type.beforeExpr;
    };
    
    // Token-specific context update code
    
    tt.parenR.updateContext = tt.braceR.updateContext = function () {
      if (this.context.length == 1) {
        this.exprAllowed = true;
        return;
      }
      var out = this.context.pop();
      if (out === types.b_stat && this.curContext() === types.f_expr) {
        this.context.pop();
        this.exprAllowed = false;
      } else if (out === types.b_tmpl) {
        this.exprAllowed = true;
      } else {
        this.exprAllowed = !out.isExpr;
      }
    };
    
    tt.braceL.updateContext = function (prevType) {
      this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
      this.exprAllowed = true;
    };
    
    tt.dollarBraceL.updateContext = function () {
      this.context.push(types.b_tmpl);
      this.exprAllowed = true;
    };
    
    tt.parenL.updateContext = function (prevType) {
      var statementParens = prevType === tt._if || prevType === tt._for || prevType === tt._with || prevType === tt._while;
      this.context.push(statementParens ? types.p_stat : types.p_expr);
      this.exprAllowed = true;
    };
    
    tt.incDec.updateContext = function () {};
    
    tt._function.updateContext = function () {
      if (this.curContext() !== types.b_stat) this.context.push(types.f_expr);
      this.exprAllowed = false;
    };
    
    tt.backQuote.updateContext = function () {
      if (this.curContext() === types.q_tmpl) this.context.pop();else this.context.push(types.q_tmpl);
      this.exprAllowed = false;
    };
    
    // tokExprAllowed stays unchanged
    
    },{"./state":9,"./tokentype":13,"./whitespace":15}],12:[function(_dereq_,module,exports){
    "use strict";
    
    var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
    
    exports.__esModule = true;
    
    var _identifier = _dereq_("./identifier");
    
    var isIdentifierStart = _identifier.isIdentifierStart;
    var isIdentifierChar = _identifier.isIdentifierChar;
    
    var _tokentype = _dereq_("./tokentype");
    
    var tt = _tokentype.types;
    var keywordTypes = _tokentype.keywords;
    
    var Parser = _dereq_("./state").Parser;
    
    var SourceLocation = _dereq_("./location").SourceLocation;
    
    var _whitespace = _dereq_("./whitespace");
    
    var lineBreak = _whitespace.lineBreak;
    var lineBreakG = _whitespace.lineBreakG;
    var isNewLine = _whitespace.isNewLine;
    var nonASCIIwhitespace = _whitespace.nonASCIIwhitespace;
    
    // Object type used to represent tokens. Note that normally, tokens
    // simply exist as properties on the parser object. This is only
    // used for the onToken callback and the external tokenizer.
    
    var Token = exports.Token = function Token(p) {
      _classCallCheck(this, Token);
    
      this.type = p.type;
      this.value = p.value;
      this.start = p.start;
      this.end = p.end;
      if (p.options.locations) this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
      if (p.options.ranges) this.range = [p.start, p.end];
    };
    
    // ## Tokenizer
    
    var pp = Parser.prototype;
    
    // Move to the next token
    
    pp.next = function () {
      if (this.options.onToken) this.options.onToken(new Token(this));
    
      this.lastTokEnd = this.end;
      this.lastTokStart = this.start;
      this.lastTokEndLoc = this.endLoc;
      this.lastTokStartLoc = this.startLoc;
      this.nextToken();
    };
    
    pp.getToken = function () {
      this.next();
      return new Token(this);
    };
    
    // If we're in an ES6 environment, make parsers iterable
    if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function () {
      var self = this;
      return { next: function next() {
          var token = self.getToken();
          return {
            done: token.type === tt.eof,
            value: token
          };
        } };
    };
    
    // Toggle strict mode. Re-reads the next number or string to please
    // pedantic tests (`"use strict"; 010;` should fail).
    
    pp.setStrict = function (strict) {
      this.strict = strict;
      if (this.type !== tt.num && this.type !== tt.string) return;
      this.pos = this.start;
      if (this.options.locations) {
        while (this.pos < this.lineStart) {
          this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
          --this.curLine;
        }
      }
      this.nextToken();
    };
    
    pp.curContext = function () {
      return this.context[this.context.length - 1];
    };
    
    // Read a single token, updating the parser object's token-related
    // properties.
    
    pp.nextToken = function () {
      var curContext = this.curContext();
      if (!curContext || !curContext.preserveSpace) this.skipSpace();
    
      this.start = this.pos;
      if (this.options.locations) this.startLoc = this.curPosition();
      if (this.pos >= this.input.length) return this.finishToken(tt.eof);
    
      if (curContext.override) return curContext.override(this);else this.readToken(this.fullCharCodeAtPos());
    };
    
    pp.readToken = function (code) {
      // Identifier or keyword. '\uXXXX' sequences are allowed in
      // identifiers, so '\' also dispatches to that.
      if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */) return this.readWord();
    
      return this.getTokenFromCode(code);
    };
    
    pp.fullCharCodeAtPos = function () {
      var code = this.input.charCodeAt(this.pos);
      if (code <= 55295 || code >= 57344) return code;
      var next = this.input.charCodeAt(this.pos + 1);
      return (code << 10) + next - 56613888;
    };
    
    pp.skipBlockComment = function () {
      var startLoc = this.options.onComment && this.options.locations && this.curPosition();
      var start = this.pos,
          end = this.input.indexOf("*/", this.pos += 2);
      if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
      this.pos = end + 2;
      if (this.options.locations) {
        lineBreakG.lastIndex = start;
        var match = undefined;
        while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
          ++this.curLine;
          this.lineStart = match.index + match[0].length;
        }
      }
      if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.options.locations && this.curPosition());
    };
    
    pp.skipLineComment = function (startSkip) {
      var start = this.pos;
      var startLoc = this.options.onComment && this.options.locations && this.curPosition();
      var ch = this.input.charCodeAt(this.pos += startSkip);
      while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
        ++this.pos;
        ch = this.input.charCodeAt(this.pos);
      }
      if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.options.locations && this.curPosition());
    };
    
    // Called at the start of the parse and after every token. Skips
    // whitespace and comments, and.
    
    pp.skipSpace = function () {
      while (this.pos < this.input.length) {
        var ch = this.input.charCodeAt(this.pos);
        if (ch === 32) {
          // ' '
          ++this.pos;
        } else if (ch === 13) {
          ++this.pos;
          var next = this.input.charCodeAt(this.pos);
          if (next === 10) {
            ++this.pos;
          }
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
        } else if (ch === 10 || ch === 8232 || ch === 8233) {
          ++this.pos;
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
        } else if (ch > 8 && ch < 14) {
          ++this.pos;
        } else if (ch === 47) {
          // '/'
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 42) {
            // '*'
            this.skipBlockComment();
          } else if (next === 47) {
            // '/'
            this.skipLineComment(2);
          } else break;
        } else if (ch === 160) {
          // '\xa0'
          ++this.pos;
        } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break;
        }
      }
    };
    
    // Called at the end of every token. Sets `end`, `val`, and
    // maintains `context` and `exprAllowed`, and skips the space after
    // the token, so that the next one's `start` will point at the
    // right position.
    
    pp.finishToken = function (type, val) {
      this.end = this.pos;
      if (this.options.locations) this.endLoc = this.curPosition();
      var prevType = this.type;
      this.type = type;
      this.value = val;
    
      this.updateContext(prevType);
    };
    
    // ### Token reading
    
    // This is the function that is called to fetch the next token. It
    // is somewhat obscure, because it works in character codes rather
    // than characters, and because operator parsing has been inlined
    // into it.
    //
    // All in the name of speed.
    //
    pp.readToken_dot = function () {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next >= 48 && next <= 57) return this.readNumber(true);
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
        // 46 = dot '.'
        this.pos += 3;
        return this.finishToken(tt.ellipsis);
      } else {
        ++this.pos;
        return this.finishToken(tt.dot);
      }
    };
    
    pp.readToken_slash = function () {
      // '/'
      var next = this.input.charCodeAt(this.pos + 1);
      if (this.exprAllowed) {
        ++this.pos;return this.readRegexp();
      }
      if (next === 61) return this.finishOp(tt.assign, 2);
      return this.finishOp(tt.slash, 1);
    };
    
    pp.readToken_mult_modulo = function (code) {
      // '%*'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) return this.finishOp(tt.assign, 2);
      return this.finishOp(code === 42 ? tt.star : tt.modulo, 1);
    };
    
    pp.readToken_pipe_amp = function (code) {
      // '|&'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) return this.finishOp(code === 124 ? tt.logicalOR : tt.logicalAND, 2);
      if (next === 61) return this.finishOp(tt.assign, 2);
      return this.finishOp(code === 124 ? tt.bitwiseOR : tt.bitwiseAND, 1);
    };
    
    pp.readToken_caret = function () {
      // '^'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) return this.finishOp(tt.assign, 2);
      return this.finishOp(tt.bitwiseXOR, 1);
    };
    
    pp.readToken_plus_min = function (code) {
      // '+-'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) {
        if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 && lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
          // A `-->` line comment
          this.skipLineComment(3);
          this.skipSpace();
          return this.nextToken();
        }
        return this.finishOp(tt.incDec, 2);
      }
      if (next === 61) return this.finishOp(tt.assign, 2);
      return this.finishOp(tt.plusMin, 1);
    };
    
    pp.readToken_lt_gt = function (code) {
      // '<>'
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(tt.assign, size + 1);
        return this.finishOp(tt.bitShift, size);
      }
      if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) {
        if (this.inModule) this.unexpected();
        // `<!--`, an XML-style comment that should be interpreted as a line comment
        this.skipLineComment(4);
        this.skipSpace();
        return this.nextToken();
      }
      if (next === 61) size = this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2;
      return this.finishOp(tt.relational, size);
    };
    
    pp.readToken_eq_excl = function (code) {
      // '=!'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) return this.finishOp(tt.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
      if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
        // '=>'
        this.pos += 2;
        return this.finishToken(tt.arrow);
      }
      return this.finishOp(code === 61 ? tt.eq : tt.prefix, 1);
    };
    
    pp.getTokenFromCode = function (code) {
      switch (code) {
        // The interpretation of a dot depends on whether it is followed
        // by a digit or another two dots.
        case 46:
          // '.'
          return this.readToken_dot();
    
        // Punctuation tokens.
        case 40:
          ++this.pos;return this.finishToken(tt.parenL);
        case 41:
          ++this.pos;return this.finishToken(tt.parenR);
        case 59:
          ++this.pos;return this.finishToken(tt.semi);
        case 44:
          ++this.pos;return this.finishToken(tt.comma);
        case 91:
          ++this.pos;return this.finishToken(tt.bracketL);
        case 93:
          ++this.pos;return this.finishToken(tt.bracketR);
        case 123:
          ++this.pos;return this.finishToken(tt.braceL);
        case 125:
          ++this.pos;return this.finishToken(tt.braceR);
        case 58:
          ++this.pos;return this.finishToken(tt.colon);
        case 63:
          ++this.pos;return this.finishToken(tt.question);
    
        case 96:
          // '`'
          if (this.options.ecmaVersion < 6) break;
          ++this.pos;
          return this.finishToken(tt.backQuote);
    
        case 48:
          // '0'
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number
          if (this.options.ecmaVersion >= 6) {
            if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number
            if (next === 98 || next === 66) return this.readRadixNumber(2); // '0b', '0B' - binary number
          }
        // Anything else beginning with a digit is an integer, octal
        // number, or float.
        case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
          // 1-9
          return this.readNumber(false);
    
        // Quotes produce strings.
        case 34:case 39:
          // '"', "'"
          return this.readString(code);
    
        // Operators are parsed inline in tiny state machines. '=' (61) is
        // often referred to. `finishOp` simply skips the amount of
        // characters it is given as second argument, and returns a token
        // of the type given by its first argument.
    
        case 47:
          // '/'
          return this.readToken_slash();
    
        case 37:case 42:
          // '%*'
          return this.readToken_mult_modulo(code);
    
        case 124:case 38:
          // '|&'
          return this.readToken_pipe_amp(code);
    
        case 94:
          // '^'
          return this.readToken_caret();
    
        case 43:case 45:
          // '+-'
          return this.readToken_plus_min(code);
    
        case 60:case 62:
          // '<>'
          return this.readToken_lt_gt(code);
    
        case 61:case 33:
          // '=!'
          return this.readToken_eq_excl(code);
    
        case 126:
          // '~'
          return this.finishOp(tt.prefix, 1);
      }
    
      this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
    };
    
    pp.finishOp = function (type, size) {
      var str = this.input.slice(this.pos, this.pos + size);
      this.pos += size;
      return this.finishToken(type, str);
    };
    
    var regexpUnicodeSupport = false;
    try {
      new RegExp("￿", "u");regexpUnicodeSupport = true;
    } catch (e) {}
    
    // Parse a regular expression. Some context-awareness is necessary,
    // since a '/' inside a '[]' set does not end the expression.
    
    pp.readRegexp = function () {
      var escaped = undefined,
          inClass = undefined,
          start = this.pos;
      for (;;) {
        if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
        var ch = this.input.charAt(this.pos);
        if (lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
        if (!escaped) {
          if (ch === "[") inClass = true;else if (ch === "]" && inClass) inClass = false;else if (ch === "/" && !inClass) break;
          escaped = ch === "\\";
        } else escaped = false;
        ++this.pos;
      }
      var content = this.input.slice(start, this.pos);
      ++this.pos;
      // Need to use `readWord1` because '\uXXXX' sequences are allowed
      // here (don't ask).
      var mods = this.readWord1();
      var tmp = content;
      if (mods) {
        var validFlags = /^[gmsiy]*$/;
        if (this.options.ecmaVersion >= 6) validFlags = /^[gmsiyu]*$/;
        if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag");
        if (mods.indexOf("u") >= 0 && !regexpUnicodeSupport) {
          // Replace each astral symbol and every Unicode escape sequence that
          // possibly represents an astral symbol or a paired surrogate with a
          // single ASCII symbol to avoid throwing on regular expressions that
          // are only valid in combination with the `/u` flag.
          // Note: replacing with the ASCII symbol `x` might cause false
          // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
          // perfectly valid pattern that is equivalent to `[a-b]`, but it would
          // be replaced by `[x-b]` which throws an error.
          tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|\\u\{([0-9a-fA-F]+)\}|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
        }
      }
      // Detect invalid regular expressions.
      try {
        new RegExp(tmp);
      } catch (e) {
        if (e instanceof SyntaxError) this.raise(start, "Error parsing regular expression: " + e.message);
        this.raise(e);
      }
      // Get a regular expression object for this pattern-flag pair, or `null` in
      // case the current environment doesn't support the flags it uses.
      var value = undefined;
      try {
        value = new RegExp(content, mods);
      } catch (err) {
        value = null;
      }
      return this.finishToken(tt.regexp, { pattern: content, flags: mods, value: value });
    };
    
    // Read an integer in the given radix. Return null if zero digits
    // were read, the integer value otherwise. When `len` is given, this
    // will return `null` unless the integer has exactly `len` digits.
    
    pp.readInt = function (radix, len) {
      var start = this.pos,
          total = 0;
      for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        var code = this.input.charCodeAt(this.pos),
            val = undefined;
        if (code >= 97) val = code - 97 + 10; // a
        else if (code >= 65) val = code - 65 + 10; // A
        else if (code >= 48 && code <= 57) val = code - 48; // 0-9
        else val = Infinity;
        if (val >= radix) break;
        ++this.pos;
        total = total * radix + val;
      }
      if (this.pos === start || len != null && this.pos - start !== len) return null;
    
      return total;
    };
    
    pp.readRadixNumber = function (radix) {
      this.pos += 2; // 0x
      var val = this.readInt(radix);
      if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
      if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
      return this.finishToken(tt.num, val);
    };
    
    // Read an integer, octal integer, or floating-point number.
    
    pp.readNumber = function (startsWithDot) {
      var start = this.pos,
          isFloat = false,
          octal = this.input.charCodeAt(this.pos) === 48;
      if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number");
      if (this.input.charCodeAt(this.pos) === 46) {
        ++this.pos;
        this.readInt(10);
        isFloat = true;
      }
      var next = this.input.charCodeAt(this.pos);
      if (next === 69 || next === 101) {
        // 'eE'
        next = this.input.charCodeAt(++this.pos);
        if (next === 43 || next === 45) ++this.pos; // '+-'
        if (this.readInt(10) === null) this.raise(start, "Invalid number");
        isFloat = true;
      }
      if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
    
      var str = this.input.slice(start, this.pos),
          val = undefined;
      if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || this.strict) this.raise(start, "Invalid number");else val = parseInt(str, 8);
      return this.finishToken(tt.num, val);
    };
    
    // Read a string value, interpreting backslash-escapes.
    
    pp.readCodePoint = function () {
      var ch = this.input.charCodeAt(this.pos),
          code = undefined;
    
      if (ch === 123) {
        if (this.options.ecmaVersion < 6) this.unexpected();
        ++this.pos;
        code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
        ++this.pos;
        if (code > 1114111) this.unexpected();
      } else {
        code = this.readHexChar(4);
      }
      return code;
    };
    
    function codePointToString(code) {
      // UTF-16 Decoding
      if (code <= 65535) {
        return String.fromCharCode(code);
      }return String.fromCharCode((code - 65536 >> 10) + 55296, (code - 65536 & 1023) + 56320);
    }
    
    pp.readString = function (quote) {
      var out = "",
          chunkStart = ++this.pos;
      for (;;) {
        if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
        var ch = this.input.charCodeAt(this.pos);
        if (ch === quote) break;
        if (ch === 92) {
          // '\'
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar();
          chunkStart = this.pos;
        } else {
          if (isNewLine(ch)) this.raise(this.start, "Unterminated string constant");
          ++this.pos;
        }
      }
      out += this.input.slice(chunkStart, this.pos++);
      return this.finishToken(tt.string, out);
    };
    
    // Reads template string tokens.
    
    pp.readTmplToken = function () {
      var out = "",
          chunkStart = this.pos;
      for (;;) {
        if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
        var ch = this.input.charCodeAt(this.pos);
        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
          // '`', '${'
          if (this.pos === this.start && this.type === tt.template) {
            if (ch === 36) {
              this.pos += 2;
              return this.finishToken(tt.dollarBraceL);
            } else {
              ++this.pos;
              return this.finishToken(tt.backQuote);
            }
          }
          out += this.input.slice(chunkStart, this.pos);
          return this.finishToken(tt.template, out);
        }
        if (ch === 92) {
          // '\'
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar();
          chunkStart = this.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.pos);
          ++this.pos;
          if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
            out += "\n";
          } else {
            out += String.fromCharCode(ch);
          }
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          chunkStart = this.pos;
        } else {
          ++this.pos;
        }
      }
    };
    
    // Used to read escaped characters
    
    pp.readEscapedChar = function () {
      var ch = this.input.charCodeAt(++this.pos);
      var octal = /^[0-7]+/.exec(this.input.slice(this.pos, this.pos + 3));
      if (octal) octal = octal[0];
      while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);
      if (octal === "0") octal = null;
      ++this.pos;
      if (octal) {
        if (this.strict) this.raise(this.pos - 2, "Octal literal in strict mode");
        this.pos += octal.length - 1;
        return String.fromCharCode(parseInt(octal, 8));
      } else {
        switch (ch) {
          case 110:
            return "\n"; // 'n' -> '\n'
          case 114:
            return "\r"; // 'r' -> '\r'
          case 120:
            return String.fromCharCode(this.readHexChar(2)); // 'x'
          case 117:
            return codePointToString(this.readCodePoint()); // 'u'
          case 116:
            return "\t"; // 't' -> '\t'
          case 98:
            return "\b"; // 'b' -> '\b'
          case 118:
            return "\u000b"; // 'v' -> '\u000b'
          case 102:
            return "\f"; // 'f' -> '\f'
          case 48:
            return "\u0000"; // 0 -> '\0'
          case 13:
            if (this.input.charCodeAt(this.pos) === 10) ++this.pos; // '\r\n'
          case 10:
            // ' \n'
            if (this.options.locations) {
              this.lineStart = this.pos;++this.curLine;
            }
            return "";
          default:
            return String.fromCharCode(ch);
        }
      }
    };
    
    // Used to read character escape sequences ('\x', '\u', '\U').
    
    pp.readHexChar = function (len) {
      var n = this.readInt(16, len);
      if (n === null) this.raise(this.start, "Bad character escape sequence");
      return n;
    };
    
    // Used to signal to callers of `readWord1` whether the word
    // contained any escape sequences. This is needed because words with
    // escape sequences must not be interpreted as keywords.
    
    var containsEsc;
    
    // Read an identifier, and return it as a string. Sets `containsEsc`
    // to whether the word contained a '\u' escape.
    //
    // Incrementally adds only escaped chars, adding other chunks as-is
    // as a micro-optimization.
    
    pp.readWord1 = function () {
      containsEsc = false;
      var word = "",
          first = true,
          chunkStart = this.pos;
      var astral = this.options.ecmaVersion >= 6;
      while (this.pos < this.input.length) {
        var ch = this.fullCharCodeAtPos();
        if (isIdentifierChar(ch, astral)) {
          this.pos += ch <= 65535 ? 1 : 2;
        } else if (ch === 92) {
          // "\"
          containsEsc = true;
          word += this.input.slice(chunkStart, this.pos);
          var escStart = this.pos;
          if (this.input.charCodeAt(++this.pos) != 117) // "u"
            this.raise(this.pos, "Expecting Unicode escape sequence \\uXXXX");
          ++this.pos;
          var esc = this.readCodePoint();
          if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) this.raise(escStart, "Invalid Unicode escape");
          word += codePointToString(esc);
          chunkStart = this.pos;
        } else {
          break;
        }
        first = false;
      }
      return word + this.input.slice(chunkStart, this.pos);
    };
    
    // Read an identifier or keyword token. Will check for reserved
    // words when necessary.
    
    pp.readWord = function () {
      var word = this.readWord1();
      var type = tt.name;
      if ((this.options.ecmaVersion >= 6 || !containsEsc) && this.isKeyword(word)) type = keywordTypes[word];
      return this.finishToken(type, word);
    };
    
    },{"./identifier":3,"./location":4,"./state":9,"./tokentype":13,"./whitespace":15}],13:[function(_dereq_,module,exports){
    "use strict";
    
    var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
    
    exports.__esModule = true;
    // ## Token types
    
    // The assignment of fine-grained, information-carrying type objects
    // allows the tokenizer to store the information it has about a
    // token in a way that is very cheap for the parser to look up.
    
    // All token type variables start with an underscore, to make them
    // easy to recognize.
    
    // The `beforeExpr` property is used to disambiguate between regular
    // expressions and divisions. It is set on all token types that can
    // be followed by an expression (thus, a slash after them would be a
    // regular expression).
    //
    // `isLoop` marks a keyword as starting a loop, which is important
    // to know when parsing a label, in order to allow or disallow
    // continue jumps to that label.
    
    var TokenType = exports.TokenType = function TokenType(label) {
      var conf = arguments[1] === undefined ? {} : arguments[1];
    
      _classCallCheck(this, TokenType);
    
      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop || null;
      this.updateContext = null;
    };
    
    function binop(name, prec) {
      return new TokenType(name, { beforeExpr: true, binop: prec });
    }
    var beforeExpr = { beforeExpr: true },
        startsExpr = { startsExpr: true };
    
    var types = {
      num: new TokenType("num", startsExpr),
      regexp: new TokenType("regexp", startsExpr),
      string: new TokenType("string", startsExpr),
      name: new TokenType("name", startsExpr),
      eof: new TokenType("eof"),
    
      // Punctuation token types.
      bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
      bracketR: new TokenType("]"),
      braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
      braceR: new TokenType("}"),
      parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
      parenR: new TokenType(")"),
      comma: new TokenType(",", beforeExpr),
      semi: new TokenType(";", beforeExpr),
      colon: new TokenType(":", beforeExpr),
      dot: new TokenType("."),
      question: new TokenType("?", beforeExpr),
      arrow: new TokenType("=>", beforeExpr),
      template: new TokenType("template"),
      ellipsis: new TokenType("...", beforeExpr),
      backQuote: new TokenType("`", startsExpr),
      dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
    
      // Operators. These carry several kinds of properties to help the
      // parser use them properly (the presence of these properties is
      // what categorizes them as operators).
      //
      // `binop`, when present, specifies that this operator is a binary
      // operator, and will refer to its precedence.
      //
      // `prefix` and `postfix` mark the operator as a prefix or postfix
      // unary operator.
      //
      // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
      // binary operators with a very low precedence, that should result
      // in AssignmentExpression nodes.
    
      eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
      assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
      incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
      prefix: new TokenType("prefix", { beforeExpr: true, prefix: true, startsExpr: true }),
      logicalOR: binop("||", 1),
      logicalAND: binop("&&", 2),
      bitwiseOR: binop("|", 3),
      bitwiseXOR: binop("^", 4),
      bitwiseAND: binop("&", 5),
      equality: binop("==/!=", 6),
      relational: binop("</>", 7),
      bitShift: binop("<</>>", 8),
      plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
      modulo: binop("%", 10),
      star: binop("*", 10),
      slash: binop("/", 10)
    };
    
    exports.types = types;
    // Map keyword names to token types.
    
    var keywords = {};
    
    exports.keywords = keywords;
    // Succinct definitions of keyword token types
    function kw(name) {
      var options = arguments[1] === undefined ? {} : arguments[1];
    
      options.keyword = name;
      keywords[name] = types["_" + name] = new TokenType(name, options);
    }
    
    kw("break");
    kw("case", beforeExpr);
    kw("catch");
    kw("continue");
    kw("debugger");
    kw("default");
    kw("do", { isLoop: true });
    kw("else", beforeExpr);
    kw("finally");
    kw("for", { isLoop: true });
    kw("function", startsExpr);
    kw("if");
    kw("return", beforeExpr);
    kw("switch");
    kw("throw", beforeExpr);
    kw("try");
    kw("var");
    kw("let");
    kw("const");
    kw("while", { isLoop: true });
    kw("with");
    kw("new", { beforeExpr: true, startsExpr: true });
    kw("this", startsExpr);
    kw("super", startsExpr);
    kw("class");
    kw("extends", beforeExpr);
    kw("export");
    kw("import");
    kw("yield", { beforeExpr: true, startsExpr: true });
    kw("null", startsExpr);
    kw("true", startsExpr);
    kw("false", startsExpr);
    kw("in", { beforeExpr: true, binop: 7 });
    kw("instanceof", { beforeExpr: true, binop: 7 });
    kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true });
    kw("void", { beforeExpr: true, prefix: true, startsExpr: true });
    kw("delete", { beforeExpr: true, prefix: true, startsExpr: true });
    
    },{}],14:[function(_dereq_,module,exports){
    "use strict";
    
    exports.isArray = isArray;
    
    // Checks if an object has a property.
    
    exports.has = has;
    exports.__esModule = true;
    
    function isArray(obj) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    }
    
    function has(obj, propName) {
      return Object.prototype.hasOwnProperty.call(obj, propName);
    }
    
    },{}],15:[function(_dereq_,module,exports){
    "use strict";
    
    exports.isNewLine = isNewLine;
    exports.__esModule = true;
    // Matches a whole line break (where CRLF is considered a single
    // line break). Used to count lines.
    
    var lineBreak = /\r\n?|\n|\u2028|\u2029/;
    exports.lineBreak = lineBreak;
    var lineBreakG = new RegExp(lineBreak.source, "g");
    
    exports.lineBreakG = lineBreakG;
    
    function isNewLine(code) {
      return code === 10 || code === 13 || code === 8232 || code == 8233;
    }
    
    var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
    exports.nonASCIIwhitespace = nonASCIIwhitespace;
    
    },{}]},{},[1])(1)
    });
  provide("acorn", module.exports);
}(global));

// pakmanager:asap/raw
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    
    var domain; // The domain module is executed on demand
    var hasSetImmediate = typeof setImmediate === "function";
    
    // Use the fastest means possible to execute a task in its own turn, with
    // priority over other events including network IO events in Node.js.
    //
    // An exception thrown by a task will permanently interrupt the processing of
    // subsequent tasks. The higher level `asap` function ensures that if an
    // exception is thrown by a task, that the task queue will continue flushing as
    // soon as possible, but if you use `rawAsap` directly, you are responsible to
    // either ensure that no exceptions are thrown from your task, or to manually
    // call `rawAsap.requestFlush` if an exception is thrown.
    module.exports = rawAsap;
    function rawAsap(task) {
        if (!queue.length) {
            requestFlush();
            flushing = true;
        }
        // Avoids a function call
        queue[queue.length] = task;
    }
    
    var queue = [];
    // Once a flush has been requested, no further calls to `requestFlush` are
    // necessary until the next `flush` completes.
    var flushing = false;
    // The position of the next task to execute in the task queue. This is
    // preserved between calls to `flush` so that it can be resumed if
    // a task throws an exception.
    var index = 0;
    // If a task schedules additional tasks recursively, the task queue can grow
    // unbounded. To prevent memory excaustion, the task queue will periodically
    // truncate already-completed tasks.
    var capacity = 1024;
    
    // The flush function processes all tasks that have been scheduled with
    // `rawAsap` unless and until one of those tasks throws an exception.
    // If a task throws an exception, `flush` ensures that its state will remain
    // consistent and will resume where it left off when called again.
    // However, `flush` does not make any arrangements to be called again if an
    // exception is thrown.
    function flush() {
        while (index < queue.length) {
            var currentIndex = index;
            // Advance the index before calling the task. This ensures that we will
            // begin flushing on the next task the task throws an error.
            index = index + 1;
            queue[currentIndex].call();
            // Prevent leaking memory for long chains of recursive calls to `asap`.
            // If we call `asap` within tasks scheduled by `asap`, the queue will
            // grow, but to avoid an O(n) walk for every task we execute, we don't
            // shift tasks off the queue after they have been executed.
            // Instead, we periodically shift 1024 tasks off the queue.
            if (index > capacity) {
                // Manually shift all values starting at the index back to the
                // beginning of the queue.
                for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                    queue[scan] = queue[scan + index];
                }
                queue.length -= index;
                index = 0;
            }
        }
        queue.length = 0;
        index = 0;
        flushing = false;
    }
    
    rawAsap.requestFlush = requestFlush;
    function requestFlush() {
        // Ensure flushing is not bound to any domain.
        // It is not sufficient to exit the domain, because domains exist on a stack.
        // To execute code outside of any domain, the following dance is necessary.
        var parentDomain = process.domain;
        if (parentDomain) {
            if (!domain) {
                // Lazy execute the domain module.
                // Only employed if the user elects to use domains.
                domain = require("domain");
            }
            domain.active = process.domain = null;
        }
    
        // `setImmediate` is slower that `process.nextTick`, but `process.nextTick`
        // cannot handle recursion.
        // `requestFlush` will only be called recursively from `asap.js`, to resume
        // flushing after an error is thrown into a domain.
        // Conveniently, `setImmediate` was introduced in the same version
        // `process.nextTick` started throwing recursion errors.
        if (flushing && hasSetImmediate) {
            setImmediate(flush);
        } else {
            process.nextTick(flush);
        }
    
        if (parentDomain) {
            domain.active = process.domain = parentDomain;
        }
    }
    
  provide("asap/raw", module.exports);
}(global));

// pakmanager:asap
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    
    var rawAsap =  require('asap/raw');
    var freeTasks = [];
    
    /**
     * Calls a task as soon as possible after returning, in its own event, with
     * priority over IO events. An exception thrown in a task can be handled by
     * `process.on("uncaughtException") or `domain.on("error")`, but will otherwise
     * crash the process. If the error is handled, all subsequent tasks will
     * resume.
     *
     * @param {{call}} task A callable object, typically a function that takes no
     * arguments.
     */
    module.exports = asap;
    function asap(task) {
        var rawTask;
        if (freeTasks.length) {
            rawTask = freeTasks.pop();
        } else {
            rawTask = new RawTask();
        }
        rawTask.task = task;
        rawTask.domain = process.domain;
        rawAsap(rawTask);
    }
    
    function RawTask() {
        this.task = null;
        this.domain = null;
    }
    
    RawTask.prototype.call = function () {
        if (this.domain) {
            this.domain.enter();
        }
        var threw = true;
        try {
            this.task.call();
            threw = false;
            // If the task throws an exception (presumably) Node.js restores the
            // domain stack for the next event.
            if (this.domain) {
                this.domain.exit();
            }
        } finally {
            // We use try/finally and a threw flag to avoid messing up stack traces
            // when we catch and release errors.
            if (threw) {
                // In Node.js, uncaught exceptions are considered fatal errors.
                // Re-throw them to interrupt flushing!
                // Ensure that flushing continues if an uncaught exception is
                // suppressed listening process.on("uncaughtException") or
                // domain.on("error").
                rawAsap.requestFlush();
            }
            // If the task threw an error, we do not want to exit the domain here.
            // Exiting the domain would prevent the domain from catching the error.
            this.task = null;
            this.domain = null;
            freeTasks.push(this);
        }
    };
    
    
  provide("asap", module.exports);
}(global));

// pakmanager:source-map/source-map/base64
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var charToIntMap = {};
      var intToCharMap = {};
    
      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
        .split('')
        .forEach(function (ch, index) {
          charToIntMap[ch] = index;
          intToCharMap[index] = ch;
        });
    
      /**
       * Encode an integer in the range of 0 to 63 to a single base 64 digit.
       */
      exports.encode = function base64_encode(aNumber) {
        if (aNumber in intToCharMap) {
          return intToCharMap[aNumber];
        }
        throw new TypeError("Must be between 0 and 63: " + aNumber);
      };
    
      /**
       * Decode a single base 64 digit to an integer.
       */
      exports.decode = function base64_decode(aChar) {
        if (aChar in charToIntMap) {
          return charToIntMap[aChar];
        }
        throw new TypeError("Not a valid base 64 digit: " + aChar);
      };
    
    });
    
  provide("source-map/source-map/base64", module.exports);
}(global));

// pakmanager:source-map/source-map/util
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      /**
       * This is a helper function for getting values from parameter/options
       * objects.
       *
       * @param args The object we are extracting values from
       * @param name The name of the property we are getting.
       * @param defaultValue An optional value to return if the property is missing
       * from the object. If this is not specified and the property is missing, an
       * error will be thrown.
       */
      function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
          return aArgs[aName];
        } else if (arguments.length === 3) {
          return aDefaultValue;
        } else {
          throw new Error('"' + aName + '" is a required argument.');
        }
      }
      exports.getArg = getArg;
    
      var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
      var dataUrlRegexp = /^data:.+\,.+$/;
    
      function urlParse(aUrl) {
        var match = aUrl.match(urlRegexp);
        if (!match) {
          return null;
        }
        return {
          scheme: match[1],
          auth: match[2],
          host: match[3],
          port: match[4],
          path: match[5]
        };
      }
      exports.urlParse = urlParse;
    
      function urlGenerate(aParsedUrl) {
        var url = '';
        if (aParsedUrl.scheme) {
          url += aParsedUrl.scheme + ':';
        }
        url += '//';
        if (aParsedUrl.auth) {
          url += aParsedUrl.auth + '@';
        }
        if (aParsedUrl.host) {
          url += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
          url += ":" + aParsedUrl.port
        }
        if (aParsedUrl.path) {
          url += aParsedUrl.path;
        }
        return url;
      }
      exports.urlGenerate = urlGenerate;
    
      /**
       * Normalizes a path, or the path portion of a URL:
       *
       * - Replaces consequtive slashes with one slash.
       * - Removes unnecessary '.' parts.
       * - Removes unnecessary '<dir>/..' parts.
       *
       * Based on code in the Node.js 'path' core module.
       *
       * @param aPath The path or url to normalize.
       */
      function normalize(aPath) {
        var path = aPath;
        var url = urlParse(aPath);
        if (url) {
          if (!url.path) {
            return aPath;
          }
          path = url.path;
        }
        var isAbsolute = (path.charAt(0) === '/');
    
        var parts = path.split(/\/+/);
        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
          part = parts[i];
          if (part === '.') {
            parts.splice(i, 1);
          } else if (part === '..') {
            up++;
          } else if (up > 0) {
            if (part === '') {
              // The first part is blank if the path is absolute. Trying to go
              // above the root is a no-op. Therefore we can remove all '..' parts
              // directly after the root.
              parts.splice(i + 1, up);
              up = 0;
            } else {
              parts.splice(i, 2);
              up--;
            }
          }
        }
        path = parts.join('/');
    
        if (path === '') {
          path = isAbsolute ? '/' : '.';
        }
    
        if (url) {
          url.path = path;
          return urlGenerate(url);
        }
        return path;
      }
      exports.normalize = normalize;
    
      /**
       * Joins two paths/URLs.
       *
       * @param aRoot The root path or URL.
       * @param aPath The path or URL to be joined with the root.
       *
       * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
       *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
       *   first.
       * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
       *   is updated with the result and aRoot is returned. Otherwise the result
       *   is returned.
       *   - If aPath is absolute, the result is aPath.
       *   - Otherwise the two paths are joined with a slash.
       * - Joining for example 'http://' and 'www.example.com' is also supported.
       */
      function join(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        if (aPath === "") {
          aPath = ".";
        }
        var aPathUrl = urlParse(aPath);
        var aRootUrl = urlParse(aRoot);
        if (aRootUrl) {
          aRoot = aRootUrl.path || '/';
        }
    
        // `join(foo, '//www.example.org')`
        if (aPathUrl && !aPathUrl.scheme) {
          if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
          }
          return urlGenerate(aPathUrl);
        }
    
        if (aPathUrl || aPath.match(dataUrlRegexp)) {
          return aPath;
        }
    
        // `join('http://', 'www.example.com')`
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
          aRootUrl.host = aPath;
          return urlGenerate(aRootUrl);
        }
    
        var joined = aPath.charAt(0) === '/'
          ? aPath
          : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
    
        if (aRootUrl) {
          aRootUrl.path = joined;
          return urlGenerate(aRootUrl);
        }
        return joined;
      }
      exports.join = join;
    
      /**
       * Make a path relative to a URL or another path.
       *
       * @param aRoot The root path or URL.
       * @param aPath The path or URL to be made relative to aRoot.
       */
      function relative(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
    
        aRoot = aRoot.replace(/\/$/, '');
    
        // XXX: It is possible to remove this block, and the tests still pass!
        var url = urlParse(aRoot);
        if (aPath.charAt(0) == "/" && url && url.path == "/") {
          return aPath.slice(1);
        }
    
        return aPath.indexOf(aRoot + '/') === 0
          ? aPath.substr(aRoot.length + 1)
          : aPath;
      }
      exports.relative = relative;
    
      /**
       * Because behavior goes wacky when you set `__proto__` on objects, we
       * have to prefix all the strings in our set with an arbitrary character.
       *
       * See https://github.com/mozilla/source-map/pull/31 and
       * https://github.com/mozilla/source-map/issues/30
       *
       * @param String aStr
       */
      function toSetString(aStr) {
        return '$' + aStr;
      }
      exports.toSetString = toSetString;
    
      function fromSetString(aStr) {
        return aStr.substr(1);
      }
      exports.fromSetString = fromSetString;
    
      function strcmp(aStr1, aStr2) {
        var s1 = aStr1 || "";
        var s2 = aStr2 || "";
        return (s1 > s2) - (s1 < s2);
      }
    
      /**
       * Comparator between two mappings where the original positions are compared.
       *
       * Optionally pass in `true` as `onlyCompareGenerated` to consider two
       * mappings with the same original source/line/column, but different generated
       * line and column the same. Useful when searching for a mapping with a
       * stubbed out mapping.
       */
      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
        var cmp;
    
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp) {
          return cmp;
        }
    
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp) {
          return cmp;
        }
    
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp || onlyCompareOriginal) {
          return cmp;
        }
    
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp) {
          return cmp;
        }
    
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp) {
          return cmp;
        }
    
        return strcmp(mappingA.name, mappingB.name);
      };
      exports.compareByOriginalPositions = compareByOriginalPositions;
    
      /**
       * Comparator between two mappings where the generated positions are
       * compared.
       *
       * Optionally pass in `true` as `onlyCompareGenerated` to consider two
       * mappings with the same generated line and column, but different
       * source/name/original line and column the same. Useful when searching for a
       * mapping with a stubbed out mapping.
       */
      function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
        var cmp;
    
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp) {
          return cmp;
        }
    
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp || onlyCompareGenerated) {
          return cmp;
        }
    
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp) {
          return cmp;
        }
    
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp) {
          return cmp;
        }
    
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp) {
          return cmp;
        }
    
        return strcmp(mappingA.name, mappingB.name);
      };
      exports.compareByGeneratedPositions = compareByGeneratedPositions;
    
    });
    
  provide("source-map/source-map/util", module.exports);
}(global));

// pakmanager:source-map/source-map/base64-vlq
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     *
     * Based on the Base 64 VLQ implementation in Closure Compiler:
     * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
     *
     * Copyright 2011 The Closure Compiler Authors. All rights reserved.
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are
     * met:
     *
     *  * Redistributions of source code must retain the above copyright
     *    notice, this list of conditions and the following disclaimer.
     *  * Redistributions in binary form must reproduce the above
     *    copyright notice, this list of conditions and the following
     *    disclaimer in the documentation and/or other materials provided
     *    with the distribution.
     *  * Neither the name of Google Inc. nor the names of its
     *    contributors may be used to endorse or promote products derived
     *    from this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
     * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
     * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
     * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
     * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
     * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
     * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var base64 =  require('source-map/source-map/base64');
    
      // A single base 64 digit can contain 6 bits of data. For the base 64 variable
      // length quantities we use in the source map spec, the first bit is the sign,
      // the next four bits are the actual value, and the 6th bit is the
      // continuation bit. The continuation bit tells us whether there are more
      // digits in this value following this digit.
      //
      //   Continuation
      //   |    Sign
      //   |    |
      //   V    V
      //   101011
    
      var VLQ_BASE_SHIFT = 5;
    
      // binary: 100000
      var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    
      // binary: 011111
      var VLQ_BASE_MASK = VLQ_BASE - 1;
    
      // binary: 100000
      var VLQ_CONTINUATION_BIT = VLQ_BASE;
    
      /**
       * Converts from a two-complement value to a value where the sign bit is
       * placed in the least significant bit.  For example, as decimals:
       *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
       *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
       */
      function toVLQSigned(aValue) {
        return aValue < 0
          ? ((-aValue) << 1) + 1
          : (aValue << 1) + 0;
      }
    
      /**
       * Converts to a two-complement value from a value where the sign bit is
       * placed in the least significant bit.  For example, as decimals:
       *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
       *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
       */
      function fromVLQSigned(aValue) {
        var isNegative = (aValue & 1) === 1;
        var shifted = aValue >> 1;
        return isNegative
          ? -shifted
          : shifted;
      }
    
      /**
       * Returns the base 64 VLQ encoded value.
       */
      exports.encode = function base64VLQ_encode(aValue) {
        var encoded = "";
        var digit;
    
        var vlq = toVLQSigned(aValue);
    
        do {
          digit = vlq & VLQ_BASE_MASK;
          vlq >>>= VLQ_BASE_SHIFT;
          if (vlq > 0) {
            // There are still more digits in this value, so we must make sure the
            // continuation bit is marked.
            digit |= VLQ_CONTINUATION_BIT;
          }
          encoded += base64.encode(digit);
        } while (vlq > 0);
    
        return encoded;
      };
    
      /**
       * Decodes the next base 64 VLQ value from the given string and returns the
       * value and the rest of the string via the out parameter.
       */
      exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
        var strLen = aStr.length;
        var result = 0;
        var shift = 0;
        var continuation, digit;
    
        do {
          if (aIndex >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
          }
          digit = base64.decode(aStr.charAt(aIndex++));
          continuation = !!(digit & VLQ_CONTINUATION_BIT);
          digit &= VLQ_BASE_MASK;
          result = result + (digit << shift);
          shift += VLQ_BASE_SHIFT;
        } while (continuation);
    
        aOutParam.value = fromVLQSigned(result);
        aOutParam.rest = aIndex;
      };
    
    });
    
  provide("source-map/source-map/base64-vlq", module.exports);
}(global));

// pakmanager:source-map/source-map/array-set
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var util =  require('source-map/source-map/util');
    
      /**
       * A data structure which is a combination of an array and a set. Adding a new
       * member is O(1), testing for membership is O(1), and finding the index of an
       * element is O(1). Removing elements from the set is not supported. Only
       * strings are supported for membership.
       */
      function ArraySet() {
        this._array = [];
        this._set = {};
      }
    
      /**
       * Static method for creating ArraySet instances from an existing array.
       */
      ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
        var set = new ArraySet();
        for (var i = 0, len = aArray.length; i < len; i++) {
          set.add(aArray[i], aAllowDuplicates);
        }
        return set;
      };
    
      /**
       * Add the given string to this set.
       *
       * @param String aStr
       */
      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
        var isDuplicate = this.has(aStr);
        var idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          this._set[util.toSetString(aStr)] = idx;
        }
      };
    
      /**
       * Is the given string a member of this set?
       *
       * @param String aStr
       */
      ArraySet.prototype.has = function ArraySet_has(aStr) {
        return Object.prototype.hasOwnProperty.call(this._set,
                                                    util.toSetString(aStr));
      };
    
      /**
       * What is the index of the given string in the array?
       *
       * @param String aStr
       */
      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
        if (this.has(aStr)) {
          return this._set[util.toSetString(aStr)];
        }
        throw new Error('"' + aStr + '" is not in the set.');
      };
    
      /**
       * What is the element at the given index?
       *
       * @param Number aIdx
       */
      ArraySet.prototype.at = function ArraySet_at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error('No element indexed by ' + aIdx);
      };
    
      /**
       * Returns the array representation of this set (which has the proper indices
       * indicated by indexOf). Note that this is a copy of the internal array used
       * for storing the members so that no one can mess with internal state.
       */
      ArraySet.prototype.toArray = function ArraySet_toArray() {
        return this._array.slice();
      };
    
      exports.ArraySet = ArraySet;
    
    });
    
  provide("source-map/source-map/array-set", module.exports);
}(global));

// pakmanager:source-map/source-map/mapping-list
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2014 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var util =  require('source-map/source-map/util');
    
      /**
       * Determine whether mappingB is after mappingA with respect to generated
       * position.
       */
      function generatedPositionAfter(mappingA, mappingB) {
        // Optimized for most common case
        var lineA = mappingA.generatedLine;
        var lineB = mappingB.generatedLine;
        var columnA = mappingA.generatedColumn;
        var columnB = mappingB.generatedColumn;
        return lineB > lineA || lineB == lineA && columnB >= columnA ||
               util.compareByGeneratedPositions(mappingA, mappingB) <= 0;
      }
    
      /**
       * A data structure to provide a sorted view of accumulated mappings in a
       * performance conscious manner. It trades a neglibable overhead in general
       * case for a large speedup in case of mappings being added in order.
       */
      function MappingList() {
        this._array = [];
        this._sorted = true;
        // Serves as infimum
        this._last = {generatedLine: -1, generatedColumn: 0};
      }
    
      /**
       * Iterate through internal items. This method takes the same arguments that
       * `Array.prototype.forEach` takes.
       *
       * NOTE: The order of the mappings is NOT guaranteed.
       */
      MappingList.prototype.unsortedForEach =
        function MappingList_forEach(aCallback, aThisArg) {
          this._array.forEach(aCallback, aThisArg);
        };
    
      /**
       * Add the given source mapping.
       *
       * @param Object aMapping
       */
      MappingList.prototype.add = function MappingList_add(aMapping) {
        var mapping;
        if (generatedPositionAfter(this._last, aMapping)) {
          this._last = aMapping;
          this._array.push(aMapping);
        } else {
          this._sorted = false;
          this._array.push(aMapping);
        }
      };
    
      /**
       * Returns the flat, sorted array of mappings. The mappings are sorted by
       * generated position.
       *
       * WARNING: This method returns internal data without copying, for
       * performance. The return value must NOT be mutated, and should be treated as
       * an immutable borrow. If you want to take ownership, you must make your own
       * copy.
       */
      MappingList.prototype.toArray = function MappingList_toArray() {
        if (!this._sorted) {
          this._array.sort(util.compareByGeneratedPositions);
          this._sorted = true;
        }
        return this._array;
      };
    
      exports.MappingList = MappingList;
    
    });
    
  provide("source-map/source-map/mapping-list", module.exports);
}(global));

// pakmanager:source-map/source-map/binary-search
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      exports.GREATEST_LOWER_BOUND = 1;
      exports.LEAST_UPPER_BOUND = 2;
    
      /**
       * Recursive implementation of binary search.
       *
       * @param aLow Indices here and lower do not contain the needle.
       * @param aHigh Indices here and higher do not contain the needle.
       * @param aNeedle The element being searched for.
       * @param aHaystack The non-empty array being searched.
       * @param aCompare Function which takes two elements and returns -1, 0, or 1.
       * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
       *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       */
      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
        // This function terminates when one of the following is true:
        //
        //   1. We find the exact element we are looking for.
        //
        //   2. We did not find the exact element, but we can return the index of
        //      the next-closest element.
        //
        //   3. We did not find the exact element, and there is no next-closest
        //      element than the one we are searching for, so we return -1.
        var mid = Math.floor((aHigh - aLow) / 2) + aLow;
        var cmp = aCompare(aNeedle, aHaystack[mid], true);
        if (cmp === 0) {
          // Found the element we are looking for.
          return mid;
        }
        else if (cmp > 0) {
          // Our needle is greater than aHaystack[mid].
          if (aHigh - mid > 1) {
            // The element is in the upper half.
            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
          }
    
          // The exact needle element was not found in this haystack. Determine if
          // we are in termination case (3) or (2) and return the appropriate thing.
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return aHigh < aHaystack.length ? aHigh : -1;
          } else {
            return mid;
          }
        }
        else {
          // Our needle is less than aHaystack[mid].
          if (mid - aLow > 1) {
            // The element is in the lower half.
            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
          }
    
          // we are in termination case (3) or (2) and return the appropriate thing.
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return mid;
          } else {
            return aLow < 0 ? -1 : aLow;
          }
        }
      }
    
      /**
       * This is an implementation of binary search which will always try and return
       * the index of the closest element if there is no exact hit. This is because
       * mappings between original and generated line/col pairs are single points,
       * and there is an implicit region between each of them, so a miss just means
       * that you aren't on the very start of a region.
       *
       * @param aNeedle The element you are looking for.
       * @param aHaystack The array that is being searched.
       * @param aCompare A function which takes the needle and an element in the
       *     array and returns -1, 0, or 1 depending on whether the needle is less
       *     than, equal to, or greater than the element, respectively.
       * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
       *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
       */
      exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
        if (aHaystack.length === 0) {
          return -1;
        }
    
        var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                                    aCompare, aBias || exports.GREATEST_LOWER_BOUND);
        if (index < 0) {
          return -1;
        }
    
        // We have found either the exact element, or the next-closest element than
        // the one we are searching for. However, there may be more than one such
        // element. Make sure we always return the smallest of these.
        while (index - 1 >= 0) {
          if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
            break;
          }
          --index;
        }
    
        return index;
      };
    
    });
    
  provide("source-map/source-map/binary-search", module.exports);
}(global));

// pakmanager:source-map/source-map/source-map-generator
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var base64VLQ =  require('source-map/source-map/base64-vlq');
      var util =  require('source-map/source-map/util');
      var ArraySet =  require('source-map/source-map/array-set').ArraySet;
      var MappingList =  require('source-map/source-map/mapping-list').MappingList;
    
      /**
       * An instance of the SourceMapGenerator represents a source map which is
       * being built incrementally. You may pass an object with the following
       * properties:
       *
       *   - file: The filename of the generated source.
       *   - sourceRoot: A root for all relative URLs in this source map.
       */
      function SourceMapGenerator(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util.getArg(aArgs, 'file', null);
        this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
        this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
        this._sources = new ArraySet();
        this._names = new ArraySet();
        this._mappings = new MappingList();
        this._sourcesContents = null;
      }
    
      SourceMapGenerator.prototype._version = 3;
    
      /**
       * Creates a new SourceMapGenerator based on a SourceMapConsumer
       *
       * @param aSourceMapConsumer The SourceMap.
       */
      SourceMapGenerator.fromSourceMap =
        function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
          var sourceRoot = aSourceMapConsumer.sourceRoot;
          var generator = new SourceMapGenerator({
            file: aSourceMapConsumer.file,
            sourceRoot: sourceRoot
          });
          aSourceMapConsumer.eachMapping(function (mapping) {
            var newMapping = {
              generated: {
                line: mapping.generatedLine,
                column: mapping.generatedColumn
              }
            };
    
            if (mapping.source != null) {
              newMapping.source = mapping.source;
              if (sourceRoot != null) {
                newMapping.source = util.relative(sourceRoot, newMapping.source);
              }
    
              newMapping.original = {
                line: mapping.originalLine,
                column: mapping.originalColumn
              };
    
              if (mapping.name != null) {
                newMapping.name = mapping.name;
              }
            }
    
            generator.addMapping(newMapping);
          });
          aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              generator.setSourceContent(sourceFile, content);
            }
          });
          return generator;
        };
    
      /**
       * Add a single mapping from original source line and column to the generated
       * source's line and column for this source map being created. The mapping
       * object should have the following properties:
       *
       *   - generated: An object with the generated line and column positions.
       *   - original: An object with the original line and column positions.
       *   - source: The original source file (relative to the sourceRoot).
       *   - name: An optional original token name for this mapping.
       */
      SourceMapGenerator.prototype.addMapping =
        function SourceMapGenerator_addMapping(aArgs) {
          var generated = util.getArg(aArgs, 'generated');
          var original = util.getArg(aArgs, 'original', null);
          var source = util.getArg(aArgs, 'source', null);
          var name = util.getArg(aArgs, 'name', null);
    
          if (!this._skipValidation) {
            this._validateMapping(generated, original, source, name);
          }
    
          if (source != null && !this._sources.has(source)) {
            this._sources.add(source);
          }
    
          if (name != null && !this._names.has(name)) {
            this._names.add(name);
          }
    
          this._mappings.add({
            generatedLine: generated.line,
            generatedColumn: generated.column,
            originalLine: original != null && original.line,
            originalColumn: original != null && original.column,
            source: source,
            name: name
          });
        };
    
      /**
       * Set the source content for a source file.
       */
      SourceMapGenerator.prototype.setSourceContent =
        function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
          var source = aSourceFile;
          if (this._sourceRoot != null) {
            source = util.relative(this._sourceRoot, source);
          }
    
          if (aSourceContent != null) {
            // Add the source content to the _sourcesContents map.
            // Create a new _sourcesContents map if the property is null.
            if (!this._sourcesContents) {
              this._sourcesContents = {};
            }
            this._sourcesContents[util.toSetString(source)] = aSourceContent;
          } else if (this._sourcesContents) {
            // Remove the source file from the _sourcesContents map.
            // If the _sourcesContents map is empty, set the property to null.
            delete this._sourcesContents[util.toSetString(source)];
            if (Object.keys(this._sourcesContents).length === 0) {
              this._sourcesContents = null;
            }
          }
        };
    
      /**
       * Applies the mappings of a sub-source-map for a specific source file to the
       * source map being generated. Each mapping to the supplied source file is
       * rewritten using the supplied source map. Note: The resolution for the
       * resulting mappings is the minimium of this map and the supplied map.
       *
       * @param aSourceMapConsumer The source map to be applied.
       * @param aSourceFile Optional. The filename of the source file.
       *        If omitted, SourceMapConsumer's file property will be used.
       * @param aSourceMapPath Optional. The dirname of the path to the source map
       *        to be applied. If relative, it is relative to the SourceMapConsumer.
       *        This parameter is needed when the two source maps aren't in the same
       *        directory, and the source map to be applied contains relative source
       *        paths. If so, those relative source paths need to be rewritten
       *        relative to the SourceMapGenerator.
       */
      SourceMapGenerator.prototype.applySourceMap =
        function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
          var sourceFile = aSourceFile;
          // If aSourceFile is omitted, we will use the file property of the SourceMap
          if (aSourceFile == null) {
            if (aSourceMapConsumer.file == null) {
              throw new Error(
                'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
                'or the source map\'s "file" property. Both were omitted.'
              );
            }
            sourceFile = aSourceMapConsumer.file;
          }
          var sourceRoot = this._sourceRoot;
          // Make "sourceFile" relative if an absolute Url is passed.
          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          // Applying the SourceMap can add and remove items from the sources and
          // the names array.
          var newSources = new ArraySet();
          var newNames = new ArraySet();
    
          // Find mappings for the "sourceFile"
          this._mappings.unsortedForEach(function (mapping) {
            if (mapping.source === sourceFile && mapping.originalLine != null) {
              // Check if it can be mapped by the source map, then update the mapping.
              var original = aSourceMapConsumer.originalPositionFor({
                line: mapping.originalLine,
                column: mapping.originalColumn
              });
              if (original.source != null) {
                // Copy mapping
                mapping.source = original.source;
                if (aSourceMapPath != null) {
                  mapping.source = util.join(aSourceMapPath, mapping.source)
                }
                if (sourceRoot != null) {
                  mapping.source = util.relative(sourceRoot, mapping.source);
                }
                mapping.originalLine = original.line;
                mapping.originalColumn = original.column;
                if (original.name != null) {
                  mapping.name = original.name;
                }
              }
            }
    
            var source = mapping.source;
            if (source != null && !newSources.has(source)) {
              newSources.add(source);
            }
    
            var name = mapping.name;
            if (name != null && !newNames.has(name)) {
              newNames.add(name);
            }
    
          }, this);
          this._sources = newSources;
          this._names = newNames;
    
          // Copy sourcesContents of applied map.
          aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              if (aSourceMapPath != null) {
                sourceFile = util.join(aSourceMapPath, sourceFile);
              }
              if (sourceRoot != null) {
                sourceFile = util.relative(sourceRoot, sourceFile);
              }
              this.setSourceContent(sourceFile, content);
            }
          }, this);
        };
    
      /**
       * A mapping can have one of the three levels of data:
       *
       *   1. Just the generated position.
       *   2. The Generated position, original position, and original source.
       *   3. Generated and original position, original source, as well as a name
       *      token.
       *
       * To maintain consistency, we validate that any new mapping being added falls
       * in to one of these categories.
       */
      SourceMapGenerator.prototype._validateMapping =
        function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                    aName) {
          if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
              && aGenerated.line > 0 && aGenerated.column >= 0
              && !aOriginal && !aSource && !aName) {
            // Case 1.
            return;
          }
          else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
                   && aOriginal && 'line' in aOriginal && 'column' in aOriginal
                   && aGenerated.line > 0 && aGenerated.column >= 0
                   && aOriginal.line > 0 && aOriginal.column >= 0
                   && aSource) {
            // Cases 2 and 3.
            return;
          }
          else {
            throw new Error('Invalid mapping: ' + JSON.stringify({
              generated: aGenerated,
              source: aSource,
              original: aOriginal,
              name: aName
            }));
          }
        };
    
      /**
       * Serialize the accumulated mappings in to the stream of base 64 VLQs
       * specified by the source map format.
       */
      SourceMapGenerator.prototype._serializeMappings =
        function SourceMapGenerator_serializeMappings() {
          var previousGeneratedColumn = 0;
          var previousGeneratedLine = 1;
          var previousOriginalColumn = 0;
          var previousOriginalLine = 0;
          var previousName = 0;
          var previousSource = 0;
          var result = '';
          var mapping;
    
          var mappings = this._mappings.toArray();
    
          for (var i = 0, len = mappings.length; i < len; i++) {
            mapping = mappings[i];
    
            if (mapping.generatedLine !== previousGeneratedLine) {
              previousGeneratedColumn = 0;
              while (mapping.generatedLine !== previousGeneratedLine) {
                result += ';';
                previousGeneratedLine++;
              }
            }
            else {
              if (i > 0) {
                if (!util.compareByGeneratedPositions(mapping, mappings[i - 1])) {
                  continue;
                }
                result += ',';
              }
            }
    
            result += base64VLQ.encode(mapping.generatedColumn
                                       - previousGeneratedColumn);
            previousGeneratedColumn = mapping.generatedColumn;
    
            if (mapping.source != null) {
              result += base64VLQ.encode(this._sources.indexOf(mapping.source)
                                         - previousSource);
              previousSource = this._sources.indexOf(mapping.source);
    
              // lines are stored 0-based in SourceMap spec version 3
              result += base64VLQ.encode(mapping.originalLine - 1
                                         - previousOriginalLine);
              previousOriginalLine = mapping.originalLine - 1;
    
              result += base64VLQ.encode(mapping.originalColumn
                                         - previousOriginalColumn);
              previousOriginalColumn = mapping.originalColumn;
    
              if (mapping.name != null) {
                result += base64VLQ.encode(this._names.indexOf(mapping.name)
                                           - previousName);
                previousName = this._names.indexOf(mapping.name);
              }
            }
          }
    
          return result;
        };
    
      SourceMapGenerator.prototype._generateSourcesContent =
        function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
          return aSources.map(function (source) {
            if (!this._sourcesContents) {
              return null;
            }
            if (aSourceRoot != null) {
              source = util.relative(aSourceRoot, source);
            }
            var key = util.toSetString(source);
            return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                        key)
              ? this._sourcesContents[key]
              : null;
          }, this);
        };
    
      /**
       * Externalize the source map.
       */
      SourceMapGenerator.prototype.toJSON =
        function SourceMapGenerator_toJSON() {
          var map = {
            version: this._version,
            sources: this._sources.toArray(),
            names: this._names.toArray(),
            mappings: this._serializeMappings()
          };
          if (this._file != null) {
            map.file = this._file;
          }
          if (this._sourceRoot != null) {
            map.sourceRoot = this._sourceRoot;
          }
          if (this._sourcesContents) {
            map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
          }
    
          return map;
        };
    
      /**
       * Render the source map being generated to a string.
       */
      SourceMapGenerator.prototype.toString =
        function SourceMapGenerator_toString() {
          return JSON.stringify(this.toJSON());
        };
    
      exports.SourceMapGenerator = SourceMapGenerator;
    
    });
    
  provide("source-map/source-map/source-map-generator", module.exports);
}(global));

// pakmanager:source-map/source-map/source-map-consumer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var util =  require('source-map/source-map/util');
      var binarySearch =  require('source-map/source-map/binary-search');
      var ArraySet =  require('source-map/source-map/array-set').ArraySet;
      var base64VLQ =  require('source-map/source-map/base64-vlq');
    
      function SourceMapConsumer(aSourceMap) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === 'string') {
          sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
        }
    
        return sourceMap.sections != null
          ? new IndexedSourceMapConsumer(sourceMap)
          : new BasicSourceMapConsumer(sourceMap);
      }
    
      SourceMapConsumer.fromSourceMap = function(aSourceMap) {
        return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
      }
    
      /**
       * The version of the source mapping spec that we are consuming.
       */
      SourceMapConsumer.prototype._version = 3;
    
      // `__generatedMappings` and `__originalMappings` are arrays that hold the
      // parsed mapping coordinates from the source map's "mappings" attribute. They
      // are lazily instantiated, accessed via the `_generatedMappings` and
      // `_originalMappings` getters respectively, and we only parse the mappings
      // and create these arrays once queried for a source location. We jump through
      // these hoops because there can be many thousands of mappings, and parsing
      // them is expensive, so we only want to do it if we must.
      //
      // Each object in the arrays is of the form:
      //
      //     {
      //       generatedLine: The line number in the generated code,
      //       generatedColumn: The column number in the generated code,
      //       source: The path to the original source file that generated this
      //               chunk of code,
      //       originalLine: The line number in the original source that
      //                     corresponds to this chunk of generated code,
      //       originalColumn: The column number in the original source that
      //                       corresponds to this chunk of generated code,
      //       name: The name of the original symbol which generated this chunk of
      //             code.
      //     }
      //
      // All properties except for `generatedLine` and `generatedColumn` can be
      // `null`.
      //
      // `_generatedMappings` is ordered by the generated positions.
      //
      // `_originalMappings` is ordered by the original positions.
    
      SourceMapConsumer.prototype.__generatedMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
        get: function () {
          if (!this.__generatedMappings) {
            this.__generatedMappings = [];
            this.__originalMappings = [];
            this._parseMappings(this._mappings, this.sourceRoot);
          }
    
          return this.__generatedMappings;
        }
      });
    
      SourceMapConsumer.prototype.__originalMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
        get: function () {
          if (!this.__originalMappings) {
            this.__generatedMappings = [];
            this.__originalMappings = [];
            this._parseMappings(this._mappings, this.sourceRoot);
          }
    
          return this.__originalMappings;
        }
      });
    
      SourceMapConsumer.prototype._nextCharIsMappingSeparator =
        function SourceMapConsumer_nextCharIsMappingSeparator(aStr, index) {
          var c = aStr.charAt(index);
          return c === ";" || c === ",";
        };
    
      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      SourceMapConsumer.prototype._parseMappings =
        function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
          throw new Error("Subclasses must implement _parseMappings");
        };
    
      SourceMapConsumer.GENERATED_ORDER = 1;
      SourceMapConsumer.ORIGINAL_ORDER = 2;
    
      SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
      SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    
      /**
       * Iterate over each mapping between an original source/line/column and a
       * generated line/column in this source map.
       *
       * @param Function aCallback
       *        The function that is called with each mapping.
       * @param Object aContext
       *        Optional. If specified, this object will be the value of `this` every
       *        time that `aCallback` is called.
       * @param aOrder
       *        Either `SourceMapConsumer.GENERATED_ORDER` or
       *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
       *        iterate over the mappings sorted by the generated file's line/column
       *        order or the original's source/line/column order, respectively. Defaults to
       *        `SourceMapConsumer.GENERATED_ORDER`.
       */
      SourceMapConsumer.prototype.eachMapping =
        function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
          var context = aContext || null;
          var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    
          var mappings;
          switch (order) {
          case SourceMapConsumer.GENERATED_ORDER:
            mappings = this._generatedMappings;
            break;
          case SourceMapConsumer.ORIGINAL_ORDER:
            mappings = this._originalMappings;
            break;
          default:
            throw new Error("Unknown order of iteration.");
          }
    
          var sourceRoot = this.sourceRoot;
          mappings.map(function (mapping) {
            var source = mapping.source;
            if (source != null && sourceRoot != null) {
              source = util.join(sourceRoot, source);
            }
            return {
              source: source,
              generatedLine: mapping.generatedLine,
              generatedColumn: mapping.generatedColumn,
              originalLine: mapping.originalLine,
              originalColumn: mapping.originalColumn,
              name: mapping.name
            };
          }).forEach(aCallback, context);
        };
    
      /**
       * Returns all generated line and column information for the original source,
       * line, and column provided. If no column is provided, returns all mappings
       * corresponding to a single line. Otherwise, returns all mappings
       * corresponding to a single line and column.
       *
       * The only argument is an object with the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.
       *   - column: Optional. the column number in the original source.
       *
       * and an array of objects is returned, each with the following properties:
       *
       *   - line: The line number in the generated source, or null.
       *   - column: The column number in the generated source, or null.
       */
      SourceMapConsumer.prototype.allGeneratedPositionsFor =
        function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
          // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
          // returns the index of the closest mapping less than the needle. By
          // setting needle.originalColumn to 0, we thus find the last mapping for
          // the given line, provided such a mapping exists.
          var needle = {
            source: util.getArg(aArgs, 'source'),
            originalLine: util.getArg(aArgs, 'line'),
            originalColumn: util.getArg(aArgs, 'column', 0)
          };
    
          if (this.sourceRoot != null) {
            needle.source = util.relative(this.sourceRoot, needle.source);
          }
    
          var mappings = [];
    
          var index = this._findMapping(needle,
                                        this._originalMappings,
                                        "originalLine",
                                        "originalColumn",
                                        util.compareByOriginalPositions,
                                        binarySearch.LEAST_UPPER_BOUND);
          if (index >= 0) {
            var mapping = this._originalMappings[index];
            var originalLine = mapping.originalLine;
            var originalColumn = mapping.originalColumn;
    
            // Iterate until either we run out of mappings, or we run into
            // a mapping for a different line. Since mappings are sorted, this is
            // guaranteed to find all mappings for the line we are searching for.
            while (mapping && mapping.originalLine === originalLine &&
                   (aArgs.column === undefined ||
                    mapping.originalColumn === originalColumn)) {
              mappings.push({
                line: util.getArg(mapping, 'generatedLine', null),
                column: util.getArg(mapping, 'generatedColumn', null),
                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
              });
    
              mapping = this._originalMappings[++index];
            }
          }
    
          return mappings;
        };
    
      exports.SourceMapConsumer = SourceMapConsumer;
    
      /**
       * A BasicSourceMapConsumer instance represents a parsed source map which we can
       * query for information about the original file positions by giving it a file
       * position in the generated source.
       *
       * The only parameter is the raw source map (either as a JSON string, or
       * already parsed to an object). According to the spec, source maps have the
       * following attributes:
       *
       *   - version: Which version of the source map spec this map is following.
       *   - sources: An array of URLs to the original source files.
       *   - names: An array of identifiers which can be referrenced by individual mappings.
       *   - sourceRoot: Optional. The URL root from which all sources are relative.
       *   - sourcesContent: Optional. An array of contents of the original source files.
       *   - mappings: A string of base64 VLQs which contain the actual mappings.
       *   - file: Optional. The generated file this source map is associated with.
       *
       * Here is an example source map, taken from the source map spec[0]:
       *
       *     {
       *       version : 3,
       *       file: "out.js",
       *       sourceRoot : "",
       *       sources: ["foo.js", "bar.js"],
       *       names: ["src", "maps", "are", "fun"],
       *       mappings: "AA,AB;;ABCDE;"
       *     }
       *
       * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
       */
      function BasicSourceMapConsumer(aSourceMap) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === 'string') {
          sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
        }
    
        var version = util.getArg(sourceMap, 'version');
        var sources = util.getArg(sourceMap, 'sources');
        // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
        // requires the array) to play nice here.
        var names = util.getArg(sourceMap, 'names', []);
        var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
        var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
        var mappings = util.getArg(sourceMap, 'mappings');
        var file = util.getArg(sourceMap, 'file', null);
    
        // Once again, Sass deviates from the spec and supplies the version as a
        // string rather than a number, so we use loose equality checking here.
        if (version != this._version) {
          throw new Error('Unsupported version: ' + version);
        }
    
        // Some source maps produce relative source paths like "./foo.js" instead of
        // "foo.js".  Normalize these first so that future comparisons will succeed.
        // See bugzil.la/1090768.
        sources = sources.map(util.normalize);
    
        // Pass `true` below to allow duplicate names and sources. While source maps
        // are intended to be compressed and deduplicated, the TypeScript compiler
        // sometimes generates source maps with duplicates in them. See Github issue
        // #72 and bugzil.la/889492.
        this._names = ArraySet.fromArray(names, true);
        this._sources = ArraySet.fromArray(sources, true);
    
        this.sourceRoot = sourceRoot;
        this.sourcesContent = sourcesContent;
        this._mappings = mappings;
        this.file = file;
      }
    
      BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    
      /**
       * Create a BasicSourceMapConsumer from a SourceMapGenerator.
       *
       * @param SourceMapGenerator aSourceMap
       *        The source map that will be consumed.
       * @returns BasicSourceMapConsumer
       */
      BasicSourceMapConsumer.fromSourceMap =
        function SourceMapConsumer_fromSourceMap(aSourceMap) {
          var smc = Object.create(BasicSourceMapConsumer.prototype);
    
          smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
          smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
          smc.sourceRoot = aSourceMap._sourceRoot;
          smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                                  smc.sourceRoot);
          smc.file = aSourceMap._file;
    
          smc.__generatedMappings = aSourceMap._mappings.toArray().slice();
          smc.__originalMappings = aSourceMap._mappings.toArray().slice()
            .sort(util.compareByOriginalPositions);
    
          return smc;
        };
    
      /**
       * The version of the source mapping spec that we are consuming.
       */
      BasicSourceMapConsumer.prototype._version = 3;
    
      /**
       * The list of original sources.
       */
      Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
        get: function () {
          return this._sources.toArray().map(function (s) {
            return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
          }, this);
        }
      });
    
      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      BasicSourceMapConsumer.prototype._parseMappings =
        function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
          var generatedLine = 1;
          var previousGeneratedColumn = 0;
          var previousOriginalLine = 0;
          var previousOriginalColumn = 0;
          var previousSource = 0;
          var previousName = 0;
          var length = aStr.length;
          var index = 0;
          var cachedValues = {};
          var temp = {};
          var mapping, str, values, end, value;
    
          while (index < length) {
            if (aStr.charAt(index) === ';') {
              generatedLine++;
              ++index;
              previousGeneratedColumn = 0;
            }
            else if (aStr.charAt(index) === ',') {
              ++index;
            }
            else {
              mapping = {};
              mapping.generatedLine = generatedLine;
    
              // Because each offset is encoded relative to the previous one,
              // many segments often have the same encoding. We can exploit this
              // fact by caching the parsed variable length fields of each segment,
              // allowing us to avoid a second parse if we encounter the same
              // segment again.
              for (end = index; end < length; ++end) {
                if (this._nextCharIsMappingSeparator(aStr, end)) {
                  break;
                }
              }
              str = aStr.slice(index, end);
    
              values = cachedValues[str];
              if (values) {
                index += str.length;
              } else {
                values = [];
                while (index < end) {
                  base64VLQ.decode(aStr, index, temp);
                  value = temp.value;
                  index = temp.rest;
                  values.push(value);
                }
                cachedValues[str] = values;
              }
    
              // Generated column.
              mapping.generatedColumn = previousGeneratedColumn + values[0];
              previousGeneratedColumn = mapping.generatedColumn;
    
              if (values.length > 1) {
                // Original source.
                mapping.source = this._sources.at(previousSource + values[1]);
                previousSource += values[1];
                if (values.length === 2) {
                  throw new Error('Found a source, but no line and column');
                }
    
                // Original line.
                mapping.originalLine = previousOriginalLine + values[2];
                previousOriginalLine = mapping.originalLine;
                // Lines are stored 0-based
                mapping.originalLine += 1;
                if (values.length === 3) {
                  throw new Error('Found a source and line, but no column');
                }
    
                // Original column.
                mapping.originalColumn = previousOriginalColumn + values[3];
                previousOriginalColumn = mapping.originalColumn;
    
                if (values.length > 4) {
                  // Original name.
                  mapping.name = this._names.at(previousName + values[4]);
                  previousName += values[4];
                }
              }
    
              this.__generatedMappings.push(mapping);
              if (typeof mapping.originalLine === 'number') {
                this.__originalMappings.push(mapping);
              }
            }
          }
    
          this.__generatedMappings.sort(util.compareByGeneratedPositions);
          this.__originalMappings.sort(util.compareByOriginalPositions);
        };
    
      /**
       * Find the mapping that best matches the hypothetical "needle" mapping that
       * we are searching for in the given "haystack" of mappings.
       */
      BasicSourceMapConsumer.prototype._findMapping =
        function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                               aColumnName, aComparator, aBias) {
          // To return the position we are searching for, we must first find the
          // mapping for the given position and then return the opposite position it
          // points to. Because the mappings are sorted, we can use binary search to
          // find the best mapping.
    
          if (aNeedle[aLineName] <= 0) {
            throw new TypeError('Line must be greater than or equal to 1, got '
                                + aNeedle[aLineName]);
          }
          if (aNeedle[aColumnName] < 0) {
            throw new TypeError('Column must be greater than or equal to 0, got '
                                + aNeedle[aColumnName]);
          }
    
          return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
        };
    
      /**
       * Compute the last column for each generated mapping. The last column is
       * inclusive.
       */
      BasicSourceMapConsumer.prototype.computeColumnSpans =
        function SourceMapConsumer_computeColumnSpans() {
          for (var index = 0; index < this._generatedMappings.length; ++index) {
            var mapping = this._generatedMappings[index];
    
            // Mappings do not contain a field for the last generated columnt. We
            // can come up with an optimistic estimate, however, by assuming that
            // mappings are contiguous (i.e. given two consecutive mappings, the
            // first mapping ends where the second one starts).
            if (index + 1 < this._generatedMappings.length) {
              var nextMapping = this._generatedMappings[index + 1];
    
              if (mapping.generatedLine === nextMapping.generatedLine) {
                mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
                continue;
              }
            }
    
            // The last mapping for each line spans the entire line.
            mapping.lastGeneratedColumn = Infinity;
          }
        };
    
      /**
       * Returns the original source, line, and column information for the generated
       * source's line and column positions provided. The only argument is an object
       * with the following properties:
       *
       *   - line: The line number in the generated source.
       *   - column: The column number in the generated source.
       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
       *
       * and an object is returned with the following properties:
       *
       *   - source: The original source file, or null.
       *   - line: The line number in the original source, or null.
       *   - column: The column number in the original source, or null.
       *   - name: The original identifier, or null.
       */
      BasicSourceMapConsumer.prototype.originalPositionFor =
        function SourceMapConsumer_originalPositionFor(aArgs) {
          var needle = {
            generatedLine: util.getArg(aArgs, 'line'),
            generatedColumn: util.getArg(aArgs, 'column')
          };
    
          var index = this._findMapping(
            needle,
            this._generatedMappings,
            "generatedLine",
            "generatedColumn",
            util.compareByGeneratedPositions,
            util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
          );
    
          if (index >= 0) {
            var mapping = this._generatedMappings[index];
    
            if (mapping.generatedLine === needle.generatedLine) {
              var source = util.getArg(mapping, 'source', null);
              if (source != null && this.sourceRoot != null) {
                source = util.join(this.sourceRoot, source);
              }
              return {
                source: source,
                line: util.getArg(mapping, 'originalLine', null),
                column: util.getArg(mapping, 'originalColumn', null),
                name: util.getArg(mapping, 'name', null)
              };
            }
          }
    
          return {
            source: null,
            line: null,
            column: null,
            name: null
          };
        };
    
      /**
       * Returns the original source content. The only argument is the url of the
       * original source file. Returns null if no original source content is
       * availible.
       */
      BasicSourceMapConsumer.prototype.sourceContentFor =
        function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
          if (!this.sourcesContent) {
            return null;
          }
    
          if (this.sourceRoot != null) {
            aSource = util.relative(this.sourceRoot, aSource);
          }
    
          if (this._sources.has(aSource)) {
            return this.sourcesContent[this._sources.indexOf(aSource)];
          }
    
          var url;
          if (this.sourceRoot != null
              && (url = util.urlParse(this.sourceRoot))) {
            // XXX: file:// URIs and absolute paths lead to unexpected behavior for
            // many users. We can help them out when they expect file:// URIs to
            // behave like it would if they were running a local HTTP server. See
            // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
            var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
            if (url.scheme == "file"
                && this._sources.has(fileUriAbsPath)) {
              return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
            }
    
            if ((!url.path || url.path == "/")
                && this._sources.has("/" + aSource)) {
              return this.sourcesContent[this._sources.indexOf("/" + aSource)];
            }
          }
    
          // This function is used recursively from
          // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
          // don't want to throw if we can't find the source - we just want to
          // return null, so we provide a flag to exit gracefully.
          if (nullOnMissing) {
            return null;
          }
          else {
            throw new Error('"' + aSource + '" is not in the SourceMap.');
          }
        };
    
      /**
       * Returns the generated line and column information for the original source,
       * line, and column positions provided. The only argument is an object with
       * the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.
       *   - column: The column number in the original source.
       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
       *
       * and an object is returned with the following properties:
       *
       *   - line: The line number in the generated source, or null.
       *   - column: The column number in the generated source, or null.
       */
      BasicSourceMapConsumer.prototype.generatedPositionFor =
        function SourceMapConsumer_generatedPositionFor(aArgs) {
          var needle = {
            source: util.getArg(aArgs, 'source'),
            originalLine: util.getArg(aArgs, 'line'),
            originalColumn: util.getArg(aArgs, 'column')
          };
    
          if (this.sourceRoot != null) {
            needle.source = util.relative(this.sourceRoot, needle.source);
          }
    
          var index = this._findMapping(
            needle,
            this._originalMappings,
            "originalLine",
            "originalColumn",
            util.compareByOriginalPositions,
            util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
          );
    
          if (index >= 0) {
            var mapping = this._originalMappings[index];
    
            if (mapping.source === needle.source) {
              return {
                line: util.getArg(mapping, 'generatedLine', null),
                column: util.getArg(mapping, 'generatedColumn', null),
                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
              };
            }
          }
    
          return {
            line: null,
            column: null,
            lastColumn: null
          };
        };
    
      exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    
      /**
       * An IndexedSourceMapConsumer instance represents a parsed source map which
       * we can query for information. It differs from BasicSourceMapConsumer in
       * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
       * input.
       *
       * The only parameter is a raw source map (either as a JSON string, or already
       * parsed to an object). According to the spec for indexed source maps, they
       * have the following attributes:
       *
       *   - version: Which version of the source map spec this map is following.
       *   - file: Optional. The generated file this source map is associated with.
       *   - sections: A list of section definitions.
       *
       * Each value under the "sections" field has two fields:
       *   - offset: The offset into the original specified at which this section
       *       begins to apply, defined as an object with a "line" and "column"
       *       field.
       *   - map: A source map definition. This source map could also be indexed,
       *       but doesn't have to be.
       *
       * Instead of the "map" field, it's also possible to have a "url" field
       * specifying a URL to retrieve a source map from, but that's currently
       * unsupported.
       *
       * Here's an example source map, taken from the source map spec[0], but
       * modified to omit a section which uses the "url" field.
       *
       *  {
       *    version : 3,
       *    file: "app.js",
       *    sections: [{
       *      offset: {line:100, column:10},
       *      map: {
       *        version : 3,
       *        file: "section.js",
       *        sources: ["foo.js", "bar.js"],
       *        names: ["src", "maps", "are", "fun"],
       *        mappings: "AAAA,E;;ABCDE;"
       *      }
       *    }],
       *  }
       *
       * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
       */
      function IndexedSourceMapConsumer(aSourceMap) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === 'string') {
          sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
        }
    
        var version = util.getArg(sourceMap, 'version');
        var sections = util.getArg(sourceMap, 'sections');
    
        if (version != this._version) {
          throw new Error('Unsupported version: ' + version);
        }
    
        var lastOffset = {
          line: -1,
          column: 0
        };
        this._sections = sections.map(function (s) {
          if (s.url) {
            // The url field will require support for asynchronicity.
            // See https://github.com/mozilla/source-map/issues/16
            throw new Error('Support for url field in sections not implemented.');
          }
          var offset = util.getArg(s, 'offset');
          var offsetLine = util.getArg(offset, 'line');
          var offsetColumn = util.getArg(offset, 'column');
    
          if (offsetLine < lastOffset.line ||
              (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
            throw new Error('Section offsets must be ordered and non-overlapping.');
          }
          lastOffset = offset;
    
          return {
            generatedOffset: {
              // The offset fields are 0-based, but we use 1-based indices when
              // encoding/decoding from VLQ.
              generatedLine: offsetLine + 1,
              generatedColumn: offsetColumn + 1
            },
            consumer: new SourceMapConsumer(util.getArg(s, 'map'))
          }
        });
      }
    
      IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    
      /**
       * The version of the source mapping spec that we are consuming.
       */
      IndexedSourceMapConsumer.prototype._version = 3;
    
      /**
       * The list of original sources.
       */
      Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
        get: function () {
          var sources = [];
          for (var i = 0; i < this._sections.length; i++) {
            for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
              sources.push(this._sections[i].consumer.sources[j]);
            }
          };
          return sources;
        }
      });
    
      /**
       * Returns the original source, line, and column information for the generated
       * source's line and column positions provided. The only argument is an object
       * with the following properties:
       *
       *   - line: The line number in the generated source.
       *   - column: The column number in the generated source.
       *
       * and an object is returned with the following properties:
       *
       *   - source: The original source file, or null.
       *   - line: The line number in the original source, or null.
       *   - column: The column number in the original source, or null.
       *   - name: The original identifier, or null.
       */
      IndexedSourceMapConsumer.prototype.originalPositionFor =
        function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
          var needle = {
            generatedLine: util.getArg(aArgs, 'line'),
            generatedColumn: util.getArg(aArgs, 'column')
          };
    
          // Find the section containing the generated position we're trying to map
          // to an original position.
          var sectionIndex = binarySearch.search(needle, this._sections,
            function(needle, section) {
              var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
              if (cmp) {
                return cmp;
              }
    
              return (needle.generatedColumn -
                      section.generatedOffset.generatedColumn);
            });
          var section = this._sections[sectionIndex];
    
          if (!section) {
            return {
              source: null,
              line: null,
              column: null,
              name: null
            };
          }
    
          return section.consumer.originalPositionFor({
            line: needle.generatedLine -
              (section.generatedOffset.generatedLine - 1),
            column: needle.generatedColumn -
              (section.generatedOffset.generatedLine === needle.generatedLine
               ? section.generatedOffset.generatedColumn - 1
               : 0),
            bias: aArgs.bias
          });
        };
    
      /**
       * Returns the original source content. The only argument is the url of the
       * original source file. Returns null if no original source content is
       * available.
       */
      IndexedSourceMapConsumer.prototype.sourceContentFor =
        function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
          for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i];
    
            var content = section.consumer.sourceContentFor(aSource, true);
            if (content) {
              return content;
            }
          }
          if (nullOnMissing) {
            return null;
          }
          else {
            throw new Error('"' + aSource + '" is not in the SourceMap.');
          }
        };
    
      /**
       * Returns the generated line and column information for the original source,
       * line, and column positions provided. The only argument is an object with
       * the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.
       *   - column: The column number in the original source.
       *
       * and an object is returned with the following properties:
       *
       *   - line: The line number in the generated source, or null.
       *   - column: The column number in the generated source, or null.
       */
      IndexedSourceMapConsumer.prototype.generatedPositionFor =
        function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
          for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i];
    
            // Only consider this section if the requested source is in the list of
            // sources of the consumer.
            if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
              continue;
            }
            var generatedPosition = section.consumer.generatedPositionFor(aArgs);
            if (generatedPosition) {
              var ret = {
                line: generatedPosition.line +
                  (section.generatedOffset.generatedLine - 1),
                column: generatedPosition.column +
                  (section.generatedOffset.generatedLine === generatedPosition.line
                   ? section.generatedOffset.generatedColumn - 1
                   : 0)
              };
              return ret;
            }
          }
    
          return {
            line: null,
            column: null
          };
        };
    
      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      IndexedSourceMapConsumer.prototype._parseMappings =
        function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
          this.__generatedMappings = [];
          this.__originalMappings = [];
          for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i];
            var sectionMappings = section.consumer._generatedMappings;
            for (var j = 0; j < sectionMappings.length; j++) {
              var mapping = sectionMappings[i];
    
              var source = mapping.source;
              var sourceRoot = section.consumer.sourceRoot;
    
              if (source != null && sourceRoot != null) {
                source = util.join(sourceRoot, source);
              }
    
              // The mappings coming from the consumer for the section have
              // generated positions relative to the start of the section, so we
              // need to offset them to be relative to the start of the concatenated
              // generated file.
              var adjustedMapping = {
                source: source,
                generatedLine: mapping.generatedLine +
                  (section.generatedOffset.generatedLine - 1),
                generatedColumn: mapping.column +
                  (section.generatedOffset.generatedLine === mapping.generatedLine)
                  ? section.generatedOffset.generatedColumn - 1
                  : 0,
                originalLine: mapping.originalLine,
                originalColumn: mapping.originalColumn,
                name: mapping.name
              };
    
              this.__generatedMappings.push(adjustedMapping);
              if (typeof adjustedMapping.originalLine === 'number') {
                this.__originalMappings.push(adjustedMapping);
              }
            };
          };
    
        this.__generatedMappings.sort(util.compareByGeneratedPositions);
        this.__originalMappings.sort(util.compareByOriginalPositions);
      };
    
      exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
    
    });
    
  provide("source-map/source-map/source-map-consumer", module.exports);
}(global));

// pakmanager:source-map/source-map/source-node
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var SourceMapGenerator =  require('source-map/source-map/source-map-generator').SourceMapGenerator;
      var util =  require('source-map/source-map/util');
    
      // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
      // operating systems these days (capturing the result).
      var REGEX_NEWLINE = /(\r?\n)/;
    
      // Newline character code for charCodeAt() comparisons
      var NEWLINE_CODE = 10;
    
      // Private symbol for identifying `SourceNode`s when multiple versions of
      // the source-map library are loaded. This MUST NOT CHANGE across
      // versions!
      var isSourceNode = "$$$isSourceNode$$$";
    
      /**
       * SourceNodes provide a way to abstract over interpolating/concatenating
       * snippets of generated JavaScript source code while maintaining the line and
       * column information associated with the original source code.
       *
       * @param aLine The original line number.
       * @param aColumn The original column number.
       * @param aSource The original source's filename.
       * @param aChunks Optional. An array of strings which are snippets of
       *        generated JS, or other SourceNodes.
       * @param aName The original identifier.
       */
      function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
        this.children = [];
        this.sourceContents = {};
        this.line = aLine == null ? null : aLine;
        this.column = aColumn == null ? null : aColumn;
        this.source = aSource == null ? null : aSource;
        this.name = aName == null ? null : aName;
        this[isSourceNode] = true;
        if (aChunks != null) this.add(aChunks);
      }
    
      /**
       * Creates a SourceNode from generated code and a SourceMapConsumer.
       *
       * @param aGeneratedCode The generated code
       * @param aSourceMapConsumer The SourceMap for the generated code
       * @param aRelativePath Optional. The path that relative sources in the
       *        SourceMapConsumer should be relative to.
       */
      SourceNode.fromStringWithSourceMap =
        function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
          // The SourceNode we want to fill with the generated code
          // and the SourceMap
          var node = new SourceNode();
    
          // All even indices of this array are one line of the generated code,
          // while all odd indices are the newlines between two adjacent lines
          // (since `REGEX_NEWLINE` captures its match).
          // Processed fragments are removed from this array, by calling `shiftNextLine`.
          var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
          var shiftNextLine = function() {
            var lineContents = remainingLines.shift();
            // The last line of a file might not have a newline.
            var newLine = remainingLines.shift() || "";
            return lineContents + newLine;
          };
    
          // We need to remember the position of "remainingLines"
          var lastGeneratedLine = 1, lastGeneratedColumn = 0;
    
          // The generate SourceNodes we need a code range.
          // To extract it current and last mapping is used.
          // Here we store the last mapping.
          var lastMapping = null;
    
          aSourceMapConsumer.eachMapping(function (mapping) {
            if (lastMapping !== null) {
              // We add the code from "lastMapping" to "mapping":
              // First check if there is a new line in between.
              if (lastGeneratedLine < mapping.generatedLine) {
                var code = "";
                // Associate first line with "lastMapping"
                addMappingWithCode(lastMapping, shiftNextLine());
                lastGeneratedLine++;
                lastGeneratedColumn = 0;
                // The remaining code is added without mapping
              } else {
                // There is no new line in between.
                // Associate the code between "lastGeneratedColumn" and
                // "mapping.generatedColumn" with "lastMapping"
                var nextLine = remainingLines[0];
                var code = nextLine.substr(0, mapping.generatedColumn -
                                              lastGeneratedColumn);
                remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                                    lastGeneratedColumn);
                lastGeneratedColumn = mapping.generatedColumn;
                addMappingWithCode(lastMapping, code);
                // No more remaining code, continue
                lastMapping = mapping;
                return;
              }
            }
            // We add the generated code until the first mapping
            // to the SourceNode without any mapping.
            // Each line is added as separate string.
            while (lastGeneratedLine < mapping.generatedLine) {
              node.add(shiftNextLine());
              lastGeneratedLine++;
            }
            if (lastGeneratedColumn < mapping.generatedColumn) {
              var nextLine = remainingLines[0];
              node.add(nextLine.substr(0, mapping.generatedColumn));
              remainingLines[0] = nextLine.substr(mapping.generatedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
            }
            lastMapping = mapping;
          }, this);
          // We have processed all mappings.
          if (remainingLines.length > 0) {
            if (lastMapping) {
              // Associate the remaining code in the current line with "lastMapping"
              addMappingWithCode(lastMapping, shiftNextLine());
            }
            // and add the remaining lines without any mapping
            node.add(remainingLines.join(""));
          }
    
          // Copy sourcesContent into SourceNode
          aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              if (aRelativePath != null) {
                sourceFile = util.join(aRelativePath, sourceFile);
              }
              node.setSourceContent(sourceFile, content);
            }
          });
    
          return node;
    
          function addMappingWithCode(mapping, code) {
            if (mapping === null || mapping.source === undefined) {
              node.add(code);
            } else {
              var source = aRelativePath
                ? util.join(aRelativePath, mapping.source)
                : mapping.source;
              node.add(new SourceNode(mapping.originalLine,
                                      mapping.originalColumn,
                                      source,
                                      code,
                                      mapping.name));
            }
          }
        };
    
      /**
       * Add a chunk of generated JS to this source node.
       *
       * @param aChunk A string snippet of generated JS code, another instance of
       *        SourceNode, or an array where each member is one of those things.
       */
      SourceNode.prototype.add = function SourceNode_add(aChunk) {
        if (Array.isArray(aChunk)) {
          aChunk.forEach(function (chunk) {
            this.add(chunk);
          }, this);
        }
        else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          if (aChunk) {
            this.children.push(aChunk);
          }
        }
        else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
    
      /**
       * Add a chunk of generated JS to the beginning of this source node.
       *
       * @param aChunk A string snippet of generated JS code, another instance of
       *        SourceNode, or an array where each member is one of those things.
       */
      SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
        if (Array.isArray(aChunk)) {
          for (var i = aChunk.length-1; i >= 0; i--) {
            this.prepend(aChunk[i]);
          }
        }
        else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          this.children.unshift(aChunk);
        }
        else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
    
      /**
       * Walk over the tree of JS snippets in this node and its children. The
       * walking function is called once for each snippet of JS and is passed that
       * snippet and the its original associated source's line/column location.
       *
       * @param aFn The traversal function.
       */
      SourceNode.prototype.walk = function SourceNode_walk(aFn) {
        var chunk;
        for (var i = 0, len = this.children.length; i < len; i++) {
          chunk = this.children[i];
          if (chunk[isSourceNode]) {
            chunk.walk(aFn);
          }
          else {
            if (chunk !== '') {
              aFn(chunk, { source: this.source,
                           line: this.line,
                           column: this.column,
                           name: this.name });
            }
          }
        }
      };
    
      /**
       * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
       * each of `this.children`.
       *
       * @param aSep The separator.
       */
      SourceNode.prototype.join = function SourceNode_join(aSep) {
        var newChildren;
        var i;
        var len = this.children.length;
        if (len > 0) {
          newChildren = [];
          for (i = 0; i < len-1; i++) {
            newChildren.push(this.children[i]);
            newChildren.push(aSep);
          }
          newChildren.push(this.children[i]);
          this.children = newChildren;
        }
        return this;
      };
    
      /**
       * Call String.prototype.replace on the very right-most source snippet. Useful
       * for trimming whitespace from the end of a source node, etc.
       *
       * @param aPattern The pattern to replace.
       * @param aReplacement The thing to replace the pattern with.
       */
      SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
        var lastChild = this.children[this.children.length - 1];
        if (lastChild[isSourceNode]) {
          lastChild.replaceRight(aPattern, aReplacement);
        }
        else if (typeof lastChild === 'string') {
          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
        }
        else {
          this.children.push(''.replace(aPattern, aReplacement));
        }
        return this;
      };
    
      /**
       * Set the source content for a source file. This will be added to the SourceMapGenerator
       * in the sourcesContent field.
       *
       * @param aSourceFile The filename of the source file
       * @param aSourceContent The content of the source file
       */
      SourceNode.prototype.setSourceContent =
        function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
          this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
        };
    
      /**
       * Walk over the tree of SourceNodes. The walking function is called for each
       * source file content and is passed the filename and source content.
       *
       * @param aFn The traversal function.
       */
      SourceNode.prototype.walkSourceContents =
        function SourceNode_walkSourceContents(aFn) {
          for (var i = 0, len = this.children.length; i < len; i++) {
            if (this.children[i][isSourceNode]) {
              this.children[i].walkSourceContents(aFn);
            }
          }
    
          var sources = Object.keys(this.sourceContents);
          for (var i = 0, len = sources.length; i < len; i++) {
            aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
          }
        };
    
      /**
       * Return the string representation of this source node. Walks over the tree
       * and concatenates all the various snippets together to one string.
       */
      SourceNode.prototype.toString = function SourceNode_toString() {
        var str = "";
        this.walk(function (chunk) {
          str += chunk;
        });
        return str;
      };
    
      /**
       * Returns the string representation of this source node along with a source
       * map.
       */
      SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
        var generated = {
          code: "",
          line: 1,
          column: 0
        };
        var map = new SourceMapGenerator(aArgs);
        var sourceMappingActive = false;
        var lastOriginalSource = null;
        var lastOriginalLine = null;
        var lastOriginalColumn = null;
        var lastOriginalName = null;
        this.walk(function (chunk, original) {
          generated.code += chunk;
          if (original.source !== null
              && original.line !== null
              && original.column !== null) {
            if(lastOriginalSource !== original.source
               || lastOriginalLine !== original.line
               || lastOriginalColumn !== original.column
               || lastOriginalName !== original.name) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
          } else if (sourceMappingActive) {
            map.addMapping({
              generated: {
                line: generated.line,
                column: generated.column
              }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
          }
          for (var idx = 0, length = chunk.length; idx < length; idx++) {
            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
              generated.line++;
              generated.column = 0;
              // Mappings end at eol
              if (idx + 1 === length) {
                lastOriginalSource = null;
                sourceMappingActive = false;
              } else if (sourceMappingActive) {
                map.addMapping({
                  source: original.source,
                  original: {
                    line: original.line,
                    column: original.column
                  },
                  generated: {
                    line: generated.line,
                    column: generated.column
                  },
                  name: original.name
                });
              }
            } else {
              generated.column++;
            }
          }
        });
        this.walkSourceContents(function (sourceFile, sourceContent) {
          map.setSourceContent(sourceFile, sourceContent);
        });
    
        return { code: generated.code, map: map };
      };
    
      exports.SourceNode = SourceNode;
    
    });
    
  provide("source-map/source-map/source-node", module.exports);
}(global));

// pakmanager:source-map
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * Copyright 2009-2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE.txt or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    exports.SourceMapGenerator =  require('source-map/source-map/source-map-generator').SourceMapGenerator;
    exports.SourceMapConsumer =  require('source-map/source-map/source-map-consumer').SourceMapConsumer;
    exports.SourceNode =  require('source-map/source-map/source-node').SourceNode;
    
  provide("source-map", module.exports);
}(global));

// pakmanager:source-map-resolve/lib/resolve-url
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2014 Simon Lydell
    // X11 (“MIT”) Licensed. (See LICENSE.)
    
    var url = require("url")
    
    function resolveUrl(/* ...urls */) {
      return Array.prototype.reduce.call(arguments, function(resolved, nextUrl) {
        return url.resolve(resolved, nextUrl)
      })
    }
    
    module.exports = resolveUrl
    
  provide("source-map-resolve/lib/resolve-url", module.exports);
}(global));

// pakmanager:source-map-resolve
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2014 Simon Lydell
    // X11 (“MIT”) Licensed. (See LICENSE.)
    
    var sourceMappingURL = require("source-map-url")
    var resolveUrl       =  require('source-map-resolve/lib/resolve-url')
    var urix             = require("urix")
    var atob             = require("atob")
    
    
    
    function callbackAsync(callback, error, result) {
      setImmediate(function() { callback(error, result) })
    }
    
    function parseMapToJSON(string) {
      return JSON.parse(string.replace(/^\)\]\}'/, ""))
    }
    
    
    
    function resolveSourceMap(code, codeUrl, read, callback) {
      var mapData
      try {
        mapData = resolveSourceMapHelper(code, codeUrl)
      } catch (error) {
        return callbackAsync(callback, error)
      }
      if (!mapData || mapData.map) {
        return callbackAsync(callback, null, mapData)
      }
      read(mapData.url, function(error, result) {
        if (error) {
          return callback(error)
        }
        try {
          mapData.map = parseMapToJSON(String(result))
        } catch (error) {
          return callback(error)
        }
        callback(null, mapData)
      })
    }
    
    function resolveSourceMapSync(code, codeUrl, read) {
      var mapData = resolveSourceMapHelper(code, codeUrl)
      if (!mapData || mapData.map) {
        return mapData
      }
      mapData.map = parseMapToJSON(String(read(mapData.url)))
      return mapData
    }
    
    var dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/
    var jsonMimeTypeRegex = /^(?:application|text)\/json$/
    
    function resolveSourceMapHelper(code, codeUrl) {
      codeUrl = urix(codeUrl)
    
      var url = sourceMappingURL.getFrom(code)
      if (!url) {
        return null
      }
    
      var dataUri = url.match(dataUriRegex)
      if (dataUri) {
        var mimeType = dataUri[1]
        var lastParameter = dataUri[2]
        var encoded = dataUri[3]
        if (!jsonMimeTypeRegex.test(mimeType)) {
          throw new Error("Unuseful data uri mime type: " + (mimeType || "text/plain"))
        }
        return {
          sourceMappingURL: url,
          url: null,
          sourcesRelativeTo: codeUrl,
          map: parseMapToJSON(lastParameter === ";base64" ? atob(encoded) : decodeURIComponent(encoded))
        }
      }
    
      var mapUrl = resolveUrl(codeUrl, url)
      return {
        sourceMappingURL: url,
        url: mapUrl,
        sourcesRelativeTo: mapUrl,
        map: null
      }
    }
    
    
    
    function resolveSources(map, mapUrl, read, options, callback) {
      if (typeof options === "function") {
        callback = options
        options = {}
      }
      var pending = map.sources.length
      var errored = false
      var result = {
        sourcesResolved: [],
        sourcesContent:  []
      }
    
      var done = function(error) {
        if (errored) {
          return
        }
        if (error) {
          errored = true
          return callback(error)
        }
        pending--
        if (pending === 0) {
          callback(null, result)
        }
      }
    
      resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
        result.sourcesResolved[index] = fullUrl
        if (typeof sourceContent === "string") {
          result.sourcesContent[index] = sourceContent
          callbackAsync(done, null)
        } else {
          read(fullUrl, function(error, source) {
            result.sourcesContent[index] = String(source)
            done(error)
          })
        }
      })
    }
    
    function resolveSourcesSync(map, mapUrl, read, options) {
      var result = {
        sourcesResolved: [],
        sourcesContent:  []
      }
      resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
        result.sourcesResolved[index] = fullUrl
        if (read !== null) {
          if (typeof sourceContent === "string") {
            result.sourcesContent[index] = sourceContent
          } else {
            result.sourcesContent[index] = String(read(fullUrl))
          }
        }
      })
      return result
    }
    
    var endingSlash = /\/?$/
    
    function resolveSourcesHelper(map, mapUrl, options, fn) {
      options = options || {}
      mapUrl = urix(mapUrl)
      var fullUrl
      var sourceContent
      for (var index = 0, len = map.sources.length; index < len; index++) {
        if (map.sourceRoot && !options.ignoreSourceRoot) {
          // Make sure that the sourceRoot ends with a slash, so that `/scripts/subdir` becomes
          // `/scripts/subdir/<source>`, not `/scripts/<source>`. Pointing to a file as source root
          // does not make sense.
          fullUrl = resolveUrl(mapUrl, map.sourceRoot.replace(endingSlash, "/"), map.sources[index])
        } else {
          fullUrl = resolveUrl(mapUrl, map.sources[index])
        }
        sourceContent = (map.sourcesContent || [])[index]
        fn(fullUrl, sourceContent, index)
      }
    }
    
    
    
    function resolve(code, codeUrl, read, options, callback) {
      if (typeof options === "function") {
        callback = options
        options = {}
      }
      resolveSourceMap(code, codeUrl, read, function(error, mapData) {
        if (error) {
          return callback(error)
        }
        if (!mapData) {
          return callback(null, null)
        }
        resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function(error, result) {
          if (error) {
            return callback(error)
          }
          mapData.sourcesResolved = result.sourcesResolved
          mapData.sourcesContent  = result.sourcesContent
          callback(null, mapData)
        })
      })
    }
    
    function resolveSync(code, codeUrl, read, options) {
      var mapData = resolveSourceMapSync(code, codeUrl, read)
      if (!mapData) {
        return null
      }
      var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options)
      mapData.sourcesResolved = result.sourcesResolved
      mapData.sourcesContent  = result.sourcesContent
      return mapData
    }
    
    
    
    module.exports = {
      resolveSourceMap:     resolveSourceMap,
      resolveSourceMapSync: resolveSourceMapSync,
      resolveSources:       resolveSources,
      resolveSourcesSync:   resolveSourcesSync,
      resolve:              resolve,
      resolveSync:          resolveSync
    }
    
  provide("source-map-resolve", module.exports);
}(global));

// pakmanager:inherits
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = require('util').inherits
    
  provide("inherits", module.exports);
}(global));

// pakmanager:async
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * async
     * https://github.com/caolan/async
     *
     * Copyright 2010-2014 Caolan McMahon
     * Released under the MIT license
     */
    (function () {
    
        var async = {};
        var noop = function () {};
    
        // global on the server, window in the browser
        var root, previous_async;
    
        if (typeof window == 'object' && this === window) {
            root = window;
        }
        else if (typeof global == 'object' && this === global) {
            root = global;
        }
        else {
            root = this;
        }
    
        if (root != null) {
          previous_async = root.async;
        }
    
        async.noConflict = function () {
            root.async = previous_async;
            return async;
        };
    
        function only_once(fn) {
            var called = false;
            return function() {
                if (called) throw new Error("Callback was already called.");
                called = true;
                fn.apply(root, arguments);
            };
        }
    
        //// cross-browser compatiblity functions ////
    
        var _toString = Object.prototype.toString;
    
        var _isArray = Array.isArray || function (obj) {
            return _toString.call(obj) === '[object Array]';
        };
    
        var _each = function (arr, iterator) {
          var index = -1,
              length = arr.length;
    
          while (++index < length) {
            iterator(arr[index], index, arr);
          }
        };
    
        var _map = function (arr, iterator) {
          var index = -1,
              length = arr.length,
              result = Array(length);
    
          while (++index < length) {
            result[index] = iterator(arr[index], index, arr);
          }
          return result;
        };
    
        var _reduce = function (arr, iterator, memo) {
            _each(arr, function (x, i, a) {
                memo = iterator(memo, x, i, a);
            });
            return memo;
        };
    
        var _forEachOf = function (object, iterator) {
            _each(_keys(object), function (key) {
                iterator(object[key], key);
            });
        };
    
        var _keys = Object.keys || function (obj) {
            var keys = [];
            for (var k in obj) {
                if (obj.hasOwnProperty(k)) {
                    keys.push(k);
                }
            }
            return keys;
        };
    
        var _baseSlice = function (arr, start) {
            start = start || 0;
            var index = -1;
            var length = arr.length;
    
            if (start) {
              length -= start;
              length = length < 0 ? 0 : length;
            }
            var result = Array(length);
    
            while (++index < length) {
              result[index] = arr[index + start];
            }
            return result;
        };
    
        //// exported async module functions ////
    
        //// nextTick implementation with browser-compatible fallback ////
    
        // capture the global reference to guard against fakeTimer mocks
        var _setImmediate;
        if (typeof setImmediate === 'function') {
            _setImmediate = setImmediate;
        }
    
        if (typeof process === 'undefined' || !(process.nextTick)) {
            if (_setImmediate) {
                async.nextTick = function (fn) {
                    // not a direct alias for IE10 compatibility
                    _setImmediate(fn);
                };
                async.setImmediate = async.nextTick;
            }
            else {
                async.nextTick = function (fn) {
                    setTimeout(fn, 0);
                };
                async.setImmediate = async.nextTick;
            }
        }
        else {
            async.nextTick = process.nextTick;
            if (_setImmediate) {
                async.setImmediate = function (fn) {
                  // not a direct alias for IE10 compatibility
                  _setImmediate(fn);
                };
            }
            else {
                async.setImmediate = async.nextTick;
            }
        }
    
        async.each = function (arr, iterator, callback) {
            callback = callback || noop;
            if (!arr.length) {
                return callback();
            }
            var completed = 0;
            _each(arr, function (x) {
                iterator(x, only_once(done) );
            });
            function done(err) {
              if (err) {
                  callback(err);
                  callback = noop;
              }
              else {
                  completed += 1;
                  if (completed >= arr.length) {
                      callback();
                  }
              }
            }
        };
        async.forEach = async.each;
    
        async.eachSeries = function (arr, iterator, callback) {
            callback = callback || noop;
            if (!arr.length) {
                return callback();
            }
            var completed = 0;
            var iterate = function () {
                iterator(arr[completed], function (err) {
                    if (err) {
                        callback(err);
                        callback = noop;
                    }
                    else {
                        completed += 1;
                        if (completed >= arr.length) {
                            callback();
                        }
                        else {
                            iterate();
                        }
                    }
                });
            };
            iterate();
        };
        async.forEachSeries = async.eachSeries;
    
    
        async.eachLimit = function (arr, limit, iterator, callback) {
            var fn = _eachLimit(limit);
            fn.apply(null, [arr, iterator, callback]);
        };
        async.forEachLimit = async.eachLimit;
    
        var _eachLimit = function (limit) {
    
            return function (arr, iterator, callback) {
                callback = callback || noop;
                if (!arr.length || limit <= 0) {
                    return callback();
                }
                var completed = 0;
                var started = 0;
                var running = 0;
    
                (function replenish () {
                    if (completed >= arr.length) {
                        return callback();
                    }
    
                    while (running < limit && started < arr.length) {
                        started += 1;
                        running += 1;
                        iterator(arr[started - 1], function (err) {
                            if (err) {
                                callback(err);
                                callback = noop;
                            }
                            else {
                                completed += 1;
                                running -= 1;
                                if (completed >= arr.length) {
                                    callback();
                                }
                                else {
                                    replenish();
                                }
                            }
                        });
                    }
                })();
            };
        };
    
    
    
        async.forEachOf = async.eachOf = function (object, iterator, callback) {
            callback = callback || function () {};
            var size = object.length || _keys(object).length;
            var completed = 0;
            if (!size) {
                return callback();
            }
            _forEachOf(object, function (value, key) {
                iterator(object[key], key, function (err) {
                    if (err) {
                        callback(err);
                        callback = function () {};
                    } else {
                        completed += 1;
                        if (completed === size) {
                            callback(null);
                        }
                    }
                });
            });
        };
    
        async.forEachOfSeries = async.eachOfSeries = function (obj, iterator, callback) {
            callback = callback || function () {};
            var keys = _keys(obj);
            var size = keys.length;
            if (!size) {
                return callback();
            }
            var completed = 0;
            var iterate = function () {
                var sync = true;
                var key = keys[completed];
                iterator(obj[key], key, function (err) {
                    if (err) {
                        callback(err);
                        callback = function () {};
                    }
                    else {
                        completed += 1;
                        if (completed >= size) {
                            callback(null);
                        }
                        else {
                            if (sync) {
                                async.nextTick(iterate);
                            }
                            else {
                                iterate();
                            }
                        }
                    }
                });
                sync = false;
            };
            iterate();
        };
    
    
    
        async.forEachOfLimit = async.eachOfLimit = function (obj, limit, iterator, callback) {
            _forEachOfLimit(limit)(obj, iterator, callback);
        };
    
        var _forEachOfLimit = function (limit) {
    
            return function (obj, iterator, callback) {
                callback = callback || function () {};
                var keys = _keys(obj);
                var size = keys.length;
                if (!size || limit <= 0) {
                    return callback();
                }
                var completed = 0;
                var started = 0;
                var running = 0;
    
                (function replenish () {
                    if (completed >= size) {
                        return callback();
                    }
    
                    while (running < limit && started < size) {
                        started += 1;
                        running += 1;
                        var key = keys[started - 1];
                        iterator(obj[key], key, function (err) {
                            if (err) {
                                callback(err);
                                callback = function () {};
                            }
                            else {
                                completed += 1;
                                running -= 1;
                                if (completed >= size) {
                                    callback();
                                }
                                else {
                                    replenish();
                                }
                            }
                        });
                    }
                })();
            };
        };
    
    
        var doParallel = function (fn) {
            return function () {
                var args = _baseSlice(arguments);
                return fn.apply(null, [async.each].concat(args));
            };
        };
        var doParallelLimit = function(limit, fn) {
            return function () {
                var args = _baseSlice(arguments);
                return fn.apply(null, [_eachLimit(limit)].concat(args));
            };
        };
        var doSeries = function (fn) {
            return function () {
                var args = _baseSlice(arguments);
                return fn.apply(null, [async.eachSeries].concat(args));
            };
        };
    
    
        var _asyncMap = function (eachfn, arr, iterator, callback) {
            arr = _map(arr, function (x, i) {
                return {index: i, value: x};
            });
            if (!callback) {
                eachfn(arr, function (x, callback) {
                    iterator(x.value, function (err) {
                        callback(err);
                    });
                });
            } else {
                var results = [];
                eachfn(arr, function (x, callback) {
                    iterator(x.value, function (err, v) {
                        results[x.index] = v;
                        callback(err);
                    });
                }, function (err) {
                    callback(err, results);
                });
            }
        };
        async.map = doParallel(_asyncMap);
        async.mapSeries = doSeries(_asyncMap);
        async.mapLimit = function (arr, limit, iterator, callback) {
            return _mapLimit(limit)(arr, iterator, callback);
        };
    
        var _mapLimit = function(limit) {
            return doParallelLimit(limit, _asyncMap);
        };
    
        // reduce only has a series version, as doing reduce in parallel won't
        // work in many situations.
        async.reduce = function (arr, memo, iterator, callback) {
            async.eachSeries(arr, function (x, callback) {
                iterator(memo, x, function (err, v) {
                    memo = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, memo);
            });
        };
        // inject alias
        async.inject = async.reduce;
        // foldl alias
        async.foldl = async.reduce;
    
        async.reduceRight = function (arr, memo, iterator, callback) {
            var reversed = _map(arr, function (x) {
                return x;
            }).reverse();
            async.reduce(reversed, memo, iterator, callback);
        };
        // foldr alias
        async.foldr = async.reduceRight;
    
        var _filter = function (eachfn, arr, iterator, callback) {
            var results = [];
            arr = _map(arr, function (x, i) {
                return {index: i, value: x};
            });
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (v) {
                    if (v) {
                        results.push(x);
                    }
                    callback();
                });
            }, function (err) {
                callback(_map(results.sort(function (a, b) {
                    return a.index - b.index;
                }), function (x) {
                    return x.value;
                }));
            });
        };
        async.filter = doParallel(_filter);
        async.filterSeries = doSeries(_filter);
        // select alias
        async.select = async.filter;
        async.selectSeries = async.filterSeries;
    
        var _reject = function (eachfn, arr, iterator, callback) {
            var results = [];
            arr = _map(arr, function (x, i) {
                return {index: i, value: x};
            });
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (v) {
                    if (!v) {
                        results.push(x);
                    }
                    callback();
                });
            }, function (err) {
                callback(_map(results.sort(function (a, b) {
                    return a.index - b.index;
                }), function (x) {
                    return x.value;
                }));
            });
        };
        async.reject = doParallel(_reject);
        async.rejectSeries = doSeries(_reject);
    
        var _detect = function (eachfn, arr, iterator, main_callback) {
            eachfn(arr, function (x, callback) {
                iterator(x, function (result) {
                    if (result) {
                        main_callback(x);
                        main_callback = noop;
                    }
                    else {
                        callback();
                    }
                });
            }, function (err) {
                main_callback();
            });
        };
        async.detect = doParallel(_detect);
        async.detectSeries = doSeries(_detect);
    
        async.some = function (arr, iterator, main_callback) {
            async.each(arr, function (x, callback) {
                iterator(x, function (v) {
                    if (v) {
                        main_callback(true);
                        main_callback = noop;
                    }
                    callback();
                });
            }, function (err) {
                main_callback(false);
            });
        };
        // any alias
        async.any = async.some;
    
        async.every = function (arr, iterator, main_callback) {
            async.each(arr, function (x, callback) {
                iterator(x, function (v) {
                    if (!v) {
                        main_callback(false);
                        main_callback = noop;
                    }
                    callback();
                });
            }, function (err) {
                main_callback(true);
            });
        };
        // all alias
        async.all = async.every;
    
        async.sortBy = function (arr, iterator, callback) {
            async.map(arr, function (x, callback) {
                iterator(x, function (err, criteria) {
                    if (err) {
                        callback(err);
                    }
                    else {
                        callback(null, {value: x, criteria: criteria});
                    }
                });
            }, function (err, results) {
                if (err) {
                    return callback(err);
                }
                else {
                    var fn = function (left, right) {
                        var a = left.criteria, b = right.criteria;
                        return a < b ? -1 : a > b ? 1 : 0;
                    };
                    callback(null, _map(results.sort(fn), function (x) {
                        return x.value;
                    }));
                }
            });
        };
    
        async.auto = function (tasks, callback) {
            callback = callback || noop;
            var keys = _keys(tasks);
            var remainingTasks = keys.length;
            if (!remainingTasks) {
                return callback();
            }
    
            var results = {};
    
            var listeners = [];
            var addListener = function (fn) {
                listeners.unshift(fn);
            };
            var removeListener = function (fn) {
                for (var i = 0; i < listeners.length; i += 1) {
                    if (listeners[i] === fn) {
                        listeners.splice(i, 1);
                        return;
                    }
                }
            };
            var taskComplete = function () {
                remainingTasks--;
                _each(listeners.slice(0), function (fn) {
                    fn();
                });
            };
    
            addListener(function () {
                if (!remainingTasks) {
                    var theCallback = callback;
                    // prevent final callback from calling itself if it errors
                    callback = noop;
    
                    theCallback(null, results);
                }
            });
    
            _each(keys, function (k) {
                var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
                var taskCallback = function (err) {
                    var args = _baseSlice(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    if (err) {
                        var safeResults = {};
                        _each(_keys(results), function(rkey) {
                            safeResults[rkey] = results[rkey];
                        });
                        safeResults[k] = args;
                        callback(err, safeResults);
                        // stop subsequent errors hitting callback multiple times
                        callback = noop;
                    }
                    else {
                        results[k] = args;
                        async.setImmediate(taskComplete);
                    }
                };
                var requires = task.slice(0, Math.abs(task.length - 1)) || [];
                // prevent dead-locks
                var len = requires.length;
                var dep;
                while (len--) {
                    if (!(dep = tasks[requires[len]])) {
                        throw new Error('Has inexistant dependency');
                    }
                    if (_isArray(dep) && !!~dep.indexOf(k)) {
                        throw new Error('Has cyclic dependencies');
                    }
                }
                var ready = function () {
                    return _reduce(requires, function (a, x) {
                        return (a && results.hasOwnProperty(x));
                    }, true) && !results.hasOwnProperty(k);
                };
                if (ready()) {
                    task[task.length - 1](taskCallback, results);
                }
                else {
                    var listener = function () {
                        if (ready()) {
                            removeListener(listener);
                            task[task.length - 1](taskCallback, results);
                        }
                    };
                    addListener(listener);
                }
            });
        };
    
        async.retry = function(times, task, callback) {
            var DEFAULT_TIMES = 5;
            var attempts = [];
            // Use defaults if times not passed
            if (typeof times === 'function') {
                callback = task;
                task = times;
                times = DEFAULT_TIMES;
            }
            // Make sure times is a number
            times = parseInt(times, 10) || DEFAULT_TIMES;
            var wrappedTask = function(wrappedCallback, wrappedResults) {
                var retryAttempt = function(task, finalAttempt) {
                    return function(seriesCallback) {
                        task(function(err, result){
                            seriesCallback(!err || finalAttempt, {err: err, result: result});
                        }, wrappedResults);
                    };
                };
                while (times) {
                    attempts.push(retryAttempt(task, !(times-=1)));
                }
                async.series(attempts, function(done, data){
                    data = data[data.length - 1];
                    (wrappedCallback || callback)(data.err, data.result);
                });
            };
            // If a callback is passed, run this as a controll flow
            return callback ? wrappedTask() : wrappedTask;
        };
    
        async.waterfall = function (tasks, callback) {
            callback = callback || noop;
            if (!_isArray(tasks)) {
              var err = new Error('First argument to waterfall must be an array of functions');
              return callback(err);
            }
            if (!tasks.length) {
                return callback();
            }
            var wrapIterator = function (iterator) {
                return function (err) {
                    if (err) {
                        callback.apply(null, arguments);
                        callback = noop;
                    }
                    else {
                        var args = _baseSlice(arguments, 1);
                        var next = iterator.next();
                        if (next) {
                            args.push(wrapIterator(next));
                        }
                        else {
                            args.push(callback);
                        }
                        async.setImmediate(function () {
                            iterator.apply(null, args);
                        });
                    }
                };
            };
            wrapIterator(async.iterator(tasks))();
        };
    
        var _parallel = function(eachfn, tasks, callback) {
            callback = callback || noop;
            if (_isArray(tasks)) {
                eachfn.map(tasks, function (fn, callback) {
                    if (fn) {
                        fn(function (err) {
                            var args = _baseSlice(arguments, 1);
                            if (args.length <= 1) {
                                args = args[0];
                            }
                            callback.call(null, err, args);
                        });
                    }
                }, callback);
            }
            else {
                var results = {};
                eachfn.each(_keys(tasks), function (k, callback) {
                    tasks[k](function (err) {
                        var args = _baseSlice(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        results[k] = args;
                        callback(err);
                    });
                }, function (err) {
                    callback(err, results);
                });
            }
        };
    
        async.parallel = function (tasks, callback) {
            _parallel({ map: async.map, each: async.each }, tasks, callback);
        };
    
        async.parallelLimit = function(tasks, limit, callback) {
            _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
        };
    
        async.series = function (tasks, callback) {
            callback = callback || noop;
            if (_isArray(tasks)) {
                async.mapSeries(tasks, function (fn, callback) {
                    if (fn) {
                        fn(function (err) {
                            var args = _baseSlice(arguments, 1);
                            if (args.length <= 1) {
                                args = args[0];
                            }
                            callback.call(null, err, args);
                        });
                    }
                }, callback);
            }
            else {
                var results = {};
                async.eachSeries(_keys(tasks), function (k, callback) {
                    tasks[k](function (err) {
                        var args = _baseSlice(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        results[k] = args;
                        callback(err);
                    });
                }, function (err) {
                    callback(err, results);
                });
            }
        };
    
        async.iterator = function (tasks) {
            var makeCallback = function (index) {
                var fn = function () {
                    if (tasks.length) {
                        tasks[index].apply(null, arguments);
                    }
                    return fn.next();
                };
                fn.next = function () {
                    return (index < tasks.length - 1) ? makeCallback(index + 1): null;
                };
                return fn;
            };
            return makeCallback(0);
        };
    
        async.apply = function (fn) {
            var args = _baseSlice(arguments, 1);
            return function () {
                return fn.apply(
                    null, args.concat(_baseSlice(arguments))
                );
            };
        };
    
        var _concat = function (eachfn, arr, fn, callback) {
            var r = [];
            eachfn(arr, function (x, cb) {
                fn(x, function (err, y) {
                    r = r.concat(y || []);
                    cb(err);
                });
            }, function (err) {
                callback(err, r);
            });
        };
        async.concat = doParallel(_concat);
        async.concatSeries = doSeries(_concat);
    
        async.whilst = function (test, iterator, callback) {
            if (test()) {
                iterator(function (err) {
                    if (err) {
                        return callback(err);
                    }
                    async.whilst(test, iterator, callback);
                });
            }
            else {
                callback();
            }
        };
    
        async.doWhilst = function (iterator, test, callback) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                var args = _baseSlice(arguments, 1);
                if (test.apply(null, args)) {
                    async.doWhilst(iterator, test, callback);
                }
                else {
                    callback();
                }
            });
        };
    
        async.until = function (test, iterator, callback) {
            if (!test()) {
                iterator(function (err) {
                    if (err) {
                        return callback(err);
                    }
                    async.until(test, iterator, callback);
                });
            }
            else {
                callback();
            }
        };
    
        async.doUntil = function (iterator, test, callback) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                var args = _baseSlice(arguments, 1);
                if (!test.apply(null, args)) {
                    async.doUntil(iterator, test, callback);
                }
                else {
                    callback();
                }
            });
        };
    
        async.queue = function (worker, concurrency) {
            if (concurrency === undefined) {
                concurrency = 1;
            }
            else if(concurrency === 0) {
                throw new Error('Concurrency must not be zero');
            }
            function _insert(q, data, pos, callback) {
              if (!q.started){
                q.started = true;
              }
              if (!_isArray(data)) {
                  data = [data];
              }
              if(data.length === 0) {
                 // call drain immediately if there are no tasks
                 return async.setImmediate(function() {
                     if (q.drain) {
                         q.drain();
                     }
                 });
              }
              _each(data, function(task) {
                  var item = {
                      data: task,
                      callback: typeof callback === 'function' ? callback : null
                  };
    
                  if (pos) {
                    q.tasks.unshift(item);
                  } else {
                    q.tasks.push(item);
                  }
    
                  if (q.saturated && q.tasks.length === q.concurrency) {
                      q.saturated();
                  }
                  async.setImmediate(q.process);
              });
            }
    
            var workers = 0;
            var q = {
                tasks: [],
                concurrency: concurrency,
                saturated: null,
                empty: null,
                drain: null,
                started: false,
                paused: false,
                push: function (data, callback) {
                  _insert(q, data, false, callback);
                },
                kill: function () {
                  q.drain = null;
                  q.tasks = [];
                },
                unshift: function (data, callback) {
                  _insert(q, data, true, callback);
                },
                process: function () {
                    if (!q.paused && workers < q.concurrency && q.tasks.length) {
                        var task = q.tasks.shift();
                        if (q.empty && q.tasks.length === 0) {
                            q.empty();
                        }
                        workers += 1;
                        var next = function () {
                            workers -= 1;
                            if (task.callback) {
                                task.callback.apply(task, arguments);
                            }
                            if (q.drain && q.tasks.length + workers === 0) {
                                q.drain();
                            }
                            q.process();
                        };
                        var cb = only_once(next);
                        worker(task.data, cb);
                    }
                },
                length: function () {
                    return q.tasks.length;
                },
                running: function () {
                    return workers;
                },
                idle: function() {
                    return q.tasks.length + workers === 0;
                },
                pause: function () {
                    if (q.paused === true) { return; }
                    q.paused = true;
                },
                resume: function () {
                    if (q.paused === false) { return; }
                    q.paused = false;
                    var resumeCount = Math.min(q.concurrency, q.tasks.length);
                    // Need to call q.process once per concurrent
                    // worker to preserve full concurrency after pause
                    for (var w = 1; w <= resumeCount; w++) {
                        async.setImmediate(q.process);
                    }
                }
            };
            return q;
        };
    
        async.priorityQueue = function (worker, concurrency) {
    
            function _compareTasks(a, b){
              return a.priority - b.priority;
            }
    
            function _binarySearch(sequence, item, compare) {
              var beg = -1,
                  end = sequence.length - 1;
              while (beg < end) {
                var mid = beg + ((end - beg + 1) >>> 1);
                if (compare(item, sequence[mid]) >= 0) {
                  beg = mid;
                } else {
                  end = mid - 1;
                }
              }
              return beg;
            }
    
            function _insert(q, data, priority, callback) {
              if (!q.started){
                q.started = true;
              }
              if (!_isArray(data)) {
                  data = [data];
              }
              if(data.length === 0) {
                 // call drain immediately if there are no tasks
                 return async.setImmediate(function() {
                     if (q.drain) {
                         q.drain();
                     }
                 });
              }
              _each(data, function(task) {
                  var item = {
                      data: task,
                      priority: priority,
                      callback: typeof callback === 'function' ? callback : null
                  };
    
                  q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);
    
                  if (q.saturated && q.tasks.length === q.concurrency) {
                      q.saturated();
                  }
                  async.setImmediate(q.process);
              });
            }
    
            // Start with a normal queue
            var q = async.queue(worker, concurrency);
    
            // Override push to accept second parameter representing priority
            q.push = function (data, priority, callback) {
              _insert(q, data, priority, callback);
            };
    
            // Remove unshift function
            delete q.unshift;
    
            return q;
        };
    
        async.cargo = function (worker, payload) {
            var working     = false,
                tasks       = [];
    
            var cargo = {
                tasks: tasks,
                payload: payload,
                saturated: null,
                empty: null,
                drain: null,
                drained: true,
                push: function (data, callback) {
                    if (!_isArray(data)) {
                        data = [data];
                    }
                    _each(data, function(task) {
                        tasks.push({
                            data: task,
                            callback: typeof callback === 'function' ? callback : null
                        });
                        cargo.drained = false;
                        if (cargo.saturated && tasks.length === payload) {
                            cargo.saturated();
                        }
                    });
                    async.setImmediate(cargo.process);
                },
                process: function process() {
                    if (working) return;
                    if (tasks.length === 0) {
                        if(cargo.drain && !cargo.drained) cargo.drain();
                        cargo.drained = true;
                        return;
                    }
    
                    var ts = typeof payload === 'number' ?
                        tasks.splice(0, payload) :
                        tasks.splice(0, tasks.length);
    
                    var ds = _map(ts, function (task) {
                        return task.data;
                    });
    
                    if(cargo.empty) cargo.empty();
                    working = true;
                    worker(ds, function () {
                        working = false;
    
                        var args = arguments;
                        _each(ts, function (data) {
                            if (data.callback) {
                                data.callback.apply(null, args);
                            }
                        });
    
                        process();
                    });
                },
                length: function () {
                    return tasks.length;
                },
                running: function () {
                    return working;
                }
            };
            return cargo;
        };
    
        var _console_fn = function (name) {
            return function (fn) {
                var args = _baseSlice(arguments, 1);
                fn.apply(null, args.concat([function (err) {
                    var args = _baseSlice(arguments, 1);
                    if (typeof console !== 'undefined') {
                        if (err) {
                            if (console.error) {
                                console.error(err);
                            }
                        }
                        else if (console[name]) {
                            _each(args, function (x) {
                                console[name](x);
                            });
                        }
                    }
                }]));
            };
        };
        async.log = _console_fn('log');
        async.dir = _console_fn('dir');
        /*async.info = _console_fn('info');
        async.warn = _console_fn('warn');
        async.error = _console_fn('error');*/
    
        async.memoize = function (fn, hasher) {
            var memo = {};
            var queues = {};
            hasher = hasher || function (x) {
                return x;
            };
            var memoized = function () {
                var args = _baseSlice(arguments);
                var callback = args.pop();
                var key = hasher.apply(null, args);
                if (key in memo) {
                    async.nextTick(function () {
                        callback.apply(null, memo[key]);
                    });
                }
                else if (key in queues) {
                    queues[key].push(callback);
                }
                else {
                    queues[key] = [callback];
                    fn.apply(null, args.concat([function () {
                        memo[key] = _baseSlice(arguments);
                        var q = queues[key];
                        delete queues[key];
                        for (var i = 0, l = q.length; i < l; i++) {
                          q[i].apply(null, arguments);
                        }
                    }]));
                }
            };
            memoized.memo = memo;
            memoized.unmemoized = fn;
            return memoized;
        };
    
        async.unmemoize = function (fn) {
          return function () {
            return (fn.unmemoized || fn).apply(null, arguments);
          };
        };
    
        async.times = function (count, iterator, callback) {
            var counter = [];
            for (var i = 0; i < count; i++) {
                counter.push(i);
            }
            return async.map(counter, iterator, callback);
        };
    
        async.timesSeries = function (count, iterator, callback) {
            var counter = [];
            for (var i = 0; i < count; i++) {
                counter.push(i);
            }
            return async.mapSeries(counter, iterator, callback);
        };
    
        async.seq = function (/* functions... */) {
            var fns = arguments;
            return function () {
                var that = this;
                var args = _baseSlice(arguments);
                var callback = args.pop();
                async.reduce(fns, args, function (newargs, fn, cb) {
                    fn.apply(that, newargs.concat([function () {
                        var err = arguments[0];
                        var nextargs = _baseSlice(arguments, 1);
                        cb(err, nextargs);
                    }]));
                },
                function (err, results) {
                    callback.apply(that, [err].concat(results));
                });
            };
        };
    
        async.compose = function (/* functions... */) {
          return async.seq.apply(null, Array.prototype.reverse.call(arguments));
        };
    
        var _applyEach = function (eachfn, fns /*args...*/) {
            var go = function () {
                var that = this;
                var args = _baseSlice(arguments);
                var callback = args.pop();
                return eachfn(fns, function (fn, cb) {
                    fn.apply(that, args.concat([cb]));
                },
                callback);
            };
            if (arguments.length > 2) {
                var args = _baseSlice(arguments, 2);
                return go.apply(this, args);
            }
            else {
                return go;
            }
        };
        async.applyEach = doParallel(_applyEach);
        async.applyEachSeries = doSeries(_applyEach);
    
        async.forever = function (fn, callback) {
            function next(err) {
                if (err) {
                    if (callback) {
                        return callback(err);
                    }
                    throw err;
                }
                fn(next);
            }
            next();
        };
    
        // Node.js
        if (typeof module !== 'undefined' && module.exports) {
            module.exports = async;
        }
        // AMD / RequireJS
        else if (typeof define !== 'undefined' && define.amd) {
            define([], function () {
                return async;
            });
        }
        // included directly via <script> tag
        else {
            root.async = async;
        }
    
    }());
    
  provide("async", module.exports);
}(global));

// pakmanager:uglify-to-browserify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    var fs = require('fs')
    var PassThrough = require('stream').PassThrough
    var Transform = require('stream').Transform
    
    if (typeof Transform === 'undefined') {
      throw new Error('UglifyJS only supports browserify when using node >= 0.10.x')
    }
    
    var cache = {}
    module.exports = transform
    function transform(file) {
      if (!/tools\/node\.js$/.test(file.replace(/\\/g,'/'))) return new PassThrough();
      if (cache[file]) return makeStream(cache[file])
      var uglify = require(file)
      var src = 'var sys = require("util");\nvar MOZ_SourceMap = require("source-map");\nvar UglifyJS = exports;\n' + uglify.FILES.map(function (path) { return fs.readFileSync(path, 'utf8') }).join('\n')
    
      var ast = uglify.parse(src)
      ast.figure_out_scope()
    
      var variables = ast.variables
        .map(function (node, name) {
          return name
        })
    
      src += '\n\n' + variables.map(function (v) { return 'exports.' + v + ' = ' + v + ';' }).join('\n') + '\n\n'
    
      src += 'exports.AST_Node.warn_function = function (txt) { if (typeof console != "undefined" && typeof console.warn === "function") console.warn(txt) }\n\n'
    
      src += 'exports.minify = ' + uglify.minify.toString() + ';\n\n'
      src += 'exports.describe_ast = ' + uglify.describe_ast.toString() + ';'
    
      // TODO: remove once https://github.com/substack/node-browserify/issues/631 is resolved
      src = src.replace(/"for"/g, '"fo" + "r"')
    
      cache[file] = src
      return makeStream(src);
    }
    
    function makeStream(src) {
      var res = new Transform();
      res._transform = function (chunk, encoding, callback) { callback() }
      res._flush = function (callback) {
        res.push(src)
        callback()
      }
      return res;
    }
    
  provide("uglify-to-browserify", module.exports);
}(global));

// pakmanager:yargs/lib/completion
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require('fs'),
      path = require('path')
    
    // add bash completions to your
    //  yargs-powered applications.
    module.exports = function (yargs, usage) {
      var self = {
        completionKey: 'get-yargs-completions'
      }
    
      // get a list of completion commands.
      self.getCompletion = function (done) {
        var completions = [],
        current = process.argv[process.argv.length - 1],
        previous = process.argv.slice(process.argv.indexOf('--' + self.completionKey) + 1),
        argv = yargs.parse(previous)
    
        // a custom completion function can be provided
        // to completion().
        if (completionFunction) {
          if (completionFunction.length < 3) {
            // synchronous completion function.
            return done(completionFunction(current, argv))
          } else {
            // asynchronous completion function
            return completionFunction(current, argv, function (completions) {
              done(completions)
            })
          }
        }
    
        if (!current.match(/^-/)) {
          usage.getCommands().forEach(function (command) {
            completions.push(command[0])
          })
        }
    
        if (current.match(/^-/)) {
          Object.keys(yargs.getOptions().key).forEach(function (key) {
            completions.push('--' + key)
          })
        }
    
        done(completions)
      }
    
      // generate the completion script to add to your .bashrc.
      self.generateCompletionScript = function ($0) {
        var script = fs.readFileSync(
          path.resolve(__dirname, '../completion.sh.hbs'),
          'utf-8'
        ),
        name = path.basename($0)
    
        // add ./to applications not yet installed as bin.
        if ($0.match(/\.js$/)) $0 = './' + $0
    
        script = script.replace(/{{app_name}}/g, name)
        return script.replace(/{{app_path}}/g, $0)
      }
    
      // register a function to perform your own custom
      // completions., this function can be either
      // synchrnous or asynchronous.
      var completionFunction = null
      self.registerFunction = function (fn) {
        completionFunction = fn
      }
    
      return self
    }
    
  provide("yargs/lib/completion", module.exports);
}(global));

// pakmanager:yargs/lib/parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // fancy-pants parsing of argv, originally forked
    // from minimist: https://www.npmjs.com/package/minimist
    var camelCase = require('camelcase'),
      path = require('path')
    
    function increment (orig) {
      return orig !== undefined ? orig + 1 : 0
    }
    
    module.exports = function (args, opts) {
      if (!opts) opts = {}
      var flags = { arrays: {}, bools: {}, strings: {}, counts: {}, normalize: {}, configs: {} }
    
      ;[].concat(opts['array']).filter(Boolean).forEach(function (key) {
        flags.arrays[key] = true
      })
    
      ;[].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
        flags.bools[key] = true
      })
    
      ;[].concat(opts.string).filter(Boolean).forEach(function (key) {
        flags.strings[key] = true
      })
    
      ;[].concat(opts.count).filter(Boolean).forEach(function (key) {
        flags.counts[key] = true
      })
    
      ;[].concat(opts.normalize).filter(Boolean).forEach(function (key) {
        flags.normalize[key] = true
      })
    
      ;[].concat(opts.config).filter(Boolean).forEach(function (key) {
        flags.configs[key] = true
      })
    
      var aliases = {},
      newAliases = {}
    
      extendAliases(opts.key)
      extendAliases(opts.alias)
    
      var defaults = opts['default'] || {}
      Object.keys(defaults).forEach(function (key) {
        if (/-/.test(key) && !opts.alias[key]) {
          aliases[key] = aliases[key] || []
        }
        (aliases[key] || []).forEach(function (alias) {
          defaults[alias] = defaults[key]
        })
      })
    
      var argv = { _: [] }
    
      Object.keys(flags.bools).forEach(function (key) {
        setArg(key, !(key in defaults) ? false : defaults[key])
      })
    
      var notFlags = []
      if (args.indexOf('--') !== -1) {
        notFlags = args.slice(args.indexOf('--') + 1)
        args = args.slice(0, args.indexOf('--'))
      }
    
      for (var i = 0; i < args.length; i++) {
        var arg = args[i],
          broken,
          key,
          letters,
          m,
          next
    
        // -- seperated by =
        if (arg.match(/^--.+=/)) {
          // Using [\s\S] instead of . because js doesn't support the
          // 'dotall' regex modifier. See:
          // http://stackoverflow.com/a/1068308/13216
          m = arg.match(/^--([^=]+)=([\s\S]*)$/)
          setArg(m[1], m[2])
        } else if (arg.match(/^--no-.+/)) {
          key = arg.match(/^--no-(.+)/)[1]
          setArg(key, false)
    
        // -- seperated by space.
        } else if (arg.match(/^--.+/)) {
          key = arg.match(/^--(.+)/)[1]
    
          if (checkAllAliases(key, opts.narg)) {
            i = eatNargs(i, key, args)
          } else {
            next = args[i + 1]
    
            if (next !== undefined && !next.match(/^-/)
            && !checkAllAliases(key, flags.bools)
            && !checkAllAliases(key, flags.counts)) {
              setArg(key, next)
              i++
            } else if (/^(true|false)$/.test(next)) {
              setArg(key, next)
              i++
            } else {
              setArg(key, defaultForType(guessType(key, flags)))
            }
          }
    
        // dot-notation flag seperated by '='.
        } else if (arg.match(/^-.\..+=/)) {
          m = arg.match(/^-([^=]+)=([\s\S]*)$/)
          setArg(m[1], m[2])
    
        // dot-notation flag seperated by space.
        } else if (arg.match(/^-.\..+/)) {
          next = args[i + 1]
          key = arg.match(/^-(.\..+)/)[1]
    
          if (next !== undefined && !next.match(/^-/)
            && !checkAllAliases(key, flags.bools)
            && !checkAllAliases(key, flags.counts)) {
            setArg(key, next)
            i++
          } else {
            setArg(key, defaultForType(guessType(key, flags)))
          }
        } else if (arg.match(/^-[^-]+/)) {
          letters = arg.slice(1, -1).split('')
          broken = false
    
          for (var j = 0; j < letters.length; j++) {
            next = arg.slice(j + 2)
    
            if (letters[j + 1] && letters[j + 1] === '=') {
              setArg(letters[j], arg.slice(j + 3))
              broken = true
              break
            }
    
            if (next === '-') {
              setArg(letters[j], next)
              continue
            }
    
            if (/[A-Za-z]/.test(letters[j])
            && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
              setArg(letters[j], next)
              broken = true
              break
            }
    
            if (letters[j + 1] && letters[j + 1].match(/\W/)) {
              setArg(letters[j], arg.slice(j + 2))
              broken = true
              break
            } else {
              setArg(letters[j], defaultForType(guessType(letters[j], flags)))
            }
          }
    
          key = arg.slice(-1)[0]
    
          if (!broken && key !== '-') {
            if (checkAllAliases(key, opts.narg)) {
              i = eatNargs(i, key, args)
            } else {
              if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1])
              && !checkAllAliases(key, flags.bools)
              && !checkAllAliases(key, flags.counts)) {
                setArg(key, args[i + 1])
                i++
              } else if (args[i + 1] && /true|false/.test(args[i + 1])) {
                setArg(key, args[i + 1])
                i++
              } else {
                setArg(key, defaultForType(guessType(key, flags)))
              }
            }
          }
        } else {
          argv._.push(
            flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
          )
        }
      }
    
      setConfig(argv)
      applyDefaultsAndAliases(argv, aliases, defaults)
    
      Object.keys(flags.counts).forEach(function (key) {
        setArg(key, defaults[key])
      })
    
      notFlags.forEach(function (key) {
        argv._.push(key)
      })
    
      // how many arguments should we consume, based
      // on the nargs option?
      function eatNargs (i, key, args) {
        var toEat = checkAllAliases(key, opts.narg)
    
        if (args.length - (i + 1) < toEat) throw Error('not enough arguments following: ' + key)
    
        for (var ii = i + 1; ii < (toEat + i + 1); ii++) {
          setArg(key, args[ii])
        }
    
        return (i + toEat)
      }
    
      function setArg (key, val) {
        // handle parsing boolean arguments --foo=true --bar false.
        if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
          if (typeof val === 'string') val = val === 'true'
        }
    
        if (/-/.test(key) && !(aliases[key] && aliases[key].length)) {
          var c = camelCase(key)
          aliases[key] = [c]
          newAliases[c] = true
        }
    
        var value = !checkAllAliases(key, flags.strings) && isNumber(val) ? Number(val) : val
    
        if (checkAllAliases(key, flags.counts)) {
          value = increment
        }
    
        var splitKey = key.split('.')
        setKey(argv, splitKey, value)
    
        ;(aliases[splitKey[0]] || []).forEach(function (x) {
          x = x.split('.')
    
          // handle populating dot notation for both
          // the key and its aliases.
          if (splitKey.length > 1) {
            var a = [].concat(splitKey)
            a.shift() // nuke the old key.
            x = x.concat(a)
          }
    
          setKey(argv, x, value)
        })
    
        var keys = [key].concat(aliases[key] || [])
        for (var i = 0, l = keys.length; i < l; i++) {
          if (flags.normalize[keys[i]]) {
            keys.forEach(function (key) {
              argv.__defineSetter__(key, function (v) {
                val = path.normalize(v)
              })
    
              argv.__defineGetter__(key, function () {
                return typeof val === 'string' ?
                path.normalize(val) : val
              })
            })
            break
          }
        }
      }
    
      // set args from config.json file, this should be
      // applied last so that defaults can be applied.
      function setConfig (argv) {
        var configLookup = {}
    
        // expand defaults/aliases, in-case any happen to reference
        // the config.json file.
        applyDefaultsAndAliases(configLookup, aliases, defaults)
    
        Object.keys(flags.configs).forEach(function (configKey) {
          var configPath = argv[configKey] || configLookup[configKey]
          if (configPath) {
            try {
              var config = require(path.resolve(process.cwd(), configPath))
    
              Object.keys(config).forEach(function (key) {
                // setting arguments via CLI takes precedence over
                // values within the config file.
                if (argv[key] === undefined) {
                  delete argv[key]
                  setArg(key, config[key])
                }
              })
            } catch (ex) {
              throw Error('invalid json config file: ' + configPath)
            }
          }
        })
      }
    
      function applyDefaultsAndAliases (obj, aliases, defaults) {
        Object.keys(defaults).forEach(function (key) {
          if (!hasKey(obj, key.split('.'))) {
            setKey(obj, key.split('.'), defaults[key])
    
            ;(aliases[key] || []).forEach(function (x) {
              setKey(obj, x.split('.'), defaults[key])
            })
          }
        })
      }
    
      function hasKey (obj, keys) {
        var o = obj
        keys.slice(0, -1).forEach(function (key) {
          o = (o[key] || {})
        })
    
        var key = keys[keys.length - 1]
        return key in o
      }
    
      function setKey (obj, keys, value) {
        var o = obj
        keys.slice(0, -1).forEach(function (key) {
          if (o[key] === undefined) o[key] = {}
          o = o[key]
        })
    
        var key = keys[keys.length - 1]
        if (value === increment) {
          o[key] = increment(o[key])
        } else if (o[key] === undefined && checkAllAliases(key, flags.arrays)) {
          o[key] = Array.isArray(value) ? value : [value]
        } else if (o[key] === undefined || typeof o[key] === 'boolean') {
          o[key] = value
        } else if (Array.isArray(o[key])) {
          o[key].push(value)
        } else {
          o[key] = [ o[key], value ]
        }
      }
    
      // extend the aliases list with inferred aliases.
      function extendAliases (obj) {
        Object.keys(obj || {}).forEach(function (key) {
          aliases[key] = [].concat(opts.alias[key] || [])
          // For "--option-name", also set argv.optionName
          aliases[key].concat(key).forEach(function (x) {
            if (/-/.test(x)) {
              var c = camelCase(x)
              aliases[key].push(c)
              newAliases[c] = true
            }
          })
          aliases[key].forEach(function (x) {
            aliases[x] = [key].concat(aliases[key].filter(function (y) {
              return x !== y
            }))
          })
        })
      }
    
      // check if a flag is set for any of a key's aliases.
      function checkAllAliases (key, flag) {
        var isSet = false,
        toCheck = [].concat(aliases[key] || [], key)
    
        toCheck.forEach(function (key) {
          if (flag[key]) isSet = flag[key]
        })
    
        return isSet
      }
    
      // return a default value, given the type of a flag.,
      // e.g., key of type 'string' will default to '', rather than 'true'.
      function defaultForType (type) {
        var def = {
          boolean: true,
          string: '',
          array: []
        }
    
        return def[type]
      }
    
      // given a flag, enforce a default type.
      function guessType (key, flags) {
        var type = 'boolean'
    
        if (flags.strings && flags.strings[key]) type = 'string'
        else if (flags.arrays && flags.arrays[key]) type = 'array'
    
        return type
      }
    
      function isNumber (x) {
        if (typeof x === 'number') return true
        if (/^0x[0-9a-f]+$/i.test(x)) return true
        return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x)
      }
    
      return {
        argv: argv,
        aliases: aliases,
        newAliases: newAliases
      }
    }
    
  provide("yargs/lib/parser", module.exports);
}(global));

// pakmanager:yargs/lib/usage
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // this file handles outputting usage instructions,
    // failures, etc. keeps logging in one place.
    var cliui = require('cliui'),
      decamelize = require('decamelize'),
      wsize = require('window-size')
    
    module.exports = function (yargs) {
      var self = {}
    
      // methods for ouputting/building failure message.
      var fails = []
      self.failFn = function (f) {
        fails.push(f)
      }
    
      var failMessage = null
      var showHelpOnFail = true
      self.showHelpOnFail = function (enabled, message) {
        if (typeof enabled === 'string') {
          message = enabled
          enabled = true
        } else if (typeof enabled === 'undefined') {
          enabled = true
        }
        failMessage = message
        showHelpOnFail = enabled
        return self
      }
    
      self.fail = function (msg) {
        if (fails.length) {
          fails.forEach(function (f) {
            f(msg)
          })
        } else {
          if (showHelpOnFail) yargs.showHelp('error')
          if (msg) console.error(msg)
          if (failMessage) {
            if (msg) console.error('')
            console.error(failMessage)
          }
          if (yargs.getExitProcess()) {
            process.exit(1)
          } else {
            throw new Error(msg)
          }
        }
      }
    
      // methods for ouputting/building help (usage) message.
      var usage
      self.usage = function (msg) {
        usage = msg
      }
    
      var examples = []
      self.example = function (cmd, description) {
        examples.push([cmd, description || ''])
      }
    
      var commands = []
      self.command = function (cmd, description) {
        commands.push([cmd, description || ''])
      }
      self.getCommands = function () {
        return commands
      }
    
      var descriptions = {}
      self.describe = function (key, desc) {
        if (typeof key === 'object') {
          Object.keys(key).forEach(function (k) {
            self.describe(k, key[k])
          })
        } else {
          descriptions[key] = desc
        }
      }
      self.getDescriptions = function () {
        return descriptions
      }
    
      var epilog
      self.epilog = function (msg) {
        epilog = msg
      }
    
      var wrap = windowWidth()
      self.wrap = function (cols) {
        wrap = cols
      }
    
      self.help = function () {
        normalizeAliases()
    
        var demanded = yargs.getDemanded(),
          options = yargs.getOptions(),
          keys = Object.keys(
            Object.keys(descriptions)
            .concat(Object.keys(demanded))
            .concat(Object.keys(options.default))
            .reduce(function (acc, key) {
              if (key !== '_') acc[key] = true
              return acc
            }, {})
          ),
          ui = cliui({
            width: wrap,
            wrap: !!wrap
          })
    
        // the usage string.
        if (usage) {
          var u = usage.replace(/\$0/g, yargs.$0)
          ui.div(u + '\n')
        }
    
        // your application's commands, i.e., non-option
        // arguments populated in '_'.
        if (commands.length) {
          ui.div('Commands:')
    
          commands.forEach(function (command) {
            ui.div(
              {text: command[0], padding: [0, 2, 0, 2], width: maxWidth(commands) + 4},
              {text: command[1]}
            )
          })
    
          ui.div()
        }
    
        // the options table.
        var aliasKeys = (Object.keys(options.alias) || [])
          .concat(Object.keys(yargs.parsed.newAliases) || [])
    
        keys = keys.filter(function (key) {
          return !yargs.parsed.newAliases[key] && aliasKeys.every(function (alias) {
            return (options.alias[alias] || []).indexOf(key) === -1
          })
        })
    
        var switches = keys.reduce(function (acc, key) {
          acc[key] = [ key ].concat(options.alias[key] || [])
          .map(function (sw) {
            return (sw.length > 1 ? '--' : '-') + sw
          })
          .join(', ')
    
          return acc
        }, {})
    
        if (keys.length) {
          ui.div('Options:')
    
          keys.forEach(function (key) {
            var kswitch = switches[key]
            var desc = descriptions[key] || ''
            var type = null
    
            if (~options.boolean.indexOf(key)) type = '[boolean]'
            if (~options.count.indexOf(key)) type = '[count]'
            if (~options.string.indexOf(key)) type = '[string]'
            if (~options.normalize.indexOf(key)) type = '[string]'
            if (~options.array.indexOf(key)) type = '[array]'
    
            var extra = [
                type,
                demanded[key] ? '[required]' : null,
                defaultString(options.default[key], options.defaultDescription[key])
              ].filter(Boolean).join(' ')
    
            ui.span(
              {text: kswitch, padding: [0, 2, 0, 2], width: maxWidth(switches) + 4},
              desc
            )
    
            if (extra) ui.div({text: extra, padding: [0, 0, 0, 2], align: 'right'})
            else ui.div()
          })
    
          ui.div()
        }
    
        // describe some common use-cases for your application.
        if (examples.length) {
          ui.div('Examples:')
    
          examples.forEach(function (example) {
            example[0] = example[0].replace(/\$0/g, yargs.$0)
          })
    
          examples.forEach(function (example) {
            ui.div(
              {text: example[0], padding: [0, 2, 0, 2], width: maxWidth(examples) + 4},
              example[1]
            )
          })
    
          ui.div()
        }
    
        // the usage string.
        if (epilog) {
          var e = epilog.replace(/\$0/g, yargs.$0)
          ui.div(e + '\n')
        }
    
        return ui.toString()
      }
    
      // return the maximum width of a string
      // in the left-hand column of a table.
      function maxWidth (table) {
        var width = 0
    
        // table might be of the form [leftColumn],
        // or {key: leftColumn}}
        if (!Array.isArray(table)) {
          table = Object.keys(table).map(function (key) {
            return [table[key]]
          })
        }
    
        table.forEach(function (v) {
          width = Math.max(v[0].length, width)
        })
    
        // if we've enabled 'wrap' we should limit
        // the max-width of the left-column.
        if (wrap) width = Math.min(width, parseInt(wrap * 0.5, 10))
    
        return width
      }
    
      // make sure any options set for aliases,
      // are copied to the keys being aliased.
      function normalizeAliases () {
        var options = yargs.getOptions(),
        demanded = yargs.getDemanded()
    
        ;(Object.keys(options.alias) || []).forEach(function (key) {
          options.alias[key].forEach(function (alias) {
            // copy descriptions.
            if (descriptions[alias]) self.describe(key, descriptions[alias])
            // copy demanded.
            if (demanded[alias]) yargs.demand(key, demanded[alias].msg)
    
            // type messages.
            if (~options.boolean.indexOf(alias)) yargs.boolean(key)
            if (~options.count.indexOf(alias)) yargs.count(key)
            if (~options.string.indexOf(alias)) yargs.string(key)
            if (~options.normalize.indexOf(alias)) yargs.normalize(key)
            if (~options.array.indexOf(alias)) yargs.array(key)
          })
        })
      }
    
      self.showHelp = function (level) {
        level = level || 'error'
        console[level](self.help())
      }
    
      self.functionDescription = function (fn, defaultDescription) {
        if (defaultDescription) {
          return defaultDescription
        }
        var description = fn.name ? decamelize(fn.name, '-') : 'generated-value'
        return ['(', description, ')'].join('')
      }
    
      // format the default-value-string displayed in
      // the right-hand column.
      function defaultString (value, defaultDescription) {
        var string = '[default: '
    
        if (value === undefined) return null
    
        if (defaultDescription) {
          string += defaultDescription
        } else {
          switch (typeof value) {
            case 'string':
              string += JSON.stringify(value)
              break
            case 'object':
              string += JSON.stringify(value)
              break
            default:
              string += value
          }
        }
    
        return string + ']'
      }
    
      // guess the width of the console window, max-width 80.
      function windowWidth () {
        return wsize.width ? Math.min(80, wsize.width) : null
      }
    
      // logic for displaying application version.
      var version = null
      self.version = function (ver, opt, msg) {
        version = ver
      }
    
      self.showVersion = function () {
        if (typeof version === 'function') console.log(version())
        else console.log(version)
      }
    
      return self
    }
    
  provide("yargs/lib/usage", module.exports);
}(global));

// pakmanager:yargs/lib/validation
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // validation-type-stuff, missing params,
    // bad implications, custom checks.
    module.exports = function (yargs, usage) {
      var self = {}
    
      // validate appropriate # of non-option
      // arguments were provided, i.e., '_'.
      self.nonOptionCount = function (argv) {
        var demanded = yargs.getDemanded()
    
        if (demanded._ && argv._.length < demanded._.count) {
          if (demanded._.msg !== undefined) {
            usage.fail(demanded._.msg)
          } else {
            usage.fail('Not enough non-option arguments: got '
              + argv._.length + ', need at least ' + demanded._.count
            )
          }
        }
      }
    
      // make sure that any args that require an
      // value (--foo=bar), have a value.
      self.missingArgumentValue = function (argv) {
        var options = yargs.getOptions(),
          defaultValues = [true, false, '']
    
        if (options.requiresArg.length > 0) {
          var missingRequiredArgs = []
    
          options.requiresArg.forEach(function (key) {
            var value = argv[key]
    
            // if a value is explicitly requested,
            // flag argument as missing if it does not
            // look like foo=bar was entered.
            if (~defaultValues.indexOf(value)
            || (Array.isArray(value) && !value.length)) {
              missingRequiredArgs.push(key)
            }
          })
    
          if (missingRequiredArgs.length === 1) {
            usage.fail('Missing argument value: ' + missingRequiredArgs[0])
          } else if (missingRequiredArgs.length > 1) {
            var message = 'Missing argument values: ' + missingRequiredArgs.join(', ')
            usage.fail(message)
          }
        }
      }
    
      // make sure all the required arguments are present.
      self.requiredArguments = function (argv) {
        var demanded = yargs.getDemanded(),
          missing = null
    
        Object.keys(demanded).forEach(function (key) {
          if (!argv.hasOwnProperty(key)) {
            missing = missing || {}
            missing[key] = demanded[key]
          }
        })
    
        if (missing) {
          var customMsgs = []
          Object.keys(missing).forEach(function (key) {
            var msg = missing[key].msg
            if (msg && customMsgs.indexOf(msg) < 0) {
              customMsgs.push(msg)
            }
          })
    
          var customMsg = customMsgs.length ? '\n' + customMsgs.join('\n') : ''
          usage.fail('Missing required arguments: ' + Object.keys(missing).join(', ') + customMsg)
        }
      }
    
      // check for unknown arguments (strict-mode).
      self.unknownArguments = function (argv, aliases) {
        var descriptions = usage.getDescriptions(),
          demanded = yargs.getDemanded(),
          unknown = [],
          aliasLookup = {}
    
        Object.keys(aliases).forEach(function (key) {
          aliases[key].forEach(function (alias) {
            aliasLookup[alias] = key
          })
        })
    
        Object.keys(argv).forEach(function (key) {
          if (key !== '$0' && key !== '_' &&
            !descriptions.hasOwnProperty(key) &&
            !demanded.hasOwnProperty(key) &&
            !aliasLookup.hasOwnProperty(key)) {
            unknown.push(key)
          }
        })
    
        if (unknown.length === 1) {
          usage.fail('Unknown argument: ' + unknown[0])
        } else if (unknown.length > 1) {
          usage.fail('Unknown arguments: ' + unknown.join(', '))
        }
      }
    
      // custom checks, added using the `check` option on yargs.
      var checks = []
      self.check = function (f) {
        checks.push(f)
      }
    
      self.customChecks = function (argv, aliases) {
        checks.forEach(function (f) {
          try {
            var result = f(argv, aliases)
            if (!result) {
              usage.fail('Argument check failed: ' + f.toString())
            } else if (typeof result === 'string') {
              usage.fail(result)
            }
          } catch (err) {
            usage.fail(err.message ? err.message : err)
          }
        })
      }
    
      // check implications, argument foo implies => argument bar.
      var implied = {}
      self.implies = function (key, value) {
        if (typeof key === 'object') {
          Object.keys(key).forEach(function (k) {
            self.implies(k, key[k])
          })
        } else {
          implied[key] = value
        }
      }
      self.getImplied = function () {
        return implied
      }
    
      self.implications = function (argv) {
        var implyFail = []
    
        Object.keys(implied).forEach(function (key) {
          var num,
            origKey = key,
            value = implied[key]
    
          // convert string '1' to number 1
          num = Number(key)
          key = isNaN(num) ? key : num
    
          if (typeof key === 'number') {
            // check length of argv._
            key = argv._.length >= key
          } else if (key.match(/^--no-.+/)) {
            // check if key doesn't exist
            key = key.match(/^--no-(.+)/)[1]
            key = !argv[key]
          } else {
            // check if key exists
            key = argv[key]
          }
    
          num = Number(value)
          value = isNaN(num) ? value : num
    
          if (typeof value === 'number') {
            value = argv._.length >= value
          } else if (value.match(/^--no-.+/)) {
            value = value.match(/^--no-(.+)/)[1]
            value = !argv[value]
          } else {
            value = argv[value]
          }
    
          if (key && !value) {
            implyFail.push(origKey)
          }
        })
    
        if (implyFail.length) {
          var msg = 'Implications failed:\n'
    
          implyFail.forEach(function (key) {
            msg += ('  ' + key + ' -> ' + implied[key])
          })
    
          usage.fail(msg)
        }
      }
    
      return self
    }
    
  provide("yargs/lib/validation", module.exports);
}(global));

// pakmanager:yargs
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var assert = require('assert'),
      path = require('path'),
      Completion =  require('yargs/lib/completion'),
      Parser =  require('yargs/lib/parser'),
      Usage =  require('yargs/lib/usage'),
      Validation =  require('yargs/lib/validation')
    
    Argv(process.argv.slice(2))
    
    var exports = module.exports = Argv
    function Argv (processArgs, cwd) {
      processArgs = processArgs || [] // handle calling yargs().
    
      var self = {}
      var completion = null
      var usage = null
      var validation = null
    
      if (!cwd) cwd = process.cwd()
    
      self.$0 = process.argv
        .slice(0, 2)
        .map(function (x, i) {
          // ignore the node bin, specify this in your
          // bin file with #!/usr/bin/env node
          if (i === 0 && /\b(node|iojs)$/.test(x)) return
          var b = rebase(cwd, x)
          return x.match(/^\//) && b.length < x.length
          ? b : x
        })
        .join(' ').trim()
    
      if (process.env._ !== undefined && process.argv[1] === process.env._) {
        self.$0 = process.env._.replace(
          path.dirname(process.execPath) + '/', ''
        )
      }
    
      var options
      self.resetOptions = self.reset = function () {
        // put yargs back into its initial
        // state, this is useful for creating a
        // nested CLI.
        options = {
          array: [],
          boolean: [],
          string: [],
          narg: {},
          key: {},
          alias: {},
          default: {},
          defaultDescription: {},
          requiresArg: [],
          count: [],
          normalize: [],
          config: []
        }
    
        usage = Usage(self) // handle usage output.
        validation = Validation(self, usage) // handle arg validation.
        completion = Completion(self, usage)
    
        demanded = {}
    
        exitProcess = true
        strict = false
        helpOpt = null
        versionOpt = null
        completionOpt = null
        commandHandlers = {}
        self.parsed = false
    
        return self
      }
      self.resetOptions()
    
      self.boolean = function (bools) {
        options.boolean.push.apply(options.boolean, [].concat(bools))
        return self
      }
    
      self.array = function (arrays) {
        options.array.push.apply(options.array, [].concat(arrays))
        return self
      }
    
      self.nargs = function (key, n) {
        if (typeof key === 'object') {
          Object.keys(key).forEach(function (k) {
            self.nargs(k, key[k])
          })
        } else {
          options.narg[key] = n
        }
        return self
      }
    
      self.normalize = function (strings) {
        options.normalize.push.apply(options.normalize, [].concat(strings))
        return self
      }
    
      self.config = function (configs) {
        options.config.push.apply(options.config, [].concat(configs))
        return self
      }
    
      self.example = function (cmd, description) {
        usage.example(cmd, description)
        return self
      }
    
      self.command = function (cmd, description, fn) {
        usage.command(cmd, description)
        if (fn) commandHandlers[cmd] = fn
        return self
      }
    
      var commandHandlers = {}
      self.getCommandHandlers = function () {
        return commandHandlers
      }
    
      self.string = function (strings) {
        options.string.push.apply(options.string, [].concat(strings))
        return self
      }
    
      self.default = function (key, value, defaultDescription) {
        if (typeof key === 'object') {
          Object.keys(key).forEach(function (k) {
            self.default(k, key[k])
          })
        } else {
          if (typeof value === 'function') {
            defaultDescription = usage.functionDescription(value, defaultDescription)
            value = value.call()
          }
          options.defaultDescription[key] = defaultDescription
          options.default[key] = value
        }
        return self
      }
    
      self.alias = function (x, y) {
        if (typeof x === 'object') {
          Object.keys(x).forEach(function (key) {
            self.alias(key, x[key])
          })
        } else {
          options.alias[x] = (options.alias[x] || []).concat(y)
        }
        return self
      }
    
      self.count = function (counts) {
        options.count.push.apply(options.count, [].concat(counts))
        return self
      }
    
      var demanded = {}
      self.demand = self.required = self.require = function (keys, msg) {
        if (typeof keys === 'number') {
          if (!demanded._) demanded._ = { count: 0, msg: null }
          demanded._.count += keys
          demanded._.msg = msg
        } else if (Array.isArray(keys)) {
          keys.forEach(function (key) {
            self.demand(key, msg)
          })
        } else {
          if (typeof msg === 'string') {
            demanded[keys] = { msg: msg }
          } else if (msg === true || typeof msg === 'undefined') {
            demanded[keys] = { msg: undefined }
          }
        }
    
        return self
      }
      self.getDemanded = function () {
        return demanded
      }
    
      self.requiresArg = function (requiresArgs) {
        options.requiresArg.push.apply(options.requiresArg, [].concat(requiresArgs))
        return self
      }
    
      self.implies = function (key, value) {
        validation.implies(key, value)
        return self
      }
    
      self.usage = function (msg, opts) {
        if (!opts && typeof msg === 'object') {
          opts = msg
          msg = null
        }
    
        usage.usage(msg)
    
        if (opts) self.options(opts)
    
        return self
      }
    
      self.epilogue = self.epilog = function (msg) {
        usage.epilog(msg)
        return self
      }
    
      self.fail = function (f) {
        usage.failFn(f)
        return self
      }
    
      self.check = function (f) {
        validation.check(f)
        return self
      }
    
      self.defaults = self.default
    
      self.describe = function (key, desc) {
        options.key[key] = true
        usage.describe(key, desc)
        return self
      }
    
      self.parse = function (args) {
        return parseArgs(args)
      }
    
      self.option = self.options = function (key, opt) {
        if (typeof key === 'object') {
          Object.keys(key).forEach(function (k) {
            self.options(k, key[k])
          })
        } else {
          assert(typeof opt === 'object', 'second argument to option must be an object')
    
          options.key[key] = true // track manually set keys.
    
          if (opt.alias) self.alias(key, opt.alias)
    
          var demand = opt.demand || opt.required || opt.require
    
          if (demand) {
            self.demand(key, demand)
          } if ('default' in opt) {
            self.default(key, opt.default)
          } if ('nargs' in opt) {
            self.nargs(key, opt.nargs)
          } if (opt.boolean || opt.type === 'boolean') {
            self.boolean(key)
            if (opt.alias) self.boolean(opt.alias)
          } if (opt.array || opt.type === 'array') {
            self.array(key)
            if (opt.alias) self.array(opt.alias)
          } if (opt.string || opt.type === 'string') {
            self.string(key)
            if (opt.alias) self.string(opt.alias)
          } if (opt.count || opt.type === 'count') {
            self.count(key)
          }
    
          var desc = opt.describe || opt.description || opt.desc
          if (desc) {
            self.describe(key, desc)
          }
    
          if (opt.requiresArg) {
            self.requiresArg(key)
          }
        }
    
        return self
      }
      self.getOptions = function () {
        return options
      }
    
      self.wrap = function (cols) {
        usage.wrap(cols)
        return self
      }
    
      var strict = false
      self.strict = function () {
        strict = true
        return self
      }
      self.getStrict = function () {
        return strict
      }
    
      self.showHelp = function (level) {
        if (!self.parsed) parseArgs(processArgs) // run parser, if it has not already been executed.
        usage.showHelp(level)
        return self
      }
    
      var versionOpt = null
      self.version = function (ver, opt, msg) {
        versionOpt = opt || 'version'
        usage.version(ver)
        self.boolean(versionOpt)
        self.describe(versionOpt, msg || 'Show version number')
        return self
      }
    
      var helpOpt = null
      self.addHelpOpt = function (opt, msg) {
        helpOpt = opt
        self.boolean(opt)
        self.describe(opt, msg || 'Show help')
        return self
      }
    
      self.showHelpOnFail = function (enabled, message) {
        usage.showHelpOnFail(enabled, message)
        return self
      }
    
      var exitProcess = true
      self.exitProcess = function (enabled) {
        if (typeof enabled !== 'boolean') {
          enabled = true
        }
        exitProcess = enabled
        return self
      }
      self.getExitProcess = function () {
        return exitProcess
      }
    
      self.help = function () {
        if (arguments.length > 0) return self.addHelpOpt.apply(self, arguments)
    
        if (!self.parsed) parseArgs(processArgs) // run parser, if it has not already been executed.
    
        return usage.help()
      }
    
      var completionOpt = null,
      completionCommand = null
      self.completion = function (cmd, desc, fn) {
        // a function to execute when generating
        // completions can be provided as the second
        // or third argument to completion.
        if (typeof desc === 'function') {
          fn = desc
          desc = null
        }
    
        // register the completion command.
        completionCommand = cmd
        completionOpt = completion.completionKey
        self.command(completionCommand, desc || 'generate bash completion script')
    
        // a function can be provided
        if (fn) completion.registerFunction(fn)
    
        return self
      }
    
      self.showCompletionScript = function ($0) {
        $0 = $0 || self.$0
        console.log(completion.generateCompletionScript($0))
        return self
      }
    
      self.getUsageInstance = function () {
        return usage
      }
    
      self.getValidationInstance = function () {
        return validation
      }
    
      Object.defineProperty(self, 'argv', {
        get: function () {
          var args = null
    
          try {
            args = parseArgs(processArgs)
          } catch (err) {
            usage.fail(err.message)
          }
    
          return args
        },
        enumerable: true
      })
    
      function parseArgs (args) {
        var parsed = Parser(args, options),
          argv = parsed.argv,
          aliases = parsed.aliases
    
        argv.$0 = self.$0
    
        self.parsed = parsed
    
        // generate a completion script for adding to ~/.bashrc.
        if (completionCommand && ~argv._.indexOf(completionCommand)) {
          self.showCompletionScript()
          if (exitProcess) {
            process.exit(0)
          }
        }
    
        // if there's a handler associated with a
        // command defer processing to it.
        var handlerKeys = Object.keys(self.getCommandHandlers())
        for (var i = 0, command; (command = handlerKeys[i]) !== undefined; i++) {
          if (~argv._.indexOf(command)) {
            self.getCommandHandlers()[command](self.reset())
            return self.argv
          }
        }
    
        Object.keys(argv).forEach(function (key) {
          if (key === helpOpt && argv[key]) {
            self.showHelp('log')
            if (exitProcess) {
              process.exit(0)
            }
          } else if (key === versionOpt && argv[key]) {
            usage.showVersion()
            if (exitProcess) {
              process.exit(0)
            }
          } else if (key === completionOpt) {
            // we allow for asynchronous completions,
            // e.g., loading in a list of commands from an API.
            completion.getCompletion(function (completions) {
              ;(completions || []).forEach(function (completion) {
                console.log(completion)
              })
    
              if (exitProcess) {
                process.exit(0)
              }
            })
            return
          }
        })
    
        validation.nonOptionCount(argv)
        validation.missingArgumentValue(argv)
        validation.requiredArguments(argv)
    
        if (strict) {
          validation.unknownArguments(argv, aliases)
        }
    
        validation.customChecks(argv, aliases)
        validation.implications(argv)
        setPlaceholderKeys(argv)
    
        return argv
      }
    
      function setPlaceholderKeys (argv) {
        Object.keys(options.key).forEach(function (key) {
          if (typeof argv[key] === 'undefined') argv[key] = undefined
        })
      }
    
      sigletonify(self)
      return self
    }
    
    // rebase an absolute path to a relative one with respect to a base directory
    // exported for tests
    exports.rebase = rebase
    function rebase (base, dir) {
      return path.relative(base, dir)
    }
    
    /*  Hack an instance of Argv with process.argv into Argv
        so people can do
         require('yargs')(['--beeble=1','-z','zizzle']).argv
        to parse a list of args and
         require('yargs').argv
        to get a parsed version of process.argv.
    */
    function sigletonify (inst) {
      Object.keys(inst).forEach(function (key) {
        if (key === 'argv') {
          Argv.__defineGetter__(key, inst.__lookupGetter__(key))
        } else {
          Argv[key] = typeof inst[key] === 'function'
          ? inst[key].bind(inst)
          : inst[key]
        }
      })
    }
    
  provide("yargs", module.exports);
}(global));

// pakmanager:arr-diff
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * arr-diff <https://github.com/jonschlinkert/arr-diff>
     *
     * Copyright (c) 2014 Jon Schlinkert, contributors.
     * Licensed under the MIT License
     */
    
    'use strict';
    
    var slice = require('array-slice');
    
    /**
     * Expose `diff`
     */
    
    module.exports = diff;
    
    /**
     * Return the difference between the first array and
     * additional arrays.
     *
     * ```js
     * var diff = require('{%= name %}');
     *
     * var a = ['a', 'b', 'c', 'd'];
     * var b = ['b', 'c'];
     *
     * console.log(diff(a, b))
     * //=> ['a', 'd']
     * ```
     *
     * @param  {Array} `a`
     * @param  {Array} `b`
     * @return {Array}
     * @api public
     */
    
    function diff(a, b, c) {
      var len = a.length;
      var arr = [];
      var rest;
    
      if (!b) {
        return a;
      }
    
      if (!c) {
        rest = b;
      } else {
        rest = [].concat.apply([], slice(arguments, 1));
      }
    
      while (len--) {
        if (rest.indexOf(a[len]) === -1) {
          arr.unshift(a[len]);
        }
      }
      return arr;
    }
    
  provide("arr-diff", module.exports);
}(global));

// pakmanager:braces
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * braces <https://github.com/jonschlinkert/braces>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT license.
     */
    
    'use strict';
    
    /**
     * Module dependencies
     */
    
    var expand = require('expand-range');
    var repeat = require('repeat-element');
    var tokens = require('preserve');
    var cache = {};
    
    /**
     * Expose `braces`
     */
    
    module.exports = function (str, options) {
      if (typeof str !== 'string') {
        throw new Error('braces expects a string');
      }
      return braces(str, options);
    };
    
    /**
     * Expand `{foo,bar}` or `{1..5}` braces in the
     * given `string`.
     *
     * @param  {String} `str`
     * @param  {Array} `arr`
     * @param  {Object} `options`
     * @return {Array}
     */
    
    function braces(str, arr, options) {
      if (str === '') {
        return [];
      }
    
      if (!Array.isArray(arr)) {
        options = arr;
        arr = [];
      }
    
      var opts = options || {};
      arr = arr || [];
    
      if (typeof opts.nodupes === 'undefined') {
        opts.nodupes = true;
      }
    
      var fn = opts.fn;
      var es6;
    
      if (typeof opts === 'function') {
        fn = opts;
        opts = {};
      }
    
      if (!(patternRe instanceof RegExp)) {
        patternRe = patternRegex();
      }
    
      var matches = str.match(patternRe) || [];
      var m = matches[0];
    
      switch(m) {
        case '\\,':
          return escapeCommas(str, arr, opts);
        case '\\.':
          return escapeDots(str, arr, opts);
        case '\/.':
          return escapePaths(str, arr, opts);
        case ' ':
          return splitWhitespace(str);
        case '{,}':
          return exponential(str, opts, braces);
        case '{}':
          return emptyBraces(str, arr, opts);
        case '\\{':
        case '\\}':
          return escapeBraces(str, arr, opts);
        case '${':
          if (!/\{[^{]+\{/.test(str)) {
            return arr.concat(str);
          } else {
            es6 = true;
            str = tokens.before(str, es6Regex());
          }
      }
    
      if (!(braceRe instanceof RegExp)) {
        braceRe = braceRegex();
      }
    
      var match = braceRe.exec(str);
      if (match == null) {
        return [str];
      }
    
      var outter = match[1];
      var inner = match[2];
      if (inner === '') { return [str]; }
    
      var segs, segsLength;
    
      if (inner.indexOf('..') !== -1) {
        segs = expand(inner, opts, fn) || inner.split(',');
        segsLength = segs.length;
    
      } else if (inner[0] === '"' || inner[0] === '\'') {
        return arr.concat(str.split(/['"]/).join(''));
    
      } else {
        segs = inner.split(',');
        if (opts.makeRe) {
          return braces(str.replace(outter, wrap(segs, '|')), opts);
        }
    
        segsLength = segs.length;
        if (segsLength === 1 && opts.bash) {
          segs[0] = wrap(segs[0], '\\');
        }
      }
    
      var len = segs.length;
      var i = 0, val;
    
      while (len--) {
        var path = segs[i++];
        var bash = false;
    
        if (/(\.[^.\/])/.test(path)) {
          if (segsLength > 1) {
            return segs;
          } else {
            return [str];
          }
        }
    
        val = splice(str, outter, path);
    
        if (/\{[^{}]+?\}/.test(val)) {
          arr = braces(val, arr, opts);
        } else if (val !== '') {
          if (opts.nodupes && arr.indexOf(val) !== -1) { continue; }
          arr.push(es6 ? tokens.after(val) : val);
        }
      }
    
      if (opts.strict) { return filter(arr, filterEmpty); }
      return arr;
    }
    
    /**
     * Expand exponential ranges
     *
     *   `a{,}{,}` => ['a', 'a', 'a', 'a']
     */
    
    function exponential(str, options, fn) {
      if (typeof options === 'function') {
        fn = options;
        options = null;
      }
    
      var opts = options || {};
      var esc = '__ESC_EXP__';
      var exp = 0;
      var res;
    
      var parts = str.split('{,}');
      if (opts.nodupes) {
        return fn(parts.join(''), opts);
      }
    
      exp = parts.length - 1;
      res = fn(parts.join(esc), opts);
      var len = res.length;
      var arr = [];
      var i = 0;
    
      while (len--) {
        var ele = res[i++];
        var idx = ele.indexOf(esc);
    
        if (idx === -1) {
          arr.push(ele);
    
        } else {
          ele = ele.split('__ESC_EXP__').join('');
          if (!!ele && opts.nodupes !== false) {
            arr.push(ele);
    
          } else {
            var num = Math.pow(2, exp);
            arr.push.apply(arr, repeat(ele, num));
          }
        }
      }
      return arr;
    }
    
    /**
     * Wrap a value with parens, brackets or braces,
     * based on the given character/separator.
     *
     * @param  {String|Array} `val`
     * @param  {String} `ch`
     * @return {String}
     */
    
    function wrap(val, ch) {
      if (ch === '|') {
        return '(' + val.join(ch) + ')';
      }
      if (ch === ',') {
        return '{' + val.join(ch) + '}';
      }
      if (ch === '-') {
        return '[' + val.join(ch) + ']';
      }
      if (ch === '\\') {
        return '\\{' + val + '\\}';
      }
    }
    
    /**
     * Handle empty braces: `{}`
     */
    
    function emptyBraces(str, arr, opts) {
      return braces(str.split('{}').join('\\{\\}'), arr, opts);
    }
    
    /**
     * Filter out empty-ish values
     */
    
    function filterEmpty(ele) {
      return !!ele && ele !== '\\';
    }
    
    /**
     * Handle patterns with whitespace
     */
    
    function splitWhitespace(str) {
      var segs = str.split(' ');
      var len = segs.length;
      var res = [];
      var i = 0;
    
      while (len--) {
        res.push.apply(res, braces(segs[i++]));
      }
      return res;
    }
    
    /**
     * Handle escaped braces: `\\{foo,bar}`
     */
    
    function escapeBraces(str, arr, opts) {
      if (!/\{[^{]+\{/.test(str)) {
        return arr.concat(str.split('\\').join(''));
      } else {
        str = str.split('\\{').join('__LT_BRACE__');
        str = str.split('\\}').join('__RT_BRACE__');
        return map(braces(str, arr, opts), function (ele) {
          ele = ele.split('__LT_BRACE__').join('{');
          return ele.split('__RT_BRACE__').join('}');
        });
      }
    }
    
    /**
     * Handle escaped dots: `{1\\.2}`
     */
    
    function escapeDots(str, arr, opts) {
      if (!/[^\\]\..+\\\./.test(str)) {
        return arr.concat(str.split('\\').join(''));
      } else {
        str = str.split('\\.').join('__ESC_DOT__');
        return map(braces(str, arr, opts), function (ele) {
          return ele.split('__ESC_DOT__').join('.');
        });
      }
    }
    
    /**
     * Handle escaped dots: `{1\\.2}`
     */
    
    function escapePaths(str, arr, opts) {
      str = str.split('\/.').join('__ESC_PATH__');
      return map(braces(str, arr, opts), function (ele) {
        return ele.split('__ESC_PATH__').join('\/.');
      });
    }
    
    /**
     * Handle escaped commas: `{a\\,b}`
     */
    
    function escapeCommas(str, arr, opts) {
      if (!/\w,/.test(str)) {
        return arr.concat(str.split('\\').join(''));
      } else {
        str = str.split('\\,').join('__ESC_COMMA__');
        return map(braces(str, arr, opts), function (ele) {
          return ele.split('__ESC_COMMA__').join(',');
        });
      }
    }
    
    /**
     * Regex for common patterns
     */
    
    function patternRegex() {
      return /\$\{|[ \t]|{}|{,}|\\,|\/\.|\\\.|\\{|\\}/;
    }
    
    /**
     * Braces regex.
     */
    
    function braceRegex() {
      return /.*(\\?\{([^}]+)\})/;
    }
    
    /**
     * es6 delimiter regex.
     */
    
    function es6Regex() {
      return /\$\{([^}]+)\}/;
    }
    
    var braceRe;
    var patternRe;
    
    /**
     * Faster alternative to `String.replace()` when the
     * index of the token to be replaces can't be supplied
     */
    
    function splice(str, token, replacement) {
      var i = str.indexOf(token);
      return str.substr(0, i) + replacement
        + str.substr(i + token.length);
    }
    
    /**
     * Fast array map
     */
    
    function map(arr, fn) {
      if (arr == null) {
        return [];
      }
    
      var len = arr.length;
      var res = new Array(len);
      var i = -1;
    
      while (++i < len) {
        res[i] = fn(arr[i], i, arr);
      }
    
      return res;
    }
    
    /**
     * Fast array filter
     */
    
    function filter(arr, cb) {
      if (arr == null) return [];
      if (typeof cb !== 'function') {
        throw new TypeError('braces: filter expects a callback function.');
      }
    
      var len = arr.length;
      var res = arr.slice();
      var i = 0;
    
      while (len--) {
        if (!cb(arr[len], i++)) {
          res.splice(len, 1);
        }
      }
      return res;
    }
    
  provide("braces", module.exports);
}(global));

// pakmanager:debug
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var tty = require('tty');
    var util = require('util');
    
    /**
     * This is the Node.js implementation of `debug()`.
     *
     * Expose `debug()` as the module.
     */
    
    exports = module.exports =   require('debug');
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    
    /**
     * Colors.
     */
    
    exports.colors = [6, 2, 3, 4, 5, 1];
    
    /**
     * The file descriptor to write the `debug()` calls to.
     * Set the `DEBUG_FD` env variable to override with another value. i.e.:
     *
     *   $ DEBUG_FD=3 node script.js 3>debug.log
     */
    
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    var stream = 1 === fd ? process.stdout :
                 2 === fd ? process.stderr :
                 createWritableStdioStream(fd);
    
    /**
     * Is stdout a TTY? Colored output is enabled when `true`.
     */
    
    function useColors() {
      var debugColors = (process.env.DEBUG_COLORS || '').trim().toLowerCase();
      if (0 === debugColors.length) {
        return tty.isatty(fd);
      } else {
        return '0' !== debugColors
            && 'no' !== debugColors
            && 'false' !== debugColors
            && 'disabled' !== debugColors;
      }
    }
    
    /**
     * Map %o to `util.inspect()`, since Node doesn't do that out of the box.
     */
    
    var inspect = (4 === util.inspect.length ?
      // node <= 0.8.x
      function (v, colors) {
        return util.inspect(v, void 0, void 0, colors);
      } :
      // node > 0.8.x
      function (v, colors) {
        return util.inspect(v, { colors: colors });
      }
    );
    
    exports.formatters.o = function(v) {
      return inspect(v, this.useColors)
        .replace(/\s*\n\s*/g, ' ');
    };
    
    /**
     * Adds ANSI color escape codes if enabled.
     *
     * @api public
     */
    
    function formatArgs() {
      var args = arguments;
      var useColors = this.useColors;
      var name = this.namespace;
    
      if (useColors) {
        var c = this.color;
    
        args[0] = '  \u001b[3' + c + ';1m' + name + ' '
          + '\u001b[0m'
          + args[0] + '\u001b[3' + c + 'm'
          + ' +' + exports.humanize(this.diff) + '\u001b[0m';
      } else {
        args[0] = new Date().toUTCString()
          + ' ' + name + ' ' + args[0];
      }
      return args;
    }
    
    /**
     * Invokes `console.error()` with the specified arguments.
     */
    
    function log() {
      return stream.write(util.format.apply(this, arguments) + '\n');
    }
    
    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    
    function save(namespaces) {
      if (null == namespaces) {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    
    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */
    
    function load() {
      return process.env.DEBUG;
    }
    
    /**
     * Copied from `node/src/node.js`.
     *
     * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
     * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
     */
    
    function createWritableStdioStream (fd) {
      var stream;
      var tty_wrap = process.binding('tty_wrap');
    
      // Note stream._type is used for test-module-load-list.js
    
      switch (tty_wrap.guessHandleType(fd)) {
        case 'TTY':
          stream = new tty.WriteStream(fd);
          stream._type = 'tty';
    
          // Hack to have stream not keep the event loop alive.
          // See https://github.com/joyent/node/issues/1726
          if (stream._handle && stream._handle.unref) {
            stream._handle.unref();
          }
          break;
    
        case 'FILE':
          var fs = require('fs');
          stream = new fs.SyncWriteStream(fd, { autoClose: false });
          stream._type = 'fs';
          break;
    
        case 'PIPE':
        case 'TCP':
          var net = require('net');
          stream = new net.Socket({
            fd: fd,
            readable: false,
            writable: true
          });
    
          // FIXME Should probably have an option in net.Socket to create a
          // stream from an existing fd which is writable only. But for now
          // we'll just add this hack and set the `readable` member to false.
          // Test: ./node test/fixtures/echo.js < /etc/passwd
          stream.readable = false;
          stream.read = null;
          stream._type = 'pipe';
    
          // FIXME Hack to have stream not keep the event loop alive.
          // See https://github.com/joyent/node/issues/1726
          if (stream._handle && stream._handle.unref) {
            stream._handle.unref();
          }
          break;
    
        default:
          // Probably an error on in uv_guess_handle()
          throw new Error('Implement me. Unknown stream file type!');
      }
    
      // For supporting legacy API we put the FD here.
      stream.fd = fd;
    
      stream._isStdio = true;
    
      return stream;
    }
    
    /**
     * Enable namespaces listed in `process.env.DEBUG` initially.
     */
    
    exports.enable(load());
    
  provide("debug", module.exports);
}(global));

// pakmanager:expand-brackets
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * expand-brackets <https://github.com/jonschlinkert/expand-brackets>
     *
     * Copyright (c) 2015 Jon Schlinkert.
     * Licensed under the MIT license.
     */
    
    'use strict';
    
    /**
     * POSIX character classes
     */
    
    var POSIX = {
      alnum: 'a-zA-Z0-9',
      alpha: 'a-zA-Z',
      blank: ' \\s\\t',
      cntrl: '\\x00-\\x1F\\x7F',
      digit: '0-9',
      graph: '\\x21-\\x7E',
      lower: 'a-z',
      print: '\\x20-\\x7E',
      punct: '!"#$%&\'()\\*+,-./:;<=>?@[\\]^_`{|}~',
      space: ' \\s\\t\\r\\n\\v\\f',
      upper: 'A-Z',
      word:  'A-Za-z0-9_',
      xdigit: 'A-Fa-f0-9',
    };
    
    /**
     * Expose `brackets`
     */
    
    module.exports = brackets;
    
    function brackets(str) {
      var negated = false;
    
      if (str.indexOf('[^') !== -1) {
        negated = true;
        str = str.split('[^').join('[');
      }
      if (str.indexOf('[!') !== -1) {
        negated = true;
        str = str.split('[!').join('[');
      }
    
      var a = str.split('[');
      var b = str.split(']');
      var imbalanced = a.length !== b.length;
    
      var parts = str.split(/(?::\]\[:|\[?\[:|:\]\]?)/);
      var len = parts.length, i = 0;
      var end = '', beg = '';
      var res = [];
    
      while (len--) {
        var inner = parts[i++];
        if (inner === '^[!' || inner === '[!') {
          inner = '';
          negated = true;
        }
    
        var prefix = negated ? '^' : '';
        var ch = POSIX[inner];
    
        if (ch) {
          res.push('[' + prefix + ch + ']');
        } else if (inner) {
          if (/^\[?\w-\w\]?$/.test(inner)) {
            if (i === parts.length) {
              res.push('[' + prefix + inner);
            } else if (i === 1) {
              res.push(prefix + inner + ']');
            } else {
              res.push(prefix + inner);
            }
          } else {
            if (i === 1) {
              beg += inner;
            } else if (i === parts.length) {
              end += inner;
            } else {
              res.push('[' + prefix + inner + ']');
            }
          }
        }
      }
    
      var result = res.join('|');
      var len = res.length || 1;
      if (len > 1) {
        result = '(?:' + result + ')';
        len = 1;
      }
      if (beg) {
        len++;
        if (beg.charAt(0) === '[') {
          if (imbalanced) {
            beg = '\\[' + beg.slice(1);
          } else {
            beg += ']';
          }
        }
        result = beg + result;
      }
      if (end) {
        len++;
        if (end.slice(-1) === ']') {
          if (imbalanced) {
            end = end.slice(0, end.length - 1) + '\\]';
          } else {
            end = '[' + end;
          }
        }
        result += end;
      }
    
      if (len > 1) {
        result = result.split('][').join(']|[');
        if (result.indexOf('|') !== -1 && !/\(\?/.test(result)) {
          result = '(?:' + result + ')';
        }
      }
    
      result = result.replace(/\[+=|=\]+/g, '\\b');
      return result;
    }
    
    brackets.makeRe = function (pattern) {
      try {
        return new RegExp(brackets(pattern));
      } catch (err) {}
    };
    
    brackets.isMatch = function (str, pattern) {
      try {
        return brackets.makeRe(pattern).test(str);
      } catch (err) {
        return false;
      }
    };
    
    brackets.match = function (arr, pattern) {
      var len = arr.length, i = 0;
      var res = arr.slice();
    
      var re = brackets.makeRe(pattern);
      while (i < len) {
        var ele = arr[i++];
        if (!re.test(ele)) {
          continue;
        }
        res.splice(i, 1);
      }
      return res;
    };
    
  provide("expand-brackets", module.exports);
}(global));

// pakmanager:filename-regex
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * filename-regex <https://github.com/regexps/filename-regex>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert
     * Licensed under the MIT license.
     */
    
    module.exports = function filenameRegex() {
      return /([^\\\/]+)$/;
    };
    
  provide("filename-regex", module.exports);
}(global));

// pakmanager:object.omit
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * object.omit <https://github.com/jonschlinkert/object.omit>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var isObject = require('isobject');
    var forOwn = require('for-own');
    
    module.exports = function omit(obj, keys) {
      if (!isObject(obj)) return {};
      if (!keys) return obj;
    
      keys = Array.isArray(keys) ? keys : [keys];
      var res = {};
    
      forOwn(obj, function (value, key) {
        if (keys.indexOf(key) === -1) {
          res[key] = value;
        }
      });
      return res;
    };
    
  provide("object.omit", module.exports);
}(global));

// pakmanager:parse-glob
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * parse-glob <https://github.com/jonschlinkert/parse-glob>
     *
     * Copyright (c) 2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var isGlob = require('is-glob');
    var findBase = require('glob-base');
    var extglob = require('is-extglob');
    var dotfile = require('is-dotfile');
    
    /**
     * Expose `cache`
     */
    
    var cache = module.exports.cache = {};
    
    /**
     * Parse a glob pattern into tokens.
     *
     * When no paths or '**' are in the glob, we use a
     * different strategy for parsing the filename, since
     * file names can contain braces and other difficult
     * patterns. such as:
     *
     *  - `*.{a,b}`
     *  - `(**|*.js)`
     */
    
    module.exports = function parseGlob(glob) {
      if (cache.hasOwnProperty(glob)) {
        return cache[glob];
      }
    
      var tok = {};
      tok.orig = glob;
      tok.is = {};
    
      // unescape dots and slashes in braces/brackets
      glob = escape(glob);
    
      var parsed = findBase(glob);
      tok.is.glob = parsed.isGlob;
    
      tok.glob = parsed.glob;
      tok.base = parsed.base;
      var segs = /([^\/]*)$/.exec(glob);
    
      tok.path = {};
      tok.path.dirname = '';
      tok.path.basename = segs[1] || '';
      tok.path.dirname = glob.split(tok.path.basename).join('') || '';
      var basename = (tok.path.basename || '').split('.') || '';
      tok.path.filename = basename[0] || '';
      tok.path.extname = basename.slice(1).join('.') || '';
      tok.path.ext = '';
    
      if (isGlob(tok.path.dirname) && !tok.path.basename) {
        if (!/\/$/.test(tok.glob)) {
          tok.path.basename = tok.glob;
        }
        tok.path.dirname = tok.base;
      }
    
      if (glob.indexOf('/') === -1 && !tok.is.globstar) {
        tok.path.dirname = '';
        tok.path.basename = tok.orig;
      }
    
      var dot = tok.path.basename.indexOf('.');
      if (dot !== -1) {
        tok.path.filename = tok.path.basename.slice(0, dot);
        tok.path.extname = tok.path.basename.slice(dot);
      }
    
      if (tok.path.extname.charAt(0) === '.') {
        var exts = tok.path.extname.split('.');
        tok.path.ext = exts[exts.length - 1];
      }
    
      // unescape dots and slashes in braces/brackets
      tok.glob = unescape(tok.glob);
      tok.path.dirname = unescape(tok.path.dirname);
      tok.path.basename = unescape(tok.path.basename);
      tok.path.filename = unescape(tok.path.filename);
      tok.path.extname = unescape(tok.path.extname);
    
      // Booleans
      var is = (glob && tok.is.glob);
      tok.is.negated  = glob && glob.charAt(0) === '!';
      tok.is.extglob  = glob && extglob(glob);
      tok.is.braces   = has(is, glob, '{');
      tok.is.brackets = has(is, glob, '[:');
      tok.is.globstar = has(is, glob, '**');
      tok.is.dotfile  = dotfile(tok.path.basename) || dotfile(tok.path.filename);
      tok.is.dotdir   = dotdir(tok.path.dirname);
      return (cache[glob] = tok);
    }
    
    /**
     * Returns true if the glob matches dot-directories.
     *
     * @param  {Object} `tok` The tokens object
     * @param  {Object} `path` The path object
     * @return {Object}
     */
    
    function dotdir(base) {
      if (base.indexOf('/.') !== -1) {
        return true;
      }
      if (base.charAt(0) === '.' && base.charAt(1) !== '/') {
        return true;
      }
      return false;
    }
    
    /**
     * Returns true if the pattern has the given `ch`aracter(s)
     *
     * @param  {Object} `glob` The glob pattern.
     * @param  {Object} `ch` The character to test for
     * @return {Object}
     */
    
    function has(is, glob, ch) {
      return is && glob.indexOf(ch) !== -1;
    }
    
    /**
     * Escape/unescape utils
     */
    
    function escape(str) {
      var re = /\{([^{}]*?)}|\(([^()]*?)\)|\[([^\[\]]*?)\]/g;
      return str.replace(re, function (outter, braces, parens, brackets) {
        var inner = braces || parens || brackets;
        if (!inner) { return outter; }
        return outter.split(inner).join(esc(inner));
      });
    }
    
    function esc(str) {
      str = str.split('/').join('__SLASH__');
      str = str.split('.').join('__DOT__');
      return str;
    }
    
    function unescape(str) {
      str = str.split('__SLASH__').join('/');
      str = str.split('__DOT__').join('.');
      return str;
    }
    
  provide("parse-glob", module.exports);
}(global));

// pakmanager:regex-cache
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * regex-cache <https://github.com/jonschlinkert/regex-cache>
     *
     * Copyright (c) 2015 Jon Schlinkert.
     * Licensed under the MIT license.
     */
    
    'use strict';
    
    var isPrimitive = require('is-primitive');
    var equal = require('is-equal-shallow');
    
    /**
     * Expose `regexCache`
     */
    
    module.exports = regexCache;
    
    /**
     * Memoize the results of a call to the new RegExp constructor.
     *
     * @param  {Function} fn [description]
     * @param  {String} str [description]
     * @param  {Options} options [description]
     * @param  {Boolean} nocompare [description]
     * @return {RegExp}
     */
    
    function regexCache(fn, str, opts) {
      var key = '_default_', regex, cached;
    
      if (!str && !opts) {
        if (typeof fn !== 'function') {
          return fn;
        }
        return basic[key] || (basic[key] = fn());
      }
    
      var isString = typeof str === 'string';
      if (isString) {
        if (!opts) {
          return basic[str] || (basic[str] = fn(str));
        }
        key = str;
      } else {
        opts = str;
      }
    
      cached = cache[key];
      if (cached && equal(cached.opts, opts)) {
        return cached.regex;
      }
    
      memo(key, opts, (regex = fn(str, opts)));
      return regex;
    }
    
    function memo(key, opts, regex) {
      cache[key] = {regex: regex, opts: opts};
    }
    
    /**
     * Expose `cache`
     */
    
    var cache = module.exports.cache = {};
    var basic = module.exports.basic = {};
    
  provide("regex-cache", module.exports);
}(global));

// pakmanager:brace-expansion
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var concatMap = require('concat-map');
    var balanced = require('balanced-match');
    
    module.exports = expandTop;
    
    var escSlash = '\0SLASH'+Math.random()+'\0';
    var escOpen = '\0OPEN'+Math.random()+'\0';
    var escClose = '\0CLOSE'+Math.random()+'\0';
    var escComma = '\0COMMA'+Math.random()+'\0';
    var escPeriod = '\0PERIOD'+Math.random()+'\0';
    
    function numeric(str) {
      return parseInt(str, 10) == str
        ? parseInt(str, 10)
        : str.charCodeAt(0);
    }
    
    function escapeBraces(str) {
      return str.split('\\\\').join(escSlash)
                .split('\\{').join(escOpen)
                .split('\\}').join(escClose)
                .split('\\,').join(escComma)
                .split('\\.').join(escPeriod);
    }
    
    function unescapeBraces(str) {
      return str.split(escSlash).join('\\')
                .split(escOpen).join('{')
                .split(escClose).join('}')
                .split(escComma).join(',')
                .split(escPeriod).join('.');
    }
    
    
    // Basically just str.split(","), but handling cases
    // where we have nested braced sections, which should be
    // treated as individual members, like {a,{b,c},d}
    function parseCommaParts(str) {
      if (!str)
        return [''];
    
      var parts = [];
      var m = balanced('{', '}', str);
    
      if (!m)
        return str.split(',');
    
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(',');
    
      p[p.length-1] += '{' + body + '}';
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length-1] += postParts.shift();
        p.push.apply(p, postParts);
      }
    
      parts.push.apply(parts, p);
    
      return parts;
    }
    
    function expandTop(str) {
      if (!str)
        return [];
    
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    
    function identity(e) {
      return e;
    }
    
    function embrace(str) {
      return '{' + str + '}';
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    
    function expand(str, isTop) {
      var expansions = [];
    
      var m = balanced('{', '}', str);
      if (!m || /\$$/.test(m.pre)) return [str];
    
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = /^(.*,)+(.+)?$/.test(m.body);
      if (!isSequence && !isOptions) {
        // {a},b}
        if (m.post.match(/,.*}/)) {
          str = m.pre + '{' + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
    
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          // x{{a,b}}y ==> x{a}y x{b}y
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length
              ? expand(m.post, false)
              : [''];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
    
      // at this point, n is the parts, and we know it's not a comma set
      // with a single entry.
    
      // no need to expand pre, since it is guaranteed to be free of brace-sets
      var pre = m.pre;
      var post = m.post.length
        ? expand(m.post, false)
        : [''];
    
      var N;
    
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length)
        var incr = n.length == 3
          ? Math.abs(numeric(n[2]))
          : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
    
        N = [];
    
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === '\\')
              c = '';
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join('0');
                if (i < 0)
                  c = '-' + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) { return expand(el, false) });
      }
    
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
    
      return expansions;
    }
    
    
  provide("brace-expansion", module.exports);
}(global));

// pakmanager:core-util-is
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // NOTE: These type checking functions intentionally don't use `instanceof`
    // because it is fragile and can be easily faked with `Object.create()`.
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    exports.isBoolean = isBoolean;
    
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    exports.isNumber = isNumber;
    
    function isString(arg) {
      return typeof arg === 'string';
    }
    exports.isString = isString;
    
    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    exports.isSymbol = isSymbol;
    
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;
    
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    exports.isObject = isObject;
    
    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;
    
    function isError(e) {
      return isObject(e) &&
          (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    exports.isError = isError;
    
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    exports.isFunction = isFunction;
    
    function isPrimitive(arg) {
      return arg === null ||
             typeof arg === 'boolean' ||
             typeof arg === 'number' ||
             typeof arg === 'string' ||
             typeof arg === 'symbol' ||  // ES6 symbol
             typeof arg === 'undefined';
    }
    exports.isPrimitive = isPrimitive;
    
    function isBuffer(arg) {
      return Buffer.isBuffer(arg);
    }
    exports.isBuffer = isBuffer;
    
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  provide("core-util-is", module.exports);
}(global));

// pakmanager:isarray
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = Array.isArray || function (arr) {
      return Object.prototype.toString.call(arr) == '[object Array]';
    };
    
  provide("isarray", module.exports);
}(global));

// pakmanager:string_decoder
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    var Buffer = require('buffer').Buffer;
    
    var isBufferEncoding = Buffer.isEncoding
      || function(encoding) {
           switch (encoding && encoding.toLowerCase()) {
             case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
             default: return false;
           }
         }
    
    
    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error('Unknown encoding: ' + encoding);
      }
    }
    
    // StringDecoder provides an interface for efficiently splitting a series of
    // buffers into a series of JS strings without breaking apart multi-byte
    // characters. CESU-8 is handled as part of the UTF-8 encoding.
    //
    // @TODO Handling all encodings inside a single object makes it very difficult
    // to reason about this code, so it should be split up in the future.
    // @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
    // points as used by CESU-8.
    var StringDecoder = exports.StringDecoder = function(encoding) {
      this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
      assertEncoding(encoding);
      switch (this.encoding) {
        case 'utf8':
          // CESU-8 represents each of Surrogate Pair by 3-bytes
          this.surrogateSize = 3;
          break;
        case 'ucs2':
        case 'utf16le':
          // UTF-16 represents each of Surrogate Pair by 2-bytes
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case 'base64':
          // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }
    
      // Enough space to store all bytes of a single character. UTF-8 needs 4
      // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
      this.charBuffer = new Buffer(6);
      // Number of bytes received for the current incomplete multi-byte character.
      this.charReceived = 0;
      // Number of bytes expected for the current incomplete multi-byte character.
      this.charLength = 0;
    };
    
    
    // write decodes the given buffer and returns it as JS string that is
    // guaranteed to not contain any partial multi-byte characters. Any partial
    // character found at the end of the buffer is buffered up, and will be
    // returned when calling write again with the remaining bytes.
    //
    // Note: Converting a Buffer containing an orphan surrogate to a String
    // currently works, but converting a String to a Buffer (via `new Buffer`, or
    // Buffer#write) will replace incomplete surrogates with the unicode
    // replacement character. See https://codereview.chromium.org/121173009/ .
    StringDecoder.prototype.write = function(buffer) {
      var charStr = '';
      // if our last write ended with an incomplete multibyte character
      while (this.charLength) {
        // determine how many remaining bytes this buffer has to offer for this char
        var available = (buffer.length >= this.charLength - this.charReceived) ?
            this.charLength - this.charReceived :
            buffer.length;
    
        // add the new bytes to the char buffer
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
    
        if (this.charReceived < this.charLength) {
          // still not enough chars in this buffer? wait for more ...
          return '';
        }
    
        // remove bytes belonging to the current character from the buffer
        buffer = buffer.slice(available, buffer.length);
    
        // get the character that was split
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
    
        // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 0xD800 && charCode <= 0xDBFF) {
          this.charLength += this.surrogateSize;
          charStr = '';
          continue;
        }
        this.charReceived = this.charLength = 0;
    
        // if there are no more bytes in this buffer, just emit our char
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
    
      // determine and set charLength / charReceived
      this.detectIncompleteChar(buffer);
    
      var end = buffer.length;
      if (this.charLength) {
        // buffer the incomplete character bytes we got
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
    
      charStr += buffer.toString(this.encoding, 0, end);
    
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
      if (charCode >= 0xD800 && charCode <= 0xDBFF) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
    
      // or just emit the charStr
      return charStr;
    };
    
    // detectIncompleteChar determines if there is an incomplete UTF-8 character at
    // the end of the given buffer. If so, it sets this.charLength to the byte
    // length that character, and sets this.charReceived to the number of bytes
    // that are available for this character.
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      // determine how many bytes we have to check at the end of this buffer
      var i = (buffer.length >= 3) ? 3 : buffer.length;
    
      // Figure out if one of the last i bytes of our buffer announces an
      // incomplete char.
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
    
        // See http://en.wikipedia.org/wiki/UTF-8#Description
    
        // 110XXXXX
        if (i == 1 && c >> 5 == 0x06) {
          this.charLength = 2;
          break;
        }
    
        // 1110XXXX
        if (i <= 2 && c >> 4 == 0x0E) {
          this.charLength = 3;
          break;
        }
    
        // 11110XXX
        if (i <= 3 && c >> 3 == 0x1E) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    
    StringDecoder.prototype.end = function(buffer) {
      var res = '';
      if (buffer && buffer.length)
        res = this.write(buffer);
    
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
    
      return res;
    };
    
    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }
    
    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }
    
    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }
    
  provide("string_decoder", module.exports);
}(global));

// pakmanager:mime-db
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * mime-db
     * Copyright(c) 2014 Jonathan Ong
     * MIT Licensed
     */
    
    /**
     * Module exports.
     */
    
    module.exports = require('./db.json')
    
  provide("mime-db", module.exports);
}(global));

// pakmanager:depd/lib/compat/buffer-concat
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * depd
     * Copyright(c) 2014 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    /**
     * Module exports.
     */
    
    module.exports = bufferConcat
    
    /**
     * Concatenate an array of Buffers.
     */
    
    function bufferConcat(bufs) {
      var length = 0
    
      for (var i = 0, len = bufs.length; i < len; i++) {
        length += bufs[i].length
      }
    
      var buf = new Buffer(length)
      var pos = 0
    
      for (var i = 0, len = bufs.length; i < len; i++) {
        bufs[i].copy(buf, pos)
        pos += bufs[i].length
      }
    
      return buf
    }
    
  provide("depd/lib/compat/buffer-concat", module.exports);
}(global));

// pakmanager:depd/lib/compat/callsite-tostring
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * depd
     * Copyright(c) 2014 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    /**
     * Module exports.
     */
    
    module.exports = callSiteToString
    
    /**
     * Format a CallSite file location to a string.
     */
    
    function callSiteFileLocation(callSite) {
      var fileName
      var fileLocation = ''
    
      if (callSite.isNative()) {
        fileLocation = 'native'
      } else if (callSite.isEval()) {
        fileName = callSite.getScriptNameOrSourceURL()
        if (!fileName) {
          fileLocation = callSite.getEvalOrigin()
        }
      } else {
        fileName = callSite.getFileName()
      }
    
      if (fileName) {
        fileLocation += fileName
    
        var lineNumber = callSite.getLineNumber()
        if (lineNumber != null) {
          fileLocation += ':' + lineNumber
    
          var columnNumber = callSite.getColumnNumber()
          if (columnNumber) {
            fileLocation += ':' + columnNumber
          }
        }
      }
    
      return fileLocation || 'unknown source'
    }
    
    /**
     * Format a CallSite to a string.
     */
    
    function callSiteToString(callSite) {
      var addSuffix = true
      var fileLocation = callSiteFileLocation(callSite)
      var functionName = callSite.getFunctionName()
      var isConstructor = callSite.isConstructor()
      var isMethodCall = !(callSite.isToplevel() || isConstructor)
      var line = ''
    
      if (isMethodCall) {
        var methodName = callSite.getMethodName()
        var typeName = getConstructorName(callSite)
    
        if (functionName) {
          if (typeName && functionName.indexOf(typeName) !== 0) {
            line += typeName + '.'
          }
    
          line += functionName
    
          if (methodName && functionName.lastIndexOf('.' + methodName) !== functionName.length - methodName.length - 1) {
            line += ' [as ' + methodName + ']'
          }
        } else {
          line += typeName + '.' + (methodName || '<anonymous>')
        }
      } else if (isConstructor) {
        line += 'new ' + (functionName || '<anonymous>')
      } else if (functionName) {
        line += functionName
      } else {
        addSuffix = false
        line += fileLocation
      }
    
      if (addSuffix) {
        line += ' (' + fileLocation + ')'
      }
    
      return line
    }
    
    /**
     * Get constructor name of reviver.
     */
    
    function getConstructorName(obj) {
      var receiver = obj.receiver
      return (receiver.constructor && receiver.constructor.name) || null
    }
    
  provide("depd/lib/compat/callsite-tostring", module.exports);
}(global));

// pakmanager:depd/lib/compat
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * depd
     * Copyright(c) 2014 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    /**
     * Module exports.
     */
    
    lazyProperty(module.exports, 'bufferConcat', function bufferConcat() {
      return Buffer.concat ||  require('depd/lib/compat/buffer-concat')
    })
    
    lazyProperty(module.exports, 'callSiteToString', function callSiteToString() {
      var limit = Error.stackTraceLimit
      var obj = {}
      var prep = Error.prepareStackTrace
    
      function prepareObjectStackTrace(obj, stack) {
        return stack
      }
    
      Error.prepareStackTrace = prepareObjectStackTrace
      Error.stackTraceLimit = 2
    
      // capture the stack
      Error.captureStackTrace(obj)
    
      // slice the stack
      var stack = obj.stack.slice()
    
      Error.prepareStackTrace = prep
      Error.stackTraceLimit = limit
    
      return stack[0].toString ? toString :  require('depd/lib/compat/callsite-tostring')
    })
    
    /**
     * Define a lazy property.
     */
    
    function lazyProperty(obj, prop, getter) {
      function get() {
        var val = getter()
    
        Object.defineProperty(obj, prop, {
          configurable: true,
          enumerable: true,
          value: val
        })
    
        return val
      }
    
      Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: true,
        get: get
      })
    }
    
    /**
     * Call toString() on the obj
     */
    
    function toString(obj) {
      return obj.toString()
    }
    
  provide("depd/lib/compat", module.exports);
}(global));

// pakmanager:depd
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * depd
     * Copyright(c) 2014 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    /**
     * Module dependencies.
     */
    
    var callSiteToString =  require('depd/lib/compat').callSiteToString
    var EventEmitter = require('events').EventEmitter
    var relative = require('path').relative
    
    /**
     * Module exports.
     */
    
    module.exports = depd
    
    /**
     * Get the path to base files on.
     */
    
    var basePath = process.cwd()
    
    /**
     * Get listener count on event emitter.
     */
    
    /*istanbul ignore next*/
    var eventListenerCount = EventEmitter.listenerCount
      || function (emitter, type) { return emitter.listeners(type).length }
    
    /**
     * Determine if namespace is contained in the string.
     */
    
    function containsNamespace(str, namespace) {
      var val = str.split(/[ ,]+/)
    
      namespace = String(namespace).toLowerCase()
    
      for (var i = 0 ; i < val.length; i++) {
        if (!(str = val[i])) continue;
    
        // namespace contained
        if (str === '*' || str.toLowerCase() === namespace) {
          return true
        }
      }
    
      return false
    }
    
    /**
     * Convert a data descriptor to accessor descriptor.
     */
    
    function convertDataDescriptorToAccessor(obj, prop, message) {
      var descriptor = Object.getOwnPropertyDescriptor(obj, prop)
      var value = descriptor.value
    
      descriptor.get = function getter() { return value }
    
      if (descriptor.writable) {
        descriptor.set = function setter(val) { return value = val }
      }
    
      delete descriptor.value
      delete descriptor.writable
    
      Object.defineProperty(obj, prop, descriptor)
    
      return descriptor
    }
    
    /**
     * Create arguments string to keep arity.
     */
    
    function createArgumentsString(arity) {
      var str = ''
    
      for (var i = 0; i < arity; i++) {
        str += ', arg' + i
      }
    
      return str.substr(2)
    }
    
    /**
     * Create stack string from stack.
     */
    
    function createStackString(stack) {
      var str = this.name + ': ' + this.namespace
    
      if (this.message) {
        str += ' deprecated ' + this.message
      }
    
      for (var i = 0; i < stack.length; i++) {
        str += '\n    at ' + callSiteToString(stack[i])
      }
    
      return str
    }
    
    /**
     * Create deprecate for namespace in caller.
     */
    
    function depd(namespace) {
      if (!namespace) {
        throw new TypeError('argument namespace is required')
      }
    
      var stack = getStack()
      var site = callSiteLocation(stack[1])
      var file = site[0]
    
      function deprecate(message) {
        // call to self as log
        log.call(deprecate, message)
      }
    
      deprecate._file = file
      deprecate._ignored = isignored(namespace)
      deprecate._namespace = namespace
      deprecate._traced = istraced(namespace)
      deprecate._warned = Object.create(null)
    
      deprecate.function = wrapfunction
      deprecate.property = wrapproperty
    
      return deprecate
    }
    
    /**
     * Determine if namespace is ignored.
     */
    
    function isignored(namespace) {
      /* istanbul ignore next: tested in a child processs */
      if (process.noDeprecation) {
        // --no-deprecation support
        return true
      }
    
      var str = process.env.NO_DEPRECATION || ''
    
      // namespace ignored
      return containsNamespace(str, namespace)
    }
    
    /**
     * Determine if namespace is traced.
     */
    
    function istraced(namespace) {
      /* istanbul ignore next: tested in a child processs */
      if (process.traceDeprecation) {
        // --trace-deprecation support
        return true
      }
    
      var str = process.env.TRACE_DEPRECATION || ''
    
      // namespace traced
      return containsNamespace(str, namespace)
    }
    
    /**
     * Display deprecation message.
     */
    
    function log(message, site) {
      var haslisteners = eventListenerCount(process, 'deprecation') !== 0
    
      // abort early if no destination
      if (!haslisteners && this._ignored) {
        return
      }
    
      var caller
      var callFile
      var callSite
      var i = 0
      var seen = false
      var stack = getStack()
      var file = this._file
    
      if (site) {
        // provided site
        callSite = callSiteLocation(stack[1])
        callSite.name = site.name
        file = callSite[0]
      } else {
        // get call site
        i = 2
        site = callSiteLocation(stack[i])
        callSite = site
      }
    
      // get caller of deprecated thing in relation to file
      for (; i < stack.length; i++) {
        caller = callSiteLocation(stack[i])
        callFile = caller[0]
    
        if (callFile === file) {
          seen = true
        } else if (callFile === this._file) {
          file = this._file
        } else if (seen) {
          break
        }
      }
    
      var key = caller
        ? site.join(':') + '__' + caller.join(':')
        : undefined
    
      if (key !== undefined && key in this._warned) {
        // already warned
        return
      }
    
      this._warned[key] = true
    
      // generate automatic message from call site
      if (!message) {
        message = callSite === site || !callSite.name
          ? defaultMessage(site)
          : defaultMessage(callSite)
      }
    
      // emit deprecation if listeners exist
      if (haslisteners) {
        var err = DeprecationError(this._namespace, message, stack.slice(i))
        process.emit('deprecation', err)
        return
      }
    
      // format and write message
      var format = process.stderr.isTTY
        ? formatColor
        : formatPlain
      var msg = format.call(this, message, caller, stack.slice(i))
      process.stderr.write(msg + '\n', 'utf8')
    
      return
    }
    
    /**
     * Get call site location as array.
     */
    
    function callSiteLocation(callSite) {
      var file = callSite.getFileName() || '<anonymous>'
      var line = callSite.getLineNumber()
      var colm = callSite.getColumnNumber()
    
      if (callSite.isEval()) {
        file = callSite.getEvalOrigin() + ', ' + file
      }
    
      var site = [file, line, colm]
    
      site.callSite = callSite
      site.name = callSite.getFunctionName()
    
      return site
    }
    
    /**
     * Generate a default message from the site.
     */
    
    function defaultMessage(site) {
      var callSite = site.callSite
      var funcName = site.name
    
      // make useful anonymous name
      if (!funcName) {
        funcName = '<anonymous@' + formatLocation(site) + '>'
      }
    
      var context = callSite.getThis()
      var typeName = context && callSite.getTypeName()
    
      // ignore useless type name
      if (typeName === 'Object') {
        typeName = undefined
      }
    
      // make useful type name
      if (typeName === 'Function') {
        typeName = context.name || typeName
      }
    
      return typeName && callSite.getMethodName()
        ? typeName + '.' + funcName
        : funcName
    }
    
    /**
     * Format deprecation message without color.
     */
    
    function formatPlain(msg, caller, stack) {
      var timestamp = new Date().toUTCString()
    
      var formatted = timestamp
        + ' ' + this._namespace
        + ' deprecated ' + msg
    
      // add stack trace
      if (this._traced) {
        for (var i = 0; i < stack.length; i++) {
          formatted += '\n    at ' + callSiteToString(stack[i])
        }
    
        return formatted
      }
    
      if (caller) {
        formatted += ' at ' + formatLocation(caller)
      }
    
      return formatted
    }
    
    /**
     * Format deprecation message with color.
     */
    
    function formatColor(msg, caller, stack) {
      var formatted = '\x1b[36;1m' + this._namespace + '\x1b[22;39m' // bold cyan
        + ' \x1b[33;1mdeprecated\x1b[22;39m' // bold yellow
        + ' \x1b[0m' + msg + '\x1b[39m' // reset
    
      // add stack trace
      if (this._traced) {
        for (var i = 0; i < stack.length; i++) {
          formatted += '\n    \x1b[36mat ' + callSiteToString(stack[i]) + '\x1b[39m' // cyan
        }
    
        return formatted
      }
    
      if (caller) {
        formatted += ' \x1b[36m' + formatLocation(caller) + '\x1b[39m' // cyan
      }
    
      return formatted
    }
    
    /**
     * Format call site location.
     */
    
    function formatLocation(callSite) {
      return relative(basePath, callSite[0])
        + ':' + callSite[1]
        + ':' + callSite[2]
    }
    
    /**
     * Get the stack as array of call sites.
     */
    
    function getStack() {
      var limit = Error.stackTraceLimit
      var obj = {}
      var prep = Error.prepareStackTrace
    
      Error.prepareStackTrace = prepareObjectStackTrace
      Error.stackTraceLimit = Math.max(10, limit)
    
      // capture the stack
      Error.captureStackTrace(obj)
    
      // slice this function off the top
      var stack = obj.stack.slice(1)
    
      Error.prepareStackTrace = prep
      Error.stackTraceLimit = limit
    
      return stack
    }
    
    /**
     * Capture call site stack from v8.
     */
    
    function prepareObjectStackTrace(obj, stack) {
      return stack
    }
    
    /**
     * Return a wrapped function in a deprecation message.
     */
    
    function wrapfunction(fn, message) {
      if (typeof fn !== 'function') {
        throw new TypeError('argument fn must be a function')
      }
    
      var args = createArgumentsString(fn.length)
      var deprecate = this
      var stack = getStack()
      var site = callSiteLocation(stack[1])
    
      site.name = fn.name
    
      var deprecatedfn = eval('(function (' + args + ') {\n'
        + '"use strict"\n'
        + 'log.call(deprecate, message, site)\n'
        + 'return fn.apply(this, arguments)\n'
        + '})')
    
      return deprecatedfn
    }
    
    /**
     * Wrap property in a deprecation message.
     */
    
    function wrapproperty(obj, prop, message) {
      if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
        throw new TypeError('argument obj must be object')
      }
    
      var descriptor = Object.getOwnPropertyDescriptor(obj, prop)
    
      if (!descriptor) {
        throw new TypeError('must call property on owner object')
      }
    
      if (!descriptor.configurable) {
        throw new TypeError('property must be configurable')
      }
    
      var deprecate = this
      var stack = getStack()
      var site = callSiteLocation(stack[1])
    
      // set site name
      site.name = prop
    
      // convert data descriptor
      if ('value' in descriptor) {
        descriptor = convertDataDescriptorToAccessor(obj, prop, message)
      }
    
      var get = descriptor.get
      var set = descriptor.set
    
      // wrap getter
      if (typeof get === 'function') {
        descriptor.get = function getter() {
          log.call(deprecate, message, site)
          return get.apply(this, arguments)
        }
      }
    
      // wrap setter
      if (typeof set === 'function') {
        descriptor.set = function setter() {
          log.call(deprecate, message, site)
          return set.apply(this, arguments)
        }
      }
    
      Object.defineProperty(obj, prop, descriptor)
    }
    
    /**
     * Create DeprecationError for deprecation
     */
    
    function DeprecationError(namespace, message, stack) {
      var error = new Error()
      var stackString
    
      Object.defineProperty(error, 'constructor', {
        value: DeprecationError
      })
    
      Object.defineProperty(error, 'message', {
        configurable: true,
        enumerable: false,
        value: message,
        writable: true
      })
    
      Object.defineProperty(error, 'name', {
        enumerable: false,
        configurable: true,
        value: 'DeprecationError',
        writable: true
      })
    
      Object.defineProperty(error, 'namespace', {
        configurable: true,
        enumerable: false,
        value: namespace,
        writable: true
      })
    
      Object.defineProperty(error, 'stack', {
        configurable: true,
        enumerable: false,
        get: function () {
          if (stackString !== undefined) {
            return stackString
          }
    
          // prepare stack trace
          return stackString = createStackString.call(this, stack)
        },
        set: function setter(val) {
          stackString = val
        }
      })
    
      return error
    }
    
  provide("depd", module.exports);
}(global));

// pakmanager:destroy
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var ReadStream = require('fs').ReadStream
    var Stream = require('stream')
    
    module.exports = function destroy(stream) {
      if (stream instanceof ReadStream) {
        return destroyReadStream(stream)
      }
    
      if (!(stream instanceof Stream)) {
        return stream
      }
    
      if (typeof stream.destroy === 'function') {
        stream.destroy()
      }
    
      return stream
    }
    
    function destroyReadStream(stream) {
      stream.destroy()
    
      if (typeof stream.close === 'function') {
        // node.js core bug work-around
        stream.on('open', onopenClose)
      }
    
      return stream
    }
    
    function onopenClose() {
      if (typeof this.fd === 'number') {
        // actually close down the fd
        this.close()
      }
    }
    
  provide("destroy", module.exports);
}(global));

// pakmanager:escape-html
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Escape special characters in the given string of html.
     *
     * @param  {String} html
     * @return {String}
     * @api private
     */
    
    module.exports = function(html) {
      return String(html)
        .replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    }
    
  provide("escape-html", module.exports);
}(global));

// pakmanager:etag
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * etag
     * Copyright(c) 2014-2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    /**
     * Module exports.
     */
    
    module.exports = etag
    
    /**
     * Module dependencies.
     */
    
    var crc = require('crc').crc32
    var crypto = require('crypto')
    var Stats = require('fs').Stats
    
    /**
     * Module variables.
     */
    
    var crc32threshold = 1000 // 1KB
    var NULL = new Buffer([0])
    var toString = Object.prototype.toString
    
    /**
     * Create a simple ETag.
     *
     * @param {string|Buffer|Stats} entity
     * @param {object} [options]
     * @param {boolean} [options.weak]
     * @return {String}
     * @api public
     */
    
    function etag(entity, options) {
      if (entity == null) {
        throw new TypeError('argument entity is required')
      }
    
      var isStats = isstats(entity)
      var weak = options && typeof options.weak === 'boolean'
        ? options.weak
        : isStats
    
      // support fs.Stats object
      if (isStats) {
        return stattag(entity, weak)
      }
    
      if (typeof entity !== 'string' && !Buffer.isBuffer(entity)) {
        throw new TypeError('argument entity must be string, Buffer, or fs.Stats')
      }
    
      var hash = weak
        ? weakhash(entity)
        : stronghash(entity)
    
      return weak
        ? 'W/"' + hash + '"'
        : '"' + hash + '"'
    }
    
    /**
     * Determine if object is a Stats object.
     *
     * @param {object} obj
     * @return {boolean}
     * @api private
     */
    
    function isstats(obj) {
      // genuine fs.Stats
      if (typeof Stats === 'function' && obj instanceof Stats) {
        return true
      }
    
      // quack quack
      return obj && typeof obj === 'object'
        && 'ctime' in obj && toString.call(obj.ctime) === '[object Date]'
        && 'mtime' in obj && toString.call(obj.mtime) === '[object Date]'
        && 'ino' in obj && typeof obj.ino === 'number'
        && 'size' in obj && typeof obj.size === 'number'
    }
    
    /**
     * Generate a tag for a stat.
     *
     * @param {Buffer} entity
     * @return {String}
     * @api private
     */
    
    function stattag(stat, weak) {
      var mtime = stat.mtime.toISOString()
      var size = stat.size.toString(16)
    
      if (weak) {
        return 'W/"' + size + '-' + crc(mtime) + '"'
      }
    
      var hash = crypto
        .createHash('md5')
        .update('file', 'utf8')
        .update(NULL)
        .update(size, 'utf8')
        .update(NULL)
        .update(mtime, 'utf8')
        .digest('base64')
    
      return '"' + hash + '"'
    }
    
    /**
     * Generate a strong hash.
     *
     * @param {Buffer} entity
     * @return {String}
     * @api private
     */
    
    function stronghash(entity) {
      if (entity.length === 0) {
        // fast-path empty
        return '1B2M2Y8AsgTpgAmY7PhCfg=='
      }
    
      return crypto
        .createHash('md5')
        .update(entity, 'utf8')
        .digest('base64')
    }
    
    /**
     * Generate a weak hash.
     *
     * @param {Buffer} entity
     * @return {String}
     * @api private
     */
    
    function weakhash(entity) {
      if (entity.length === 0) {
        // fast-path empty
        return '0-0'
      }
    
      var len = typeof entity === 'string'
        ? Buffer.byteLength(entity, 'utf8')
        : entity.length
    
      if (len <= crc32threshold) {
        // crc32 plus length when it's fast
        // crc(str) only accepts utf-8 encoding
        return len.toString(16) + '-' + crc(entity).toString(16)
      }
    
      // use md4 for long strings
      return crypto
        .createHash('md4')
        .update(entity, 'utf8')
        .digest('base64')
    }
    
  provide("etag", module.exports);
}(global));

// pakmanager:fresh
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Expose `fresh()`.
     */
    
    module.exports = fresh;
    
    /**
     * Check freshness of `req` and `res` headers.
     *
     * When the cache is "fresh" __true__ is returned,
     * otherwise __false__ is returned to indicate that
     * the cache is now stale.
     *
     * @param {Object} req
     * @param {Object} res
     * @return {Boolean}
     * @api public
     */
    
    function fresh(req, res) {
      // defaults
      var etagMatches = true;
      var notModified = true;
    
      // fields
      var modifiedSince = req['if-modified-since'];
      var noneMatch = req['if-none-match'];
      var lastModified = res['last-modified'];
      var etag = res['etag'];
      var cc = req['cache-control'];
    
      // unconditional request
      if (!modifiedSince && !noneMatch) return false;
    
      // check for no-cache cache request directive
      if (cc && cc.indexOf('no-cache') !== -1) return false;  
    
      // parse if-none-match
      if (noneMatch) noneMatch = noneMatch.split(/ *, */);
    
      // if-none-match
      if (noneMatch) {
        etagMatches = noneMatch.some(function (match) {
          return match === '*' || match === etag || match === 'W/' + etag;
        });
      }
    
      // if-modified-since
      if (modifiedSince) {
        modifiedSince = new Date(modifiedSince);
        lastModified = new Date(lastModified);
        notModified = lastModified <= modifiedSince;
      }
    
      return !! (etagMatches && notModified);
    }
    
  provide("fresh", module.exports);
}(global));

// pakmanager:mime
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var path = require('path');
    var fs = require('fs');
    
    function Mime() {
      // Map of extension -> mime type
      this.types = Object.create(null);
    
      // Map of mime type -> extension
      this.extensions = Object.create(null);
    }
    
    /**
     * Define mimetype -> extension mappings.  Each key is a mime-type that maps
     * to an array of extensions associated with the type.  The first extension is
     * used as the default extension for the type.
     *
     * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
     *
     * @param map (Object) type definitions
     */
    Mime.prototype.define = function (map) {
      for (var type in map) {
        var exts = map[type];
        for (var i = 0; i < exts.length; i++) {
          if (process.env.DEBUG_MIME && this.types[exts]) {
            console.warn(this._loading.replace(/.*\//, ''), 'changes "' + exts[i] + '" extension type from ' +
              this.types[exts] + ' to ' + type);
          }
    
          this.types[exts[i]] = type;
        }
    
        // Default extension is the first one we encounter
        if (!this.extensions[type]) {
          this.extensions[type] = exts[0];
        }
      }
    };
    
    /**
     * Load an Apache2-style ".types" file
     *
     * This may be called multiple times (it's expected).  Where files declare
     * overlapping types/extensions, the last file wins.
     *
     * @param file (String) path of file to load.
     */
    Mime.prototype.load = function(file) {
      this._loading = file;
      // Read file and split into lines
      var map = {},
          content = fs.readFileSync(file, 'ascii'),
          lines = content.split(/[\r\n]+/);
    
      lines.forEach(function(line) {
        // Clean up whitespace/comments, and split into fields
        var fields = line.replace(/\s*#.*|^\s*|\s*$/g, '').split(/\s+/);
        map[fields.shift()] = fields;
      });
    
      this.define(map);
    
      this._loading = null;
    };
    
    /**
     * Lookup a mime type based on extension
     */
    Mime.prototype.lookup = function(path, fallback) {
      var ext = path.replace(/.*[\.\/\\]/, '').toLowerCase();
    
      return this.types[ext] || fallback || this.default_type;
    };
    
    /**
     * Return file extension associated with a mime type
     */
    Mime.prototype.extension = function(mimeType) {
      var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
      return this.extensions[type];
    };
    
    // Default instance
    var mime = new Mime();
    
    // Define built-in types
    mime.define(require('./types.json'));
    
    // Default type
    mime.default_type = mime.lookup('bin');
    
    //
    // Additional API specific to the default instance
    //
    
    mime.Mime = Mime;
    
    /**
     * Lookup a charset based on mime type.
     */
    mime.charsets = {
      lookup: function(mimeType, fallback) {
        // Assume text types are utf8
        return (/^text\//).test(mimeType) ? 'UTF-8' : fallback;
      }
    };
    
    module.exports = mime;
    
  provide("mime", module.exports);
}(global));

// pakmanager:on-finished
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * on-finished
     * Copyright(c) 2013 Jonathan Ong
     * Copyright(c) 2014 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    /**
     * Module exports.
     */
    
    module.exports = onFinished;
    module.exports.isFinished = isFinished;
    
    /**
    * Module dependencies.
    */
    
    var first = require('ee-first')
    
    /**
    * Variables.
    */
    
    /* istanbul ignore next */
    var defer = typeof setImmediate === 'function'
      ? setImmediate
      : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }
    
    /**
     * Invoke callback when the response has finished, useful for
     * cleaning up resources afterwards.
     *
     * @param {object} msg
     * @param {function} listener
     * @return {object}
     * @api public
     */
    
    function onFinished(msg, listener) {
      if (isFinished(msg) !== false) {
        defer(listener, null, msg)
        return msg
      }
    
      // attach the listener to the message
      attachListener(msg, listener)
    
      return msg
    }
    
    /**
     * Determine if message is already finished.
     *
     * @param {object} msg
     * @return {boolean}
     * @api public
     */
    
    function isFinished(msg) {
      var socket = msg.socket
    
      if (typeof msg.finished === 'boolean') {
        // OutgoingMessage
        return Boolean(msg.finished || (socket && !socket.writable))
      }
    
      if (typeof msg.complete === 'boolean') {
        // IncomingMessage
        return Boolean(!socket || !socket.readable || (msg.complete && !msg.readable))
      }
    
      // don't know
      return undefined
    }
    
    /**
     * Attach a finished listener to the message.
     *
     * @param {object} msg
     * @param {function} callback
     * @private
     */
    
    function attachFinishedListener(msg, callback) {
      var eeMsg
      var eeSocket
      var finished = false
    
      function onFinish(error) {
        eeMsg.cancel()
        eeSocket.cancel()
    
        finished = true
        callback(error)
      }
    
      // finished on first message event
      eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish)
    
      function onSocket(socket) {
        // remove listener
        msg.removeListener('socket', onSocket)
    
        if (finished) return
        if (eeMsg !== eeSocket) return
    
        // finished on first socket event
        eeSocket = first([[socket, 'error', 'close']], onFinish)
      }
    
      if (msg.socket) {
        // socket already assigned
        onSocket(msg.socket)
        return
      }
    
      // wait for socket to be assigned
      msg.on('socket', onSocket)
    
      if (msg.socket === undefined) {
        // node.js 0.8 patch
        patchAssignSocket(msg, onSocket)
      }
    }
    
    /**
     * Attach the listener to the message.
     *
     * @param {object} msg
     * @return {function}
     * @api private
     */
    
    function attachListener(msg, listener) {
      var attached = msg.__onFinished
    
      // create a private single listener with queue
      if (!attached || !attached.queue) {
        attached = msg.__onFinished = createListener(msg)
        attachFinishedListener(msg, attached)
      }
    
      attached.queue.push(listener)
    }
    
    /**
     * Create listener on message.
     *
     * @param {object} msg
     * @return {function}
     * @api private
     */
    
    function createListener(msg) {
      function listener(err) {
        if (msg.__onFinished === listener) msg.__onFinished = null
        if (!listener.queue) return
    
        var queue = listener.queue
        listener.queue = null
    
        for (var i = 0; i < queue.length; i++) {
          queue[i](err, msg)
        }
      }
    
      listener.queue = []
    
      return listener
    }
    
    /**
     * Patch ServerResponse.prototype.assignSocket for node.js 0.8.
     *
     * @param {ServerResponse} res
     * @param {function} callback
     * @private
     */
    
    function patchAssignSocket(res, callback) {
      var assignSocket = res.assignSocket
    
      if (typeof assignSocket !== 'function') return
    
      // res.on('socket', callback) is broken in 0.8
      res.assignSocket = function _assignSocket(socket) {
        assignSocket.call(this, socket)
        callback(socket)
      }
    }
    
  provide("on-finished", module.exports);
}(global));

// pakmanager:range-parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Parse "Range" header `str` relative to the given file `size`.
     *
     * @param {Number} size
     * @param {String} str
     * @return {Array}
     * @api public
     */
    
    module.exports = function(size, str){
      var valid = true;
      var i = str.indexOf('=');
    
      if (-1 == i) return -2;
    
      var arr = str.slice(i + 1).split(',').map(function(range){
        var range = range.split('-')
          , start = parseInt(range[0], 10)
          , end = parseInt(range[1], 10);
    
        // -nnn
        if (isNaN(start)) {
          start = size - end;
          end = size - 1;
        // nnn-
        } else if (isNaN(end)) {
          end = size - 1;
        }
    
        // limit last-byte-pos to current length
        if (end > size - 1) end = size - 1;
    
        // invalid
        if (isNaN(start)
          || isNaN(end)
          || start > end
          || start < 0) valid = false;
    
        return {
          start: start,
          end: end
        };
      });
    
      arr.type = str.slice(0, i);
    
      return valid ? arr : -1;
    };
    
  provide("range-parser", module.exports);
}(global));

// pakmanager:once
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var wrappy = require('wrappy')
    module.exports = wrappy(once)
    
    once.proto = once(function () {
      Object.defineProperty(Function.prototype, 'once', {
        value: function () {
          return once(this)
        },
        configurable: true
      })
    })
    
    function once (fn) {
      var f = function () {
        if (f.called) return f.value
        f.called = true
        return f.value = fn.apply(this, arguments)
      }
      f.called = false
      return f
    }
    
  provide("once", module.exports);
}(global));

// pakmanager:graceful-readlink
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require('fs')
      , lstat = fs.lstatSync;
    
    exports.readlinkSync = function (p) {
      if (lstat(p).isSymbolicLink()) {
        return fs.readlinkSync(p);
      } else {
        return p;
      }
    };
    
    
    
  provide("graceful-readlink", module.exports);
}(global));

// pakmanager:acorn-globals
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var acorn = require('acorn');
    var walk = require('acorn/dist/walk');
    
    // polyfill for https://github.com/marijnh/acorn/pull/231
    walk.base.ExportNamedDeclaration = walk.base.ExportDefaultDeclaration = function (node, st, c) {
      return c(node.declaration, st);
    };
    walk.base.ImportDefaultSpecifier = walk.base.ImportNamespaceSpecifier = function () {};
    
    function isScope(node) {
      return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration' || node.type === 'Program';
    }
    function isBlockScope(node) {
      return node.type === 'BlockStatement' || isScope(node);
    }
    
    function declaresArguments(node) {
      return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration' || node.type === 'ArrowFunction';
    }
    function declaresThis(node) {
      return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration';
    }
    
    function reallyParse(source) {
      try {
        return acorn.parse(source, {
          ecmaVersion: 6,
          allowReturnOutsideFunction: true,
          sourceType: 'module'
        });
      } catch (ex) {
        if (ex.name !== 'SyntaxError') {
          throw ex;
        }
        try {
          return acorn.parse(source, {
            ecmaVersion: 6,
            allowReturnOutsideFunction: true
          });
        } catch (ex) {
          if (ex.name !== 'SyntaxError') {
            throw ex;
          }
          return acorn.parse(source, {
            ecmaVersion: 5,
            allowReturnOutsideFunction: true
          });
        }
      }
    }
    module.exports = findGlobals;
    module.exports.parse = reallyParse;
    function findGlobals(source) {
      var globals = [];
      var ast = typeof source === 'string' ?
        ast = reallyParse(source) :
        source;
      if (!(ast && typeof ast === 'object' && ast.type === 'Program')) {
        throw new TypeError('Source must be either a string of JavaScript or an acorn AST');
      }
      var declareFunction = function (node) {
        var fn = node;
        fn.locals = fn.locals || {};
        node.params.forEach(function (node) {
          fn.locals[node.name] = true;
        });
        if (node.id) {
          fn.locals[node.id.name] = true;
        }
      }
      walk.ancestor(ast, {
        'VariableDeclaration': function (node, parents) {
          var parent = null;
          for (var i = parents.length - 1; i >= 0 && parent === null; i--) {
            if (node.kind === 'var' ? isScope(parents[i]) : isBlockScope(parents[i])) {
              parent = parents[i];
            }
          }
          parent.locals = parent.locals || {};
          node.declarations.forEach(function (declaration) {
            parent.locals[declaration.id.name] = true;
          });
        },
        'FunctionDeclaration': function (node, parents) {
          var parent = null;
          for (var i = parents.length - 2; i >= 0 && parent === null; i--) {
            if (isScope(parents[i])) {
              parent = parents[i];
            }
          }
          parent.locals = parent.locals || {};
          parent.locals[node.id.name] = true;
          declareFunction(node);
        },
        'Function': declareFunction,
        'TryStatement': function (node) {
          node.handler.body.locals = node.handler.body.locals || {};
          node.handler.body.locals[node.handler.param.name] = true;
        },
        'ImportDefaultSpecifier': function (node) {
          if (node.local.type === 'Identifier') {
            ast.locals = ast.locals || {};
            ast.locals[node.local.name] = true;
          }
        },
        'ImportSpecifier': function (node) {
          var id = node.local ? node.local : node.imported;
          if (id.type === 'Identifier') {
            ast.locals = ast.locals || {};
            ast.locals[id.name] = true;
          }
        },
        'ImportNamespaceSpecifier': function (node) {
          if (node.local.type === 'Identifier') {
            ast.locals = ast.locals || {};
            ast.locals[node.local.name] = true;
          }
        }
      });
      walk.ancestor(ast, {
        'Identifier': function (node, parents) {
          var name = node.name;
          if (name === 'undefined') return;
          for (var i = 0; i < parents.length; i++) {
            if (name === 'arguments' && declaresArguments(parents[i])) {
              return;
            }
            if (parents[i].locals && name in parents[i].locals) {
              return;
            }
          }
          node.parents = parents;
          globals.push(node);
        },
        ThisExpression: function (node, parents) {
          for (var i = 0; i < parents.length; i++) {
            if (declaresThis(parents[i])) {
              return;
            }
          }
          node.parents = parents;
          globals.push(node);
        }
      });
      var groupedGlobals = {};
      globals.forEach(function (node) {
        groupedGlobals[node.name] = (groupedGlobals[node.name] || []);
        groupedGlobals[node.name].push(node);
      });
      return Object.keys(groupedGlobals).sort().map(function (name) {
        return {name: name, nodes: groupedGlobals[name]};
      });
    }
    
  provide("acorn-globals", module.exports);
}(global));

// pakmanager:minimist
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function (args, opts) {
        if (!opts) opts = {};
        
        var flags = { bools : {}, strings : {}, unknownFn: null };
    
        if (typeof opts['unknown'] === 'function') {
            flags.unknownFn = opts['unknown'];
        }
    
        if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {
          flags.allBools = true;
        } else {
          [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
              flags.bools[key] = true;
          });
        }
        
        var aliases = {};
        Object.keys(opts.alias || {}).forEach(function (key) {
            aliases[key] = [].concat(opts.alias[key]);
            aliases[key].forEach(function (x) {
                aliases[x] = [key].concat(aliases[key].filter(function (y) {
                    return x !== y;
                }));
            });
        });
    
        [].concat(opts.string).filter(Boolean).forEach(function (key) {
            flags.strings[key] = true;
            if (aliases[key]) {
                flags.strings[aliases[key]] = true;
            }
         });
    
        var defaults = opts['default'] || {};
        
        var argv = { _ : [] };
        Object.keys(flags.bools).forEach(function (key) {
            setArg(key, defaults[key] === undefined ? false : defaults[key]);
        });
        
        var notFlags = [];
    
        if (args.indexOf('--') !== -1) {
            notFlags = args.slice(args.indexOf('--')+1);
            args = args.slice(0, args.indexOf('--'));
        }
    
        function argDefined(key, arg) {
            return (flags.allBools && /^--[^=]+$/.test(arg)) ||
                flags.strings[key] || flags.bools[key] || aliases[key];
        }
    
        function setArg (key, val, arg) {
            if (arg && flags.unknownFn && !argDefined(key, arg)) {
                if (flags.unknownFn(arg) === false) return;
            }
    
            var value = !flags.strings[key] && isNumber(val)
                ? Number(val) : val
            ;
            setKey(argv, key.split('.'), value);
            
            (aliases[key] || []).forEach(function (x) {
                setKey(argv, x.split('.'), value);
            });
        }
    
        function setKey (obj, keys, value) {
            var o = obj;
            keys.slice(0,-1).forEach(function (key) {
                if (o[key] === undefined) o[key] = {};
                o = o[key];
            });
    
            var key = keys[keys.length - 1];
            if (o[key] === undefined || flags.bools[key] || typeof o[key] === 'boolean') {
                o[key] = value;
            }
            else if (Array.isArray(o[key])) {
                o[key].push(value);
            }
            else {
                o[key] = [ o[key], value ];
            }
        }
        
        for (var i = 0; i < args.length; i++) {
            var arg = args[i];
            
            if (/^--.+=/.test(arg)) {
                // Using [\s\S] instead of . because js doesn't support the
                // 'dotall' regex modifier. See:
                // http://stackoverflow.com/a/1068308/13216
                var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
                setArg(m[1], m[2], arg);
            }
            else if (/^--no-.+/.test(arg)) {
                var key = arg.match(/^--no-(.+)/)[1];
                setArg(key, false, arg);
            }
            else if (/^--.+/.test(arg)) {
                var key = arg.match(/^--(.+)/)[1];
                var next = args[i + 1];
                if (next !== undefined && !/^-/.test(next)
                && !flags.bools[key]
                && !flags.allBools
                && (aliases[key] ? !flags.bools[aliases[key]] : true)) {
                    setArg(key, next, arg);
                    i++;
                }
                else if (/^(true|false)$/.test(next)) {
                    setArg(key, next === 'true', arg);
                    i++;
                }
                else {
                    setArg(key, flags.strings[key] ? '' : true, arg);
                }
            }
            else if (/^-[^-]+/.test(arg)) {
                var letters = arg.slice(1,-1).split('');
                
                var broken = false;
                for (var j = 0; j < letters.length; j++) {
                    var next = arg.slice(j+2);
                    
                    if (next === '-') {
                        setArg(letters[j], next, arg)
                        continue;
                    }
                    
                    if (/[A-Za-z]/.test(letters[j])
                    && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                        setArg(letters[j], next, arg);
                        broken = true;
                        break;
                    }
                    
                    if (letters[j+1] && letters[j+1].match(/\W/)) {
                        setArg(letters[j], arg.slice(j+2), arg);
                        broken = true;
                        break;
                    }
                    else {
                        setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);
                    }
                }
                
                var key = arg.slice(-1)[0];
                if (!broken && key !== '-') {
                    if (args[i+1] && !/^(-|--)[^-]/.test(args[i+1])
                    && !flags.bools[key]
                    && (aliases[key] ? !flags.bools[aliases[key]] : true)) {
                        setArg(key, args[i+1], arg);
                        i++;
                    }
                    else if (args[i+1] && /true|false/.test(args[i+1])) {
                        setArg(key, args[i+1] === 'true', arg);
                        i++;
                    }
                    else {
                        setArg(key, flags.strings[key] ? '' : true, arg);
                    }
                }
            }
            else {
                if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                    argv._.push(
                        flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
                    );
                }
                if (opts.stopEarly) {
                    argv._.push.apply(argv._, args.slice(i + 1));
                    break;
                }
            }
        }
        
        Object.keys(defaults).forEach(function (key) {
            if (!hasKey(argv, key.split('.'))) {
                setKey(argv, key.split('.'), defaults[key]);
                
                (aliases[key] || []).forEach(function (x) {
                    setKey(argv, x.split('.'), defaults[key]);
                });
            }
        });
        
        if (opts['--']) {
            argv['--'] = new Array();
            notFlags.forEach(function(key) {
                argv['--'].push(key);
            });
        }
        else {
            notFlags.forEach(function(key) {
                argv._.push(key);
            });
        }
    
        return argv;
    };
    
    function hasKey (obj, keys) {
        var o = obj;
        keys.slice(0,-1).forEach(function (key) {
            o = (o[key] || {});
        });
    
        var key = keys[keys.length - 1];
        return key in o;
    }
    
    function isNumber (x) {
        if (typeof x === 'number') return true;
        if (/^0x[0-9a-f]+$/i.test(x)) return true;
        return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
    
    
  provide("minimist", module.exports);
}(global));

// pakmanager:promise/lib/core.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var asap = require('asap/raw');
    
    function noop() {}
    
    // States:
    //
    // 0 - pending
    // 1 - fulfilled with _value
    // 2 - rejected with _value
    // 3 - adopted the state of another promise, _value
    //
    // once the state is no longer pending (0) it is immutable
    
    // All `_` prefixed properties will be reduced to `_{random number}`
    // at build time to obfuscate them and discourage their use.
    // We don't use symbols or Object.defineProperty to fully hide them
    // because the performance isn't good enough.
    
    
    // to avoid using try/catch inside critical functions, we
    // extract them to here.
    var LAST_ERROR = null;
    var IS_ERROR = {};
    function getThen(obj) {
      try {
        return obj.then;
      } catch (ex) {
        LAST_ERROR = ex;
        return IS_ERROR;
      }
    }
    
    function tryCallOne(fn, a) {
      try {
        return fn(a);
      } catch (ex) {
        LAST_ERROR = ex;
        return IS_ERROR;
      }
    }
    function tryCallTwo(fn, a, b) {
      try {
        fn(a, b);
      } catch (ex) {
        LAST_ERROR = ex;
        return IS_ERROR;
      }
    }
    
    module.exports = Promise;
    
    function Promise(fn) {
      if (typeof this !== 'object') {
        throw new TypeError('Promises must be constructed via new');
      }
      if (typeof fn !== 'function') {
        throw new TypeError('not a function');
      }
      this._32 = 0;
      this._8 = null;
      this._89 = [];
      if (fn === noop) return;
      doResolve(fn, this);
    }
    Promise._83 = noop;
    
    Promise.prototype.then = function(onFulfilled, onRejected) {
      if (this.constructor !== Promise) {
        return safeThen(this, onFulfilled, onRejected);
      }
      var res = new Promise(noop);
      handle(this, new Handler(onFulfilled, onRejected, res));
      return res;
    };
    
    function safeThen(self, onFulfilled, onRejected) {
      return new self.constructor(function (resolve, reject) {
        var res = new Promise(noop);
        res.then(resolve, reject);
        handle(self, new Handler(onFulfilled, onRejected, res));
      });
    };
    function handle(self, deferred) {
      while (self._32 === 3) {
        self = self._8;
      }
      if (self._32 === 0) {
        self._89.push(deferred);
        return;
      }
      asap(function() {
        var cb = self._32 === 1 ? deferred.onFulfilled : deferred.onRejected;
        if (cb === null) {
          if (self._32 === 1) {
            resolve(deferred.promise, self._8);
          } else {
            reject(deferred.promise, self._8);
          }
          return;
        }
        var ret = tryCallOne(cb, self._8);
        if (ret === IS_ERROR) {
          reject(deferred.promise, LAST_ERROR);
        } else {
          resolve(deferred.promise, ret);
        }
      });
    }
    function resolve(self, newValue) {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) {
        return reject(
          self,
          new TypeError('A promise cannot be resolved with itself.')
        );
      }
      if (
        newValue &&
        (typeof newValue === 'object' || typeof newValue === 'function')
      ) {
        var then = getThen(newValue);
        if (then === IS_ERROR) {
          return reject(self, LAST_ERROR);
        }
        if (
          then === self.then &&
          newValue instanceof Promise
        ) {
          self._32 = 3;
          self._8 = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(then.bind(newValue), self);
          return;
        }
      }
      self._32 = 1;
      self._8 = newValue;
      finale(self);
    }
    
    function reject(self, newValue) {
      self._32 = 2;
      self._8 = newValue;
      finale(self);
    }
    function finale(self) {
      for (var i = 0; i < self._89.length; i++) {
        handle(self, self._89[i]);
      }
      self._89 = null;
    }
    
    function Handler(onFulfilled, onRejected, promise){
      this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
      this.onRejected = typeof onRejected === 'function' ? onRejected : null;
      this.promise = promise;
    }
    
    /**
     * Take a potentially misbehaving resolver function and make sure
     * onFulfilled and onRejected are only called once.
     *
     * Makes no guarantees about asynchrony.
     */
    function doResolve(fn, promise) {
      var done = false;
      var res = tryCallTwo(fn, function (value) {
        if (done) return;
        done = true;
        resolve(promise, value);
      }, function (reason) {
        if (done) return;
        done = true;
        reject(promise, reason);
      })
      if (!done && res === IS_ERROR) {
        done = true;
        reject(promise, LAST_ERROR);
      }
    }
    
  provide("promise/lib/core.js", module.exports);
}(global));

// pakmanager:promise/lib/done.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Promise =  require('promise/lib/core.js');
    
    module.exports = Promise;
    Promise.prototype.done = function (onFulfilled, onRejected) {
      var self = arguments.length ? this.then.apply(this, arguments) : this;
      self.then(null, function (err) {
        setTimeout(function () {
          throw err;
        }, 0);
      });
    };
    
  provide("promise/lib/done.js", module.exports);
}(global));

// pakmanager:promise/lib/finally.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Promise =  require('promise/lib/core.js');
    
    module.exports = Promise;
    Promise.prototype['finally'] = function (f) {
      return this.then(function (value) {
        return Promise.resolve(f()).then(function () {
          return value;
        });
      }, function (err) {
        return Promise.resolve(f()).then(function () {
          throw err;
        });
      });
    };
    
  provide("promise/lib/finally.js", module.exports);
}(global));

// pakmanager:promise/lib/es6-extensions.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    //This file contains the ES6 extensions to the core Promises/A+ API
    
    var Promise =  require('promise/lib/core.js');
    var asap = require('asap/raw');
    
    module.exports = Promise;
    
    /* Static Functions */
    
    var TRUE = valuePromise(true);
    var FALSE = valuePromise(false);
    var NULL = valuePromise(null);
    var UNDEFINED = valuePromise(undefined);
    var ZERO = valuePromise(0);
    var EMPTYSTRING = valuePromise('');
    
    function valuePromise(value) {
      var p = new Promise(Promise._83);
      p._32 = 1;
      p._8 = value;
      return p;
    }
    Promise.resolve = function (value) {
      if (value instanceof Promise) return value;
    
      if (value === null) return NULL;
      if (value === undefined) return UNDEFINED;
      if (value === true) return TRUE;
      if (value === false) return FALSE;
      if (value === 0) return ZERO;
      if (value === '') return EMPTYSTRING;
    
      if (typeof value === 'object' || typeof value === 'function') {
        try {
          var then = value.then;
          if (typeof then === 'function') {
            return new Promise(then.bind(value));
          }
        } catch (ex) {
          return new Promise(function (resolve, reject) {
            reject(ex);
          });
        }
      }
      return valuePromise(value);
    };
    
    Promise.all = function (arr) {
      var args = Array.prototype.slice.call(arr);
    
      return new Promise(function (resolve, reject) {
        if (args.length === 0) return resolve([]);
        var remaining = args.length;
        function res(i, val) {
          if (val && (typeof val === 'object' || typeof val === 'function')) {
            if (val instanceof Promise && val.then === Promise.prototype.then) {
              while (val._32 === 3) {
                val = val._8;
              }
              if (val._32 === 1) return res(i, val._8);
              if (val._32 === 2) reject(val._8);
              val.then(function (val) {
                res(i, val);
              }, reject);
              return;
            } else {
              var then = val.then;
              if (typeof then === 'function') {
                var p = new Promise(then.bind(val));
                p.then(function (val) {
                  res(i, val);
                }, reject);
                return;
              }
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        }
        for (var i = 0; i < args.length; i++) {
          res(i, args[i]);
        }
      });
    };
    
    Promise.reject = function (value) {
      return new Promise(function (resolve, reject) {
        reject(value);
      });
    };
    
    Promise.race = function (values) {
      return new Promise(function (resolve, reject) {
        values.forEach(function(value){
          Promise.resolve(value).then(resolve, reject);
        });
      });
    };
    
    /* Prototype Methods */
    
    Promise.prototype['catch'] = function (onRejected) {
      return this.then(null, onRejected);
    };
    
  provide("promise/lib/es6-extensions.js", module.exports);
}(global));

// pakmanager:promise/lib/node-extensions.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    // This file contains then/promise specific extensions that are only useful
    // for node.js interop
    
    var Promise =  require('promise/lib/core.js');
    var asap = require('asap');
    
    module.exports = Promise;
    
    /* Static Functions */
    
    Promise.denodeify = function (fn, argumentCount) {
      argumentCount = argumentCount || Infinity;
      return function () {
        var self = this;
        var args = Array.prototype.slice.call(arguments);
        return new Promise(function (resolve, reject) {
          while (args.length && args.length > argumentCount) {
            args.pop();
          }
          args.push(function (err, res) {
            if (err) reject(err);
            else resolve(res);
          })
          var res = fn.apply(self, args);
          if (res &&
            (
              typeof res === 'object' ||
              typeof res === 'function'
            ) &&
            typeof res.then === 'function'
          ) {
            resolve(res);
          }
        })
      }
    }
    Promise.nodeify = function (fn) {
      return function () {
        var args = Array.prototype.slice.call(arguments);
        var callback =
          typeof args[args.length - 1] === 'function' ? args.pop() : null;
        var ctx = this;
        try {
          return fn.apply(this, arguments).nodeify(callback, ctx);
        } catch (ex) {
          if (callback === null || typeof callback == 'undefined') {
            return new Promise(function (resolve, reject) {
              reject(ex);
            });
          } else {
            asap(function () {
              callback.call(ctx, ex);
            })
          }
        }
      }
    }
    
    Promise.prototype.nodeify = function (callback, ctx) {
      if (typeof callback != 'function') return this;
    
      this.then(function (value) {
        asap(function () {
          callback.call(ctx, null, value);
        });
      }, function (err) {
        asap(function () {
          callback.call(ctx, err);
        });
      });
    }
    
  provide("promise/lib/node-extensions.js", module.exports);
}(global));

// pakmanager:promise/lib
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    module.exports =  require('promise/lib/core.js');
     require('promise/lib/done.js');
     require('promise/lib/finally.js');
     require('promise/lib/es6-extensions.js');
     require('promise/lib/node-extensions.js');
    
  provide("promise/lib", module.exports);
}(global));

// pakmanager:promise
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    module.exports =  require('promise/lib')
    
  provide("promise", module.exports);
}(global));

// pakmanager:css/lib/stringify/compiler
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Expose `Compiler`.
     */
    
    module.exports = Compiler;
    
    /**
     * Initialize a compiler.
     *
     * @param {Type} name
     * @return {Type}
     * @api public
     */
    
    function Compiler(opts) {
      this.options = opts || {};
    }
    
    /**
     * Emit `str`
     */
    
    Compiler.prototype.emit = function(str) {
      return str;
    };
    
    /**
     * Visit `node`.
     */
    
    Compiler.prototype.visit = function(node){
      return this[node.type](node);
    };
    
    /**
     * Map visit over array of `nodes`, optionally using a `delim`
     */
    
    Compiler.prototype.mapVisit = function(nodes, delim){
      var buf = '';
      delim = delim || '';
    
      for (var i = 0, length = nodes.length; i < length; i++) {
        buf += this.visit(nodes[i]);
        if (delim && i < length - 1) buf += this.emit(delim);
      }
    
      return buf;
    };
    
  provide("css/lib/stringify/compiler", module.exports);
}(global));

// pakmanager:css/lib/stringify/compress
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Base =  require('css/lib/stringify/compiler');
    var inherits = require('inherits');
    
    /**
     * Expose compiler.
     */
    
    module.exports = Compiler;
    
    /**
     * Initialize a new `Compiler`.
     */
    
    function Compiler(options) {
      Base.call(this, options);
    }
    
    /**
     * Inherit from `Base.prototype`.
     */
    
    inherits(Compiler, Base);
    
    /**
     * Compile `node`.
     */
    
    Compiler.prototype.compile = function(node){
      return node.stylesheet
        .rules.map(this.visit, this)
        .join('');
    };
    
    /**
     * Visit comment node.
     */
    
    Compiler.prototype.comment = function(node){
      return this.emit('', node.position);
    };
    
    /**
     * Visit import node.
     */
    
    Compiler.prototype.import = function(node){
      return this.emit('@import ' + node.import + ';', node.position);
    };
    
    /**
     * Visit media node.
     */
    
    Compiler.prototype.media = function(node){
      return this.emit('@media ' + node.media, node.position)
        + this.emit('{')
        + this.mapVisit(node.rules)
        + this.emit('}');
    };
    
    /**
     * Visit document node.
     */
    
    Compiler.prototype.document = function(node){
      var doc = '@' + (node.vendor || '') + 'document ' + node.document;
    
      return this.emit(doc, node.position)
        + this.emit('{')
        + this.mapVisit(node.rules)
        + this.emit('}');
    };
    
    /**
     * Visit charset node.
     */
    
    Compiler.prototype.charset = function(node){
      return this.emit('@charset ' + node.charset + ';', node.position);
    };
    
    /**
     * Visit namespace node.
     */
    
    Compiler.prototype.namespace = function(node){
      return this.emit('@namespace ' + node.namespace + ';', node.position);
    };
    
    /**
     * Visit supports node.
     */
    
    Compiler.prototype.supports = function(node){
      return this.emit('@supports ' + node.supports, node.position)
        + this.emit('{')
        + this.mapVisit(node.rules)
        + this.emit('}');
    };
    
    /**
     * Visit keyframes node.
     */
    
    Compiler.prototype.keyframes = function(node){
      return this.emit('@'
        + (node.vendor || '')
        + 'keyframes '
        + node.name, node.position)
        + this.emit('{')
        + this.mapVisit(node.keyframes)
        + this.emit('}');
    };
    
    /**
     * Visit keyframe node.
     */
    
    Compiler.prototype.keyframe = function(node){
      var decls = node.declarations;
    
      return this.emit(node.values.join(','), node.position)
        + this.emit('{')
        + this.mapVisit(decls)
        + this.emit('}');
    };
    
    /**
     * Visit page node.
     */
    
    Compiler.prototype.page = function(node){
      var sel = node.selectors.length
        ? node.selectors.join(', ')
        : '';
    
      return this.emit('@page ' + sel, node.position)
        + this.emit('{')
        + this.mapVisit(node.declarations)
        + this.emit('}');
    };
    
    /**
     * Visit font-face node.
     */
    
    Compiler.prototype['font-face'] = function(node){
      return this.emit('@font-face', node.position)
        + this.emit('{')
        + this.mapVisit(node.declarations)
        + this.emit('}');
    };
    
    /**
     * Visit host node.
     */
    
    Compiler.prototype.host = function(node){
      return this.emit('@host', node.position)
        + this.emit('{')
        + this.mapVisit(node.rules)
        + this.emit('}');
    };
    
    /**
     * Visit custom-media node.
     */
    
    Compiler.prototype['custom-media'] = function(node){
      return this.emit('@custom-media ' + node.name + ' ' + node.media + ';', node.position);
    };
    
    /**
     * Visit rule node.
     */
    
    Compiler.prototype.rule = function(node){
      var decls = node.declarations;
      if (!decls.length) return '';
    
      return this.emit(node.selectors.join(','), node.position)
        + this.emit('{')
        + this.mapVisit(decls)
        + this.emit('}');
    };
    
    /**
     * Visit declaration node.
     */
    
    Compiler.prototype.declaration = function(node){
      return this.emit(node.property + ':' + node.value, node.position) + this.emit(';');
    };
    
    
  provide("css/lib/stringify/compress", module.exports);
}(global));

// pakmanager:css/lib/stringify/identity
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Base =  require('css/lib/stringify/compiler');
    var inherits = require('inherits');
    
    /**
     * Expose compiler.
     */
    
    module.exports = Compiler;
    
    /**
     * Initialize a new `Compiler`.
     */
    
    function Compiler(options) {
      options = options || {};
      Base.call(this, options);
      this.indentation = options.indent;
    }
    
    /**
     * Inherit from `Base.prototype`.
     */
    
    inherits(Compiler, Base);
    
    /**
     * Compile `node`.
     */
    
    Compiler.prototype.compile = function(node){
      return this.stylesheet(node);
    };
    
    /**
     * Visit stylesheet node.
     */
    
    Compiler.prototype.stylesheet = function(node){
      return this.mapVisit(node.stylesheet.rules, '\n\n');
    };
    
    /**
     * Visit comment node.
     */
    
    Compiler.prototype.comment = function(node){
      return this.emit(this.indent() + '/*' + node.comment + '*/', node.position);
    };
    
    /**
     * Visit import node.
     */
    
    Compiler.prototype.import = function(node){
      return this.emit('@import ' + node.import + ';', node.position);
    };
    
    /**
     * Visit media node.
     */
    
    Compiler.prototype.media = function(node){
      return this.emit('@media ' + node.media, node.position)
        + this.emit(
            ' {\n'
            + this.indent(1))
        + this.mapVisit(node.rules, '\n\n')
        + this.emit(
            this.indent(-1)
            + '\n}');
    };
    
    /**
     * Visit document node.
     */
    
    Compiler.prototype.document = function(node){
      var doc = '@' + (node.vendor || '') + 'document ' + node.document;
    
      return this.emit(doc, node.position)
        + this.emit(
            ' '
          + ' {\n'
          + this.indent(1))
        + this.mapVisit(node.rules, '\n\n')
        + this.emit(
            this.indent(-1)
            + '\n}');
    };
    
    /**
     * Visit charset node.
     */
    
    Compiler.prototype.charset = function(node){
      return this.emit('@charset ' + node.charset + ';', node.position);
    };
    
    /**
     * Visit namespace node.
     */
    
    Compiler.prototype.namespace = function(node){
      return this.emit('@namespace ' + node.namespace + ';', node.position);
    };
    
    /**
     * Visit supports node.
     */
    
    Compiler.prototype.supports = function(node){
      return this.emit('@supports ' + node.supports, node.position)
        + this.emit(
          ' {\n'
          + this.indent(1))
        + this.mapVisit(node.rules, '\n\n')
        + this.emit(
            this.indent(-1)
            + '\n}');
    };
    
    /**
     * Visit keyframes node.
     */
    
    Compiler.prototype.keyframes = function(node){
      return this.emit('@' + (node.vendor || '') + 'keyframes ' + node.name, node.position)
        + this.emit(
          ' {\n'
          + this.indent(1))
        + this.mapVisit(node.keyframes, '\n')
        + this.emit(
            this.indent(-1)
            + '}');
    };
    
    /**
     * Visit keyframe node.
     */
    
    Compiler.prototype.keyframe = function(node){
      var decls = node.declarations;
    
      return this.emit(this.indent())
        + this.emit(node.values.join(', '), node.position)
        + this.emit(
          ' {\n'
          + this.indent(1))
        + this.mapVisit(decls, '\n')
        + this.emit(
          this.indent(-1)
          + '\n'
          + this.indent() + '}\n');
    };
    
    /**
     * Visit page node.
     */
    
    Compiler.prototype.page = function(node){
      var sel = node.selectors.length
        ? node.selectors.join(', ') + ' '
        : '';
    
      return this.emit('@page ' + sel, node.position)
        + this.emit('{\n')
        + this.emit(this.indent(1))
        + this.mapVisit(node.declarations, '\n')
        + this.emit(this.indent(-1))
        + this.emit('\n}');
    };
    
    /**
     * Visit font-face node.
     */
    
    Compiler.prototype['font-face'] = function(node){
      return this.emit('@font-face ', node.position)
        + this.emit('{\n')
        + this.emit(this.indent(1))
        + this.mapVisit(node.declarations, '\n')
        + this.emit(this.indent(-1))
        + this.emit('\n}');
    };
    
    /**
     * Visit host node.
     */
    
    Compiler.prototype.host = function(node){
      return this.emit('@host', node.position)
        + this.emit(
            ' {\n'
            + this.indent(1))
        + this.mapVisit(node.rules, '\n\n')
        + this.emit(
            this.indent(-1)
            + '\n}');
    };
    
    /**
     * Visit custom-media node.
     */
    
    Compiler.prototype['custom-media'] = function(node){
      return this.emit('@custom-media ' + node.name + ' ' + node.media + ';', node.position);
    };
    
    /**
     * Visit rule node.
     */
    
    Compiler.prototype.rule = function(node){
      var indent = this.indent();
      var decls = node.declarations;
      if (!decls.length) return '';
    
      return this.emit(node.selectors.map(function(s){ return indent + s }).join(',\n'), node.position)
        + this.emit(' {\n')
        + this.emit(this.indent(1))
        + this.mapVisit(decls, '\n')
        + this.emit(this.indent(-1))
        + this.emit('\n' + this.indent() + '}');
    };
    
    /**
     * Visit declaration node.
     */
    
    Compiler.prototype.declaration = function(node){
      return this.emit(this.indent())
        + this.emit(node.property + ': ' + node.value, node.position)
        + this.emit(';');
    };
    
    /**
     * Increase, decrease or return current indentation.
     */
    
    Compiler.prototype.indent = function(level) {
      this.level = this.level || 1;
    
      if (null != level) {
        this.level += level;
        return '';
      }
    
      return Array(this.level).join(this.indentation || '  ');
    };
    
  provide("css/lib/stringify/identity", module.exports);
}(global));

// pakmanager:css/lib/stringify/source-map-support
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var SourceMap = require('source-map').SourceMapGenerator;
    var SourceMapConsumer = require('source-map').SourceMapConsumer;
    var sourceMapResolve = require('source-map-resolve');
    var urix = require('urix');
    var fs = require('fs');
    var path = require('path');
    
    /**
     * Expose `mixin()`.
     */
    
    module.exports = mixin;
    
    /**
     * Mixin source map support into `compiler`.
     *
     * @param {Compiler} compiler
     * @api public
     */
    
    function mixin(compiler) {
      compiler._comment = compiler.comment;
      compiler.map = new SourceMap();
      compiler.position = { line: 1, column: 1 };
      compiler.files = {};
      for (var k in exports) compiler[k] = exports[k];
    }
    
    /**
     * Update position.
     *
     * @param {String} str
     * @api private
     */
    
    exports.updatePosition = function(str) {
      var lines = str.match(/\n/g);
      if (lines) this.position.line += lines.length;
      var i = str.lastIndexOf('\n');
      this.position.column = ~i ? str.length - i : this.position.column + str.length;
    };
    
    /**
     * Emit `str`.
     *
     * @param {String} str
     * @param {Object} [pos]
     * @return {String}
     * @api private
     */
    
    exports.emit = function(str, pos) {
      if (pos) {
        var sourceFile = urix(pos.source || 'source.css');
    
        this.map.addMapping({
          source: sourceFile,
          generated: {
            line: this.position.line,
            column: Math.max(this.position.column - 1, 0)
          },
          original: {
            line: pos.start.line,
            column: pos.start.column - 1
          }
        });
    
        this.addFile(sourceFile, pos);
      }
    
      this.updatePosition(str);
    
      return str;
    };
    
    /**
     * Adds a file to the source map output if it has not already been added
     * @param {String} file
     * @param {Object} pos
     */
    
    exports.addFile = function(file, pos) {
      if (typeof pos.content !== 'string') return;
      if (Object.prototype.hasOwnProperty.call(this.files, file)) return;
    
      this.files[file] = pos.content;
    };
    
    /**
     * Applies any original source maps to the output and embeds the source file
     * contents in the source map.
     */
    
    exports.applySourceMaps = function() {
      Object.keys(this.files).forEach(function(file) {
        var content = this.files[file];
        this.map.setSourceContent(file, content);
    
        if (this.options.inputSourcemaps !== false) {
          var originalMap = sourceMapResolve.resolveSync(
            content, file, fs.readFileSync);
          if (originalMap) {
            var map = new SourceMapConsumer(originalMap.map);
            var relativeTo = originalMap.sourcesRelativeTo;
            this.map.applySourceMap(map, file, urix(path.dirname(relativeTo)));
          }
        }
      }, this);
    };
    
    /**
     * Process comments, drops sourceMap comments.
     * @param {Object} node
     */
    
    exports.comment = function(node) {
      if (/^# sourceMappingURL=/.test(node.comment))
        return this.emit('', node.position);
      else
        return this._comment(node);
    };
    
  provide("css/lib/stringify/source-map-support", module.exports);
}(global));

// pakmanager:css/lib/parse
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // http://www.w3.org/TR/CSS21/grammar.html
    // https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
    var commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g
    
    module.exports = function(css, options){
      options = options || {};
    
      /**
       * Positional.
       */
    
      var lineno = 1;
      var column = 1;
    
      /**
       * Update lineno and column based on `str`.
       */
    
      function updatePosition(str) {
        var lines = str.match(/\n/g);
        if (lines) lineno += lines.length;
        var i = str.lastIndexOf('\n');
        column = ~i ? str.length - i : column + str.length;
      }
    
      /**
       * Mark position and patch `node.position`.
       */
    
      function position() {
        var start = { line: lineno, column: column };
        return function(node){
          node.position = new Position(start);
          whitespace();
          return node;
        };
      }
    
      /**
       * Store position information for a node
       */
    
      function Position(start) {
        this.start = start;
        this.end = { line: lineno, column: column };
        this.source = options.source;
      }
    
      /**
       * Non-enumerable source string
       */
    
      Position.prototype.content = css;
    
      /**
       * Error `msg`.
       */
    
      var errorsList = [];
    
      function error(msg) {
        var err = new Error(options.source + ':' + lineno + ':' + column + ': ' + msg);
        err.reason = msg;
        err.filename = options.source;
        err.line = lineno;
        err.column = column;
        err.source = css;
    
        if (options.silent) {
          errorsList.push(err);
        } else {
          throw err;
        }
      }
    
      /**
       * Parse stylesheet.
       */
    
      function stylesheet() {
        var rulesList = rules();
    
        return {
          type: 'stylesheet',
          stylesheet: {
            rules: rulesList,
            parsingErrors: errorsList
          }
        };
      }
    
      /**
       * Opening brace.
       */
    
      function open() {
        return match(/^{\s*/);
      }
    
      /**
       * Closing brace.
       */
    
      function close() {
        return match(/^}/);
      }
    
      /**
       * Parse ruleset.
       */
    
      function rules() {
        var node;
        var rules = [];
        whitespace();
        comments(rules);
        while (css.length && css.charAt(0) != '}' && (node = atrule() || rule())) {
          if (node !== false) {
            rules.push(node);
            comments(rules);
          }
        }
        return rules;
      }
    
      /**
       * Match `re` and return captures.
       */
    
      function match(re) {
        var m = re.exec(css);
        if (!m) return;
        var str = m[0];
        updatePosition(str);
        css = css.slice(str.length);
        return m;
      }
    
      /**
       * Parse whitespace.
       */
    
      function whitespace() {
        match(/^\s*/);
      }
    
      /**
       * Parse comments;
       */
    
      function comments(rules) {
        var c;
        rules = rules || [];
        while (c = comment()) {
          if (c !== false) {
            rules.push(c);
          }
        }
        return rules;
      }
    
      /**
       * Parse comment.
       */
    
      function comment() {
        var pos = position();
        if ('/' != css.charAt(0) || '*' != css.charAt(1)) return;
    
        var i = 2;
        while ("" != css.charAt(i) && ('*' != css.charAt(i) || '/' != css.charAt(i + 1))) ++i;
        i += 2;
    
        if ("" === css.charAt(i-1)) {
          return error('End of comment missing');
        }
    
        var str = css.slice(2, i - 2);
        column += 2;
        updatePosition(str);
        css = css.slice(i);
        column += 2;
    
        return pos({
          type: 'comment',
          comment: str
        });
      }
    
      /**
       * Parse selector.
       */
    
      function selector() {
        var m = match(/^([^{]+)/);
        if (!m) return;
        /* @fix Remove all comments from selectors
         * http://ostermiller.org/findcomment.html */
        return trim(m[0])
          .replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, '')
          .replace(/(?:"[^"]*"|'[^']*')/g, function(m) {
            return m.replace(/,/g, '\u200C');
          })
          .split(/\s*(?![^(]*\)),\s*/)
          .map(function(s) {
            return s.replace(/\u200C/g, ',');
          });
      }
    
      /**
       * Parse declaration.
       */
    
      function declaration() {
        var pos = position();
    
        // prop
        var prop = match(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
        if (!prop) return;
        prop = trim(prop[0]);
    
        // :
        if (!match(/^:\s*/)) return error("property missing ':'");
    
        // val
        var val = match(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/);
    
        var ret = pos({
          type: 'declaration',
          property: prop.replace(commentre, ''),
          value: val ? trim(val[0]).replace(commentre, '') : ''
        });
    
        // ;
        match(/^[;\s]*/);
    
        return ret;
      }
    
      /**
       * Parse declarations.
       */
    
      function declarations() {
        var decls = [];
    
        if (!open()) return error("missing '{'");
        comments(decls);
    
        // declarations
        var decl;
        while (decl = declaration()) {
          if (decl !== false) {
            decls.push(decl);
            comments(decls);
          }
        }
    
        if (!close()) return error("missing '}'");
        return decls;
      }
    
      /**
       * Parse keyframe.
       */
    
      function keyframe() {
        var m;
        var vals = [];
        var pos = position();
    
        while (m = match(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/)) {
          vals.push(m[1]);
          match(/^,\s*/);
        }
    
        if (!vals.length) return;
    
        return pos({
          type: 'keyframe',
          values: vals,
          declarations: declarations()
        });
      }
    
      /**
       * Parse keyframes.
       */
    
      function atkeyframes() {
        var pos = position();
        var m = match(/^@([-\w]+)?keyframes\s*/);
    
        if (!m) return;
        var vendor = m[1];
    
        // identifier
        var m = match(/^([-\w]+)\s*/);
        if (!m) return error("@keyframes missing name");
        var name = m[1];
    
        if (!open()) return error("@keyframes missing '{'");
    
        var frame;
        var frames = comments();
        while (frame = keyframe()) {
          frames.push(frame);
          frames = frames.concat(comments());
        }
    
        if (!close()) return error("@keyframes missing '}'");
    
        return pos({
          type: 'keyframes',
          name: name,
          vendor: vendor,
          keyframes: frames
        });
      }
    
      /**
       * Parse supports.
       */
    
      function atsupports() {
        var pos = position();
        var m = match(/^@supports *([^{]+)/);
    
        if (!m) return;
        var supports = trim(m[1]);
    
        if (!open()) return error("@supports missing '{'");
    
        var style = comments().concat(rules());
    
        if (!close()) return error("@supports missing '}'");
    
        return pos({
          type: 'supports',
          supports: supports,
          rules: style
        });
      }
    
      /**
       * Parse host.
       */
    
      function athost() {
        var pos = position();
        var m = match(/^@host\s*/);
    
        if (!m) return;
    
        if (!open()) return error("@host missing '{'");
    
        var style = comments().concat(rules());
    
        if (!close()) return error("@host missing '}'");
    
        return pos({
          type: 'host',
          rules: style
        });
      }
    
      /**
       * Parse media.
       */
    
      function atmedia() {
        var pos = position();
        var m = match(/^@media *([^{]+)/);
    
        if (!m) return;
        var media = trim(m[1]);
    
        if (!open()) return error("@media missing '{'");
    
        var style = comments().concat(rules());
    
        if (!close()) return error("@media missing '}'");
    
        return pos({
          type: 'media',
          media: media,
          rules: style
        });
      }
    
    
      /**
       * Parse custom-media.
       */
    
      function atcustommedia() {
        var pos = position();
        var m = match(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
        if (!m) return;
    
        return pos({
          type: 'custom-media',
          name: trim(m[1]),
          media: trim(m[2])
        });
      }
    
      /**
       * Parse paged media.
       */
    
      function atpage() {
        var pos = position();
        var m = match(/^@page */);
        if (!m) return;
    
        var sel = selector() || [];
    
        if (!open()) return error("@page missing '{'");
        var decls = comments();
    
        // declarations
        var decl;
        while (decl = declaration()) {
          decls.push(decl);
          decls = decls.concat(comments());
        }
    
        if (!close()) return error("@page missing '}'");
    
        return pos({
          type: 'page',
          selectors: sel,
          declarations: decls
        });
      }
    
      /**
       * Parse document.
       */
    
      function atdocument() {
        var pos = position();
        var m = match(/^@([-\w]+)?document *([^{]+)/);
        if (!m) return;
    
        var vendor = trim(m[1]);
        var doc = trim(m[2]);
    
        if (!open()) return error("@document missing '{'");
    
        var style = comments().concat(rules());
    
        if (!close()) return error("@document missing '}'");
    
        return pos({
          type: 'document',
          document: doc,
          vendor: vendor,
          rules: style
        });
      }
    
      /**
       * Parse font-face.
       */
    
      function atfontface() {
        var pos = position();
        var m = match(/^@font-face\s*/);
        if (!m) return;
    
        if (!open()) return error("@font-face missing '{'");
        var decls = comments();
    
        // declarations
        var decl;
        while (decl = declaration()) {
          decls.push(decl);
          decls = decls.concat(comments());
        }
    
        if (!close()) return error("@font-face missing '}'");
    
        return pos({
          type: 'font-face',
          declarations: decls
        });
      }
    
      /**
       * Parse import
       */
    
      var atimport = _compileAtrule('import');
    
      /**
       * Parse charset
       */
    
      var atcharset = _compileAtrule('charset');
    
      /**
       * Parse namespace
       */
    
      var atnamespace = _compileAtrule('namespace');
    
      /**
       * Parse non-block at-rules
       */
    
    
      function _compileAtrule(name) {
        var re = new RegExp('^@' + name + '\\s*([^;]+);');
        return function() {
          var pos = position();
          var m = match(re);
          if (!m) return;
          var ret = { type: name };
          ret[name] = m[1].trim();
          return pos(ret);
        }
      }
    
      /**
       * Parse at rule.
       */
    
      function atrule() {
        if (css[0] != '@') return;
    
        return atkeyframes()
          || atmedia()
          || atcustommedia()
          || atsupports()
          || atimport()
          || atcharset()
          || atnamespace()
          || atdocument()
          || atpage()
          || athost()
          || atfontface();
      }
    
      /**
       * Parse rule.
       */
    
      function rule() {
        var pos = position();
        var sel = selector();
    
        if (!sel) return error('selector missing');
        comments();
    
        return pos({
          type: 'rule',
          selectors: sel,
          declarations: declarations()
        });
      }
    
      return addParent(stylesheet());
    };
    
    /**
     * Trim `str`.
     */
    
    function trim(str) {
      return str ? str.replace(/^\s+|\s+$/g, '') : '';
    }
    
    /**
     * Adds non-enumerable parent node reference to each node.
     */
    
    function addParent(obj, parent) {
      var isNode = obj && typeof obj.type === 'string';
      var childParent = isNode ? obj : parent;
    
      for (var k in obj) {
        var value = obj[k];
        if (Array.isArray(value)) {
          value.forEach(function(v) { addParent(v, childParent); });
        } else if (value && typeof value === 'object') {
          addParent(value, childParent);
        }
      }
    
      if (isNode) {
        Object.defineProperty(obj, 'parent', {
          configurable: true,
          writable: true,
          enumerable: false,
          value: parent || null
        });
      }
    
      return obj;
    }
    
  provide("css/lib/parse", module.exports);
}(global));

// pakmanager:css/lib/stringify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Compressed =  require('css/lib/stringify/compress');
    var Identity =  require('css/lib/stringify/identity');
    
    /**
     * Stringfy the given AST `node`.
     *
     * Options:
     *
     *  - `compress` space-optimized output
     *  - `sourcemap` return an object with `.code` and `.map`
     *
     * @param {Object} node
     * @param {Object} [options]
     * @return {String}
     * @api public
     */
    
    module.exports = function(node, options){
      options = options || {};
    
      var compiler = options.compress
        ? new Compressed(options)
        : new Identity(options);
    
      // source maps
      if (options.sourcemap) {
        var sourcemaps =  require('css/lib/stringify/source-map-support');
        sourcemaps(compiler);
    
        var code = compiler.compile(node);
        compiler.applySourceMaps();
    
        var map = options.sourcemap === 'generator'
          ? compiler.map
          : compiler.map.toJSON();
    
        return { code: code, map: map };
      }
    
      var code = compiler.compile(node);
      return code;
    };
    
  provide("css/lib/stringify", module.exports);
}(global));

// pakmanager:css
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports.parse =  require('css/lib/parse');
    exports.stringify =  require('css/lib/stringify');
    
  provide("css", module.exports);
}(global));

// pakmanager:clone
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var clone = (function() {
    'use strict';
    
    /**
     * Clones (copies) an Object using deep copying.
     *
     * This function supports circular references by default, but if you are certain
     * there are no circular references in your object, you can save some CPU time
     * by calling clone(obj, false).
     *
     * Caution: if `circular` is false and `parent` contains circular references,
     * your program may enter an infinite loop and crash.
     *
     * @param `parent` - the object to be cloned
     * @param `circular` - set to true if the object to be cloned may contain
     *    circular references. (optional - true by default)
     * @param `depth` - set to a number if the object is only to be cloned to
     *    a particular depth. (optional - defaults to Infinity)
     * @param `prototype` - sets the prototype to be used when cloning an object.
     *    (optional - defaults to parent prototype).
    */
    function clone(parent, circular, depth, prototype) {
      var filter;
      if (typeof circular === 'object') {
        depth = circular.depth;
        prototype = circular.prototype;
        filter = circular.filter;
        circular = circular.circular
      }
      // maintain two arrays for circular references, where corresponding parents
      // and children have the same index
      var allParents = [];
      var allChildren = [];
    
      var useBuffer = typeof Buffer != 'undefined';
    
      if (typeof circular == 'undefined')
        circular = true;
    
      if (typeof depth == 'undefined')
        depth = Infinity;
    
      // recurse this function so we don't reset allParents and allChildren
      function _clone(parent, depth) {
        // cloning null always returns null
        if (parent === null)
          return null;
    
        if (depth == 0)
          return parent;
    
        var child;
        var proto;
        if (typeof parent != 'object') {
          return parent;
        }
    
        if (clone.__isArray(parent)) {
          child = [];
        } else if (clone.__isRegExp(parent)) {
          child = new RegExp(parent.source, __getRegExpFlags(parent));
          if (parent.lastIndex) child.lastIndex = parent.lastIndex;
        } else if (clone.__isDate(parent)) {
          child = new Date(parent.getTime());
        } else if (useBuffer && Buffer.isBuffer(parent)) {
          child = new Buffer(parent.length);
          parent.copy(child);
          return child;
        } else {
          if (typeof prototype == 'undefined') {
            proto = Object.getPrototypeOf(parent);
            child = Object.create(proto);
          }
          else {
            child = Object.create(prototype);
            proto = prototype;
          }
        }
    
        if (circular) {
          var index = allParents.indexOf(parent);
    
          if (index != -1) {
            return allChildren[index];
          }
          allParents.push(parent);
          allChildren.push(child);
        }
    
        for (var i in parent) {
          var attrs;
          if (proto) {
            attrs = Object.getOwnPropertyDescriptor(proto, i);
          }
    
          if (attrs && attrs.set == null) {
            continue;
          }
          child[i] = _clone(parent[i], depth - 1);
        }
    
        return child;
      }
    
      return _clone(parent, depth);
    }
    
    /**
     * Simple flat clone using prototype, accepts only objects, usefull for property
     * override on FLAT configuration object (no nested props).
     *
     * USE WITH CAUTION! This may not behave as you wish if you do not know how this
     * works.
     */
    clone.clonePrototype = function clonePrototype(parent) {
      if (parent === null)
        return null;
    
      var c = function () {};
      c.prototype = parent;
      return new c();
    };
    
    // private utility functions
    
    function __objToStr(o) {
      return Object.prototype.toString.call(o);
    };
    clone.__objToStr = __objToStr;
    
    function __isDate(o) {
      return typeof o === 'object' && __objToStr(o) === '[object Date]';
    };
    clone.__isDate = __isDate;
    
    function __isArray(o) {
      return typeof o === 'object' && __objToStr(o) === '[object Array]';
    };
    clone.__isArray = __isArray;
    
    function __isRegExp(o) {
      return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
    };
    clone.__isRegExp = __isRegExp;
    
    function __getRegExpFlags(re) {
      var flags = '';
      if (re.global) flags += 'g';
      if (re.ignoreCase) flags += 'i';
      if (re.multiline) flags += 'm';
      return flags;
    };
    clone.__getRegExpFlags = __getRegExpFlags;
    
    return clone;
    })();
    
    if (typeof module === 'object' && module.exports) {
      module.exports = clone;
    }
    
  provide("clone", module.exports);
}(global));

// pakmanager:uglify-js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var path = require("path");
    var fs = require("fs");
    var vm = require("vm");
    
    var UglifyJS = vm.createContext({
        console       : console,
        process       : process,
        Buffer        : Buffer,
        MOZ_SourceMap : require("source-map")
    });
    
    function load_global(file) {
        file = path.resolve(path.dirname(module.filename), file);
        try {
            var code = fs.readFileSync(file, "utf8");
            return vm.runInContext(code, UglifyJS, file);
        } catch(ex) {
            // XXX: in case of a syntax error, the message is kinda
            // useless. (no location information).
            console.log("ERROR in file: " + file + " / " + ex);
            process.exit(1);
        }
    };
    
    var FILES = exports.FILES = [
        "../lib/utils.js",
        "../lib/ast.js",
        "../lib/parse.js",
        "../lib/transform.js",
        "../lib/scope.js",
        "../lib/output.js",
        "../lib/compress.js",
        "../lib/sourcemap.js",
        "../lib/mozilla-ast.js",
        "../lib/propmangle.js"
    ].map(function(file){
        return fs.realpathSync(path.join(path.dirname(__filename), file));
    });
    
    FILES.forEach(load_global);
    
    UglifyJS.AST_Node.warn_function = function(txt) {
        console.error("WARN: %s", txt);
    };
    
    // XXX: perhaps we shouldn't export everything but heck, I'm lazy.
    for (var i in UglifyJS) {
        if (UglifyJS.hasOwnProperty(i)) {
            exports[i] = UglifyJS[i];
        }
    }
    
    exports.minify = function(files, options) {
        options = UglifyJS.defaults(options, {
            spidermonkey : false,
            outSourceMap : null,
            sourceRoot   : null,
            inSourceMap  : null,
            fromString   : false,
            warnings     : false,
            mangle       : {},
            output       : null,
            compress     : {}
        });
        UglifyJS.base54.reset();
    
        // 1. parse
        var toplevel = null,
            sourcesContent = {};
    
        if (options.spidermonkey) {
            toplevel = UglifyJS.AST_Node.from_mozilla_ast(files);
        } else {
            if (typeof files == "string")
                files = [ files ];
            files.forEach(function(file){
                var code = options.fromString
                    ? file
                    : fs.readFileSync(file, "utf8");
                sourcesContent[file] = code;
                toplevel = UglifyJS.parse(code, {
                    filename: options.fromString ? "?" : file,
                    toplevel: toplevel
                });
            });
        }
    
        // 2. compress
        if (options.compress) {
            var compress = { warnings: options.warnings };
            UglifyJS.merge(compress, options.compress);
            toplevel.figure_out_scope();
            var sq = UglifyJS.Compressor(compress);
            toplevel = toplevel.transform(sq);
        }
    
        // 3. mangle
        if (options.mangle) {
            toplevel.figure_out_scope(options.mangle);
            toplevel.compute_char_frequency(options.mangle);
            toplevel.mangle_names(options.mangle);
        }
    
        // 4. output
        var inMap = options.inSourceMap;
        var output = {};
        if (typeof options.inSourceMap == "string") {
            inMap = fs.readFileSync(options.inSourceMap, "utf8");
        }
        if (options.outSourceMap) {
            output.source_map = UglifyJS.SourceMap({
                file: options.outSourceMap,
                orig: inMap,
                root: options.sourceRoot
            });
            if (options.sourceMapIncludeSources) {
                for (var file in sourcesContent) {
                    if (sourcesContent.hasOwnProperty(file)) {
                        output.source_map.get().setSourceContent(file, sourcesContent[file]);
                    }
                }
            }
    
        }
        if (options.output) {
            UglifyJS.merge(output, options.output);
        }
        var stream = UglifyJS.OutputStream(output);
        toplevel.print(stream);
    
        if(options.outSourceMap){
            stream += "\n//# sourceMappingURL=" + options.outSourceMap;
        }
    
        var source_map = output.source_map;
        if (source_map) {
            source_map = source_map + "";
        }
    
        return {
            code : stream + "",
            map  : source_map
        };
    };
    
    // exports.describe_ast = function() {
    //     function doitem(ctor) {
    //         var sub = {};
    //         ctor.SUBCLASSES.forEach(function(ctor){
    //             sub[ctor.TYPE] = doitem(ctor);
    //         });
    //         var ret = {};
    //         if (ctor.SELF_PROPS.length > 0) ret.props = ctor.SELF_PROPS;
    //         if (ctor.SUBCLASSES.length > 0) ret.sub = sub;
    //         return ret;
    //     }
    //     return doitem(UglifyJS.AST_Node).sub;
    // }
    
    exports.describe_ast = function() {
        var out = UglifyJS.OutputStream({ beautify: true });
        function doitem(ctor) {
            out.print("AST_" + ctor.TYPE);
            var props = ctor.SELF_PROPS.filter(function(prop){
                return !/^\$/.test(prop);
            });
            if (props.length > 0) {
                out.space();
                out.with_parens(function(){
                    props.forEach(function(prop, i){
                        if (i) out.space();
                        out.print(prop);
                    });
                });
            }
            if (ctor.documentation) {
                out.space();
                out.print_string(ctor.documentation);
            }
            if (ctor.SUBCLASSES.length > 0) {
                out.space();
                out.with_block(function(){
                    ctor.SUBCLASSES.forEach(function(ctor, i){
                        out.indent();
                        doitem(ctor);
                        out.newline();
                    });
                });
            }
        };
        doitem(UglifyJS.AST_Node);
        return out + "";
    };
    
    function readReservedFile(filename, reserved) {
        if (!reserved) {
            reserved = { vars: [], props: [] };
        }
        var data = fs.readFileSync(filename, "utf8");
        data = JSON.parse(data);
        if (data.vars) {
            data.vars.forEach(function(name){
                UglifyJS.push_uniq(reserved.vars, name);
            });
        }
        if (data.props) {
            data.props.forEach(function(name){
                UglifyJS.push_uniq(reserved.props, name);
            });
        }
        return reserved;
    }
    
    exports.readReservedFile = readReservedFile;
    
    exports.readDefaultReservedFile = function(reserved) {
        return readReservedFile(path.join(__dirname, "domprops.json"), reserved);
    };
    
    exports.readNameCache = function(filename, key) {
        var cache = null;
        if (filename) {
            try {
                var cache = fs.readFileSync(filename, "utf8");
                cache = JSON.parse(cache)[key];
                if (!cache) throw "init";
                cache.props = UglifyJS.Dictionary.fromObject(cache.props);
            } catch(ex) {
                cache = {
                    cname: -1,
                    props: new UglifyJS.Dictionary()
                };
            }
        }
        return cache;
    };
    
    exports.writeNameCache = function(filename, key, cache) {
        if (filename) {
            var data;
            try {
                data = fs.readFileSync(filename, "utf8");
                data = JSON.parse(data);
            } catch(ex) {
                data = {};
            }
            data[key] = {
                cname: cache.cname,
                props: cache.props.toObject()
            };
            fs.writeFileSync(filename, JSON.stringify(data, null, 2), "utf8");
        }
    };
    
  provide("uglify-js", module.exports);
}(global));

// pakmanager:arrify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function (val) {
    	if (val == null) {
    		return [];
    	}
    
    	return Array.isArray(val) ? val : [val];
    };
    
  provide("arrify", module.exports);
}(global));

// pakmanager:micromatch/lib/chars
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var chars = {};
    
    /**
     * Regex for common characters
     */
    
    chars.escapeRegex = {
      '?': /\?/g,
      '@': /\@/g,
      '!': /\!/g,
      '+': /\+/g,
      '*': /\*/g,
      '(': /\(/g,
      ')': /\)/g,
      '[': /\[/g,
      ']': /\]/g,
    };
    
    /**
     * Escape characters
     */
    
    chars.ESC = {
      '?': '__UNESC_QMRK__',
      '@': '__UNESC_AMPE__',
      '!': '__UNESC_EXCL__',
      '+': '__UNESC_PLUS__',
      '*': '__UNESC_STAR__',
      ',': '__UNESC_COMMA__',
      '(': '__UNESC_LTPAREN__',
      ')': '__UNESC_RTPAREN__',
      '[': '__UNESC_LTBRACK__',
      ']': '__UNESC_RTBRACK__',
    };
    
    /**
     * Unescape characters
     */
    
    chars.UNESC = {
      '__UNESC_QMRK__'   : '\\?',
      '__UNESC_AMPE__'   : '\\@',
      '__UNESC_EXCL__'   : '\\!',
      '__UNESC_PLUS__'   : '\\+',
      '__UNESC_STAR__'   : '\\*',
      '__UNESC_COMMA__'  : '\\*',
      '__UNESC_LTPAREN__': '\\(',
      '__UNESC_RTPAREN__': '\\)',
      '__UNESC_LTBRACK__': '\\[',
      '__UNESC_RTBRACK__': '\\]',
    };
    
    chars.ESC_TEMP = {
      '?': '__TEMP_QMRK__',
      '@': '__TEMP_AMPE__',
      '!': '__TEMP_EXCL__',
      '*': '__TEMP_STAR__',
      '+': '__TEMP_PLUS__',
      ',': '__TEMP_COMMA__',
      '(': '__TEMP_LTPAREN__',
      ')': '__TEMP_RTPAREN__',
      '[': '__TEMP_LTBRACK__',
      ']': '__TEMP_RTBRACK__',
    };
    
    chars.TEMP = {
      '__TEMP_QMRK__'   : '?',
      '__TEMP_AMPE__'   : '@',
      '__TEMP_EXCL__'   : '!',
      '__TEMP_STAR__'   : '*',
      '__TEMP_PLUS__'   : '+',
      '__TEMP_COMMA__'  : ',',
      '__TEMP_LTPAREN__': '(',
      '__TEMP_RTPAREN__': ')',
      '__TEMP_LTBRACK__': '[',
      '__TEMP_RTBRACK__': ']',
    };
    
    module.exports = chars;
    
  provide("micromatch/lib/chars", module.exports);
}(global));

// pakmanager:micromatch/lib/utils
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var path = require('path');
    var fileRe = require('filename-regex');
    var win32 = process && process.platform === 'win32';
    var win;
    
    var utils = {};
    
    utils.filename = function filename(fp) {
      var seg = fp.match(fileRe());
      return seg && seg[0];
    };
    
    utils.isPath = function isPath(pattern, opts) {
      return function (fp) {
        return utils.unixify(fp, opts) === pattern;
      };
    };
    
    utils.hasPath = function hasPath(pattern, opts) {
      return function (fp) {
        return utils.unixify(fp, opts).indexOf(pattern) !== -1;
      };
    };
    
    utils.matchPath = function matchPath(pattern, opts) {
      var fn = (opts && opts.contains)
        ? utils.hasPath(pattern, opts)
        : utils.isPath(pattern, opts);
      return fn;
    };
    
    utils.hasFilename = function hasFilename(re) {
      return function (fp) {
        var name = utils.filename(fp);
        return name && re.test(name);
      };
    };
    
    /**
     * Coerce `val` to an array
     *
     * @param  {*} val
     * @return {Array}
     */
    
    utils.arrayify = function arrayify(val) {
      return !Array.isArray(val)
        ? [val]
        : val;
    };
    
    /**
     * Convert a file path to a unix path.
     */
    
    utils.unixify = function unixify(fp, opts) {
      if (opts && opts.unixify === false) return fp;
      if (opts && opts.unixify === true || win32 || path.sep === '\\') {
        return fp.split('\\').join('/');
      }
      return fp;
    };
    
    /**
     * Escape/unescape utils
     */
    
    utils.escapePath = function escapePath(fp) {
      return fp.replace(/[\\.]/g, '\\$&');
    };
    
    utils.unescapeGlob = function unescapeGlob(fp) {
      return fp.replace(/[\\"']/g, '');
    };
    
    utils.escapeRe = function escapeRe(str) {
      return str.replace(/[-[\\$*+?.#^\s{}(|)\]]/g, '\\$&');
    };
    
    /**
     * Expose `utils`
     */
    
    module.exports = utils;
    
  provide("micromatch/lib/utils", module.exports);
}(global));

// pakmanager:micromatch/lib/glob
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var brackets = require('expand-brackets');
    var braces = require('braces');
    var parse = require('parse-glob');
    var chars =  require('micromatch/lib/chars');
    
    /**
     * Expose `Glob`
     */
    
    module.exports = Glob;
    
    function Glob(pattern, options) {
      this.options = options || {};
      this.pattern = pattern;
      this.history = [];
      this.tokens = {};
      this.init(pattern);
    }
    
    /**
     * Initialize defaults
     */
    
    Glob.prototype.init = function(pattern) {
      this.orig = pattern;
      this.negated = this.isNegated();
      this.options.track = this.options.track || false;
      this.options.dot = this.options.dot || this.options.dotfiles;
      this.options.makeRe = true;
    };
    
    /**
     * Push a change into `glob.history`. Useful
     * for debugging.
     */
    
    Glob.prototype.track = function(msg) {
      if (this.options.track) {
        this.history.push({msg: msg, pattern: this.pattern});
      }
    };
    
    /**
     * Return true if the glob pattern has the given
     * `ch`aracter.
     *
     * @param  {String} `pattern`
     * @param  {String} `ch`
     * @return {Boolean}
     */
    
    Glob.prototype.has = function(pattern, ch) {
      if (ch instanceof RegExp) {
        return ch.test(pattern);
      }
      return pattern.indexOf(ch) !== -1;
    };
    
    /**
     * Return true if `glob.pattern` was negated
     * with `!`. Also removes the `!` from the pattern.
     *
     * @return {Boolean}
     */
    
    Glob.prototype.isNegated = function() {
      if (this.pattern.charCodeAt(0) === 33 /* '!' */) {
        this.pattern = this.pattern.slice(1);
        return true;
      }
      return false;
    };
    
    /**
     * Return true if the glob pattern has braces
     *
     * @param  {String} `pattern`
     * @return {Boolean}
     */
    
    Glob.prototype.hasBraces = function(pattern) {
      return this.has((pattern || this.pattern), '{');
    };
    
    /**
     * Expand braces in the given glob pattern.
     *
     * We only need to use the [braces] lib when
     * patterns are nested.
     */
    
    Glob.prototype.braces = function() {
      if (this.hasBraces() && this.options.nobraces !== true) {
        var a = this.pattern.match(/[\{\(\[]/g);
        var b = this.pattern.match(/[\}\)\]]/g);
        if (a && b && (a.length !== b.length)) {
          this.options.makeRe = false;
        }
        var expanded = braces(this.pattern, this.options);
        this.pattern = expanded.join('|');
      }
    };
    
    /**
     * Return true if the glob pattern has a POSIX
     * bracket expression (character class)
     *
     * @param  {String} `pattern`
     * @return {Boolean}
     */
    
    Glob.prototype.hasBrackets = function(pattern) {
      return this.has((pattern || this.pattern), '[:');
    };
    
    /**
     * Expand bracket expressions in `glob.pattern`
     */
    
    Glob.prototype.brackets = function() {
      if (this.hasBrackets() && this.options.nobrackets !== true) {
        this.pattern = brackets(this.pattern);
      }
    };
    
    /**
     * Parse the given glob `pattern` or `glob.pattern`
     */
    
    Glob.prototype.parse = function(pattern) {
      this.tokens = parse(pattern || this.pattern, true);
      return this.tokens;
    };
    
    /**
     * Replace `a` with `b`. Also tracks the change before and
     * after each replacement. This is disabled by default, but
     * can be enabled by setting `options.track` to true.
     *
     * Also, when the pattern is a string, `.split()` is used,
     * because it's much faster than replace.
     *
     * @param  {RegExp|String} `a`
     * @param  {String} `b`
     * @param  {Boolean} `escape` When `true`, escapes `*` and `?` in the replacement.
     * @return {String}
     */
    
    Glob.prototype._replace = function(a, b, escape) {
      this.track('before (find): "' + a + '" (replace with): "' + b + '"');
      if (escape) b = esc(b);
      if (a && b && typeof a === 'string') {
        this.pattern = this.pattern.split(a).join(b);
      } else if (a instanceof RegExp) {
        this.pattern = this.pattern.replace(a, b);
      }
      this.track('after');
    };
    
    /**
     * Escape special characters in the given string.
     *
     * @param  {String} `str` Glob pattern
     * @return {String}
     */
    
    Glob.prototype.escape = function(str) {
      this.track('before escape: ');
      var re = /["\\](['"]?[^"'\\]['"]?)/g;
    
      this.pattern = str.replace(re, function($0, $1) {
        var o = chars.ESC;
        var ch = o && o[$1];
        if (ch) {
          return ch;
        }
        if (/[a-z]/i.test($0)) {
          return $0.split('\\').join('');
        }
        return $0;
      });
    
      this.track('after escape: ');
    };
    
    /**
     * Unescape special characters in the given string.
     *
     * @param  {String} `str`
     * @return {String}
     */
    
    Glob.prototype.unescape = function(str) {
      var re = /__([A-Z]+)_([A-Z]+)__/g;
      this.pattern = str.replace(re, function($0, $1) {
        return chars[$1][$0];
      });
    };
    
    /**
     * Escape utils
     */
    
    function esc(str) {
      str = str.split('?').join('%~');
      str = str.split('*').join('%%');
      return str;
    }
    
  provide("micromatch/lib/glob", module.exports);
}(global));

// pakmanager:micromatch/lib/expand
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * micromatch <https://github.com/jonschlinkert/micromatch>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var utils =  require('micromatch/lib/utils');
    var Glob =  require('micromatch/lib/glob');
    
    /**
     * Expose `expand`
     */
    
    module.exports = expand;
    
    /**
     * Expand a glob pattern to resolve braces and
     * similar patterns before converting to regex.
     *
     * @param  {String|Array} `pattern`
     * @param  {Array} `files`
     * @param  {Options} `opts`
     * @return {Array}
     */
    
    function expand(pattern, options) {
      if (typeof pattern !== 'string') {
        throw new TypeError('micromatch.expand(): argument should be a string.');
      }
    
      var glob = new Glob(pattern, options || {});
      var opts = glob.options;
    
      // return early if glob pattern matches special patterns
      if (specialCase(pattern) && opts.safemode) {
        return new RegExp(utils.escapeRe(pattern), 'g');
      }
    
      if (opts.nonegate !== true) {
        opts.negated = glob.negated;
      }
    
      glob._replace('/.', '/\\.');
    
      // parse the glob pattern into tokens
      glob.parse();
    
      var tok = glob.tokens;
      tok.is.negated = opts.negated;
    
      if (tok.is.dotfile) {
        glob.options.dot = true;
        opts.dot = true;
      }
    
      if (!tok.is.glob) {
        return {
          pattern: utils.escapePath(glob.pattern),
          tokens: tok,
          options: opts
        };
      }
    
      // see if it might be a dotfile pattern
      if (/[{,]\./.test(glob.pattern)) {
        opts.makeRe = false;
        opts.dot = true;
      }
    
      // expand braces, e.g `{1..5}`
      glob.track('before brackets');
      if (tok.is.brackets) {
        glob.brackets();
      }
      glob.track('before braces');
      if (tok.is.braces) {
        glob.braces();
      }
    
      glob.track('after braces');
    
      glob._replace('[]', '\\[\\]');
      glob._replace('(?', '__QMARK_GROUP__');
    
      // windows drives
      glob._replace(/^(\w):([\\\/]+?)/gi, lookahead + '$1:$2', true);
    
      // negate slashes in exclusion ranges
      if (glob.pattern.indexOf('[^') !== -1) {
        glob.pattern = negateSlash(glob.pattern);
      }
    
      if (glob.pattern === '**' && opts.globstar !== false) {
         glob.pattern = globstar(opts);
    
      } else {
        if (/^\*\.\w*$/.test(glob.pattern)) {
          glob._replace('*', star(opts.dot) + '\\');
          glob._replace('__QMARK_GROUP__', '(?');
          return glob;
        }
    
        // '/*/*/*' => '(?:/*){3}'
        glob._replace(/(\/\*)+/g, function (match) {
          var len = match.length / 2;
          if (len === 1) { return match; }
          return '(?:\\/*){' + len + '}';
        });
    
        glob.pattern = balance(glob.pattern, '[', ']');
        glob.escape(glob.pattern);
    
        // if the glob is for one directory deep, we can
        // simplify the parsing and generated regex
        if (tok.path.dirname === '' && !tok.is.globstar) {
          glob.track('before expand filename');
          return expandFilename(glob, opts);
        }
    
        // if the pattern has `**`
        if (tok.is.globstar) {
          glob._replace(/\*{2,}/g, '**');
          glob.pattern = collapse(glob.pattern, '/**');
          glob.pattern = optionalGlobstar(glob.pattern);
    
          // reduce extraneous globstars
          glob._replace(/(^|[^\\])\*{2,}([^\\]|$)/g, '$1**$2');
    
          // 'foo/*'
          glob._replace(/(\w+)\*(?!\/)/g, '(?=.)$1[^/]*?', true);
          glob._replace('**', globstar(opts), true);
        }
    
        // ends with /*
        glob._replace(/\/\*$/, '\\/' + stardot(opts), true);
        // ends with *, no slashes
        glob._replace(/(?!\/)\*$/, boxQ, true);
        // has '*'
        glob._replace('*', stardot(opts), true);
        glob._replace('?.', '?\\.', true);
        glob._replace('?:', '?:', true);
    
        glob._replace(/\?+/g, function (match) {
          var len = match.length;
          if (len === 1) {
            return box;
          }
          return box + '{' + len + '}';
        });
    
        // escape '.abc' => '\\.abc'
        glob._replace(/\.([*\w]+)/g, '\\.$1');
        // fix '[^\\\\/]'
        glob._replace(/\[\^[\\\/]+\]/g, box);
        // '///' => '\/'
        glob._replace(/\/+/g, '\\/');
        // '\\\\\\' => '\\'
        glob._replace(/\\{2,}/g, '\\');
      }
    
      glob._replace('__QMARK_GROUP__', '(?');
      glob.unescape(glob.pattern);
      glob._replace('__UNESC_STAR__', '*');
      glob._replace('%~', '?');
      glob._replace('%%', '*');
      glob._replace('?.', '?\\.');
      glob._replace('[^\\/]', '[^/]');
      return glob;
    }
    
    /**
     * Expand the filename part of the glob into a regex
     * compatible string
     *
     * @param  {String} glob
     * @param  {Object} tok Tokens
     * @param  {Options} opts
     * @return {Object}
     */
    
    function expandFilename(glob, opts) {
      var tok = glob.tokens;
      switch (glob.pattern) {
        case '.':
          glob.pattern = '\\.';
          break;
        case '.*':
          glob.pattern = '\\..*';
          break;
        case '*.*':
          glob.pattern = star(opts.dot) + '\\.[^/]*?';
          break;
        case '*':
          glob.pattern = star(opts.dot);
          break;
        default:
        if (tok.path.filename === '*' && !tok.path.dirname) {
          glob.pattern = star(opts.dot) + '\\' + glob.pattern.slice(1);
        } else {
          glob._replace(/(?!\()\?/g, '[^/]');
          if (tok.path.basename.charAt(0) !== '.') {
            opts.dot = true;
          }
          glob._replace('*', star(opts.dot));
        }
      }
    
      if (glob.pattern.charAt(0) === '.') {
        glob.pattern = '\\' + glob.pattern;
      }
    
      glob._replace('__QMARK_GROUP__', '(?');
      glob.unescape(glob.pattern);
      glob._replace('__UNESC_STAR__', '*');
      glob._replace('%~', '?');
      glob._replace('%%', '*');
      return glob;
    }
    
    /**
     * Special cases
     */
    
    function specialCase(glob) {
      if (glob === '\\') {
        return true;
      }
      return false;
    }
    
    /**
     * Collapse repeated character sequences.
     *
     * ```js
     * collapse('a/../../../b', '../');
     * //=> 'a/../b'
     * ```
     *
     * @param  {String} `str`
     * @param  {String} `ch`
     * @return {String}
     */
    
    function collapse(str, ch, repeat) {
      var res = str.split(ch);
      var len = res.length;
      var isFirst = res[0] === '';
      var isLast = res[res.length - 1] === '';
      res = res.filter(Boolean);
      if (isFirst) {
        res.unshift('');
      }
      if (isLast) {
        res.push('');
      }
      var diff = len - res.length;
      if (repeat && diff >= 1) {
        ch = '(?:' + ch + '){' + (diff + 1) + '}';
      }
      return res.join(ch);
    }
    
    /**
     * Make globstars optional, as in glob spec:
     *
     * ```js
     * optionalGlobstar('a\/**\/b');
     * //=> '(?:a\/b|a\/**\/b)'
     * ```
     *
     * @param  {String} `str`
     * @return {String}
     */
    
    function optionalGlobstar(glob) {
      // globstars preceded and followed by a word character
      if (/[^\/]\/\*\*\/[^\/]/.test(glob)) {
        var tmp = glob.split('/**/').join('/');
        glob = '(?:' + tmp + '|' + glob + ')';
      // leading globstars
      } else if (/^\*\*\/[^\/]/.test(glob)) {
        glob = glob.split(/^\*\*\//).join('(^|.+\\/)');
      }
      return glob;
    }
    
    /**
     * Negate slashes in exclusion ranges, per glob spec:
     *
     * ```js
     * negateSlash('[^foo]');
     * //=> '[^\\/foo]'
     * ```
     *
     * @param  {[type]} str [description]
     * @return {[type]}
     */
    
    function negateSlash(str) {
      var re = /\[\^([^\]]*?)\]/g;
      return str.replace(re, function (match, inner) {
        if (inner.indexOf('/') === -1) {
          inner = '\\/' + inner;
        }
        return '[^' + inner + ']';
      });
    }
    
    /**
     * Escape imbalanced braces/bracket
     */
    
    function balance(str, a, b) {
      var aarr = str.split(a);
      var alen = aarr.join('').length;
      var blen = str.split(b).join('').length;
    
      if (alen !== blen) {
        str = aarr.join('\\' + a);
        return str.split(b).join('\\' + b);
      }
      return str;
    }
    
    /**
     * Escape utils
     */
    
    function esc(str) {
      str = str.split('?').join('%~');
      str = str.split('*').join('%%');
      return str;
    }
    
    /**
     * Special patterns to be converted to regex.
     * Heuristics are used to simplify patterns
     * and speed up processing.
     */
    
    var box         = '[^/]';
    var boxQ        = '[^/]*?';
    var lookahead   = '(?=.)';
    var nodot       = '(?!\\.)(?=.)';
    
    var ex = {};
    ex.dotfileGlob = '(?:^|\\/)(?:\\.{1,2})(?:$|\\/)';
    ex.stardot     = '(?!' + ex.dotfileGlob + ')(?=.)[^/]*?';
    ex.twoStarDot  = '(?:(?!' + ex.dotfileGlob + ').)*?';
    
    /**
     * Create a regex for `*`. If `dot` is true,
     * or the pattern does not begin with a leading
     * star, then return the simple regex.
     */
    
    function star(dotfile) {
      return dotfile ? boxQ : nodot + boxQ;
    }
    
    function dotstarbase(dotfile) {
      var re = dotfile ? ex.dotfileGlob : '\\.';
      return '(?!' + re + ')' + lookahead;
    }
    
    function globstar(opts) {
      if (opts.dot) { return ex.twoStarDot; }
      return '(?:(?!(?:^|\\/)\\.).)*?';
    }
    
    function stardot(opts) {
      return dotstarbase(opts && opts.dot) + '[^/]*?';
    }
    
  provide("micromatch/lib/expand", module.exports);
}(global));

// pakmanager:micromatch
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * micromatch <https://github.com/jonschlinkert/micromatch>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var diff = require('arr-diff');
    var debug = require('debug')('micromatch');
    var typeOf = require('kind-of');
    var omit = require('object.omit');
    var cache = require('regex-cache');
    var isGlob = require('is-glob');
    var expand =  require('micromatch/lib/expand');
    var utils =  require('micromatch/lib/utils');
    
    /**
     * The main function. Pass an array of filepaths,
     * and a string or array of glob patterns
     *
     * @param  {Array|String} `files`
     * @param  {Array|String} `patterns`
     * @param  {Object} `opts`
     * @return {Array} Array of matches
     */
    
    function micromatch(files, patterns, opts) {
      if (!files || !patterns) return [];
      opts = opts || {};
    
      if (typeof opts.cache === 'undefined') {
        opts.cache = true;
      }
    
      if (!Array.isArray(patterns)) {
        return match(files, patterns, opts);
      }
    
      var len = patterns.length, i = 0;
      var omit = [], keep = [];
    
      while (len--) {
        var glob = patterns[i++];
        if (glob.charCodeAt(0) === 33 /* ! */) {
          omit.push.apply(omit, match(files, glob.slice(1), opts));
        } else {
          keep.push.apply(keep, match(files, glob, opts));
        }
      }
      return diff(keep, omit);
    }
    
    /**
     * Pass an array of files and a glob pattern as a string.
     *
     * This function is called by the main `micromatch` function
     * If you only need to pass a single pattern you might get
     * very minor speed improvements using this function.
     *
     * @param  {Array} `files`
     * @param  {Array} `pattern`
     * @param  {Object} `options`
     * @return {Array}
     */
    
    function match(files, pattern, opts) {
      if (typeOf(files) !== 'string' && !Array.isArray(files)) {
        throw new Error(msg('match', 'files', 'a string or array'));
      }
    
      files = utils.arrayify(files);
      opts = opts || {};
    
      var negate = opts.negate || false;
      var orig = pattern;
    
      if (typeof pattern === 'string' && opts.nonegate !== true) {
        negate = pattern.charAt(0) === '!';
        if (negate) {
          pattern = pattern.slice(1);
        }
      }
    
      var _isMatch = matcher(pattern, opts);
      var len = files.length, i = 0;
      var res = [];
    
      while (i < len) {
        var file = files[i++];
        var fp = utils.unixify(file, opts);
    
        if (!_isMatch(fp)) { continue; }
        res.push(fp);
      }
    
      if (res.length === 0) {
        if (opts.failglob === true) {
          throw new Error('micromatch.match() found no matches for: "' + orig + '".');
        }
    
        if (opts.nonull || opts.nullglob) {
          res.push(utils.unescapeGlob(orig));
        }
      }
    
      // if `negate` was defined, diff negated files
      if (negate) { res = diff(files, res); }
    
      // if `ignore` was defined, diff ignored filed
      if (opts.ignore && opts.ignore.length) {
        pattern = opts.ignore;
        opts = omit(opts, ['ignore']);
        return diff(res, micromatch(res, pattern, opts));
      }
      return res;
    }
    
    /**
     * Returns a function that takes a glob pattern or array of glob patterns
     * to be used with `Array#filter()`. (Internally this function generates
     * the matching function using the [matcher] method).
     *
     * ```js
     * var fn = mm.filter('[a-c]');
     * ['a', 'b', 'c', 'd', 'e'].filter(fn);
     * //=> ['a', 'b', 'c']
     * ```
     *
     * @param  {String|Array} `patterns` Can be a glob or array of globs.
     * @param  {Options} `opts` Options to pass to the [matcher] method.
     * @return {Function} Filter function to be passed to `Array#filter()`.
     */
    
    function filter(patterns, opts) {
      if (!Array.isArray(patterns) && typeof patterns !== 'string') {
        throw new TypeError(msg('filter', 'patterns', 'a string or array'));
      }
    
      patterns = utils.arrayify(patterns);
      return function (fp) {
        if (fp == null) return [];
        var len = patterns.length, i = 0;
        var res = true;
    
        fp = utils.unixify(fp, opts);
        while (i < len) {
          var fn = matcher(patterns[i++], opts);
          if (!fn(fp)) {
            res = false;
            break;
          }
        }
        return res;
      };
    }
    
    /**
     * Returns true if the filepath contains the given
     * pattern. Can also return a function for matching.
     *
     * ```js
     * isMatch('foo.md', '*.md', {});
     * //=> true
     *
     * isMatch('*.md', {})('foo.md')
     * //=> true
     * ```
     *
     * @param  {String} `fp`
     * @param  {String} `pattern`
     * @param  {Object} `opts`
     * @return {Boolean}
     */
    
    function isMatch(fp, pattern, opts) {
      if (typeof fp !== 'string') {
        throw new TypeError(msg('isMatch', 'filepath', 'a string'));
      }
    
      fp = utils.unixify(fp, opts);
      if (typeOf(pattern) === 'object') {
        return matcher(fp, pattern);
      }
      return matcher(pattern, opts)(fp);
    }
    
    /**
     * Returns true if the filepath matches the
     * given pattern.
     */
    
    function contains(fp, pattern, opts) {
      if (typeof fp !== 'string') {
        throw new TypeError(msg('contains', 'pattern', 'a string'));
      }
    
      opts = opts || {};
      opts.contains = (pattern !== '');
      fp = utils.unixify(fp, opts);
    
      if (opts.contains && !isGlob(pattern)) {
        return fp.indexOf(pattern) !== -1;
      }
      return matcher(pattern, opts)(fp);
    }
    
    /**
     * Returns true if a file path matches any of the
     * given patterns.
     *
     * @param  {String} `fp` The filepath to test.
     * @param  {String|Array} `patterns` Glob patterns to use.
     * @param  {Object} `opts` Options to pass to the `matcher()` function.
     * @return {String}
     */
    
    function any(fp, patterns, opts) {
      if (!Array.isArray(patterns) && typeof patterns !== 'string') {
        throw new TypeError(msg('any', 'patterns', 'a string or array'));
      }
    
      patterns = utils.arrayify(patterns);
      var len = patterns.length;
    
      fp = utils.unixify(fp, opts);
      while (len--) {
        var isMatch = matcher(patterns[len], opts);
        if (isMatch(fp)) {
          return true;
        }
      }
      return false;
    }
    
    /**
     * Filter the keys of an object with the given `glob` pattern
     * and `options`
     *
     * @param  {Object} `object`
     * @param  {Pattern} `object`
     * @return {Array}
     */
    
    function matchKeys(obj, glob, options) {
      if (typeOf(obj) !== 'object') {
        throw new TypeError(msg('matchKeys', 'first argument', 'an object'));
      }
    
      var fn = matcher(glob, options);
      var res = {};
    
      for (var key in obj) {
        if (obj.hasOwnProperty(key) && fn(key)) {
          res[key] = obj[key];
        }
      }
      return res;
    }
    
    /**
     * Return a function for matching based on the
     * given `pattern` and `options`.
     *
     * @param  {String} `pattern`
     * @param  {Object} `options`
     * @return {Function}
     */
    
    function matcher(pattern, opts) {
      // pattern is a function
      if (typeof pattern === 'function') {
        return pattern;
      }
      // pattern is a regex
      if (pattern instanceof RegExp) {
        return function(fp) {
          return pattern.test(fp);
        };
      }
    
      // strings, all the way down...
      pattern = utils.unixify(pattern, opts);
    
      // pattern is a non-glob string
      if (!isGlob(pattern)) {
        return utils.matchPath(pattern, opts);
      }
      // pattern is a glob string
      var re = makeRe(pattern, opts);
    
      // `matchBase` is defined
      if (opts && opts.matchBase) {
        return utils.hasFilename(re, opts);
      }
      // `matchBase` is not defined
      return function(fp) {
        fp = utils.unixify(fp, opts);
        return re.test(fp);
      };
    }
    
    /**
     * Create and cache a regular expression for matching
     * file paths.
     *
     * If the leading character in the `glob` is `!`, a negation
     * regex is returned.
     *
     * @param  {String} `glob`
     * @param  {Object} `options`
     * @return {RegExp}
     */
    
    function toRegex(glob, options) {
      if (typeOf(glob) !== 'string') {
        throw new Error(msg('toRegex', 'glob', 'a string'));
      }
    
      // clone options to prevent  mutating the original object
      var opts = Object.create(options || {});
      var flags = opts.flags || '';
      if (opts.nocase && flags.indexOf('i') === -1) {
        flags += 'i';
      }
    
      var parsed = expand(glob, opts);
    
      // pass in tokens to avoid parsing more than once
      opts.negated = opts.negated || parsed.negated;
      opts.negate = opts.negated;
      glob = wrapGlob(parsed.pattern, opts);
      var re;
    
      try {
        re = new RegExp(glob, flags);
        return re;
      } catch (err) {
        var msg = 'micromatch invalid regex: (' + re + ')';
        if (opts.strict) throw new SyntaxError(msg + err);
      }
      return /$^/;
    }
    
    /**
     * Create the regex to do the matching. If the leading
     * character in the `glob` is `!` a negation regex is returned.
     *
     * @param {String} `glob`
     * @param {Boolean} `negate`
     */
    
    function wrapGlob(glob, opts) {
      var prefix = (opts && !opts.contains) ? '^' : '';
      var after = (opts && !opts.contains) ? '$' : '';
      glob = ('(?:' + glob + ')' + after);
      if (opts && opts.negate) {
        return prefix + ('(?!^' + glob + ').*$');
      }
      return prefix + glob;
    }
    
    /**
     * Wrap `toRegex` to memoize the generated regex
     * the string and options don't change
     */
    
    function makeRe(glob, opts) {
      return cache(toRegex, glob, opts);
    }
    
    /**
     * Make error messages consistent. Follows this format:
     *
     * ```js
     * msg(methodName, argNumber, nativeType);
     * // example:
     * msg('matchKeys', 'first', 'an object');
     * ```
     *
     * @param  {String} `method`
     * @param  {String} `num`
     * @param  {String} `type`
     * @return {String}
     */
    
    function msg(method, what, type) {
      return 'micromatch.' + method + '(): ' + what + ' should be ' + type + '.';
    }
    
    /**
     * Public methods
     */
    
    micromatch.any       = any;
    micromatch.braces    = micromatch.braceExpand = require('braces');
    micromatch.contains  = contains;
    micromatch.expand    = expand;
    micromatch.filter    = filter;
    micromatch.isMatch   = isMatch;
    micromatch.makeRe    = makeRe;
    micromatch.match     = match;
    micromatch.matcher   = matcher;
    micromatch.matchKeys = matchKeys;
    
    /**
     * Expose `micromatch`
     */
    
    module.exports = micromatch;
    
  provide("micromatch", module.exports);
}(global));

// pakmanager:graceful-fs/fs.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // eeeeeevvvvviiiiiiillllll
    // more evil than monkey-patching the native builtin?
    // Not sure.
    
    var mod = require("module")
    var pre = '(function (exports, require, module, __filename, __dirname) { '
    var post = '});'
    var src = pre + process.binding('natives').fs + post
    var vm = require('vm')
    var fn = vm.runInThisContext(src)
    fn(exports, require, module, __filename, __dirname)
    
  provide("graceful-fs/fs.js", module.exports);
}(global));

// pakmanager:graceful-fs/polyfills.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs =  require('graceful-fs/fs.js')
    var constants = require('constants')
    
    var origCwd = process.cwd
    var cwd = null
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process)
      return cwd
    }
    var chdir = process.chdir
    process.chdir = function(d) {
      cwd = null
      chdir.call(process, d)
    }
    
    // (re-)implement some things that are known busted or missing.
    
    // lchmod, broken prior to 0.6.2
    // back-port the fix here.
    if (constants.hasOwnProperty('O_SYMLINK') &&
        process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
      fs.lchmod = function (path, mode, callback) {
        callback = callback || noop
        fs.open( path
               , constants.O_WRONLY | constants.O_SYMLINK
               , mode
               , function (err, fd) {
          if (err) {
            callback(err)
            return
          }
          // prefer to return the chmod error, if one occurs,
          // but still try to close, and report closing errors if they occur.
          fs.fchmod(fd, mode, function (err) {
            fs.close(fd, function(err2) {
              callback(err || err2)
            })
          })
        })
      }
    
      fs.lchmodSync = function (path, mode) {
        var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)
    
        // prefer to return the chmod error, if one occurs,
        // but still try to close, and report closing errors if they occur.
        var err, err2
        try {
          var ret = fs.fchmodSync(fd, mode)
        } catch (er) {
          err = er
        }
        try {
          fs.closeSync(fd)
        } catch (er) {
          err2 = er
        }
        if (err || err2) throw (err || err2)
        return ret
      }
    }
    
    
    // lutimes implementation, or no-op
    if (!fs.lutimes) {
      if (constants.hasOwnProperty("O_SYMLINK")) {
        fs.lutimes = function (path, at, mt, cb) {
          fs.open(path, constants.O_SYMLINK, function (er, fd) {
            cb = cb || noop
            if (er) return cb(er)
            fs.futimes(fd, at, mt, function (er) {
              fs.close(fd, function (er2) {
                return cb(er || er2)
              })
            })
          })
        }
    
        fs.lutimesSync = function (path, at, mt) {
          var fd = fs.openSync(path, constants.O_SYMLINK)
            , err
            , err2
            , ret
    
          try {
            var ret = fs.futimesSync(fd, at, mt)
          } catch (er) {
            err = er
          }
          try {
            fs.closeSync(fd)
          } catch (er) {
            err2 = er
          }
          if (err || err2) throw (err || err2)
          return ret
        }
    
      } else if (fs.utimensat && constants.hasOwnProperty("AT_SYMLINK_NOFOLLOW")) {
        // maybe utimensat will be bound soonish?
        fs.lutimes = function (path, at, mt, cb) {
          fs.utimensat(path, at, mt, constants.AT_SYMLINK_NOFOLLOW, cb)
        }
    
        fs.lutimesSync = function (path, at, mt) {
          return fs.utimensatSync(path, at, mt, constants.AT_SYMLINK_NOFOLLOW)
        }
    
      } else {
        fs.lutimes = function (_a, _b, _c, cb) { process.nextTick(cb) }
        fs.lutimesSync = function () {}
      }
    }
    
    
    // https://github.com/isaacs/node-graceful-fs/issues/4
    // Chown should not fail on einval or eperm if non-root.
    // It should not fail on enosys ever, as this just indicates
    // that a fs doesn't support the intended operation.
    
    fs.chown = chownFix(fs.chown)
    fs.fchown = chownFix(fs.fchown)
    fs.lchown = chownFix(fs.lchown)
    
    fs.chmod = chownFix(fs.chmod)
    fs.fchmod = chownFix(fs.fchmod)
    fs.lchmod = chownFix(fs.lchmod)
    
    fs.chownSync = chownFixSync(fs.chownSync)
    fs.fchownSync = chownFixSync(fs.fchownSync)
    fs.lchownSync = chownFixSync(fs.lchownSync)
    
    fs.chmodSync = chownFix(fs.chmodSync)
    fs.fchmodSync = chownFix(fs.fchmodSync)
    fs.lchmodSync = chownFix(fs.lchmodSync)
    
    function chownFix (orig) {
      if (!orig) return orig
      return function (target, uid, gid, cb) {
        return orig.call(fs, target, uid, gid, function (er, res) {
          if (chownErOk(er)) er = null
          cb(er, res)
        })
      }
    }
    
    function chownFixSync (orig) {
      if (!orig) return orig
      return function (target, uid, gid) {
        try {
          return orig.call(fs, target, uid, gid)
        } catch (er) {
          if (!chownErOk(er)) throw er
        }
      }
    }
    
    // ENOSYS means that the fs doesn't support the op. Just ignore
    // that, because it doesn't matter.
    //
    // if there's no getuid, or if getuid() is something other
    // than 0, and the error is EINVAL or EPERM, then just ignore
    // it.
    //
    // This specific case is a silent failure in cp, install, tar,
    // and most other unix tools that manage permissions.
    //
    // When running as root, or if other types of errors are
    // encountered, then it's strict.
    function chownErOk (er) {
      if (!er)
        return true
    
      if (er.code === "ENOSYS")
        return true
    
      var nonroot = !process.getuid || process.getuid() !== 0
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM")
          return true
      }
    
      return false
    }
    
    
    // if lchmod/lchown do not exist, then make them no-ops
    if (!fs.lchmod) {
      fs.lchmod = function (path, mode, cb) {
        process.nextTick(cb)
      }
      fs.lchmodSync = function () {}
    }
    if (!fs.lchown) {
      fs.lchown = function (path, uid, gid, cb) {
        process.nextTick(cb)
      }
      fs.lchownSync = function () {}
    }
    
    
    
    // on Windows, A/V software can lock the directory, causing this
    // to fail with an EACCES or EPERM if the directory contains newly
    // created files.  Try again on failure, for up to 1 second.
    if (process.platform === "win32") {
      var rename_ = fs.rename
      fs.rename = function rename (from, to, cb) {
        var start = Date.now()
        rename_(from, to, function CB (er) {
          if (er
              && (er.code === "EACCES" || er.code === "EPERM")
              && Date.now() - start < 1000) {
            return rename_(from, to, CB)
          }
          if(cb) cb(er)
        })
      }
    }
    
    
    // if read() returns EAGAIN, then just try it again.
    var read = fs.read
    fs.read = function (fd, buffer, offset, length, position, callback_) {
      var callback
      if (callback_ && typeof callback_ === 'function') {
        var eagCounter = 0
        callback = function (er, _, __) {
          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter ++
            return read.call(fs, fd, buffer, offset, length, position, callback)
          }
          callback_.apply(this, arguments)
        }
      }
      return read.call(fs, fd, buffer, offset, length, position, callback)
    }
    
    var readSync = fs.readSync
    fs.readSync = function (fd, buffer, offset, length, position) {
      var eagCounter = 0
      while (true) {
        try {
          return readSync.call(fs, fd, buffer, offset, length, position)
        } catch (er) {
          if (er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter ++
            continue
          }
          throw er
        }
      }
    }
    
    
  provide("graceful-fs/polyfills.js", module.exports);
}(global));

// pakmanager:graceful-fs
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Monkey-patching the fs module.
    // It's ugly, but there is simply no other way to do this.
    var fs = module.exports =  require('graceful-fs/fs.js')
    
    var assert = require('assert')
    
    // fix up some busted stuff, mostly on windows and old nodes
     require('graceful-fs/polyfills.js')
    
    var util = require('util')
    
    function noop () {}
    
    var debug = noop
    if (util.debuglog)
      debug = util.debuglog('gfs')
    else if (/\bgfs\b/i.test(process.env.NODE_DEBUG || ''))
      debug = function() {
        var m = util.format.apply(util, arguments)
        m = 'GFS: ' + m.split(/\n/).join('\nGFS: ')
        console.error(m)
      }
    
    if (/\bgfs\b/i.test(process.env.NODE_DEBUG || '')) {
      process.on('exit', function() {
        debug('fds', fds)
        debug(queue)
        assert.equal(queue.length, 0)
      })
    }
    
    
    var originalOpen = fs.open
    fs.open = open
    
    function open(path, flags, mode, cb) {
      if (typeof mode === "function") cb = mode, mode = null
      if (typeof cb !== "function") cb = noop
      new OpenReq(path, flags, mode, cb)
    }
    
    function OpenReq(path, flags, mode, cb) {
      this.path = path
      this.flags = flags
      this.mode = mode
      this.cb = cb
      Req.call(this)
    }
    
    util.inherits(OpenReq, Req)
    
    OpenReq.prototype.process = function() {
      originalOpen.call(fs, this.path, this.flags, this.mode, this.done)
    }
    
    var fds = {}
    OpenReq.prototype.done = function(er, fd) {
      debug('open done', er, fd)
      if (fd)
        fds['fd' + fd] = this.path
      Req.prototype.done.call(this, er, fd)
    }
    
    
    var originalReaddir = fs.readdir
    fs.readdir = readdir
    
    function readdir(path, cb) {
      if (typeof cb !== "function") cb = noop
      new ReaddirReq(path, cb)
    }
    
    function ReaddirReq(path, cb) {
      this.path = path
      this.cb = cb
      Req.call(this)
    }
    
    util.inherits(ReaddirReq, Req)
    
    ReaddirReq.prototype.process = function() {
      originalReaddir.call(fs, this.path, this.done)
    }
    
    ReaddirReq.prototype.done = function(er, files) {
      if (files && files.sort)
        files = files.sort()
      Req.prototype.done.call(this, er, files)
      onclose()
    }
    
    
    var originalClose = fs.close
    fs.close = close
    
    function close (fd, cb) {
      debug('close', fd)
      if (typeof cb !== "function") cb = noop
      delete fds['fd' + fd]
      originalClose.call(fs, fd, function(er) {
        onclose()
        cb(er)
      })
    }
    
    
    var originalCloseSync = fs.closeSync
    fs.closeSync = closeSync
    
    function closeSync (fd) {
      try {
        return originalCloseSync(fd)
      } finally {
        onclose()
      }
    }
    
    
    // Req class
    function Req () {
      // start processing
      this.done = this.done.bind(this)
      this.failures = 0
      this.process()
    }
    
    Req.prototype.done = function (er, result) {
      var tryAgain = false
      if (er) {
        var code = er.code
        var tryAgain = code === "EMFILE"
        if (process.platform === "win32")
          tryAgain = tryAgain || code === "OK"
      }
    
      if (tryAgain) {
        this.failures ++
        enqueue(this)
      } else {
        var cb = this.cb
        cb(er, result)
      }
    }
    
    var queue = []
    
    function enqueue(req) {
      queue.push(req)
      debug('enqueue %d %s', queue.length, req.constructor.name, req)
    }
    
    function onclose() {
      var req = queue.shift()
      if (req) {
        debug('process', req.constructor.name, req)
        req.process()
      }
    }
    
  provide("graceful-fs", module.exports);
}(global));

// pakmanager:minimatch
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = minimatch
    minimatch.Minimatch = Minimatch
    
    var path = { sep: '/' }
    try {
      path = require('path')
    } catch (er) {}
    
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
    var expand = require('brace-expansion')
    
    // any single thing other than /
    // don't need to escape / when using new RegExp()
    var qmark = '[^/]'
    
    // * => any number of characters
    var star = qmark + '*?'
    
    // ** when dots are allowed.  Anything goes, except .. and .
    // not (^ or / followed by one or two dots followed by $ or /),
    // followed by anything, any number of times.
    var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'
    
    // not a ^ or / followed by a dot,
    // followed by anything, any number of times.
    var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'
    
    // characters that need to be escaped in RegExp.
    var reSpecials = charSet('().*{}+?[]^$\\!')
    
    // "abc" -> { a:true, b:true, c:true }
    function charSet (s) {
      return s.split('').reduce(function (set, c) {
        set[c] = true
        return set
      }, {})
    }
    
    // normalizes slashes.
    var slashSplit = /\/+/
    
    minimatch.filter = filter
    function filter (pattern, options) {
      options = options || {}
      return function (p, i, list) {
        return minimatch(p, pattern, options)
      }
    }
    
    function ext (a, b) {
      a = a || {}
      b = b || {}
      var t = {}
      Object.keys(b).forEach(function (k) {
        t[k] = b[k]
      })
      Object.keys(a).forEach(function (k) {
        t[k] = a[k]
      })
      return t
    }
    
    minimatch.defaults = function (def) {
      if (!def || !Object.keys(def).length) return minimatch
    
      var orig = minimatch
    
      var m = function minimatch (p, pattern, options) {
        return orig.minimatch(p, pattern, ext(def, options))
      }
    
      m.Minimatch = function Minimatch (pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options))
      }
    
      return m
    }
    
    Minimatch.defaults = function (def) {
      if (!def || !Object.keys(def).length) return Minimatch
      return minimatch.defaults(def).Minimatch
    }
    
    function minimatch (p, pattern, options) {
      if (typeof pattern !== 'string') {
        throw new TypeError('glob pattern string required')
      }
    
      if (!options) options = {}
    
      // shortcut: comments match nothing.
      if (!options.nocomment && pattern.charAt(0) === '#') {
        return false
      }
    
      // "" only matches ""
      if (pattern.trim() === '') return p === ''
    
      return new Minimatch(pattern, options).match(p)
    }
    
    function Minimatch (pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options)
      }
    
      if (typeof pattern !== 'string') {
        throw new TypeError('glob pattern string required')
      }
    
      if (!options) options = {}
      pattern = pattern.trim()
    
      // windows support: need to use /, not \
      if (path.sep !== '/') {
        pattern = pattern.split(path.sep).join('/')
      }
    
      this.options = options
      this.set = []
      this.pattern = pattern
      this.regexp = null
      this.negate = false
      this.comment = false
      this.empty = false
    
      // make the set of regexps etc.
      this.make()
    }
    
    Minimatch.prototype.debug = function () {}
    
    Minimatch.prototype.make = make
    function make () {
      // don't do it more than once.
      if (this._made) return
    
      var pattern = this.pattern
      var options = this.options
    
      // empty patterns and comments match nothing.
      if (!options.nocomment && pattern.charAt(0) === '#') {
        this.comment = true
        return
      }
      if (!pattern) {
        this.empty = true
        return
      }
    
      // step 1: figure out negation, etc.
      this.parseNegate()
    
      // step 2: expand braces
      var set = this.globSet = this.braceExpand()
    
      if (options.debug) this.debug = console.error
    
      this.debug(this.pattern, set)
    
      // step 3: now we have a set, so turn each one into a series of path-portion
      // matching patterns.
      // These will be regexps, except in the case of "**", which is
      // set to the GLOBSTAR object for globstar behavior,
      // and will not contain any / characters
      set = this.globParts = set.map(function (s) {
        return s.split(slashSplit)
      })
    
      this.debug(this.pattern, set)
    
      // glob --> regexps
      set = set.map(function (s, si, set) {
        return s.map(this.parse, this)
      }, this)
    
      this.debug(this.pattern, set)
    
      // filter out everything that didn't compile properly.
      set = set.filter(function (s) {
        return s.indexOf(false) === -1
      })
    
      this.debug(this.pattern, set)
    
      this.set = set
    }
    
    Minimatch.prototype.parseNegate = parseNegate
    function parseNegate () {
      var pattern = this.pattern
      var negate = false
      var options = this.options
      var negateOffset = 0
    
      if (options.nonegate) return
    
      for (var i = 0, l = pattern.length
        ; i < l && pattern.charAt(i) === '!'
        ; i++) {
        negate = !negate
        negateOffset++
      }
    
      if (negateOffset) this.pattern = pattern.substr(negateOffset)
      this.negate = negate
    }
    
    // Brace expansion:
    // a{b,c}d -> abd acd
    // a{b,}c -> abc ac
    // a{0..3}d -> a0d a1d a2d a3d
    // a{b,c{d,e}f}g -> abg acdfg acefg
    // a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
    //
    // Invalid sets are not expanded.
    // a{2..}b -> a{2..}b
    // a{b}c -> a{b}c
    minimatch.braceExpand = function (pattern, options) {
      return braceExpand(pattern, options)
    }
    
    Minimatch.prototype.braceExpand = braceExpand
    
    function braceExpand (pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options
        } else {
          options = {}
        }
      }
    
      pattern = typeof pattern === 'undefined'
        ? this.pattern : pattern
    
      if (typeof pattern === 'undefined') {
        throw new Error('undefined pattern')
      }
    
      if (options.nobrace ||
        !pattern.match(/\{.*\}/)) {
        // shortcut. no need to expand.
        return [pattern]
      }
    
      return expand(pattern)
    }
    
    // parse a component of the expanded set.
    // At this point, no pattern may contain "/" in it
    // so we're going to return a 2d array, where each entry is the full
    // pattern, split on '/', and then turned into a regular expression.
    // A regexp is made at the end which joins each array with an
    // escaped /, and another full one which joins each regexp with |.
    //
    // Following the lead of Bash 4.1, note that "**" only has special meaning
    // when it is the *only* thing in a path portion.  Otherwise, any series
    // of * is equivalent to a single *.  Globstar behavior is enabled by
    // default, and can be disabled by setting options.noglobstar.
    Minimatch.prototype.parse = parse
    var SUBPARSE = {}
    function parse (pattern, isSub) {
      var options = this.options
    
      // shortcuts
      if (!options.noglobstar && pattern === '**') return GLOBSTAR
      if (pattern === '') return ''
    
      var re = ''
      var hasMagic = !!options.nocase
      var escaping = false
      // ? => one single character
      var patternListStack = []
      var plType
      var stateChar
      var inClass = false
      var reClassStart = -1
      var classStart = -1
      // . and .. never match anything that doesn't start with .,
      // even when options.dot is set.
      var patternStart = pattern.charAt(0) === '.' ? '' // anything
      // not (start or / followed by . or .. followed by / or end)
      : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
      : '(?!\\.)'
      var self = this
    
      function clearStateChar () {
        if (stateChar) {
          // we had some state-tracking character
          // that wasn't consumed by this pass.
          switch (stateChar) {
            case '*':
              re += star
              hasMagic = true
            break
            case '?':
              re += qmark
              hasMagic = true
            break
            default:
              re += '\\' + stateChar
            break
          }
          self.debug('clearStateChar %j %j', stateChar, re)
          stateChar = false
        }
      }
    
      for (var i = 0, len = pattern.length, c
        ; (i < len) && (c = pattern.charAt(i))
        ; i++) {
        this.debug('%s\t%s %s %j', pattern, i, re, c)
    
        // skip over any that are escaped.
        if (escaping && reSpecials[c]) {
          re += '\\' + c
          escaping = false
          continue
        }
    
        switch (c) {
          case '/':
            // completely not allowed, even escaped.
            // Should already be path-split by now.
            return false
    
          case '\\':
            clearStateChar()
            escaping = true
          continue
    
          // the various stateChar values
          // for the "extglob" stuff.
          case '?':
          case '*':
          case '+':
          case '@':
          case '!':
            this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)
    
            // all of those are literals inside a class, except that
            // the glob [!a] means [^a] in regexp
            if (inClass) {
              this.debug('  in class')
              if (c === '!' && i === classStart + 1) c = '^'
              re += c
              continue
            }
    
            // if we already have a stateChar, then it means
            // that there was something like ** or +? in there.
            // Handle the stateChar, then proceed with this one.
            self.debug('call clearStateChar %j', stateChar)
            clearStateChar()
            stateChar = c
            // if extglob is disabled, then +(asdf|foo) isn't a thing.
            // just clear the statechar *now*, rather than even diving into
            // the patternList stuff.
            if (options.noext) clearStateChar()
          continue
    
          case '(':
            if (inClass) {
              re += '('
              continue
            }
    
            if (!stateChar) {
              re += '\\('
              continue
            }
    
            plType = stateChar
            patternListStack.push({ type: plType, start: i - 1, reStart: re.length })
            // negation is (?:(?!js)[^/]*)
            re += stateChar === '!' ? '(?:(?!' : '(?:'
            this.debug('plType %j %j', stateChar, re)
            stateChar = false
          continue
    
          case ')':
            if (inClass || !patternListStack.length) {
              re += '\\)'
              continue
            }
    
            clearStateChar()
            hasMagic = true
            re += ')'
            plType = patternListStack.pop().type
            // negation is (?:(?!js)[^/]*)
            // The others are (?:<pattern>)<type>
            switch (plType) {
              case '!':
                re += '[^/]*?)'
                break
              case '?':
              case '+':
              case '*':
                re += plType
                break
              case '@': break // the default anyway
            }
          continue
    
          case '|':
            if (inClass || !patternListStack.length || escaping) {
              re += '\\|'
              escaping = false
              continue
            }
    
            clearStateChar()
            re += '|'
          continue
    
          // these are mostly the same in regexp and glob
          case '[':
            // swallow any state-tracking char before the [
            clearStateChar()
    
            if (inClass) {
              re += '\\' + c
              continue
            }
    
            inClass = true
            classStart = i
            reClassStart = re.length
            re += c
          continue
    
          case ']':
            //  a right bracket shall lose its special
            //  meaning and represent itself in
            //  a bracket expression if it occurs
            //  first in the list.  -- POSIX.2 2.8.3.2
            if (i === classStart + 1 || !inClass) {
              re += '\\' + c
              escaping = false
              continue
            }
    
            // handle the case where we left a class open.
            // "[z-a]" is valid, equivalent to "\[z-a\]"
            if (inClass) {
              // split where the last [ was, make sure we don't have
              // an invalid re. if so, re-walk the contents of the
              // would-be class to re-translate any characters that
              // were passed through as-is
              // TODO: It would probably be faster to determine this
              // without a try/catch and a new RegExp, but it's tricky
              // to do safely.  For now, this is safe and works.
              var cs = pattern.substring(classStart + 1, i)
              try {
                RegExp('[' + cs + ']')
              } catch (er) {
                // not a valid class!
                var sp = this.parse(cs, SUBPARSE)
                re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
                hasMagic = hasMagic || sp[1]
                inClass = false
                continue
              }
            }
    
            // finish up the class.
            hasMagic = true
            inClass = false
            re += c
          continue
    
          default:
            // swallow any state char that wasn't consumed
            clearStateChar()
    
            if (escaping) {
              // no need
              escaping = false
            } else if (reSpecials[c]
              && !(c === '^' && inClass)) {
              re += '\\'
            }
    
            re += c
    
        } // switch
      } // for
    
      // handle the case where we left a class open.
      // "[abc" is valid, equivalent to "\[abc"
      if (inClass) {
        // split where the last [ was, and escape it
        // this is a huge pita.  We now have to re-walk
        // the contents of the would-be class to re-translate
        // any characters that were passed through as-is
        cs = pattern.substr(classStart + 1)
        sp = this.parse(cs, SUBPARSE)
        re = re.substr(0, reClassStart) + '\\[' + sp[0]
        hasMagic = hasMagic || sp[1]
      }
    
      // handle the case where we had a +( thing at the *end*
      // of the pattern.
      // each pattern list stack adds 3 chars, and we need to go through
      // and escape any | chars that were passed through as-is for the regexp.
      // Go through and escape them, taking care not to double-escape any
      // | chars that were already escaped.
      for (var pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + 3)
        // maybe some even number of \, then maybe 1 \, followed by a |
        tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function (_, $1, $2) {
          if (!$2) {
            // the | isn't already escaped, so escape it.
            $2 = '\\'
          }
    
          // need to escape all those slashes *again*, without escaping the
          // one that we need for escaping the | character.  As it works out,
          // escaping an even number of slashes can be done by simply repeating
          // it exactly after itself.  That's why this trick works.
          //
          // I am sorry that you have to see this.
          return $1 + $1 + $2 + '|'
        })
    
        this.debug('tail=%j\n   %s', tail, tail)
        var t = pl.type === '*' ? star
          : pl.type === '?' ? qmark
          : '\\' + pl.type
    
        hasMagic = true
        re = re.slice(0, pl.reStart) + t + '\\(' + tail
      }
    
      // handle trailing things that only matter at the very end.
      clearStateChar()
      if (escaping) {
        // trailing \\
        re += '\\\\'
      }
    
      // only need to apply the nodot start if the re starts with
      // something that could conceivably capture a dot
      var addPatternStart = false
      switch (re.charAt(0)) {
        case '.':
        case '[':
        case '(': addPatternStart = true
      }
    
      // if the re is not "" at this point, then we need to make sure
      // it doesn't match against an empty path part.
      // Otherwise a/* will match a/, which it should not.
      if (re !== '' && hasMagic) re = '(?=.)' + re
    
      if (addPatternStart) re = patternStart + re
    
      // parsing just a piece of a larger pattern.
      if (isSub === SUBPARSE) {
        return [re, hasMagic]
      }
    
      // skip the regexp for non-magical patterns
      // unescape anything in it, though, so that it'll be
      // an exact match against a file etc.
      if (!hasMagic) {
        return globUnescape(pattern)
      }
    
      var flags = options.nocase ? 'i' : ''
      var regExp = new RegExp('^' + re + '$', flags)
    
      regExp._glob = pattern
      regExp._src = re
    
      return regExp
    }
    
    minimatch.makeRe = function (pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe()
    }
    
    Minimatch.prototype.makeRe = makeRe
    function makeRe () {
      if (this.regexp || this.regexp === false) return this.regexp
    
      // at this point, this.set is a 2d array of partial
      // pattern strings, or "**".
      //
      // It's better to use .match().  This function shouldn't
      // be used, really, but it's pretty convenient sometimes,
      // when you just want to work with a regex.
      var set = this.set
    
      if (!set.length) {
        this.regexp = false
        return this.regexp
      }
      var options = this.options
    
      var twoStar = options.noglobstar ? star
        : options.dot ? twoStarDot
        : twoStarNoDot
      var flags = options.nocase ? 'i' : ''
    
      var re = set.map(function (pattern) {
        return pattern.map(function (p) {
          return (p === GLOBSTAR) ? twoStar
          : (typeof p === 'string') ? regExpEscape(p)
          : p._src
        }).join('\\\/')
      }).join('|')
    
      // must match entire pattern
      // ending in a * or ** will make it less strict.
      re = '^(?:' + re + ')$'
    
      // can match anything, as long as it's not this.
      if (this.negate) re = '^(?!' + re + ').*$'
    
      try {
        this.regexp = new RegExp(re, flags)
      } catch (ex) {
        this.regexp = false
      }
      return this.regexp
    }
    
    minimatch.match = function (list, pattern, options) {
      options = options || {}
      var mm = new Minimatch(pattern, options)
      list = list.filter(function (f) {
        return mm.match(f)
      })
      if (mm.options.nonull && !list.length) {
        list.push(pattern)
      }
      return list
    }
    
    Minimatch.prototype.match = match
    function match (f, partial) {
      this.debug('match', f, this.pattern)
      // short-circuit in the case of busted things.
      // comments, etc.
      if (this.comment) return false
      if (this.empty) return f === ''
    
      if (f === '/' && partial) return true
    
      var options = this.options
    
      // windows: need to use /, not \
      if (path.sep !== '/') {
        f = f.split(path.sep).join('/')
      }
    
      // treat the test path as a set of pathparts.
      f = f.split(slashSplit)
      this.debug(this.pattern, 'split', f)
    
      // just ONE of the pattern sets in this.set needs to match
      // in order for it to be valid.  If negating, then just one
      // match means that we have failed.
      // Either way, return on the first hit.
    
      var set = this.set
      this.debug(this.pattern, 'set', set)
    
      // Find the basename of the path by looking for the last non-empty segment
      var filename
      var i
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i]
        if (filename) break
      }
    
      for (i = 0; i < set.length; i++) {
        var pattern = set[i]
        var file = f
        if (options.matchBase && pattern.length === 1) {
          file = [filename]
        }
        var hit = this.matchOne(file, pattern, partial)
        if (hit) {
          if (options.flipNegate) return true
          return !this.negate
        }
      }
    
      // didn't get any hits.  this is success if it's a negative
      // pattern, failure otherwise.
      if (options.flipNegate) return false
      return this.negate
    }
    
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    Minimatch.prototype.matchOne = function (file, pattern, partial) {
      var options = this.options
    
      this.debug('matchOne',
        { 'this': this, file: file, pattern: pattern })
    
      this.debug('matchOne', file.length, pattern.length)
    
      for (var fi = 0,
          pi = 0,
          fl = file.length,
          pl = pattern.length
          ; (fi < fl) && (pi < pl)
          ; fi++, pi++) {
        this.debug('matchOne loop')
        var p = pattern[pi]
        var f = file[fi]
    
        this.debug(pattern, p, f)
    
        // should be impossible.
        // some invalid regexp stuff in the set.
        if (p === false) return false
    
        if (p === GLOBSTAR) {
          this.debug('GLOBSTAR', [pattern, p, f])
    
          // "**"
          // a/**/b/**/c would match the following:
          // a/b/x/y/z/c
          // a/x/y/z/b/c
          // a/b/x/b/x/c
          // a/b/c
          // To do this, take the rest of the pattern after
          // the **, and see if it would match the file remainder.
          // If so, return success.
          // If not, the ** "swallows" a segment, and try again.
          // This is recursively awful.
          //
          // a/**/b/**/c matching a/b/x/y/z/c
          // - a matches a
          // - doublestar
          //   - matchOne(b/x/y/z/c, b/**/c)
          //     - b matches b
          //     - doublestar
          //       - matchOne(x/y/z/c, c) -> no
          //       - matchOne(y/z/c, c) -> no
          //       - matchOne(z/c, c) -> no
          //       - matchOne(c, c) yes, hit
          var fr = fi
          var pr = pi + 1
          if (pr === pl) {
            this.debug('** at the end')
            // a ** at the end will just swallow the rest.
            // We have found a match.
            // however, it will not swallow /.x, unless
            // options.dot is set.
            // . and .. are *never* matched by **, for explosively
            // exponential reasons.
            for (; fi < fl; fi++) {
              if (file[fi] === '.' || file[fi] === '..' ||
                (!options.dot && file[fi].charAt(0) === '.')) return false
            }
            return true
          }
    
          // ok, let's see if we can swallow whatever we can.
          while (fr < fl) {
            var swallowee = file[fr]
    
            this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)
    
            // XXX remove this slice.  Just pass the start index.
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug('globstar found match!', fr, fl, swallowee)
              // found a match.
              return true
            } else {
              // can't swallow "." or ".." ever.
              // can only swallow ".foo" when explicitly asked.
              if (swallowee === '.' || swallowee === '..' ||
                (!options.dot && swallowee.charAt(0) === '.')) {
                this.debug('dot detected!', file, fr, pattern, pr)
                break
              }
    
              // ** swallows a segment, and continue.
              this.debug('globstar swallow a segment, and continue')
              fr++
            }
          }
    
          // no match was found.
          // However, in partial mode, we can't say this is necessarily over.
          // If there's more *pattern* left, then
          if (partial) {
            // ran out of file
            this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
            if (fr === fl) return true
          }
          return false
        }
    
        // something other than **
        // non-magic patterns just have to match exactly
        // patterns with magic have been turned into regexps.
        var hit
        if (typeof p === 'string') {
          if (options.nocase) {
            hit = f.toLowerCase() === p.toLowerCase()
          } else {
            hit = f === p
          }
          this.debug('string match', p, f, hit)
        } else {
          hit = f.match(p)
          this.debug('pattern match', p, f, hit)
        }
    
        if (!hit) return false
      }
    
      // Note: ending in / means that we'll get a final ""
      // at the end of the pattern.  This can only match a
      // corresponding "" at the end of the file.
      // If the file ends in /, then it can only match a
      // a pattern that ends in /, unless the pattern just
      // doesn't have any more for it. But, a/b/ should *not*
      // match "a/b/*", even though "" matches against the
      // [^/]*? pattern, except in partial mode, where it might
      // simply not be reached yet.
      // However, a/b/ should still satisfy a/*
    
      // now either we fell off the end of the pattern, or we're done.
      if (fi === fl && pi === pl) {
        // ran out of pattern and filename at the same time.
        // an exact hit!
        return true
      } else if (fi === fl) {
        // ran out of file, but still had pattern left.
        // this is ok if we're doing the match as part of
        // a glob fs traversal.
        return partial
      } else if (pi === pl) {
        // ran out of pattern, still have file left.
        // this is only acceptable if we're on the very last
        // empty segment of a file with a trailing slash.
        // a/* should match a/b/
        var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
        return emptyFileEnd
      }
    
      // should be unreachable.
      throw new Error('wtf?')
    }
    
    // replace stuff like \* with *
    function globUnescape (s) {
      return s.replace(/\\(.)/g, '$1')
    }
    
    function regExpEscape (s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
    }
    
  provide("minimatch", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_readable
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    module.exports = Readable;
    
    /*<replacement>*/
    var isArray = require('isarray');
    /*</replacement>*/
    
    
    /*<replacement>*/
    var Buffer = require('buffer').Buffer;
    /*</replacement>*/
    
    Readable.ReadableState = ReadableState;
    
    var EE = require('events').EventEmitter;
    
    /*<replacement>*/
    if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    /*</replacement>*/
    
    var Stream = require('stream');
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    var StringDecoder;
    
    util.inherits(Readable, Stream);
    
    function ReadableState(options, stream) {
      options = options || {};
    
      // the point at which it stops calling _read() to fill the buffer
      // Note: 0 is a valid value, means "don't call _read preemptively ever"
      var hwm = options.highWaterMark;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
    
      // cast to ints.
      this.highWaterMark = ~~this.highWaterMark;
    
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = false;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
    
      // In streams that never have any data, and do push(null) right away,
      // the consumer can miss the 'end' event if they do some I/O before
      // consuming the stream.  So, we don't emit('end') until some reading
      // happens.
      this.calledRead = false;
    
      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, becuase any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;
    
      // whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
    
    
      // object stream flag. Used to make read(n) ignore n and to
      // make all the buffer merging and length checks go away
      this.objectMode = !!options.objectMode;
    
      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';
    
      // when piping, we only care about 'readable' events that happen
      // after read()ing all the bytes and not getting any pushback.
      this.ranOut = false;
    
      // the number of writers that are awaiting a drain event in .pipe()s
      this.awaitDrain = 0;
    
      // if true, a maybeReadMore has been scheduled
      this.readingMore = false;
    
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require('string_decoder/').StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    
    function Readable(options) {
      if (!(this instanceof Readable))
        return new Readable(options);
    
      this._readableState = new ReadableState(options, this);
    
      // legacy
      this.readable = true;
    
      Stream.call(this);
    }
    
    // Manually shove something into the read() buffer.
    // This returns true if the highWaterMark has not been hit yet,
    // similar to how Writable.write() returns true if you should
    // write() some more.
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
    
      if (typeof chunk === 'string' && !state.objectMode) {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer(chunk, encoding);
          encoding = '';
        }
      }
    
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    
    // Unshift should *always* be something directly out of read()
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, '', true);
    };
    
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit('error', er);
      } else if (chunk === null || chunk === undefined) {
        state.reading = false;
        if (!state.ended)
          onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error('stream.push() after EOF');
          stream.emit('error', e);
        } else if (state.endEmitted && addToFront) {
          var e = new Error('stream.unshift() after end event');
          stream.emit('error', e);
        } else {
          if (state.decoder && !addToFront && !encoding)
            chunk = state.decoder.write(chunk);
    
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) {
            state.buffer.unshift(chunk);
          } else {
            state.reading = false;
            state.buffer.push(chunk);
          }
    
          if (state.needReadable)
            emitReadable(stream);
    
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    
      return needMoreData(state);
    }
    
    
    
    // if it's past the high water mark, we can push in some more.
    // Also, if we have no data yet, we can stand some
    // more bytes.  This is to work around cases where hwm=0,
    // such as the repl.  Also, if the push() triggered a
    // readable event, and the user called read(largeNumber) such that
    // needReadable was set, then we ought to push more, so that another
    // 'readable' event will be triggered.
    function needMoreData(state) {
      return !state.ended &&
             (state.needReadable ||
              state.length < state.highWaterMark ||
              state.length === 0);
    }
    
    // backwards compatibility.
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require('string_decoder/').StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
    };
    
    // Don't raise the hwm > 128MB
    var MAX_HWM = 0x800000;
    function roundUpToNextPowerOf2(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        // Get the next highest power of 2
        n--;
        for (var p = 1; p < 32; p <<= 1) n |= n >> p;
        n++;
      }
      return n;
    }
    
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended)
        return 0;
    
      if (state.objectMode)
        return n === 0 ? 0 : 1;
    
      if (n === null || isNaN(n)) {
        // only flow one buffer at a time
        if (state.flowing && state.buffer.length)
          return state.buffer[0].length;
        else
          return state.length;
      }
    
      if (n <= 0)
        return 0;
    
      // If we're asking for more than the target buffer level,
      // then raise the water mark.  Bump up to the next highest
      // power of 2, to prevent increasing it excessively in tiny
      // amounts.
      if (n > state.highWaterMark)
        state.highWaterMark = roundUpToNextPowerOf2(n);
    
      // don't have that much.  return null, unless we've ended.
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else
          return state.length;
      }
    
      return n;
    }
    
    // you can override either this method, or the async _read(n) below.
    Readable.prototype.read = function(n) {
      var state = this._readableState;
      state.calledRead = true;
      var nOrig = n;
      var ret;
    
      if (typeof n !== 'number' || n > 0)
        state.emittedReadable = false;
    
      // if we're doing read(0) to trigger a readable event, but we
      // already have a bunch of data in the buffer, then just trigger
      // the 'readable' event and move on.
      if (n === 0 &&
          state.needReadable &&
          (state.length >= state.highWaterMark || state.ended)) {
        emitReadable(this);
        return null;
      }
    
      n = howMuchToRead(n, state);
    
      // if we've ended, and we're now clear, then finish it up.
      if (n === 0 && state.ended) {
        ret = null;
    
        // In cases where the decoder did not receive enough data
        // to produce a full chunk, then immediately received an
        // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
        // howMuchToRead will see this and coerce the amount to
        // read to zero (because it's looking at the length of the
        // first <Buffer > in state.buffer), and we'll end up here.
        //
        // This can only happen via state.decoder -- no other venue
        // exists for pushing a zero-length chunk into state.buffer
        // and triggering this behavior. In this case, we return our
        // remaining data and end the stream, if appropriate.
        if (state.length > 0 && state.decoder) {
          ret = fromList(n, state);
          state.length -= ret.length;
        }
    
        if (state.length === 0)
          endReadable(this);
    
        return ret;
      }
    
      // All the actual chunk generation logic needs to be
      // *below* the call to _read.  The reason is that in certain
      // synthetic stream cases, such as passthrough streams, _read
      // may be a completely synchronous operation which may change
      // the state of the read buffer, providing enough data when
      // before there was *not* enough.
      //
      // So, the steps are:
      // 1. Figure out what the state of things will be after we do
      // a read from the buffer.
      //
      // 2. If that resulting state will trigger a _read, then call _read.
      // Note that this may be asynchronous, or synchronous.  Yes, it is
      // deeply ugly to write APIs this way, but that still doesn't mean
      // that the Readable class should behave improperly, as streams are
      // designed to be sync/async agnostic.
      // Take note if the _read call is sync or async (ie, if the read call
      // has returned yet), so that we know whether or not it's safe to emit
      // 'readable' etc.
      //
      // 3. Actually pull the requested chunks out of the buffer and return.
    
      // if we need a readable event, then we need to do some reading.
      var doRead = state.needReadable;
    
      // if we currently have less than the highWaterMark, then also read some
      if (state.length - n <= state.highWaterMark)
        doRead = true;
    
      // however, if we've ended, then there's no point, and if we're already
      // reading, then it's unnecessary.
      if (state.ended || state.reading)
        doRead = false;
    
      if (doRead) {
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0)
          state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
      }
    
      // If _read called its callback synchronously, then `reading`
      // will be false, and we need to re-evaluate how much data we
      // can return to the user.
      if (doRead && !state.reading)
        n = howMuchToRead(nOrig, state);
    
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
    
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      }
    
      state.length -= n;
    
      // If we have nothing in the buffer, then we want to know
      // as soon as we *do* get something into the buffer.
      if (state.length === 0 && !state.ended)
        state.needReadable = true;
    
      // If we happened to read() exactly the remaining amount in the
      // buffer, and the EOF has been seen at this point, then make sure
      // that we emit 'end' on the very next tick.
      if (state.ended && !state.endEmitted && state.length === 0)
        endReadable(this);
    
      return ret;
    };
    
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!Buffer.isBuffer(chunk) &&
          'string' !== typeof chunk &&
          chunk !== null &&
          chunk !== undefined &&
          !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      return er;
    }
    
    
    function onEofChunk(stream, state) {
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
    
      // if we've ended and we have some data left, then emit
      // 'readable' now to make sure it gets picked up.
      if (state.length > 0)
        emitReadable(stream);
      else
        endReadable(stream);
    }
    
    // Don't emit readable right away in sync mode, because this can trigger
    // another read() call => stack overflow.  This way, it might trigger
    // a nextTick recursion warning, but that's not so bad.
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (state.emittedReadable)
        return;
    
      state.emittedReadable = true;
      if (state.sync)
        process.nextTick(function() {
          emitReadable_(stream);
        });
      else
        emitReadable_(stream);
    }
    
    function emitReadable_(stream) {
      stream.emit('readable');
    }
    
    
    // at this point, the user has presumably seen the 'readable' event,
    // and called read() to consume some data.  that may have triggered
    // in turn another _read(n) call, in which case reading = true if
    // it's in progress.
    // However, if we're not ended, or reading, and the length < hwm,
    // then go ahead and try to read some more preemptively.
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(function() {
          maybeReadMore_(stream, state);
        });
      }
    }
    
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended &&
             state.length < state.highWaterMark) {
        stream.read(0);
        if (len === state.length)
          // didn't get any data, stop spinning.
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    
    // abstract method.  to be overridden in specific implementation classes.
    // call cb(er, data) where data is <= n in length.
    // for virtual (non-string, non-buffer) streams, "length" is somewhat
    // arbitrary, and perhaps not very meaningful.
    Readable.prototype._read = function(n) {
      this.emit('error', new Error('not implemented'));
    };
    
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
    
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
    
      var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
                  dest !== process.stdout &&
                  dest !== process.stderr;
    
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once('end', endFn);
    
      dest.on('unpipe', onunpipe);
      function onunpipe(readable) {
        if (readable !== src) return;
        cleanup();
      }
    
      function onend() {
        dest.end();
      }
    
      // when the dest drains, it reduces the awaitDrain counter
      // on the source.  This would be more elegant with a .once()
      // handler in flow(), but adding and removing repeatedly is
      // too slow.
      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);
    
      function cleanup() {
        // cleanup event handlers once the pipe is broken
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', cleanup);
    
        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (!dest._writableState || dest._writableState.needDrain)
          ondrain();
      }
    
      // if the dest has an error, then stop piping into it.
      // however, don't suppress the throwing behavior for this.
      function onerror(er) {
        unpipe();
        dest.removeListener('error', onerror);
        if (EE.listenerCount(dest, 'error') === 0)
          dest.emit('error', er);
      }
      // This is a brutally ugly hack to make sure that our error handler
      // is attached before any userland ones.  NEVER DO THIS.
      if (!dest._events || !dest._events.error)
        dest.on('error', onerror);
      else if (isArray(dest._events.error))
        dest._events.error.unshift(onerror);
      else
        dest._events.error = [onerror, dest._events.error];
    
    
    
      // Both close and finish should trigger unpipe, but only once.
      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }
      dest.once('close', onclose);
      function onfinish() {
        dest.removeListener('close', onclose);
        unpipe();
      }
      dest.once('finish', onfinish);
    
      function unpipe() {
        src.unpipe(dest);
      }
    
      // tell the dest that it's being piped to
      dest.emit('pipe', src);
    
      // start the flow if it hasn't been started already.
      if (!state.flowing) {
        // the handler that waits for readable events after all
        // the data gets sucked out in flow.
        // This would be easier to follow with a .once() handler
        // in flow(), but that is too slow.
        this.on('readable', pipeOnReadable);
    
        state.flowing = true;
        process.nextTick(function() {
          flow(src);
        });
      }
    
      return dest;
    };
    
    function pipeOnDrain(src) {
      return function() {
        var dest = this;
        var state = src._readableState;
        state.awaitDrain--;
        if (state.awaitDrain === 0)
          flow(src);
      };
    }
    
    function flow(src) {
      var state = src._readableState;
      var chunk;
      state.awaitDrain = 0;
    
      function write(dest, i, list) {
        var written = dest.write(chunk);
        if (false === written) {
          state.awaitDrain++;
        }
      }
    
      while (state.pipesCount && null !== (chunk = src.read())) {
    
        if (state.pipesCount === 1)
          write(state.pipes, 0, null);
        else
          forEach(state.pipes, write);
    
        src.emit('data', chunk);
    
        // if anyone needs a drain, then we have to wait for that.
        if (state.awaitDrain > 0)
          return;
      }
    
      // if every destination was unpiped, either before entering this
      // function, or in the while loop, then stop flowing.
      //
      // NB: This is a pretty rare edge case.
      if (state.pipesCount === 0) {
        state.flowing = false;
    
        // if there were data event listeners added, then switch to old mode.
        if (EE.listenerCount(src, 'data') > 0)
          emitDataEvents(src);
        return;
      }
    
      // at this point, no one needed a drain, so we just ran out of data
      // on the next readable event, start it over again.
      state.ranOut = true;
    }
    
    function pipeOnReadable() {
      if (this._readableState.ranOut) {
        this._readableState.ranOut = false;
        flow(this);
      }
    }
    
    
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
    
      // if we're not piping anywhere, then do nothing.
      if (state.pipesCount === 0)
        return this;
    
      // just one destination.  most common case.
      if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes)
          return this;
    
        if (!dest)
          dest = state.pipes;
    
        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener('readable', pipeOnReadable);
        state.flowing = false;
        if (dest)
          dest.emit('unpipe', this);
        return this;
      }
    
      // slow case. multiple pipe destinations.
    
      if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener('readable', pipeOnReadable);
        state.flowing = false;
    
        for (var i = 0; i < len; i++)
          dests[i].emit('unpipe', this);
        return this;
      }
    
      // try to find the right one.
      var i = indexOf(state.pipes, dest);
      if (i === -1)
        return this;
    
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
    
      dest.emit('unpipe', this);
    
      return this;
    };
    
    // set up data events if they are asked for
    // Ensure readable listeners eventually get something
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
    
      if (ev === 'data' && !this._readableState.flowing)
        emitDataEvents(this);
    
      if (ev === 'readable' && this.readable) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            this.read(0);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
    
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    
    // pause() and resume() are remnants of the legacy readable stream API
    // If the user uses them, then switch into old mode.
    Readable.prototype.resume = function() {
      emitDataEvents(this);
      this.read(0);
      this.emit('resume');
    };
    
    Readable.prototype.pause = function() {
      emitDataEvents(this, true);
      this.emit('pause');
    };
    
    function emitDataEvents(stream, startPaused) {
      var state = stream._readableState;
    
      if (state.flowing) {
        // https://github.com/isaacs/readable-stream/issues/16
        throw new Error('Cannot switch to old mode now.');
      }
    
      var paused = startPaused || false;
      var readable = false;
    
      // convert to an old-style stream.
      stream.readable = true;
      stream.pipe = Stream.prototype.pipe;
      stream.on = stream.addListener = Stream.prototype.on;
    
      stream.on('readable', function() {
        readable = true;
    
        var c;
        while (!paused && (null !== (c = stream.read())))
          stream.emit('data', c);
    
        if (c === null) {
          readable = false;
          stream._readableState.needReadable = true;
        }
      });
    
      stream.pause = function() {
        paused = true;
        this.emit('pause');
      };
    
      stream.resume = function() {
        paused = false;
        if (readable)
          process.nextTick(function() {
            stream.emit('readable');
          });
        else
          this.read(0);
        this.emit('resume');
      };
    
      // now make it start, just in case it hadn't already.
      stream.emit('readable');
    }
    
    // wrap an old-style stream as the async data source.
    // This is *not* part of the readable stream interface.
    // It is an ugly unfortunate mess of history.
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
    
      var self = this;
      stream.on('end', function() {
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self.push(chunk);
        }
    
        self.push(null);
      });
    
      stream.on('data', function(chunk) {
        if (state.decoder)
          chunk = state.decoder.write(chunk);
    
        // don't skip over falsy values in objectMode
        //if (state.objectMode && util.isNullOrUndefined(chunk))
        if (state.objectMode && (chunk === null || chunk === undefined))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
    
        var ret = self.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
    
      // proxy all the other methods.
      // important when wrapping filters and duplexes.
      for (var i in stream) {
        if (typeof stream[i] === 'function' &&
            typeof this[i] === 'undefined') {
          this[i] = function(method) { return function() {
            return stream[method].apply(stream, arguments);
          }}(i);
        }
      }
    
      // proxy certain important events.
      var events = ['error', 'close', 'destroy', 'pause', 'resume'];
      forEach(events, function(ev) {
        stream.on(ev, self.emit.bind(self, ev));
      });
    
      // when we try to consume some more bytes, simply unpause the
      // underlying stream.
      self._read = function(n) {
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
    
      return self;
    };
    
    
    
    // exposed for testing purposes only.
    Readable._fromList = fromList;
    
    // Pluck off n bytes from an array of buffers.
    // Length is the combined lengths of all the buffers in the list.
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
    
      // nothing in the list, definitely empty.
      if (list.length === 0)
        return null;
    
      if (length === 0)
        ret = null;
      else if (objectMode)
        ret = list.shift();
      else if (!n || n >= length) {
        // read it all, truncate the array.
        if (stringMode)
          ret = list.join('');
        else
          ret = Buffer.concat(list, length);
        list.length = 0;
      } else {
        // read just some of it.
        if (n < list[0].length) {
          // just take a part of the first list item.
          // slice is the same for buffers and strings.
          var buf = list[0];
          ret = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          // first list is a perfect match
          ret = list.shift();
        } else {
          // complex case.
          // we have enough to cover it, but it spans past the first buffer.
          if (stringMode)
            ret = '';
          else
            ret = new Buffer(n);
    
          var c = 0;
          for (var i = 0, l = list.length; i < l && c < n; i++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
    
            if (stringMode)
              ret += buf.slice(0, cpy);
            else
              buf.copy(ret, c, 0, cpy);
    
            if (cpy < buf.length)
              list[0] = buf.slice(cpy);
            else
              list.shift();
    
            c += cpy;
          }
        }
      }
    
      return ret;
    }
    
    function endReadable(stream) {
      var state = stream._readableState;
    
      // If we get here before consuming all the bytes, then that is a
      // bug in node.  Should never happen.
      if (state.length > 0)
        throw new Error('endReadable called on non-empty stream');
    
      if (!state.endEmitted && state.calledRead) {
        state.ended = true;
        process.nextTick(function() {
          // Check that we didn't get one last unshift.
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit('end');
          }
        });
      }
    }
    
    function forEach (xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    
    function indexOf (xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
    
  provide("readable-stream/lib/_stream_readable", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_writable
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // A bit simpler than readable streams.
    // Implement an async ._write(chunk, cb), and it'll handle all
    // the drain event emission and buffering.
    
    module.exports = Writable;
    
    /*<replacement>*/
    var Buffer = require('buffer').Buffer;
    /*</replacement>*/
    
    Writable.WritableState = WritableState;
    
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    var Stream = require('stream');
    
    util.inherits(Writable, Stream);
    
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
    }
    
    function WritableState(options, stream) {
      options = options || {};
    
      // the point at which write() starts returning false
      // Note: 0 is a valid value, means that we always return false if
      // the entire buffer is not flushed immediately on write()
      var hwm = options.highWaterMark;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
    
      // object stream flag to indicate whether or not this stream
      // contains buffers or objects.
      this.objectMode = !!options.objectMode;
    
      // cast to ints.
      this.highWaterMark = ~~this.highWaterMark;
    
      this.needDrain = false;
      // at the start of calling end()
      this.ending = false;
      // when end() has been called, and returned
      this.ended = false;
      // when 'finish' is emitted
      this.finished = false;
    
      // should we decode strings into buffers before passing to _write?
      // this is here so that some node-core streams can optimize string
      // handling at a lower level.
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
    
      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';
    
      // not an actual buffer we keep track of, but a measurement
      // of how much we're waiting to get pushed to some underlying
      // socket or file.
      this.length = 0;
    
      // a flag to see when we're in the middle of a write.
      this.writing = false;
    
      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, becuase any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;
    
      // a flag to know if we're processing previously buffered items, which
      // may call the _write() callback in the same tick, so that we don't
      // end up in an overlapped onwrite situation.
      this.bufferProcessing = false;
    
      // the callback that's passed to _write(chunk,cb)
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
    
      // the callback that the user supplies to write(chunk,encoding,cb)
      this.writecb = null;
    
      // the amount that is being written when _write is called.
      this.writelen = 0;
    
      this.buffer = [];
    
      // True if the error was already emitted and should not be thrown again
      this.errorEmitted = false;
    }
    
    function Writable(options) {
      var Duplex =  require('readable-stream/lib/_stream_duplex');
    
      // Writable ctor is applied to Duplexes, though they're not
      // instanceof Writable, they're instanceof Readable.
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
    
      this._writableState = new WritableState(options, this);
    
      // legacy.
      this.writable = true;
    
      Stream.call(this);
    }
    
    // Otherwise people can pipe Writable streams, which is just wrong.
    Writable.prototype.pipe = function() {
      this.emit('error', new Error('Cannot pipe. Not readable.'));
    };
    
    
    function writeAfterEnd(stream, state, cb) {
      var er = new Error('write after end');
      // TODO: defer error events consistently everywhere, not just the cb
      stream.emit('error', er);
      process.nextTick(function() {
        cb(er);
      });
    }
    
    // If we get something that is not a buffer, string, null, or undefined,
    // and we're not in objectMode, then that's an error.
    // Otherwise stream chunks are all considered to be of length=1, and the
    // watermarks determine how many objects to keep in the buffer, rather than
    // how many bytes or characters.
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      if (!Buffer.isBuffer(chunk) &&
          'string' !== typeof chunk &&
          chunk !== null &&
          chunk !== undefined &&
          !state.objectMode) {
        var er = new TypeError('Invalid non-string/buffer chunk');
        stream.emit('error', er);
        process.nextTick(function() {
          cb(er);
        });
        valid = false;
      }
      return valid;
    }
    
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
    
      if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
    
      if (Buffer.isBuffer(chunk))
        encoding = 'buffer';
      else if (!encoding)
        encoding = state.defaultEncoding;
    
      if (typeof cb !== 'function')
        cb = function() {};
    
      if (state.ended)
        writeAfterEnd(this, state, cb);
      else if (validChunk(this, state, chunk, cb))
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
    
      return ret;
    };
    
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode &&
          state.decodeStrings !== false &&
          typeof chunk === 'string') {
        chunk = new Buffer(chunk, encoding);
      }
      return chunk;
    }
    
    // if we're already writing something, then just put this
    // in the queue, and wait our turn.  Otherwise, call _write
    // If we return false, then we need a drain event, so set that flag.
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      if (Buffer.isBuffer(chunk))
        encoding = 'buffer';
      var len = state.objectMode ? 1 : chunk.length;
    
      state.length += len;
    
      var ret = state.length < state.highWaterMark;
      // we must ensure that previous needDrain will not be reset to false.
      if (!ret)
        state.needDrain = true;
    
      if (state.writing)
        state.buffer.push(new WriteReq(chunk, encoding, cb));
      else
        doWrite(stream, state, len, chunk, encoding, cb);
    
      return ret;
    }
    
    function doWrite(stream, state, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    
    function onwriteError(stream, state, sync, er, cb) {
      if (sync)
        process.nextTick(function() {
          cb(er);
        });
      else
        cb(er);
    
      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
    }
    
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
    
      onwriteStateUpdate(state);
    
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(stream, state);
    
        if (!finished && !state.bufferProcessing && state.buffer.length)
          clearBuffer(stream, state);
    
        if (sync) {
          process.nextTick(function() {
            afterWrite(stream, state, finished, cb);
          });
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      cb();
      if (finished)
        finishMaybe(stream, state);
    }
    
    // Must force callback to be called on nextTick, so that we don't
    // emit 'drain' before the write() consumer gets the 'false' return
    // value, and has a chance to attach a 'drain' listener.
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    }
    
    
    // if there's something in the buffer waiting, then process it
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
    
      for (var c = 0; c < state.buffer.length; c++) {
        var entry = state.buffer[c];
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
    
        doWrite(stream, state, len, chunk, encoding, cb);
    
        // if we didn't call the onwrite immediately, then
        // it means that we need to wait until it does.
        // also, that means that the chunk and cb are currently
        // being processed, so move the buffer counter past them.
        if (state.writing) {
          c++;
          break;
        }
      }
    
      state.bufferProcessing = false;
      if (c < state.buffer.length)
        state.buffer = state.buffer.slice(c);
      else
        state.buffer.length = 0;
    }
    
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error('not implemented'));
    };
    
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
    
      if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
    
      if (typeof chunk !== 'undefined' && chunk !== null)
        this.write(chunk, encoding);
    
      // ignore unnecessary end() calls.
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    
    
    function needFinish(stream, state) {
      return (state.ending &&
              state.length === 0 &&
              !state.finished &&
              !state.writing);
    }
    
    function finishMaybe(stream, state) {
      var need = needFinish(stream, state);
      if (need) {
        state.finished = true;
        stream.emit('finish');
      }
      return need;
    }
    
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once('finish', cb);
      }
      state.ended = true;
    }
    
  provide("readable-stream/lib/_stream_writable", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_duplex
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // a duplex stream is just a stream that is both readable and writable.
    // Since JS doesn't have multiple prototypal inheritance, this class
    // prototypally inherits from Readable, and then parasitically from
    // Writable.
    
    module.exports = Duplex;
    
    /*<replacement>*/
    var objectKeys = Object.keys || function (obj) {
      var keys = [];
      for (var key in obj) keys.push(key);
      return keys;
    }
    /*</replacement>*/
    
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    var Readable =  require('readable-stream/lib/_stream_readable');
    var Writable =  require('readable-stream/lib/_stream_writable');
    
    util.inherits(Duplex, Readable);
    
    forEach(objectKeys(Writable.prototype), function(method) {
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    });
    
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
    
      Readable.call(this, options);
      Writable.call(this, options);
    
      if (options && options.readable === false)
        this.readable = false;
    
      if (options && options.writable === false)
        this.writable = false;
    
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
    
      this.once('end', onend);
    }
    
    // the no-half-open enforcer
    function onend() {
      // if we allow half-open state, or if the writable side ended,
      // then we're ok.
      if (this.allowHalfOpen || this._writableState.ended)
        return;
    
      // no more data can be written.
      // But allow more writes to happen in this tick.
      process.nextTick(this.end.bind(this));
    }
    
    function forEach (xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    
  provide("readable-stream/lib/_stream_duplex", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_transform
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    
    // a transform stream is a readable/writable stream where you do
    // something with the data.  Sometimes it's called a "filter",
    // but that's not a great name for it, since that implies a thing where
    // some bits pass through, and others are simply ignored.  (That would
    // be a valid example of a transform, of course.)
    //
    // While the output is causally related to the input, it's not a
    // necessarily symmetric or synchronous transformation.  For example,
    // a zlib stream might take multiple plain-text writes(), and then
    // emit a single compressed chunk some time in the future.
    //
    // Here's how this works:
    //
    // The Transform stream has all the aspects of the readable and writable
    // stream classes.  When you write(chunk), that calls _write(chunk,cb)
    // internally, and returns false if there's a lot of pending writes
    // buffered up.  When you call read(), that calls _read(n) until
    // there's enough pending readable data buffered up.
    //
    // In a transform stream, the written data is placed in a buffer.  When
    // _read(n) is called, it transforms the queued up data, calling the
    // buffered _write cb's as it consumes chunks.  If consuming a single
    // written chunk would result in multiple output chunks, then the first
    // outputted bit calls the readcb, and subsequent chunks just go into
    // the read buffer, and will cause it to emit 'readable' if necessary.
    //
    // This way, back-pressure is actually determined by the reading side,
    // since _read has to be called to start processing a new chunk.  However,
    // a pathological inflate type of transform can cause excessive buffering
    // here.  For example, imagine a stream where every byte of input is
    // interpreted as an integer from 0-255, and then results in that many
    // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
    // 1kb of data being output.  In this case, you could write a very small
    // amount of input, and end up with a very large amount of output.  In
    // such a pathological inflating mechanism, there'd be no way to tell
    // the system to stop doing the transform.  A single 4MB write could
    // cause the system to run out of memory.
    //
    // However, even in such a pathological case, only a single written chunk
    // would be consumed, and then the rest would wait (un-transformed) until
    // the results of the previous transformed chunk were consumed.
    
    module.exports = Transform;
    
    var Duplex =  require('readable-stream/lib/_stream_duplex');
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    util.inherits(Transform, Duplex);
    
    
    function TransformState(options, stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
    
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
    
      var cb = ts.writecb;
    
      if (!cb)
        return stream.emit('error', new Error('no writecb in Transform class'));
    
      ts.writechunk = null;
      ts.writecb = null;
    
      if (data !== null && data !== undefined)
        stream.push(data);
    
      if (cb)
        cb(er);
    
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    
    
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
    
      Duplex.call(this, options);
    
      var ts = this._transformState = new TransformState(options, this);
    
      // when the writable side finishes, then flush out anything remaining.
      var stream = this;
    
      // start out asking for a readable event once data is transformed.
      this._readableState.needReadable = true;
    
      // we have implemented the _read method, and done the other things
      // that Readable wants before the first _read call, so unset the
      // sync guard flag.
      this._readableState.sync = false;
    
      this.once('finish', function() {
        if ('function' === typeof this._flush)
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    
    // This is the part where you do stuff!
    // override this function in implementation classes.
    // 'chunk' is an input chunk.
    //
    // Call `push(newChunk)` to pass along transformed output
    // to the readable side.  You may call 'push' zero or more times.
    //
    // Call `cb(err)` when you are done with this chunk.  If you pass
    // an error, then that'll put the hurt on the whole operation.  If you
    // never call cb(), then you'll never get another chunk.
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error('not implemented');
    };
    
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform ||
            rs.needReadable ||
            rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    
    // Doesn't matter what the args are here.
    // _transform does all the work.
    // That we got here means that the readable side wants more data.
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
    
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
      }
    };
    
    
    function done(stream, er) {
      if (er)
        return stream.emit('error', er);
    
      // if there's nothing in the write buffer, then that means
      // that nothing more will ever be provided
      var ws = stream._writableState;
      var rs = stream._readableState;
      var ts = stream._transformState;
    
      if (ws.length)
        throw new Error('calling transform done when ws.length != 0');
    
      if (ts.transforming)
        throw new Error('calling transform done when still transforming');
    
      return stream.push(null);
    }
    
  provide("readable-stream/lib/_stream_transform", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_readable.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    module.exports = Readable;
    
    /*<replacement>*/
    var isArray = require('isarray');
    /*</replacement>*/
    
    
    /*<replacement>*/
    var Buffer = require('buffer').Buffer;
    /*</replacement>*/
    
    Readable.ReadableState = ReadableState;
    
    var EE = require('events').EventEmitter;
    
    /*<replacement>*/
    if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    /*</replacement>*/
    
    var Stream = require('stream');
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    var StringDecoder;
    
    util.inherits(Readable, Stream);
    
    function ReadableState(options, stream) {
      options = options || {};
    
      // the point at which it stops calling _read() to fill the buffer
      // Note: 0 is a valid value, means "don't call _read preemptively ever"
      var hwm = options.highWaterMark;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
    
      // cast to ints.
      this.highWaterMark = ~~this.highWaterMark;
    
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = false;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
    
      // In streams that never have any data, and do push(null) right away,
      // the consumer can miss the 'end' event if they do some I/O before
      // consuming the stream.  So, we don't emit('end') until some reading
      // happens.
      this.calledRead = false;
    
      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, becuase any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;
    
      // whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
    
    
      // object stream flag. Used to make read(n) ignore n and to
      // make all the buffer merging and length checks go away
      this.objectMode = !!options.objectMode;
    
      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';
    
      // when piping, we only care about 'readable' events that happen
      // after read()ing all the bytes and not getting any pushback.
      this.ranOut = false;
    
      // the number of writers that are awaiting a drain event in .pipe()s
      this.awaitDrain = 0;
    
      // if true, a maybeReadMore has been scheduled
      this.readingMore = false;
    
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require('string_decoder/').StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    
    function Readable(options) {
      if (!(this instanceof Readable))
        return new Readable(options);
    
      this._readableState = new ReadableState(options, this);
    
      // legacy
      this.readable = true;
    
      Stream.call(this);
    }
    
    // Manually shove something into the read() buffer.
    // This returns true if the highWaterMark has not been hit yet,
    // similar to how Writable.write() returns true if you should
    // write() some more.
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
    
      if (typeof chunk === 'string' && !state.objectMode) {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer(chunk, encoding);
          encoding = '';
        }
      }
    
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    
    // Unshift should *always* be something directly out of read()
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, '', true);
    };
    
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit('error', er);
      } else if (chunk === null || chunk === undefined) {
        state.reading = false;
        if (!state.ended)
          onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error('stream.push() after EOF');
          stream.emit('error', e);
        } else if (state.endEmitted && addToFront) {
          var e = new Error('stream.unshift() after end event');
          stream.emit('error', e);
        } else {
          if (state.decoder && !addToFront && !encoding)
            chunk = state.decoder.write(chunk);
    
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) {
            state.buffer.unshift(chunk);
          } else {
            state.reading = false;
            state.buffer.push(chunk);
          }
    
          if (state.needReadable)
            emitReadable(stream);
    
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    
      return needMoreData(state);
    }
    
    
    
    // if it's past the high water mark, we can push in some more.
    // Also, if we have no data yet, we can stand some
    // more bytes.  This is to work around cases where hwm=0,
    // such as the repl.  Also, if the push() triggered a
    // readable event, and the user called read(largeNumber) such that
    // needReadable was set, then we ought to push more, so that another
    // 'readable' event will be triggered.
    function needMoreData(state) {
      return !state.ended &&
             (state.needReadable ||
              state.length < state.highWaterMark ||
              state.length === 0);
    }
    
    // backwards compatibility.
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require('string_decoder/').StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
    };
    
    // Don't raise the hwm > 128MB
    var MAX_HWM = 0x800000;
    function roundUpToNextPowerOf2(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        // Get the next highest power of 2
        n--;
        for (var p = 1; p < 32; p <<= 1) n |= n >> p;
        n++;
      }
      return n;
    }
    
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended)
        return 0;
    
      if (state.objectMode)
        return n === 0 ? 0 : 1;
    
      if (n === null || isNaN(n)) {
        // only flow one buffer at a time
        if (state.flowing && state.buffer.length)
          return state.buffer[0].length;
        else
          return state.length;
      }
    
      if (n <= 0)
        return 0;
    
      // If we're asking for more than the target buffer level,
      // then raise the water mark.  Bump up to the next highest
      // power of 2, to prevent increasing it excessively in tiny
      // amounts.
      if (n > state.highWaterMark)
        state.highWaterMark = roundUpToNextPowerOf2(n);
    
      // don't have that much.  return null, unless we've ended.
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else
          return state.length;
      }
    
      return n;
    }
    
    // you can override either this method, or the async _read(n) below.
    Readable.prototype.read = function(n) {
      var state = this._readableState;
      state.calledRead = true;
      var nOrig = n;
      var ret;
    
      if (typeof n !== 'number' || n > 0)
        state.emittedReadable = false;
    
      // if we're doing read(0) to trigger a readable event, but we
      // already have a bunch of data in the buffer, then just trigger
      // the 'readable' event and move on.
      if (n === 0 &&
          state.needReadable &&
          (state.length >= state.highWaterMark || state.ended)) {
        emitReadable(this);
        return null;
      }
    
      n = howMuchToRead(n, state);
    
      // if we've ended, and we're now clear, then finish it up.
      if (n === 0 && state.ended) {
        ret = null;
    
        // In cases where the decoder did not receive enough data
        // to produce a full chunk, then immediately received an
        // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
        // howMuchToRead will see this and coerce the amount to
        // read to zero (because it's looking at the length of the
        // first <Buffer > in state.buffer), and we'll end up here.
        //
        // This can only happen via state.decoder -- no other venue
        // exists for pushing a zero-length chunk into state.buffer
        // and triggering this behavior. In this case, we return our
        // remaining data and end the stream, if appropriate.
        if (state.length > 0 && state.decoder) {
          ret = fromList(n, state);
          state.length -= ret.length;
        }
    
        if (state.length === 0)
          endReadable(this);
    
        return ret;
      }
    
      // All the actual chunk generation logic needs to be
      // *below* the call to _read.  The reason is that in certain
      // synthetic stream cases, such as passthrough streams, _read
      // may be a completely synchronous operation which may change
      // the state of the read buffer, providing enough data when
      // before there was *not* enough.
      //
      // So, the steps are:
      // 1. Figure out what the state of things will be after we do
      // a read from the buffer.
      //
      // 2. If that resulting state will trigger a _read, then call _read.
      // Note that this may be asynchronous, or synchronous.  Yes, it is
      // deeply ugly to write APIs this way, but that still doesn't mean
      // that the Readable class should behave improperly, as streams are
      // designed to be sync/async agnostic.
      // Take note if the _read call is sync or async (ie, if the read call
      // has returned yet), so that we know whether or not it's safe to emit
      // 'readable' etc.
      //
      // 3. Actually pull the requested chunks out of the buffer and return.
    
      // if we need a readable event, then we need to do some reading.
      var doRead = state.needReadable;
    
      // if we currently have less than the highWaterMark, then also read some
      if (state.length - n <= state.highWaterMark)
        doRead = true;
    
      // however, if we've ended, then there's no point, and if we're already
      // reading, then it's unnecessary.
      if (state.ended || state.reading)
        doRead = false;
    
      if (doRead) {
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0)
          state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
      }
    
      // If _read called its callback synchronously, then `reading`
      // will be false, and we need to re-evaluate how much data we
      // can return to the user.
      if (doRead && !state.reading)
        n = howMuchToRead(nOrig, state);
    
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
    
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      }
    
      state.length -= n;
    
      // If we have nothing in the buffer, then we want to know
      // as soon as we *do* get something into the buffer.
      if (state.length === 0 && !state.ended)
        state.needReadable = true;
    
      // If we happened to read() exactly the remaining amount in the
      // buffer, and the EOF has been seen at this point, then make sure
      // that we emit 'end' on the very next tick.
      if (state.ended && !state.endEmitted && state.length === 0)
        endReadable(this);
    
      return ret;
    };
    
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!Buffer.isBuffer(chunk) &&
          'string' !== typeof chunk &&
          chunk !== null &&
          chunk !== undefined &&
          !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      return er;
    }
    
    
    function onEofChunk(stream, state) {
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
    
      // if we've ended and we have some data left, then emit
      // 'readable' now to make sure it gets picked up.
      if (state.length > 0)
        emitReadable(stream);
      else
        endReadable(stream);
    }
    
    // Don't emit readable right away in sync mode, because this can trigger
    // another read() call => stack overflow.  This way, it might trigger
    // a nextTick recursion warning, but that's not so bad.
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (state.emittedReadable)
        return;
    
      state.emittedReadable = true;
      if (state.sync)
        process.nextTick(function() {
          emitReadable_(stream);
        });
      else
        emitReadable_(stream);
    }
    
    function emitReadable_(stream) {
      stream.emit('readable');
    }
    
    
    // at this point, the user has presumably seen the 'readable' event,
    // and called read() to consume some data.  that may have triggered
    // in turn another _read(n) call, in which case reading = true if
    // it's in progress.
    // However, if we're not ended, or reading, and the length < hwm,
    // then go ahead and try to read some more preemptively.
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(function() {
          maybeReadMore_(stream, state);
        });
      }
    }
    
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended &&
             state.length < state.highWaterMark) {
        stream.read(0);
        if (len === state.length)
          // didn't get any data, stop spinning.
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    
    // abstract method.  to be overridden in specific implementation classes.
    // call cb(er, data) where data is <= n in length.
    // for virtual (non-string, non-buffer) streams, "length" is somewhat
    // arbitrary, and perhaps not very meaningful.
    Readable.prototype._read = function(n) {
      this.emit('error', new Error('not implemented'));
    };
    
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
    
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
    
      var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
                  dest !== process.stdout &&
                  dest !== process.stderr;
    
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once('end', endFn);
    
      dest.on('unpipe', onunpipe);
      function onunpipe(readable) {
        if (readable !== src) return;
        cleanup();
      }
    
      function onend() {
        dest.end();
      }
    
      // when the dest drains, it reduces the awaitDrain counter
      // on the source.  This would be more elegant with a .once()
      // handler in flow(), but adding and removing repeatedly is
      // too slow.
      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);
    
      function cleanup() {
        // cleanup event handlers once the pipe is broken
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', cleanup);
    
        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (!dest._writableState || dest._writableState.needDrain)
          ondrain();
      }
    
      // if the dest has an error, then stop piping into it.
      // however, don't suppress the throwing behavior for this.
      function onerror(er) {
        unpipe();
        dest.removeListener('error', onerror);
        if (EE.listenerCount(dest, 'error') === 0)
          dest.emit('error', er);
      }
      // This is a brutally ugly hack to make sure that our error handler
      // is attached before any userland ones.  NEVER DO THIS.
      if (!dest._events || !dest._events.error)
        dest.on('error', onerror);
      else if (isArray(dest._events.error))
        dest._events.error.unshift(onerror);
      else
        dest._events.error = [onerror, dest._events.error];
    
    
    
      // Both close and finish should trigger unpipe, but only once.
      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }
      dest.once('close', onclose);
      function onfinish() {
        dest.removeListener('close', onclose);
        unpipe();
      }
      dest.once('finish', onfinish);
    
      function unpipe() {
        src.unpipe(dest);
      }
    
      // tell the dest that it's being piped to
      dest.emit('pipe', src);
    
      // start the flow if it hasn't been started already.
      if (!state.flowing) {
        // the handler that waits for readable events after all
        // the data gets sucked out in flow.
        // This would be easier to follow with a .once() handler
        // in flow(), but that is too slow.
        this.on('readable', pipeOnReadable);
    
        state.flowing = true;
        process.nextTick(function() {
          flow(src);
        });
      }
    
      return dest;
    };
    
    function pipeOnDrain(src) {
      return function() {
        var dest = this;
        var state = src._readableState;
        state.awaitDrain--;
        if (state.awaitDrain === 0)
          flow(src);
      };
    }
    
    function flow(src) {
      var state = src._readableState;
      var chunk;
      state.awaitDrain = 0;
    
      function write(dest, i, list) {
        var written = dest.write(chunk);
        if (false === written) {
          state.awaitDrain++;
        }
      }
    
      while (state.pipesCount && null !== (chunk = src.read())) {
    
        if (state.pipesCount === 1)
          write(state.pipes, 0, null);
        else
          forEach(state.pipes, write);
    
        src.emit('data', chunk);
    
        // if anyone needs a drain, then we have to wait for that.
        if (state.awaitDrain > 0)
          return;
      }
    
      // if every destination was unpiped, either before entering this
      // function, or in the while loop, then stop flowing.
      //
      // NB: This is a pretty rare edge case.
      if (state.pipesCount === 0) {
        state.flowing = false;
    
        // if there were data event listeners added, then switch to old mode.
        if (EE.listenerCount(src, 'data') > 0)
          emitDataEvents(src);
        return;
      }
    
      // at this point, no one needed a drain, so we just ran out of data
      // on the next readable event, start it over again.
      state.ranOut = true;
    }
    
    function pipeOnReadable() {
      if (this._readableState.ranOut) {
        this._readableState.ranOut = false;
        flow(this);
      }
    }
    
    
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
    
      // if we're not piping anywhere, then do nothing.
      if (state.pipesCount === 0)
        return this;
    
      // just one destination.  most common case.
      if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes)
          return this;
    
        if (!dest)
          dest = state.pipes;
    
        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener('readable', pipeOnReadable);
        state.flowing = false;
        if (dest)
          dest.emit('unpipe', this);
        return this;
      }
    
      // slow case. multiple pipe destinations.
    
      if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener('readable', pipeOnReadable);
        state.flowing = false;
    
        for (var i = 0; i < len; i++)
          dests[i].emit('unpipe', this);
        return this;
      }
    
      // try to find the right one.
      var i = indexOf(state.pipes, dest);
      if (i === -1)
        return this;
    
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
    
      dest.emit('unpipe', this);
    
      return this;
    };
    
    // set up data events if they are asked for
    // Ensure readable listeners eventually get something
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
    
      if (ev === 'data' && !this._readableState.flowing)
        emitDataEvents(this);
    
      if (ev === 'readable' && this.readable) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            this.read(0);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
    
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    
    // pause() and resume() are remnants of the legacy readable stream API
    // If the user uses them, then switch into old mode.
    Readable.prototype.resume = function() {
      emitDataEvents(this);
      this.read(0);
      this.emit('resume');
    };
    
    Readable.prototype.pause = function() {
      emitDataEvents(this, true);
      this.emit('pause');
    };
    
    function emitDataEvents(stream, startPaused) {
      var state = stream._readableState;
    
      if (state.flowing) {
        // https://github.com/isaacs/readable-stream/issues/16
        throw new Error('Cannot switch to old mode now.');
      }
    
      var paused = startPaused || false;
      var readable = false;
    
      // convert to an old-style stream.
      stream.readable = true;
      stream.pipe = Stream.prototype.pipe;
      stream.on = stream.addListener = Stream.prototype.on;
    
      stream.on('readable', function() {
        readable = true;
    
        var c;
        while (!paused && (null !== (c = stream.read())))
          stream.emit('data', c);
    
        if (c === null) {
          readable = false;
          stream._readableState.needReadable = true;
        }
      });
    
      stream.pause = function() {
        paused = true;
        this.emit('pause');
      };
    
      stream.resume = function() {
        paused = false;
        if (readable)
          process.nextTick(function() {
            stream.emit('readable');
          });
        else
          this.read(0);
        this.emit('resume');
      };
    
      // now make it start, just in case it hadn't already.
      stream.emit('readable');
    }
    
    // wrap an old-style stream as the async data source.
    // This is *not* part of the readable stream interface.
    // It is an ugly unfortunate mess of history.
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
    
      var self = this;
      stream.on('end', function() {
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self.push(chunk);
        }
    
        self.push(null);
      });
    
      stream.on('data', function(chunk) {
        if (state.decoder)
          chunk = state.decoder.write(chunk);
    
        // don't skip over falsy values in objectMode
        //if (state.objectMode && util.isNullOrUndefined(chunk))
        if (state.objectMode && (chunk === null || chunk === undefined))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
    
        var ret = self.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
    
      // proxy all the other methods.
      // important when wrapping filters and duplexes.
      for (var i in stream) {
        if (typeof stream[i] === 'function' &&
            typeof this[i] === 'undefined') {
          this[i] = function(method) { return function() {
            return stream[method].apply(stream, arguments);
          }}(i);
        }
      }
    
      // proxy certain important events.
      var events = ['error', 'close', 'destroy', 'pause', 'resume'];
      forEach(events, function(ev) {
        stream.on(ev, self.emit.bind(self, ev));
      });
    
      // when we try to consume some more bytes, simply unpause the
      // underlying stream.
      self._read = function(n) {
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
    
      return self;
    };
    
    
    
    // exposed for testing purposes only.
    Readable._fromList = fromList;
    
    // Pluck off n bytes from an array of buffers.
    // Length is the combined lengths of all the buffers in the list.
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
    
      // nothing in the list, definitely empty.
      if (list.length === 0)
        return null;
    
      if (length === 0)
        ret = null;
      else if (objectMode)
        ret = list.shift();
      else if (!n || n >= length) {
        // read it all, truncate the array.
        if (stringMode)
          ret = list.join('');
        else
          ret = Buffer.concat(list, length);
        list.length = 0;
      } else {
        // read just some of it.
        if (n < list[0].length) {
          // just take a part of the first list item.
          // slice is the same for buffers and strings.
          var buf = list[0];
          ret = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          // first list is a perfect match
          ret = list.shift();
        } else {
          // complex case.
          // we have enough to cover it, but it spans past the first buffer.
          if (stringMode)
            ret = '';
          else
            ret = new Buffer(n);
    
          var c = 0;
          for (var i = 0, l = list.length; i < l && c < n; i++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
    
            if (stringMode)
              ret += buf.slice(0, cpy);
            else
              buf.copy(ret, c, 0, cpy);
    
            if (cpy < buf.length)
              list[0] = buf.slice(cpy);
            else
              list.shift();
    
            c += cpy;
          }
        }
      }
    
      return ret;
    }
    
    function endReadable(stream) {
      var state = stream._readableState;
    
      // If we get here before consuming all the bytes, then that is a
      // bug in node.  Should never happen.
      if (state.length > 0)
        throw new Error('endReadable called on non-empty stream');
    
      if (!state.endEmitted && state.calledRead) {
        state.ended = true;
        process.nextTick(function() {
          // Check that we didn't get one last unshift.
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit('end');
          }
        });
      }
    }
    
    function forEach (xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    
    function indexOf (xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
    
  provide("readable-stream/lib/_stream_readable.js", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_writable.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // A bit simpler than readable streams.
    // Implement an async ._write(chunk, cb), and it'll handle all
    // the drain event emission and buffering.
    
    module.exports = Writable;
    
    /*<replacement>*/
    var Buffer = require('buffer').Buffer;
    /*</replacement>*/
    
    Writable.WritableState = WritableState;
    
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    var Stream = require('stream');
    
    util.inherits(Writable, Stream);
    
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
    }
    
    function WritableState(options, stream) {
      options = options || {};
    
      // the point at which write() starts returning false
      // Note: 0 is a valid value, means that we always return false if
      // the entire buffer is not flushed immediately on write()
      var hwm = options.highWaterMark;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
    
      // object stream flag to indicate whether or not this stream
      // contains buffers or objects.
      this.objectMode = !!options.objectMode;
    
      // cast to ints.
      this.highWaterMark = ~~this.highWaterMark;
    
      this.needDrain = false;
      // at the start of calling end()
      this.ending = false;
      // when end() has been called, and returned
      this.ended = false;
      // when 'finish' is emitted
      this.finished = false;
    
      // should we decode strings into buffers before passing to _write?
      // this is here so that some node-core streams can optimize string
      // handling at a lower level.
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
    
      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';
    
      // not an actual buffer we keep track of, but a measurement
      // of how much we're waiting to get pushed to some underlying
      // socket or file.
      this.length = 0;
    
      // a flag to see when we're in the middle of a write.
      this.writing = false;
    
      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, becuase any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;
    
      // a flag to know if we're processing previously buffered items, which
      // may call the _write() callback in the same tick, so that we don't
      // end up in an overlapped onwrite situation.
      this.bufferProcessing = false;
    
      // the callback that's passed to _write(chunk,cb)
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
    
      // the callback that the user supplies to write(chunk,encoding,cb)
      this.writecb = null;
    
      // the amount that is being written when _write is called.
      this.writelen = 0;
    
      this.buffer = [];
    
      // True if the error was already emitted and should not be thrown again
      this.errorEmitted = false;
    }
    
    function Writable(options) {
      var Duplex =  require('readable-stream/lib/_stream_duplex');
    
      // Writable ctor is applied to Duplexes, though they're not
      // instanceof Writable, they're instanceof Readable.
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
    
      this._writableState = new WritableState(options, this);
    
      // legacy.
      this.writable = true;
    
      Stream.call(this);
    }
    
    // Otherwise people can pipe Writable streams, which is just wrong.
    Writable.prototype.pipe = function() {
      this.emit('error', new Error('Cannot pipe. Not readable.'));
    };
    
    
    function writeAfterEnd(stream, state, cb) {
      var er = new Error('write after end');
      // TODO: defer error events consistently everywhere, not just the cb
      stream.emit('error', er);
      process.nextTick(function() {
        cb(er);
      });
    }
    
    // If we get something that is not a buffer, string, null, or undefined,
    // and we're not in objectMode, then that's an error.
    // Otherwise stream chunks are all considered to be of length=1, and the
    // watermarks determine how many objects to keep in the buffer, rather than
    // how many bytes or characters.
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      if (!Buffer.isBuffer(chunk) &&
          'string' !== typeof chunk &&
          chunk !== null &&
          chunk !== undefined &&
          !state.objectMode) {
        var er = new TypeError('Invalid non-string/buffer chunk');
        stream.emit('error', er);
        process.nextTick(function() {
          cb(er);
        });
        valid = false;
      }
      return valid;
    }
    
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
    
      if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
    
      if (Buffer.isBuffer(chunk))
        encoding = 'buffer';
      else if (!encoding)
        encoding = state.defaultEncoding;
    
      if (typeof cb !== 'function')
        cb = function() {};
    
      if (state.ended)
        writeAfterEnd(this, state, cb);
      else if (validChunk(this, state, chunk, cb))
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
    
      return ret;
    };
    
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode &&
          state.decodeStrings !== false &&
          typeof chunk === 'string') {
        chunk = new Buffer(chunk, encoding);
      }
      return chunk;
    }
    
    // if we're already writing something, then just put this
    // in the queue, and wait our turn.  Otherwise, call _write
    // If we return false, then we need a drain event, so set that flag.
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      if (Buffer.isBuffer(chunk))
        encoding = 'buffer';
      var len = state.objectMode ? 1 : chunk.length;
    
      state.length += len;
    
      var ret = state.length < state.highWaterMark;
      // we must ensure that previous needDrain will not be reset to false.
      if (!ret)
        state.needDrain = true;
    
      if (state.writing)
        state.buffer.push(new WriteReq(chunk, encoding, cb));
      else
        doWrite(stream, state, len, chunk, encoding, cb);
    
      return ret;
    }
    
    function doWrite(stream, state, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    
    function onwriteError(stream, state, sync, er, cb) {
      if (sync)
        process.nextTick(function() {
          cb(er);
        });
      else
        cb(er);
    
      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
    }
    
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
    
      onwriteStateUpdate(state);
    
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(stream, state);
    
        if (!finished && !state.bufferProcessing && state.buffer.length)
          clearBuffer(stream, state);
    
        if (sync) {
          process.nextTick(function() {
            afterWrite(stream, state, finished, cb);
          });
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      cb();
      if (finished)
        finishMaybe(stream, state);
    }
    
    // Must force callback to be called on nextTick, so that we don't
    // emit 'drain' before the write() consumer gets the 'false' return
    // value, and has a chance to attach a 'drain' listener.
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    }
    
    
    // if there's something in the buffer waiting, then process it
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
    
      for (var c = 0; c < state.buffer.length; c++) {
        var entry = state.buffer[c];
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
    
        doWrite(stream, state, len, chunk, encoding, cb);
    
        // if we didn't call the onwrite immediately, then
        // it means that we need to wait until it does.
        // also, that means that the chunk and cb are currently
        // being processed, so move the buffer counter past them.
        if (state.writing) {
          c++;
          break;
        }
      }
    
      state.bufferProcessing = false;
      if (c < state.buffer.length)
        state.buffer = state.buffer.slice(c);
      else
        state.buffer.length = 0;
    }
    
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error('not implemented'));
    };
    
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
    
      if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
    
      if (typeof chunk !== 'undefined' && chunk !== null)
        this.write(chunk, encoding);
    
      // ignore unnecessary end() calls.
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    
    
    function needFinish(stream, state) {
      return (state.ending &&
              state.length === 0 &&
              !state.finished &&
              !state.writing);
    }
    
    function finishMaybe(stream, state) {
      var need = needFinish(stream, state);
      if (need) {
        state.finished = true;
        stream.emit('finish');
      }
      return need;
    }
    
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once('finish', cb);
      }
      state.ended = true;
    }
    
  provide("readable-stream/lib/_stream_writable.js", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_duplex.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // a duplex stream is just a stream that is both readable and writable.
    // Since JS doesn't have multiple prototypal inheritance, this class
    // prototypally inherits from Readable, and then parasitically from
    // Writable.
    
    module.exports = Duplex;
    
    /*<replacement>*/
    var objectKeys = Object.keys || function (obj) {
      var keys = [];
      for (var key in obj) keys.push(key);
      return keys;
    }
    /*</replacement>*/
    
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    var Readable =  require('readable-stream/lib/_stream_readable');
    var Writable =  require('readable-stream/lib/_stream_writable');
    
    util.inherits(Duplex, Readable);
    
    forEach(objectKeys(Writable.prototype), function(method) {
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    });
    
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
    
      Readable.call(this, options);
      Writable.call(this, options);
    
      if (options && options.readable === false)
        this.readable = false;
    
      if (options && options.writable === false)
        this.writable = false;
    
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
    
      this.once('end', onend);
    }
    
    // the no-half-open enforcer
    function onend() {
      // if we allow half-open state, or if the writable side ended,
      // then we're ok.
      if (this.allowHalfOpen || this._writableState.ended)
        return;
    
      // no more data can be written.
      // But allow more writes to happen in this tick.
      process.nextTick(this.end.bind(this));
    }
    
    function forEach (xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    
  provide("readable-stream/lib/_stream_duplex.js", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_transform.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    
    // a transform stream is a readable/writable stream where you do
    // something with the data.  Sometimes it's called a "filter",
    // but that's not a great name for it, since that implies a thing where
    // some bits pass through, and others are simply ignored.  (That would
    // be a valid example of a transform, of course.)
    //
    // While the output is causally related to the input, it's not a
    // necessarily symmetric or synchronous transformation.  For example,
    // a zlib stream might take multiple plain-text writes(), and then
    // emit a single compressed chunk some time in the future.
    //
    // Here's how this works:
    //
    // The Transform stream has all the aspects of the readable and writable
    // stream classes.  When you write(chunk), that calls _write(chunk,cb)
    // internally, and returns false if there's a lot of pending writes
    // buffered up.  When you call read(), that calls _read(n) until
    // there's enough pending readable data buffered up.
    //
    // In a transform stream, the written data is placed in a buffer.  When
    // _read(n) is called, it transforms the queued up data, calling the
    // buffered _write cb's as it consumes chunks.  If consuming a single
    // written chunk would result in multiple output chunks, then the first
    // outputted bit calls the readcb, and subsequent chunks just go into
    // the read buffer, and will cause it to emit 'readable' if necessary.
    //
    // This way, back-pressure is actually determined by the reading side,
    // since _read has to be called to start processing a new chunk.  However,
    // a pathological inflate type of transform can cause excessive buffering
    // here.  For example, imagine a stream where every byte of input is
    // interpreted as an integer from 0-255, and then results in that many
    // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
    // 1kb of data being output.  In this case, you could write a very small
    // amount of input, and end up with a very large amount of output.  In
    // such a pathological inflating mechanism, there'd be no way to tell
    // the system to stop doing the transform.  A single 4MB write could
    // cause the system to run out of memory.
    //
    // However, even in such a pathological case, only a single written chunk
    // would be consumed, and then the rest would wait (un-transformed) until
    // the results of the previous transformed chunk were consumed.
    
    module.exports = Transform;
    
    var Duplex =  require('readable-stream/lib/_stream_duplex');
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    util.inherits(Transform, Duplex);
    
    
    function TransformState(options, stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
    
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
    
      var cb = ts.writecb;
    
      if (!cb)
        return stream.emit('error', new Error('no writecb in Transform class'));
    
      ts.writechunk = null;
      ts.writecb = null;
    
      if (data !== null && data !== undefined)
        stream.push(data);
    
      if (cb)
        cb(er);
    
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    
    
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
    
      Duplex.call(this, options);
    
      var ts = this._transformState = new TransformState(options, this);
    
      // when the writable side finishes, then flush out anything remaining.
      var stream = this;
    
      // start out asking for a readable event once data is transformed.
      this._readableState.needReadable = true;
    
      // we have implemented the _read method, and done the other things
      // that Readable wants before the first _read call, so unset the
      // sync guard flag.
      this._readableState.sync = false;
    
      this.once('finish', function() {
        if ('function' === typeof this._flush)
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    
    // This is the part where you do stuff!
    // override this function in implementation classes.
    // 'chunk' is an input chunk.
    //
    // Call `push(newChunk)` to pass along transformed output
    // to the readable side.  You may call 'push' zero or more times.
    //
    // Call `cb(err)` when you are done with this chunk.  If you pass
    // an error, then that'll put the hurt on the whole operation.  If you
    // never call cb(), then you'll never get another chunk.
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error('not implemented');
    };
    
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform ||
            rs.needReadable ||
            rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    
    // Doesn't matter what the args are here.
    // _transform does all the work.
    // That we got here means that the readable side wants more data.
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
    
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
      }
    };
    
    
    function done(stream, er) {
      if (er)
        return stream.emit('error', er);
    
      // if there's nothing in the write buffer, then that means
      // that nothing more will ever be provided
      var ws = stream._writableState;
      var rs = stream._readableState;
      var ts = stream._transformState;
    
      if (ws.length)
        throw new Error('calling transform done when ws.length != 0');
    
      if (ts.transforming)
        throw new Error('calling transform done when still transforming');
    
      return stream.push(null);
    }
    
  provide("readable-stream/lib/_stream_transform.js", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_passthrough.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // a passthrough stream.
    // basically just the most minimal sort of Transform stream.
    // Every written chunk gets output as-is.
    
    module.exports = PassThrough;
    
    var Transform =  require('readable-stream/lib/_stream_transform');
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    util.inherits(PassThrough, Transform);
    
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
    
      Transform.call(this, options);
    }
    
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
    
  provide("readable-stream/lib/_stream_passthrough.js", module.exports);
}(global));

// pakmanager:readable-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Stream = require('stream'); // hack to fix a circular dependency issue when used with browserify
    exports = module.exports =  require('readable-stream/lib/_stream_readable.js');
    exports.Stream = Stream;
    exports.Readable = exports;
    exports.Writable =  require('readable-stream/lib/_stream_writable.js');
    exports.Duplex =  require('readable-stream/lib/_stream_duplex.js');
    exports.Transform =  require('readable-stream/lib/_stream_transform.js');
    exports.PassThrough =  require('readable-stream/lib/_stream_passthrough.js');
    
  provide("readable-stream", module.exports);
}(global));

// pakmanager:nan
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  console.log(require('path').relative('.', __dirname));
    
  provide("nan", module.exports);
}(global));

// pakmanager:bytes/lib/byte-convert
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    /**
     * Convert the value given in bytes into bytes, KB, MB, GB or TB.
     *
     * @param {number} value Value to convert.
     *
     * @returns {{value: number, unit: string}} The converted value and the second the unit.
     */
    function convertValue(value) {
      var tbValue  = ((1 << 30) * 1024),
          gbValue  = 1 << 30,
          mbValue  = 1 << 20,
          kbValue  = 1 << 10,
          absValue = Math.abs(value),
          unit     = 'B';
    
      if (absValue >= tbValue) {
        value = Math.round(value / tbValue * 100) / 100;
        unit = 'TB';
      } else if (absValue >= gbValue) {
        value = Math.round(value / gbValue * 100) / 100;
        unit = 'GB';
      } else if (absValue >= mbValue) {
        value = Math.round(value / mbValue * 100) / 100;
        unit = 'MB';
      } else if (absValue >= kbValue) {
        value = Math.round(value / kbValue * 100) / 100;
        unit = 'kB';
      }
    
      return {
        value: value,
        unit: unit
      };
    }
    
    /**
     * @see {@link parser.convert()}
     *
     * @param {number} value Value to convert
     * @param {{
     *  thousandsSeparator: string|null
     * }} [options] See byte parser options.
     *
     * @return {string|null}
     * @api public
     */
    
    module.exports = function (value, options) {
      if (typeof value !== 'number') {
        return null;
      }
    
      var converterResult = convertValue(value);
      var convertedValue = converterResult.value;
      var thousandsSeparator = (options && options.thousandsSeparator) || '';
      var unit = converterResult.unit;
    
      if (thousandsSeparator) {
        convertedValue = convertedValue.toString().replace(/\B(?=(\d{3})+(?!\d))/g, thousandsSeparator);
      }
    
      return convertedValue + unit;
    };
    
  provide("bytes/lib/byte-convert", module.exports);
}(global));

// pakmanager:bytes/lib/byte-parse
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    /**
     * Module variables.
     * @private
     */
    
    var map = {
      b:  1,
      kb: 1 << 10,
      mb: 1 << 20,
      gb: 1 << 30,
      tb: ((1 << 30) * 1024)
    };
    
    /**
     * @see {@link parser.parse()}
     *
     * @param {string} stringValue
     * @returns {number|null}
     */
    
    module.exports = function(stringValue) {
    
      // Expect value to be a string
      if (typeof stringValue !== 'string') {
        return null;
      }
    
      // Test if the string passed is valid
      var results = stringValue.match(/^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb)$/i);
      var floatValue;
      var unit = 'b';
    
      if (!results) {
        // Nothing could be extracted from the given string
        floatValue = parseInt(stringValue);
        unit = 'b'
      } else {
        // Retrieve the value and the unit
        floatValue = parseFloat(results[1]);
        unit       = results[4].toLowerCase();
      }
    
      return map[unit] * floatValue;
    };
    
  provide("bytes/lib/byte-parse", module.exports);
}(global));

// pakmanager:bytes
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    /**
     * Module exports.
     * @public
     */
    
    module.exports = bytes;
    
    /**
     * Module dependencies.
     * @private
     */
    
    var convert =  require('bytes/lib/byte-convert');
    var parse =  require('bytes/lib/byte-parse');
    
    /**
     *Convert the given value in bytes into a string or parse to string to an integer in bytes.
     *
     * @param {string|number} value
     * @param {{
     *  case: [string],
     *  thousandsSeparator: [string]
     *  }} [options] bytes options.
     *
     * @returns {string|number|null}
     */
    
    function bytes(value, options) {
      if (typeof value === 'string') {
        return parse(value);
      }
    
      if (typeof value === 'number') {
        return convert(value, options);
      }
    
      return null;
    }
    
  provide("bytes", module.exports);
}(global));

// pakmanager:iconv-lite/encodings/internal
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Export Node.js internal encodings.
    
    var utf16lebom = new Buffer([0xFF, 0xFE]);
    
    module.exports = {
        // Encodings
        utf8:   { type: "_internal", enc: "utf8" },
        cesu8:  { type: "_internal", enc: "utf8" },
        unicode11utf8: { type: "_internal", enc: "utf8" },
        ucs2:   { type: "_internal", enc: "ucs2", bom: utf16lebom },
        utf16le:{ type: "_internal", enc: "ucs2", bom: utf16lebom },
        binary: { type: "_internal", enc: "binary" },
        base64: { type: "_internal", enc: "base64" },
        hex:    { type: "_internal", enc: "hex" },
    
        // Codec.
        _internal: function(options) {
            if (!options || !options.enc)
                throw new Error("Internal codec is called without encoding type.")
    
            return {
                encoder: options.enc == "base64" ? encoderBase64 : encoderInternal,
                decoder: decoderInternal,
    
                enc: options.enc,
                bom: options.bom,
            };
        },
    };
    
    // We use node.js internal decoder. It's signature is the same as ours.
    var StringDecoder = require('string_decoder').StringDecoder;
    
    if (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.
        StringDecoder.prototype.end = function() {};
    
    function decoderInternal() {
        return new StringDecoder(this.enc);
    }
    
    // Encoder is mostly trivial
    
    function encoderInternal() {
        return {
            write: encodeInternal,
            end: function() {},
            
            enc: this.enc,
        }
    }
    
    function encodeInternal(str) {
        return new Buffer(str, this.enc);
    }
    
    
    // Except base64 encoder, which must keep its state.
    
    function encoderBase64() {
        return {
            write: encodeBase64Write,
            end: encodeBase64End,
    
            prevStr: '',
        };
    }
    
    function encodeBase64Write(str) {
        str = this.prevStr + str;
        var completeQuads = str.length - (str.length % 4);
        this.prevStr = str.slice(completeQuads);
        str = str.slice(0, completeQuads);
    
        return new Buffer(str, "base64");
    }
    
    function encodeBase64End() {
        return new Buffer(this.prevStr, "base64");
    }
    
    
  provide("iconv-lite/encodings/internal", module.exports);
}(global));

// pakmanager:iconv-lite/encodings/utf16
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    
    // == UTF16-BE codec. ==========================================================
    
    exports.utf16be = function(options) {
        return {
            encoder: utf16beEncoder,
            decoder: utf16beDecoder,
    
            bom: new Buffer([0xFE, 0xFF]),
        };
    };
    
    
    // -- Encoding
    
    function utf16beEncoder(options) {
        return {
            write: utf16beEncoderWrite,
            end: function() {},
        }
    }
    
    function utf16beEncoderWrite(str) {
        var buf = new Buffer(str, 'ucs2');
        for (var i = 0; i < buf.length; i += 2) {
            var tmp = buf[i]; buf[i] = buf[i+1]; buf[i+1] = tmp;
        }
        return buf;
    }
    
    
    // -- Decoding
    
    function utf16beDecoder(options) {
        return {
            write: utf16beDecoderWrite,
            end: function() {},
    
            overflowByte: -1,
        };
    }
    
    function utf16beDecoderWrite(buf) {
        if (buf.length == 0)
            return '';
    
        var buf2 = new Buffer(buf.length + 1),
            i = 0, j = 0;
    
        if (this.overflowByte !== -1) {
            buf2[0] = buf[0];
            buf2[1] = this.overflowByte;
            i = 1; j = 2;
        }
    
        for (; i < buf.length-1; i += 2, j+= 2) {
            buf2[j] = buf[i+1];
            buf2[j+1] = buf[i];
        }
    
        this.overflowByte = (i == buf.length-1) ? buf[buf.length-1] : -1;
    
        return buf2.slice(0, j).toString('ucs2');
    }
    
    
    // == UTF-16 codec =============================================================
    // Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
    // Defaults to UTF-16BE, according to RFC 2781, although it is against some industry practices, see
    // http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
    // Decoder default can be changed: iconv.decode(buf, 'utf16', {default: 'utf-16le'});
    
    // Encoder prepends BOM and uses UTF-16BE.
    // Endianness can also be changed: iconv.encode(str, 'utf16', {use: 'utf-16le'});
    
    exports.utf16 = function(options) {
        return {
            encoder: utf16Encoder,
            decoder: utf16Decoder,
    
            getCodec: options.iconv.getCodec,
        };
    };
    
    // -- Encoding
    
    function utf16Encoder(options) {
        options = options || {};
        var codec = this.getCodec(options.use || 'utf-16be');
        if (!codec.bom)
            throw new Error("iconv-lite: in UTF-16 encoder, 'use' parameter should be either UTF-16BE or UTF16-LE.");
    
        return {
            write: utf16EncoderWrite,
            end: utf16EncoderEnd,
    
            bom: codec.bom,
            internalEncoder: codec.encoder(options),
        };
    }
    
    function utf16EncoderWrite(str) {
        var buf = this.internalEncoder.write(str);
    
        if (this.bom) {
            buf = Buffer.concat([this.bom, buf]);
            this.bom = null;
        }
    
        return buf;
    }
    
    function utf16EncoderEnd() {
        return this.internalEncoder.end();
    }
    
    
    // -- Decoding
    
    function utf16Decoder(options) {
        return {
            write: utf16DecoderWrite,
            end: utf16DecoderEnd,
    
            internalDecoder: null,
            initialBytes: [],
            initialBytesLen: 0,
    
            options: options || {},
            getCodec: this.getCodec,
        };
    }
    
    function utf16DecoderWrite(buf) {
        if (this.internalDecoder)
            return this.internalDecoder.write(buf);
    
        // Codec is not chosen yet. Accumulate initial bytes.
        this.initialBytes.push(buf);
        this.initialBytesLen += buf.length;
        
        if (this.initialBytesLen < 16) // We need > 2 bytes to use space heuristic (see below)
            return '';
    
        // We have enough bytes -> decide endianness.
        return utf16DecoderDecideEndianness.call(this);
    }
    
    function utf16DecoderEnd() {
        if (this.internalDecoder)
            return this.internalDecoder.end();
    
        var res = utf16DecoderDecideEndianness.call(this);
        var trail;
    
        if (this.internalDecoder)
            trail = this.internalDecoder.end();
    
        return (trail && trail.length > 0) ? (res + trail) : res;
    }
    
    function utf16DecoderDecideEndianness() {
        var buf = Buffer.concat(this.initialBytes);
        this.initialBytes.length = this.initialBytesLen = 0;
    
        if (buf.length < 2)
            return ''; // Not a valid UTF-16 sequence anyway.
    
        // Default encoding.
        var enc = this.options.default || 'utf-16be';
    
        // Check BOM.
        if (buf[0] == 0xFE && buf[1] == 0xFF) { // UTF-16BE BOM
            enc = 'utf-16be'; buf = buf.slice(2);
        }
        else if (buf[0] == 0xFF && buf[1] == 0xFE) { // UTF-16LE BOM
            enc = 'utf-16le'; buf = buf.slice(2);
        }
        else {
            // No BOM found. Try to deduce encoding from initial content.
            // Most of the time, the content has spaces (U+0020), but the opposite (U+2000) is very uncommon.
            // So, we count spaces as if it was LE or BE, and decide from that.
            var spaces = [0, 0], // Counts of space chars in both positions
                _len = Math.min(buf.length - (buf.length % 2), 64); // Len is always even.
    
            for (var i = 0; i < _len; i += 2) {
                if (buf[i] == 0x00 && buf[i+1] == 0x20) spaces[0]++;
                if (buf[i] == 0x20 && buf[i+1] == 0x00) spaces[1]++;
            }
    
            if (spaces[0] > 0 && spaces[1] == 0)  
                enc = 'utf-16be';
            else if (spaces[0] == 0 && spaces[1] > 0)
                enc = 'utf-16le';
        }
    
        this.internalDecoder = this.getCodec(enc).decoder(this.options);
        return this.internalDecoder.write(buf);
    }
    
    
    
  provide("iconv-lite/encodings/utf16", module.exports);
}(global));

// pakmanager:iconv-lite/encodings/utf7
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
    // Below is UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3
    
    exports.utf7 = function(options) {
        return {
            encoder: function utf7Encoder() {
                return {
                    write: utf7EncoderWrite,
                    end: function() {},
    
                    iconv: options.iconv,
                };
            },
            decoder: function utf7Decoder() {
                return {
                    write: utf7DecoderWrite,
                    end: utf7DecoderEnd,
    
                    iconv: options.iconv,
                    inBase64: false,
                    base64Accum: '',
                };
            },
        };
    };
    
    exports.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7
    
    
    var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
    
    function utf7EncoderWrite(str) {
        // Naive implementation.
        // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
        return new Buffer(str.replace(nonDirectChars, function(chunk) {
            return "+" + (chunk === '+' ? '' : 
                this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) 
                + "-";
        }.bind(this)));
    }
    
    
    var base64Regex = /[A-Za-z0-9\/+]/;
    var base64Chars = [];
    for (var i = 0; i < 256; i++)
        base64Chars[i] = base64Regex.test(String.fromCharCode(i));
    
    var plusChar = '+'.charCodeAt(0), 
        minusChar = '-'.charCodeAt(0),
        andChar = '&'.charCodeAt(0);
    
    function utf7DecoderWrite(buf) {
        var res = "", lastI = 0,
            inBase64 = this.inBase64,
            base64Accum = this.base64Accum;
    
        // The decoder is more involved as we must handle chunks in stream.
    
        for (var i = 0; i < buf.length; i++) {
            if (!inBase64) { // We're in direct mode.
                // Write direct chars until '+'
                if (buf[i] == plusChar) {
                    res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                    lastI = i+1;
                    inBase64 = true;
                }
            } else { // We decode base64.
                if (!base64Chars[buf[i]]) { // Base64 ended.
                    if (i == lastI && buf[i] == minusChar) {// "+-" -> "+"
                        res += "+";
                    } else {
                        var b64str = base64Accum + buf.slice(lastI, i).toString();
                        res += this.iconv.decode(new Buffer(b64str, 'base64'), "utf16-be");
                    }
    
                    if (buf[i] != minusChar) // Minus is absorbed after base64.
                        i--;
    
                    lastI = i+1;
                    inBase64 = false;
                    base64Accum = '';
                }
            }
        }
    
        if (!inBase64) {
            res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
        } else {
            var b64str = base64Accum + buf.slice(lastI).toString();
    
            var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
            base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
            b64str = b64str.slice(0, canBeDecoded);
    
            res += this.iconv.decode(new Buffer(b64str, 'base64'), "utf16-be");
        }
    
        this.inBase64 = inBase64;
        this.base64Accum = base64Accum;
    
        return res;
    }
    
    function utf7DecoderEnd() {
        var res = "";
        if (this.inBase64 && this.base64Accum.length > 0)
            res = this.iconv.decode(new Buffer(this.base64Accum, 'base64'), "utf16-be");
    
        this.inBase64 = false;
        this.base64Accum = '';
        return res;
    }
    
    
    // UTF-7-IMAP codec.
    // RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
    // Differences:
    //  * Base64 part is started by "&" instead of "+"
    //  * Direct characters are 0x20-0x7E, except "&" (0x26)
    //  * In Base64, "," is used instead of "/"
    //  * Base64 must not be used to represent direct characters.
    //  * No implicit shift back from Base64 (should always end with '-')
    //  * String must end in non-shifted position.
    //  * "-&" while in base64 is not allowed.
    
    
    exports.utf7imap = function(options) {
        return {
            encoder: function utf7ImapEncoder() {
                return {
                    write: utf7ImapEncoderWrite,
                    end: utf7ImapEncoderEnd,
    
                    iconv: options.iconv,
                    inBase64: false,
                    base64Accum: new Buffer(6),
                    base64AccumIdx: 0,
                };
            },
            decoder: function utf7ImapDecoder() {
                return {
                    write: utf7ImapDecoderWrite,
                    end: utf7ImapDecoderEnd,
    
                    iconv: options.iconv,
                    inBase64: false,
                    base64Accum: '',
                };
            },
        };
    };
    
    
    function utf7ImapEncoderWrite(str) {
        var inBase64 = this.inBase64,
            base64Accum = this.base64Accum,
            base64AccumIdx = this.base64AccumIdx,
            buf = new Buffer(str.length*5 + 10), bufIdx = 0;
    
        for (var i = 0; i < str.length; i++) {
            var uChar = str.charCodeAt(i);
            if (0x20 <= uChar && uChar <= 0x7E) { // Direct character or '&'.
                if (inBase64) {
                    if (base64AccumIdx > 0) {
                        bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
                        base64AccumIdx = 0;
                    }
    
                    buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
                    inBase64 = false;
                }
    
                if (!inBase64) {
                    buf[bufIdx++] = uChar; // Write direct character
    
                    if (uChar === andChar)  // Ampersand -> '&-'
                        buf[bufIdx++] = minusChar;
                }
    
            } else { // Non-direct character
                if (!inBase64) {
                    buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
                    inBase64 = true;
                }
                if (inBase64) {
                    base64Accum[base64AccumIdx++] = uChar >> 8;
                    base64Accum[base64AccumIdx++] = uChar & 0xFF;
    
                    if (base64AccumIdx == base64Accum.length) {
                        bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
                        base64AccumIdx = 0;
                    }
                }
            }
        }
    
        this.inBase64 = inBase64;
        this.base64AccumIdx = base64AccumIdx;
    
        return buf.slice(0, bufIdx);
    }
    
    function utf7ImapEncoderEnd() {
        var buf = new Buffer(10), bufIdx = 0;
        if (this.inBase64) {
            if (this.base64AccumIdx > 0) {
                bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
                this.base64AccumIdx = 0;
            }
    
            buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
            this.inBase64 = false;
        }
    
        return buf.slice(0, bufIdx);
    }
    
    
    var base64IMAPChars = base64Chars.slice();
    base64IMAPChars[','.charCodeAt(0)] = true;
    
    function utf7ImapDecoderWrite(buf) {
        var res = "", lastI = 0,
            inBase64 = this.inBase64,
            base64Accum = this.base64Accum;
    
        // The decoder is more involved as we must handle chunks in stream.
        // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).
    
        for (var i = 0; i < buf.length; i++) {
            if (!inBase64) { // We're in direct mode.
                // Write direct chars until '&'
                if (buf[i] == andChar) {
                    res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                    lastI = i+1;
                    inBase64 = true;
                }
            } else { // We decode base64.
                if (!base64IMAPChars[buf[i]]) { // Base64 ended.
                    if (i == lastI && buf[i] == minusChar) { // "&-" -> "&"
                        res += "&";
                    } else {
                        var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');
                        res += this.iconv.decode(new Buffer(b64str, 'base64'), "utf16-be");
                    }
    
                    if (buf[i] != minusChar) // Minus may be absorbed after base64.
                        i--;
    
                    lastI = i+1;
                    inBase64 = false;
                    base64Accum = '';
                }
            }
        }
    
        if (!inBase64) {
            res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
        } else {
            var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/');
    
            var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
            base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
            b64str = b64str.slice(0, canBeDecoded);
    
            res += this.iconv.decode(new Buffer(b64str, 'base64'), "utf16-be");
        }
    
        this.inBase64 = inBase64;
        this.base64Accum = base64Accum;
    
        return res;
    }
    
    function utf7ImapDecoderEnd() {
        var res = "";
        if (this.inBase64 && this.base64Accum.length > 0)
            res = this.iconv.decode(new Buffer(this.base64Accum, 'base64'), "utf16-be");
    
        this.inBase64 = false;
        this.base64Accum = '';
        return res;
    }
    
    
    
  provide("iconv-lite/encodings/utf7", module.exports);
}(global));

// pakmanager:iconv-lite/encodings/sbcs-codec
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
    // correspond to encoded bytes (if 128 - then lower half is ASCII). 
    
    exports._sbcs = function(options) {
        if (!options)
            throw new Error("SBCS codec is called without the data.")
        
        // Prepare char buffer for decoding.
        if (!options.chars || (options.chars.length !== 128 && options.chars.length !== 256))
            throw new Error("Encoding '"+options.type+"' has incorrect 'chars' (must be of len 128 or 256)");
        
        if (options.chars.length === 128) {
            var asciiString = "";
            for (var i = 0; i < 128; i++)
                asciiString += String.fromCharCode(i);
            options.chars = asciiString + options.chars;
        }
    
        var decodeBuf = new Buffer(options.chars, 'ucs2');
        
        // Encoding buffer.
        var encodeBuf = new Buffer(65536);
        encodeBuf.fill(options.iconv.defaultCharSingleByte.charCodeAt(0));
    
        for (var i = 0; i < options.chars.length; i++)
            encodeBuf[options.chars.charCodeAt(i)] = i;
    
        return {
            encoder: encoderSBCS,
            decoder: decoderSBCS,
    
            encodeBuf: encodeBuf,
            decodeBuf: decodeBuf,
        };
    }
    
    function encoderSBCS(options) {
        return {
            write: encoderSBCSWrite,
            end: function() {},
    
            encodeBuf: this.encodeBuf,
        };
    }
    
    function encoderSBCSWrite(str) {
        var buf = new Buffer(str.length);
        for (var i = 0; i < str.length; i++)
            buf[i] = this.encodeBuf[str.charCodeAt(i)];
        
        return buf;
    }
    
    
    function decoderSBCS(options) {
        return {
            write: decoderSBCSWrite,
            end: function() {},
            
            decodeBuf: this.decodeBuf,
        };
    }
    
    function decoderSBCSWrite(buf) {
        // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
        var decodeBuf = this.decodeBuf;
        var newBuf = new Buffer(buf.length*2);
        var idx1 = 0, idx2 = 0;
        for (var i = 0, _len = buf.length; i < _len; i++) {
            idx1 = buf[i]*2; idx2 = i*2;
            newBuf[idx2] = decodeBuf[idx1];
            newBuf[idx2+1] = decodeBuf[idx1+1];
        }
        return newBuf.toString('ucs2');
    }
    
  provide("iconv-lite/encodings/sbcs-codec", module.exports);
}(global));

// pakmanager:iconv-lite/encodings/sbcs-data
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Manually added data to be used by sbcs codec in addition to generated one.
    
    module.exports = {
        // Not supported by iconv, not sure why.
        "10029": "maccenteuro",
        "maccenteuro": {
            "type": "_sbcs",
            "chars": "ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ"
        },
    
        "808": "cp808",
        "ibm808": "cp808",
        "cp808": {
            "type": "_sbcs",
            "chars": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёЄєЇїЎў°∙·√№€■ "
        },
    
        // Aliases of generated encodings.
        "ascii8bit": "ascii",
        "usascii": "ascii",
        "ansix34": "ascii",
        "ansix341968": "ascii",
        "ansix341986": "ascii",
        "csascii": "ascii",
        "cp367": "ascii",
        "ibm367": "ascii",
        "isoir6": "ascii",
        "iso646us": "ascii",
        "iso646irv": "ascii",
        "us": "ascii",
    
        "latin1": "iso88591",
        "latin2": "iso88592",
        "latin3": "iso88593",
        "latin4": "iso88594",
        "latin5": "iso88599",
        "latin6": "iso885910",
        "latin7": "iso885913",
        "latin8": "iso885914",
        "latin9": "iso885915",
        "latin10": "iso885916",
    
        "csisolatin1": "iso88591",
        "csisolatin2": "iso88592",
        "csisolatin3": "iso88593",
        "csisolatin4": "iso88594",
        "csisolatincyrillic": "iso88595",
        "csisolatinarabic": "iso88596",
        "csisolatingreek" : "iso88597",
        "csisolatinhebrew": "iso88598",
        "csisolatin5": "iso88599",
        "csisolatin6": "iso885910",
    
        "l1": "iso88591",
        "l2": "iso88592",
        "l3": "iso88593",
        "l4": "iso88594",
        "l5": "iso88599",
        "l6": "iso885910",
        "l7": "iso885913",
        "l8": "iso885914",
        "l9": "iso885915",
        "l10": "iso885916",
    
        "isoir14": "iso646jp",
        "isoir57": "iso646cn",
        "isoir100": "iso88591",
        "isoir101": "iso88592",
        "isoir109": "iso88593",
        "isoir110": "iso88594",
        "isoir144": "iso88595",
        "isoir127": "iso88596",
        "isoir126": "iso88597",
        "isoir138": "iso88598",
        "isoir148": "iso88599",
        "isoir157": "iso885910",
        "isoir166": "tis620",
        "isoir179": "iso885913",
        "isoir199": "iso885914",
        "isoir203": "iso885915",
        "isoir226": "iso885916",
    
        "cp819": "iso88591",
        "ibm819": "iso88591",
    
        "cyrillic": "iso88595",
    
        "arabic": "iso88596",
        "arabic8": "iso88596",
        "ecma114": "iso88596",
        "asmo708": "iso88596",
    
        "greek" : "iso88597",
        "greek8" : "iso88597",
        "ecma118" : "iso88597",
        "elot928" : "iso88597",
    
        "hebrew": "iso88598",
        "hebrew8": "iso88598",
    
        "turkish": "iso88599",
        "turkish8": "iso88599",
    
        "thai": "iso885911",
        "thai8": "iso885911",
    
        "celtic": "iso885914",
        "celtic8": "iso885914",
        "isoceltic": "iso885914",
    
        "tis6200": "tis620",
        "tis62025291": "tis620",
        "tis62025330": "tis620",
    
        "10000": "macroman",
        "10006": "macgreek",
        "10007": "maccyrillic",
        "10079": "maciceland",
        "10081": "macturkish",
    
        "cspc8codepage437": "cp437",
        "cspc775baltic": "cp775",
        "cspc850multilingual": "cp850",
        "cspcp852": "cp852",
        "cspc862latinhebrew": "cp862",
        "cpgr": "cp869",
    
        "msee": "cp1250",
        "mscyrl": "cp1251",
        "msansi": "cp1252",
        "msgreek": "cp1253",
        "msturk": "cp1254",
        "mshebr": "cp1255",
        "msarab": "cp1256",
        "winbaltrim": "cp1257",
    
        "cp20866": "koi8r",
        "20866": "koi8r",
        "ibm878": "koi8r",
        "cskoi8r": "koi8r",
    
        "cp21866": "koi8u",
        "21866": "koi8u",
        "ibm1168": "koi8u",
    
        "strk10482002": "rk1048",
    
        "tcvn5712": "tcvn",
        "tcvn57121": "tcvn",
    
        "gb198880": "iso646cn",
        "cn": "iso646cn",
    
        "csiso14jisc6220ro": "iso646jp",
        "jisc62201969ro": "iso646jp",
        "jp": "iso646jp",
    
        "cshproman8": "hproman8",
        "r8": "hproman8",
        "roman8": "hproman8",
        "xroman8": "hproman8",
        "ibm1051": "hproman8",
    
        "mac": "macintosh",
        "csmacintosh": "macintosh",
    };
    
    
  provide("iconv-lite/encodings/sbcs-data", module.exports);
}(global));

// pakmanager:iconv-lite/encodings/sbcs-data-generated
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
    module.exports = {
      "437": "cp437",
      "737": "cp737",
      "775": "cp775",
      "850": "cp850",
      "852": "cp852",
      "855": "cp855",
      "856": "cp856",
      "857": "cp857",
      "858": "cp858",
      "860": "cp860",
      "861": "cp861",
      "862": "cp862",
      "863": "cp863",
      "864": "cp864",
      "865": "cp865",
      "866": "cp866",
      "869": "cp869",
      "874": "windows874",
      "922": "cp922",
      "1046": "cp1046",
      "1124": "cp1124",
      "1125": "cp1125",
      "1129": "cp1129",
      "1133": "cp1133",
      "1161": "cp1161",
      "1162": "cp1162",
      "1163": "cp1163",
      "1250": "windows1250",
      "1251": "windows1251",
      "1252": "windows1252",
      "1253": "windows1253",
      "1254": "windows1254",
      "1255": "windows1255",
      "1256": "windows1256",
      "1257": "windows1257",
      "1258": "windows1258",
      "28591": "iso88591",
      "28592": "iso88592",
      "28593": "iso88593",
      "28594": "iso88594",
      "28595": "iso88595",
      "28596": "iso88596",
      "28597": "iso88597",
      "28598": "iso88598",
      "28599": "iso88599",
      "28600": "iso885910",
      "28601": "iso885911",
      "28603": "iso885913",
      "28604": "iso885914",
      "28605": "iso885915",
      "28606": "iso885916",
      "windows874": {
        "type": "_sbcs",
        "chars": "€����…�����������‘’“”•–—�������� กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����"
      },
      "win874": "windows874",
      "cp874": "windows874",
      "windows1250": {
        "type": "_sbcs",
        "chars": "€�‚�„…†‡�‰Š‹ŚŤŽŹ�‘’“”•–—�™š›śťžź ˇ˘Ł¤Ą¦§¨©Ş«¬­®Ż°±˛ł´µ¶·¸ąş»Ľ˝ľżŔÁÂĂÄĹĆÇČÉĘËĚÍÎĎĐŃŇÓÔŐÖ×ŘŮÚŰÜÝŢßŕáâăäĺćçčéęëěíîďđńňóôőö÷řůúűüýţ˙"
      },
      "win1250": "windows1250",
      "cp1250": "windows1250",
      "windows1251": {
        "type": "_sbcs",
        "chars": "ЂЃ‚ѓ„…†‡€‰Љ‹ЊЌЋЏђ‘’“”•–—�™љ›њќћџ ЎўЈ¤Ґ¦§Ё©Є«¬­®Ї°±Ііґµ¶·ё№є»јЅѕїАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя"
      },
      "win1251": "windows1251",
      "cp1251": "windows1251",
      "windows1252": {
        "type": "_sbcs",
        "chars": "€�‚ƒ„…†‡ˆ‰Š‹Œ�Ž��‘’“”•–—˜™š›œ�žŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
      },
      "win1252": "windows1252",
      "cp1252": "windows1252",
      "windows1253": {
        "type": "_sbcs",
        "chars": "€�‚ƒ„…†‡�‰�‹�����‘’“”•–—�™�›���� ΅Ά£¤¥¦§¨©�«¬­®―°±²³΄µ¶·ΈΉΊ»Ό½ΎΏΐΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡ�ΣΤΥΦΧΨΩΪΫάέήίΰαβγδεζηθικλμνξοπρςστυφχψωϊϋόύώ�"
      },
      "win1253": "windows1253",
      "cp1253": "windows1253",
      "windows1254": {
        "type": "_sbcs",
        "chars": "€�‚ƒ„…†‡ˆ‰Š‹Œ����‘’“”•–—˜™š›œ��Ÿ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏĞÑÒÓÔÕÖ×ØÙÚÛÜİŞßàáâãäåæçèéêëìíîïğñòóôõö÷øùúûüışÿ"
      },
      "win1254": "windows1254",
      "cp1254": "windows1254",
      "windows1255": {
        "type": "_sbcs",
        "chars": "€�‚ƒ„…†‡ˆ‰�‹�����‘’“”•–—˜™�›���� ¡¢£₪¥¦§¨©×«¬­®¯°±²³´µ¶·¸¹÷»¼½¾¿ְֱֲֳִֵֶַָֹ�ֻּֽ־ֿ׀ׁׂ׃װױײ׳״�������אבגדהוזחטיךכלםמןנסעףפץצקרשת��‎‏�"
      },
      "win1255": "windows1255",
      "cp1255": "windows1255",
      "windows1256": {
        "type": "_sbcs",
        "chars": "€پ‚ƒ„…†‡ˆ‰ٹ‹Œچژڈگ‘’“”•–—ک™ڑ›œ‌‍ں ،¢£¤¥¦§¨©ھ«¬­®¯°±²³´µ¶·¸¹؛»¼½¾؟ہءآأؤإئابةتثجحخدذرزسشصض×طظعغـفقكàلâمنهوçèéêëىيîïًٌٍَôُِ÷ّùْûü‎‏ے"
      },
      "win1256": "windows1256",
      "cp1256": "windows1256",
      "windows1257": {
        "type": "_sbcs",
        "chars": "€�‚�„…†‡�‰�‹�¨ˇ¸�‘’“”•–—�™�›�¯˛� �¢£¤�¦§Ø©Ŗ«¬­®Æ°±²³´µ¶·ø¹ŗ»¼½¾æĄĮĀĆÄÅĘĒČÉŹĖĢĶĪĻŠŃŅÓŌÕÖ×ŲŁŚŪÜŻŽßąįāćäåęēčéźėģķīļšńņóōõö÷ųłśūüżž˙"
      },
      "win1257": "windows1257",
      "cp1257": "windows1257",
      "windows1258": {
        "type": "_sbcs",
        "chars": "€�‚ƒ„…†‡ˆ‰�‹Œ����‘’“”•–—˜™�›œ��Ÿ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ"
      },
      "win1258": "windows1258",
      "cp1258": "windows1258",
      "iso88591": {
        "type": "_sbcs",
        "chars": " ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
      },
      "cp28591": "iso88591",
      "iso88592": {
        "type": "_sbcs",
        "chars": " Ą˘Ł¤ĽŚ§¨ŠŞŤŹ­ŽŻ°ą˛ł´ľśˇ¸šşťź˝žżŔÁÂĂÄĹĆÇČÉĘËĚÍÎĎĐŃŇÓÔŐÖ×ŘŮÚŰÜÝŢßŕáâăäĺćçčéęëěíîďđńňóôőö÷řůúűüýţ˙"
      },
      "cp28592": "iso88592",
      "iso88593": {
        "type": "_sbcs",
        "chars": " Ħ˘£¤�Ĥ§¨İŞĞĴ­�Ż°ħ²³´µĥ·¸ışğĵ½�żÀÁÂ�ÄĊĈÇÈÉÊËÌÍÎÏ�ÑÒÓÔĠÖ×ĜÙÚÛÜŬŜßàáâ�äċĉçèéêëìíîï�ñòóôġö÷ĝùúûüŭŝ˙"
      },
      "cp28593": "iso88593",
      "iso88594": {
        "type": "_sbcs",
        "chars": " ĄĸŖ¤ĨĻ§¨ŠĒĢŦ­Ž¯°ą˛ŗ´ĩļˇ¸šēģŧŊžŋĀÁÂÃÄÅÆĮČÉĘËĖÍÎĪĐŅŌĶÔÕÖ×ØŲÚÛÜŨŪßāáâãäåæįčéęëėíîīđņōķôõö÷øųúûüũū˙"
      },
      "cp28594": "iso88594",
      "iso88595": {
        "type": "_sbcs",
        "chars": " ЁЂЃЄЅІЇЈЉЊЋЌ­ЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя№ёђѓєѕіїјљњћќ§ўџ"
      },
      "cp28595": "iso88595",
      "iso88596": {
        "type": "_sbcs",
        "chars": " ���¤�������،­�������������؛���؟�ءآأؤإئابةتثجحخدذرزسشصضطظعغ�����ـفقكلمنهوىيًٌٍَُِّْ�������������"
      },
      "cp28596": "iso88596",
      "iso88597": {
        "type": "_sbcs",
        "chars": " ‘’£€₯¦§¨©ͺ«¬­�―°±²³΄΅Ά·ΈΉΊ»Ό½ΎΏΐΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡ�ΣΤΥΦΧΨΩΪΫάέήίΰαβγδεζηθικλμνξοπρςστυφχψωϊϋόύώ�"
      },
      "cp28597": "iso88597",
      "iso88598": {
        "type": "_sbcs",
        "chars": " �¢£¤¥¦§¨©×«¬­®¯°±²³´µ¶·¸¹÷»¼½¾��������������������������������‗אבגדהוזחטיךכלםמןנסעףפץצקרשת��‎‏�"
      },
      "cp28598": "iso88598",
      "iso88599": {
        "type": "_sbcs",
        "chars": " ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏĞÑÒÓÔÕÖ×ØÙÚÛÜİŞßàáâãäåæçèéêëìíîïğñòóôõö÷øùúûüışÿ"
      },
      "cp28599": "iso88599",
      "iso885910": {
        "type": "_sbcs",
        "chars": " ĄĒĢĪĨĶ§ĻĐŠŦŽ­ŪŊ°ąēģīĩķ·ļđšŧž―ūŋĀÁÂÃÄÅÆĮČÉĘËĖÍÎÏÐŅŌÓÔÕÖŨØŲÚÛÜÝÞßāáâãäåæįčéęëėíîïðņōóôõöũøųúûüýþĸ"
      },
      "cp28600": "iso885910",
      "iso885911": {
        "type": "_sbcs",
        "chars": " กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����"
      },
      "cp28601": "iso885911",
      "iso885913": {
        "type": "_sbcs",
        "chars": " ”¢£¤„¦§Ø©Ŗ«¬­®Æ°±²³“µ¶·ø¹ŗ»¼½¾æĄĮĀĆÄÅĘĒČÉŹĖĢĶĪĻŠŃŅÓŌÕÖ×ŲŁŚŪÜŻŽßąįāćäåęēčéźėģķīļšńņóōõö÷ųłśūüżž’"
      },
      "cp28603": "iso885913",
      "iso885914": {
        "type": "_sbcs",
        "chars": " Ḃḃ£ĊċḊ§Ẁ©ẂḋỲ­®ŸḞḟĠġṀṁ¶ṖẁṗẃṠỳẄẅṡÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏŴÑÒÓÔÕÖṪØÙÚÛÜÝŶßàáâãäåæçèéêëìíîïŵñòóôõöṫøùúûüýŷÿ"
      },
      "cp28604": "iso885914",
      "iso885915": {
        "type": "_sbcs",
        "chars": " ¡¢£€¥Š§š©ª«¬­®¯°±²³Žµ¶·ž¹º»ŒœŸ¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
      },
      "cp28605": "iso885915",
      "iso885916": {
        "type": "_sbcs",
        "chars": " ĄąŁ€„Š§š©Ș«Ź­źŻ°±ČłŽ”¶·žčș»ŒœŸżÀÁÂĂÄĆÆÇÈÉÊËÌÍÎÏĐŃÒÓÔŐÖŚŰÙÚÛÜĘȚßàáâăäćæçèéêëìíîïđńòóôőöśűùúûüęțÿ"
      },
      "cp28606": "iso885916",
      "cp437": {
        "type": "_sbcs",
        "chars": "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
      },
      "ibm437": "cp437",
      "csibm437": "cp437",
      "cp737": {
        "type": "_sbcs",
        "chars": "ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζηθικλμνξοπρσςτυφχψ░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀ωάέήϊίόύϋώΆΈΉΊΌΎΏ±≥≤ΪΫ÷≈°∙·√ⁿ²■ "
      },
      "ibm737": "cp737",
      "csibm737": "cp737",
      "cp775": {
        "type": "_sbcs",
        "chars": "ĆüéāäģåćłēŖŗīŹÄÅÉæÆōöĢ¢ŚśÖÜø£Ø×¤ĀĪóŻżź”¦©®¬½¼Ł«»░▒▓│┤ĄČĘĖ╣║╗╝ĮŠ┐└┴┬├─┼ŲŪ╚╔╩╦╠═╬Žąčęėįšųūž┘┌█▄▌▐▀ÓßŌŃõÕµńĶķĻļņĒŅ’­±“¾¶§÷„°∙·¹³²■ "
      },
      "ibm775": "cp775",
      "csibm775": "cp775",
      "cp850": {
        "type": "_sbcs",
        "chars": "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ðÐÊËÈıÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµþÞÚÛÙýÝ¯´­±‗¾¶§÷¸°¨·¹³²■ "
      },
      "ibm850": "cp850",
      "csibm850": "cp850",
      "cp852": {
        "type": "_sbcs",
        "chars": "ÇüéâäůćçłëŐőîŹÄĆÉĹĺôöĽľŚśÖÜŤťŁ×čáíóúĄąŽžĘę¬źČş«»░▒▓│┤ÁÂĚŞ╣║╗╝Żż┐└┴┬├─┼Ăă╚╔╩╦╠═╬¤đĐĎËďŇÍÎě┘┌█▄ŢŮ▀ÓßÔŃńňŠšŔÚŕŰýÝţ´­˝˛ˇ˘§÷¸°¨˙űŘř■ "
      },
      "ibm852": "cp852",
      "csibm852": "cp852",
      "cp855": {
        "type": "_sbcs",
        "chars": "ђЂѓЃёЁєЄѕЅіІїЇјЈљЉњЊћЋќЌўЎџЏюЮъЪаАбБцЦдДеЕфФгГ«»░▒▓│┤хХиИ╣║╗╝йЙ┐└┴┬├─┼кК╚╔╩╦╠═╬¤лЛмМнНоОп┘┌█▄Пя▀ЯрРсСтТуУжЖвВьЬ№­ыЫзЗшШэЭщЩчЧ§■ "
      },
      "ibm855": "cp855",
      "csibm855": "cp855",
      "cp856": {
        "type": "_sbcs",
        "chars": "אבגדהוזחטיךכלםמןנסעףפץצקרשת�£�×����������®¬½¼�«»░▒▓│┤���©╣║╗╝¢¥┐└┴┬├─┼��╚╔╩╦╠═╬¤���������┘┌█▄¦�▀������µ�������¯´­±‗¾¶§÷¸°¨·¹³²■ "
      },
      "ibm856": "cp856",
      "csibm856": "cp856",
      "cp857": {
        "type": "_sbcs",
        "chars": "ÇüéâäàåçêëèïîıÄÅÉæÆôöòûùİÖÜø£ØŞşáíóúñÑĞğ¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ºªÊËÈ�ÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµ�×ÚÛÙìÿ¯´­±�¾¶§÷¸°¨·¹³²■ "
      },
      "ibm857": "cp857",
      "csibm857": "cp857",
      "cp858": {
        "type": "_sbcs",
        "chars": "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ðÐÊËÈ€ÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµþÞÚÛÙýÝ¯´­±‗¾¶§÷¸°¨·¹³²■ "
      },
      "ibm858": "cp858",
      "csibm858": "cp858",
      "cp860": {
        "type": "_sbcs",
        "chars": "ÇüéâãàÁçêÊèÍÔìÃÂÉÀÈôõòÚùÌÕÜ¢£Ù₧ÓáíóúñÑªº¿Ò¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
      },
      "ibm860": "cp860",
      "csibm860": "cp860",
      "cp861": {
        "type": "_sbcs",
        "chars": "ÇüéâäàåçêëèÐðÞÄÅÉæÆôöþûÝýÖÜø£Ø₧ƒáíóúÁÍÓÚ¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
      },
      "ibm861": "cp861",
      "csibm861": "cp861",
      "cp862": {
        "type": "_sbcs",
        "chars": "אבגדהוזחטיךכלםמןנסעףפץצקרשת¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
      },
      "ibm862": "cp862",
      "csibm862": "cp862",
      "cp863": {
        "type": "_sbcs",
        "chars": "ÇüéâÂà¶çêëèïî‗À§ÉÈÊôËÏûù¤ÔÜ¢£ÙÛƒ¦´óú¨¸³¯Î⌐¬½¼¾«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
      },
      "ibm863": "cp863",
      "csibm863": "cp863",
      "cp864": {
        "type": "_sbcs",
        "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$٪&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~°·∙√▒─│┼┤┬├┴┐┌└┘β∞φ±½¼≈«»ﻷﻸ��ﻻﻼ� ­ﺂ£¤ﺄ��ﺎﺏﺕﺙ،ﺝﺡﺥ٠١٢٣٤٥٦٧٨٩ﻑ؛ﺱﺵﺹ؟¢ﺀﺁﺃﺅﻊﺋﺍﺑﺓﺗﺛﺟﺣﺧﺩﺫﺭﺯﺳﺷﺻﺿﻁﻅﻋﻏ¦¬÷×ﻉـﻓﻗﻛﻟﻣﻧﻫﻭﻯﻳﺽﻌﻎﻍﻡﹽّﻥﻩﻬﻰﻲﻐﻕﻵﻶﻝﻙﻱ■�"
      },
      "ibm864": "cp864",
      "csibm864": "cp864",
      "cp865": {
        "type": "_sbcs",
        "chars": "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø₧ƒáíóúñÑªº¿⌐¬½¼¡«¤░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
      },
      "ibm865": "cp865",
      "csibm865": "cp865",
      "cp866": {
        "type": "_sbcs",
        "chars": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёЄєЇїЎў°∙·√№¤■ "
      },
      "ibm866": "cp866",
      "csibm866": "cp866",
      "cp869": {
        "type": "_sbcs",
        "chars": "������Ά�·¬¦‘’Έ―ΉΊΪΌ��ΎΫ©Ώ²³ά£έήίϊΐόύΑΒΓΔΕΖΗ½ΘΙ«»░▒▓│┤ΚΛΜΝ╣║╗╝ΞΟ┐└┴┬├─┼ΠΡ╚╔╩╦╠═╬ΣΤΥΦΧΨΩαβγ┘┌█▄δε▀ζηθικλμνξοπρσςτ΄­±υφχ§ψ΅°¨ωϋΰώ■ "
      },
      "ibm869": "cp869",
      "csibm869": "cp869",
      "cp922": {
        "type": "_sbcs",
        "chars": " ¡¢£¤¥¦§¨©ª«¬­®‾°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏŠÑÒÓÔÕÖ×ØÙÚÛÜÝŽßàáâãäåæçèéêëìíîïšñòóôõö÷øùúûüýžÿ"
      },
      "ibm922": "cp922",
      "csibm922": "cp922",
      "cp1046": {
        "type": "_sbcs",
        "chars": "ﺈ×÷ﹱ■│─┐┌└┘ﹹﹻﹽﹿﹷﺊﻰﻳﻲﻎﻏﻐﻶﻸﻺﻼ ¤ﺋﺑﺗﺛﺟﺣ،­ﺧﺳ٠١٢٣٤٥٦٧٨٩ﺷ؛ﺻﺿﻊ؟ﻋءآأؤإئابةتثجحخدذرزسشصضطﻇعغﻌﺂﺄﺎﻓـفقكلمنهوىيًٌٍَُِّْﻗﻛﻟﻵﻷﻹﻻﻣﻧﻬﻩ�"
      },
      "ibm1046": "cp1046",
      "csibm1046": "cp1046",
      "cp1124": {
        "type": "_sbcs",
        "chars": " ЁЂҐЄЅІЇЈЉЊЋЌ­ЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя№ёђґєѕіїјљњћќ§ўџ"
      },
      "ibm1124": "cp1124",
      "csibm1124": "cp1124",
      "cp1125": {
        "type": "_sbcs",
        "chars": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёҐґЄєІіЇї·√№¤■ "
      },
      "ibm1125": "cp1125",
      "csibm1125": "cp1125",
      "cp1129": {
        "type": "_sbcs",
        "chars": " ¡¢£¤¥¦§œ©ª«¬­®¯°±²³Ÿµ¶·Œ¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ"
      },
      "ibm1129": "cp1129",
      "csibm1129": "cp1129",
      "cp1133": {
        "type": "_sbcs",
        "chars": " ກຂຄງຈສຊຍດຕຖທນບປຜຝພຟມຢຣລວຫອຮ���ຯະາຳິີຶືຸູຼັົຽ���ເແໂໃໄ່້໊໋໌ໍໆ�ໜໝ₭����������������໐໑໒໓໔໕໖໗໘໙��¢¬¦�"
      },
      "ibm1133": "cp1133",
      "csibm1133": "cp1133",
      "cp1161": {
        "type": "_sbcs",
        "chars": "��������������������������������่กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู้๊๋€฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛¢¬¦ "
      },
      "ibm1161": "cp1161",
      "csibm1161": "cp1161",
      "cp1162": {
        "type": "_sbcs",
        "chars": "€…‘’“”•–— กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����"
      },
      "ibm1162": "cp1162",
      "csibm1162": "cp1162",
      "cp1163": {
        "type": "_sbcs",
        "chars": " ¡¢£€¥¦§œ©ª«¬­®¯°±²³Ÿµ¶·Œ¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ"
      },
      "ibm1163": "cp1163",
      "csibm1163": "cp1163",
      "maccroatian": {
        "type": "_sbcs",
        "chars": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊�©⁄¤‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ"
      },
      "maccyrillic": {
        "type": "_sbcs",
        "chars": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°¢£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµ∂ЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю¤"
      },
      "macgreek": {
        "type": "_sbcs",
        "chars": "Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦­ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩάΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ�"
      },
      "maciceland": {
        "type": "_sbcs",
        "chars": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
      },
      "macroman": {
        "type": "_sbcs",
        "chars": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
      },
      "macromania": {
        "type": "_sbcs",
        "chars": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂŞ∞±≤≥¥µ∂∑∏π∫ªºΩăş¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›Ţţ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
      },
      "macthai": {
        "type": "_sbcs",
        "chars": "«»…“”�•‘’� กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู﻿​–—฿เแโใไๅๆ็่้๊๋์ํ™๏๐๑๒๓๔๕๖๗๘๙®©����"
      },
      "macturkish": {
        "type": "_sbcs",
        "chars": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙ�ˆ˜¯˘˙˚¸˝˛ˇ"
      },
      "macukraine": {
        "type": "_sbcs",
        "chars": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю¤"
      },
      "koi8r": {
        "type": "_sbcs",
        "chars": "─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ё╓╔╕╖╗╘╙╚╛╜╝╞╟╠╡Ё╢╣╤╥╦╧╨╩╪╫╬©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ"
      },
      "koi8u": {
        "type": "_sbcs",
        "chars": "─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ёє╔ії╗╘╙╚╛ґ╝╞╟╠╡ЁЄ╣ІЇ╦╧╨╩╪Ґ╬©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ"
      },
      "koi8ru": {
        "type": "_sbcs",
        "chars": "─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ёє╔ії╗╘╙╚╛ґў╞╟╠╡ЁЄ╣ІЇ╦╧╨╩╪ҐЎ©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ"
      },
      "koi8t": {
        "type": "_sbcs",
        "chars": "қғ‚Ғ„…†‡�‰ҳ‹ҲҷҶ�Қ‘’“”•–—�™�›�����ӯӮё¤ӣ¦§���«¬­®�°±²Ё�Ӣ¶·�№�»���©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ"
      },
      "armscii8": {
        "type": "_sbcs",
        "chars": " �և։)(»«—.՝,-֊…՜՛՞ԱաԲբԳգԴդԵեԶզԷէԸըԹթԺժԻիԼլԽխԾծԿկՀհՁձՂղՃճՄմՅյՆնՇշՈոՉչՊպՋջՌռՍսՎվՏտՐրՑցՒւՓփՔքՕօՖֆ՚�"
      },
      "rk1048": {
        "type": "_sbcs",
        "chars": "ЂЃ‚ѓ„…†‡€‰Љ‹ЊҚҺЏђ‘’“”•–—�™љ›њқһџ ҰұӘ¤Ө¦§Ё©Ғ«¬­®Ү°±Ііөµ¶·ё№ғ»әҢңүАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя"
      },
      "tcvn": {
        "type": "_sbcs",
        "chars": "\u0000ÚỤ\u0003ỪỬỮ\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010ỨỰỲỶỸÝỴ\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ÀẢÃÁẠẶẬÈẺẼÉẸỆÌỈĨÍỊÒỎÕÓỌỘỜỞỠỚỢÙỦŨ ĂÂÊÔƠƯĐăâêôơưđẶ̀̀̉̃́àảãáạẲằẳẵắẴẮẦẨẪẤỀặầẩẫấậèỂẻẽéẹềểễếệìỉỄẾỒĩíịòỔỏõóọồổỗốộờởỡớợùỖủũúụừửữứựỳỷỹýỵỐ"
      },
      "georgianacademy": {
        "type": "_sbcs",
        "chars": "‚ƒ„…†‡ˆ‰Š‹Œ‘’“”•–—˜™š›œŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿აბგდევზთიკლმნოპჟრსტუფქღყშჩცძწჭხჯჰჱჲჳჴჵჶçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
      },
      "georgianps": {
        "type": "_sbcs",
        "chars": "‚ƒ„…†‡ˆ‰Š‹Œ‘’“”•–—˜™š›œŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿აბგდევზჱთიკლმნჲოპჟრსტჳუფქღყშჩცძწჭხჴჯჰჵæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
      },
      "pt154": {
        "type": "_sbcs",
        "chars": "ҖҒӮғ„…ҶҮҲүҠӢҢҚҺҸҗ‘’“”•–—ҳҷҡӣңқһҹ ЎўЈӨҘҰ§Ё©Ә«¬ӯ®Ҝ°ұІіҙө¶·ё№ә»јҪҫҝАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя"
      },
      "viscii": {
        "type": "_sbcs",
        "chars": "\u0000\u0001Ẳ\u0003\u0004ẴẪ\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013Ỷ\u0015\u0016\u0017\u0018Ỹ\u001a\u001b\u001c\u001dỴ\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ẠẮẰẶẤẦẨẬẼẸẾỀỂỄỆỐỒỔỖỘỢỚỜỞỊỎỌỈỦŨỤỲÕắằặấầẩậẽẹếềểễệốồổỗỠƠộờởịỰỨỪỬơớƯÀÁÂÃẢĂẳẵÈÉÊẺÌÍĨỳĐứÒÓÔạỷừửÙÚỹỵÝỡưàáâãảăữẫèéêẻìíĩỉđựòóôõỏọụùúũủýợỮ"
      },
      "iso646cn": {
        "type": "_sbcs",
        "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#¥%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}‾��������������������������������������������������������������������������������������������������������������������������������"
      },
      "iso646jp": {
        "type": "_sbcs",
        "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[¥]^_`abcdefghijklmnopqrstuvwxyz{|}‾��������������������������������������������������������������������������������������������������������������������������������"
      },
      "hproman8": {
        "type": "_sbcs",
        "chars": " ÀÂÈÊËÎÏ´ˋˆ¨˜ÙÛ₤¯Ýý°ÇçÑñ¡¿¤£¥§ƒ¢âêôûáéóúàèòùäëöüÅîØÆåíøæÄìÖÜÉïßÔÁÃãÐðÍÌÓÒÕõŠšÚŸÿÞþ·µ¶¾—¼½ªº«■»±�"
      },
      "macintosh": {
        "type": "_sbcs",
        "chars": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
      },
      "ascii": {
        "type": "_sbcs",
        "chars": "��������������������������������������������������������������������������������������������������������������������������������"
      },
      "tis620": {
        "type": "_sbcs",
        "chars": "���������������������������������กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����"
      }
    }
  provide("iconv-lite/encodings/sbcs-data-generated", module.exports);
}(global));

// pakmanager:iconv-lite/encodings/dbcs-codec
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
    // Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
    // To save memory and loading time, we read table files only when requested.
    
    exports._dbcs = function(options) {
        return new DBCSCodec(options);
    }
    
    var UNASSIGNED = -1,
        GB18030_CODE = -2,
        SEQ_START  = -10,
        NODE_START = -1000,
        UNASSIGNED_NODE = new Array(0x100),
        DEF_CHAR = -1;
    
    for (var i = 0; i < 0x100; i++)
        UNASSIGNED_NODE[i] = UNASSIGNED;
    
    
    // Class DBCSCodec reads and initializes mapping tables.
    function DBCSCodec(options) {
        this.options = options;
        if (!options)
            throw new Error("DBCS codec is called without the data.")
        if (!options.table)
            throw new Error("Encoding '" + options.encodingName + "' has no data.");
    
        // Load tables.
        var mappingTable = options.table();
    
    
        // Decode tables: MBCS -> Unicode.
    
        // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
        // Trie root is decodeTables[0].
        // Values: >=  0 -> unicode character code. can be > 0xFFFF
        //         == UNASSIGNED -> unknown/unassigned sequence.
        //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
        //         <= NODE_START -> index of the next node in our trie to process next byte.
        //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
        this.decodeTables = [];
        this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.
    
        // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
        this.decodeTableSeq = [];
    
        // Actual mapping tables consist of chunks. Use them to fill up decode tables.
        for (var i = 0; i < mappingTable.length; i++)
            this._addDecodeChunk(mappingTable[i]);
    
        this.defaultCharUnicode = options.iconv.defaultCharUnicode;
    
        
        // Encode tables: Unicode -> DBCS.
    
        // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
        // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
        // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
        //         == UNASSIGNED -> no conversion found. Output a default char.
        //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
        this.encodeTable = [];
        
        // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
        // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
        // means end of sequence (needed when one sequence is a strict subsequence of another).
        // Objects are kept separately from encodeTable to increase performance.
        this.encodeTableSeq = [];
    
        // Some chars can be decoded, but need not be encoded.
        var skipEncodeChars = {};
        if (options.encodeSkipVals)
            for (var i = 0; i < options.encodeSkipVals.length; i++) {
                var range = options.encodeSkipVals[i];
                for (var j = range.from; j <= range.to; j++)
                    skipEncodeChars[j] = true;
            }
            
        // Use decode trie to recursively fill out encode tables.
        this._fillEncodeTable(0, 0, skipEncodeChars);
    
        // Add more encoding pairs when needed.
        if (options.encodeAdd) {
            for (var uChar in options.encodeAdd)
                if (Object.prototype.hasOwnProperty.call(options.encodeAdd, uChar))
                    this._setEncodeChar(uChar.charCodeAt(0), options.encodeAdd[uChar]);
        }
    
        this.defCharSB  = this.encodeTable[0][options.iconv.defaultCharSingleByte.charCodeAt(0)];
        if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
        if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
    
    
        // Load & create GB18030 tables when needed.
        if (typeof options.gb18030 === 'function') {
            this.gb18030 = options.gb18030(); // Load GB18030 ranges.
    
            // Add GB18030 decode tables.
            var thirdByteNodeIdx = this.decodeTables.length;
            var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
    
            var fourthByteNodeIdx = this.decodeTables.length;
            var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
    
            for (var i = 0x81; i <= 0xFE; i++) {
                var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
                var secondByteNode = this.decodeTables[secondByteNodeIdx];
                for (var j = 0x30; j <= 0x39; j++)
                    secondByteNode[j] = NODE_START - thirdByteNodeIdx;
            }
            for (var i = 0x81; i <= 0xFE; i++)
                thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
            for (var i = 0x30; i <= 0x39; i++)
                fourthByteNode[i] = GB18030_CODE
        }        
    }
    
    // Public interface: create encoder and decoder objects. 
    // The methods (write, end) are simple functions to not inhibit optimizations.
    DBCSCodec.prototype.encoder = function encoderDBCS(options) {
        return {
            // Methods
            write: encoderDBCSWrite,
            end: encoderDBCSEnd,
    
            // Encoder state
            leadSurrogate: -1,
            seqObj: undefined,
            
            // Static data
            encodeTable: this.encodeTable,
            encodeTableSeq: this.encodeTableSeq,
            defaultCharSingleByte: this.defCharSB,
            gb18030: this.gb18030,
    
            // Export for testing
            findIdx: findIdx,
        }
    }
    
    DBCSCodec.prototype.decoder = function decoderDBCS(options) {
        return {
            // Methods
            write: decoderDBCSWrite,
            end: decoderDBCSEnd,
    
            // Decoder state
            nodeIdx: 0,
            prevBuf: new Buffer(0),
    
            // Static data
            decodeTables: this.decodeTables,
            decodeTableSeq: this.decodeTableSeq,
            defaultCharUnicode: this.defaultCharUnicode,
            gb18030: this.gb18030,
        }
    }
    
    
    
    // Decoder helpers
    DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
        var bytes = [];
        for (; addr > 0; addr >>= 8)
            bytes.push(addr & 0xFF);
        if (bytes.length == 0)
            bytes.push(0);
    
        var node = this.decodeTables[0];
        for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.
            var val = node[bytes[i]];
    
            if (val == UNASSIGNED) { // Create new node.
                node[bytes[i]] = NODE_START - this.decodeTables.length;
                this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
            }
            else if (val <= NODE_START) { // Existing node.
                node = this.decodeTables[NODE_START - val];
            }
            else
                throw new Error("Overwrite byte in " + this.options.encodingName + ", addr: " + addr.toString(16));
        }
        return node;
    }
    
    
    DBCSCodec.prototype._addDecodeChunk = function(chunk) {
        // First element of chunk is the hex mbcs code where we start.
        var curAddr = parseInt(chunk[0], 16);
    
        // Choose the decoding node where we'll write our chars.
        var writeTable = this._getDecodeTrieNode(curAddr);
        curAddr = curAddr & 0xFF;
    
        // Write all other elements of the chunk to the table.
        for (var k = 1; k < chunk.length; k++) {
            var part = chunk[k];
            if (typeof part === "string") { // String, write as-is.
                for (var l = 0; l < part.length;) {
                    var code = part.charCodeAt(l++);
                    if (0xD800 <= code && code < 0xDC00) { // Decode surrogate
                        var codeTrail = part.charCodeAt(l++);
                        if (0xDC00 <= codeTrail && codeTrail < 0xE000)
                            writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);
                        else
                            throw new Error("Incorrect surrogate pair in "  + this.options.encodingName + " at chunk " + chunk[0]);
                    }
                    else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)
                        var len = 0xFFF - code + 2;
                        var seq = [];
                        for (var m = 0; m < len; m++)
                            seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.
    
                        writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
                        this.decodeTableSeq.push(seq);
                    }
                    else
                        writeTable[curAddr++] = code; // Basic char
                }
            } 
            else if (typeof part === "number") { // Integer, meaning increasing sequence starting with prev character.
                var charCode = writeTable[curAddr - 1] + 1;
                for (var l = 0; l < part; l++)
                    writeTable[curAddr++] = charCode++;
            }
            else
                throw new Error("Incorrect type '" + typeof part + "' given in "  + this.options.encodingName + " at chunk " + chunk[0]);
        }
        if (curAddr > 0xFF)
            throw new Error("Incorrect chunk in "  + this.options.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
    }
    
    // Encoder helpers
    DBCSCodec.prototype._getEncodeBucket = function(uCode) {
        var high = uCode >> 8; // This could be > 0xFF because of astral characters.
        if (this.encodeTable[high] === undefined)
            this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
        return this.encodeTable[high];
    }
    
    DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
        var bucket = this._getEncodeBucket(uCode);
        var low = uCode & 0xFF;
        if (bucket[low] <= SEQ_START)
            this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
        else if (bucket[low] == UNASSIGNED)
            bucket[low] = dbcsCode;
    }
    
    DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
        
        // Get the root of character tree according to first character of the sequence.
        var uCode = seq[0];
        var bucket = this._getEncodeBucket(uCode);
        var low = uCode & 0xFF;
    
        var node;
        if (bucket[low] <= SEQ_START) {
            // There's already a sequence with  - use it.
            node = this.encodeTableSeq[SEQ_START-bucket[low]];
        }
        else {
            // There was no sequence object - allocate a new one.
            node = {};
            if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
            bucket[low] = SEQ_START - this.encodeTableSeq.length;
            this.encodeTableSeq.push(node);
        }
    
        // Traverse the character tree, allocating new nodes as needed.
        for (var j = 1; j < seq.length-1; j++) {
            var oldVal = node[uCode];
            if (typeof oldVal === 'object')
                node = oldVal;
            else {
                node = node[uCode] = {}
                if (oldVal !== undefined)
                    node[DEF_CHAR] = oldVal
            }
        }
    
        // Set the leaf to given dbcsCode.
        uCode = seq[seq.length-1];
        node[uCode] = dbcsCode;
    }
    
    DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
        var node = this.decodeTables[nodeIdx];
        for (var i = 0; i < 0x100; i++) {
            var uCode = node[i];
            var mbCode = prefix + i;
            if (skipEncodeChars[mbCode])
                continue;
    
            if (uCode >= 0)
                this._setEncodeChar(uCode, mbCode);
            else if (uCode <= NODE_START)
                this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
            else if (uCode <= SEQ_START)
                this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
        }
    }
    
    
    
    // == Actual Encoding ==========================================================
    
    
    function encoderDBCSWrite(str) {
        var newBuf = new Buffer(str.length * (this.gb18030 ? 4 : 3)), 
            leadSurrogate = this.leadSurrogate,
            seqObj = this.seqObj, nextChar = -1,
            i = 0, j = 0;
    
        while (true) {
            // 0. Get next character.
            if (nextChar === -1) {
                if (i == str.length) break;
                var uCode = str.charCodeAt(i++);
            }
            else {
                var uCode = nextChar;
                nextChar = -1;    
            }
    
            // 1. Handle surrogates.
            if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.
                if (uCode < 0xDC00) { // We've got lead surrogate.
                    if (leadSurrogate === -1) {
                        leadSurrogate = uCode;
                        continue;
                    } else {
                        leadSurrogate = uCode;
                        // Double lead surrogate found.
                        uCode = UNASSIGNED;
                    }
                } else { // We've got trail surrogate.
                    if (leadSurrogate !== -1) {
                        uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
                        leadSurrogate = -1;
                    } else {
                        // Incomplete surrogate pair - only trail surrogate found.
                        uCode = UNASSIGNED;
                    }
                    
                }
            }
            else if (leadSurrogate !== -1) {
                // Incomplete surrogate pair - only lead surrogate found.
                nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.
                leadSurrogate = -1;
            }
    
            // 2. Convert uCode character.
            var dbcsCode = UNASSIGNED;
            if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence
                var resCode = seqObj[uCode];
                if (typeof resCode === 'object') { // Sequence continues.
                    seqObj = resCode;
                    continue;
    
                } else if (typeof resCode == 'number') { // Sequence finished. Write it.
                    dbcsCode = resCode;
    
                } else if (resCode == undefined) { // Current character is not part of the sequence.
    
                    // Try default character for this sequence
                    resCode = seqObj[DEF_CHAR];
                    if (resCode !== undefined) {
                        dbcsCode = resCode; // Found. Write it.
                        nextChar = uCode; // Current character will be written too in the next iteration.
    
                    } else {
                        // TODO: What if we have no default? (resCode == undefined)
                        // Then, we should write first char of the sequence as-is and try the rest recursively.
                        // Didn't do it for now because no encoding has this situation yet.
                        // Currently, just skip the sequence and write current char.
                    }
                }
                seqObj = undefined;
            }
            else if (uCode >= 0) {  // Regular character
                var subtable = this.encodeTable[uCode >> 8];
                if (subtable !== undefined)
                    dbcsCode = subtable[uCode & 0xFF];
                
                if (dbcsCode <= SEQ_START) { // Sequence start
                    seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];
                    continue;
                }
    
                if (dbcsCode == UNASSIGNED && this.gb18030) {
                    // Use GB18030 algorithm to find character(s) to write.
                    var idx = findIdx(this.gb18030.uChars, uCode);
                    if (idx != -1) {
                        var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
                        newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;
                        newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;
                        newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;
                        newBuf[j++] = 0x30 + dbcsCode;
                        continue;
                    }
                }
            }
    
            // 3. Write dbcsCode character.
            if (dbcsCode === UNASSIGNED)
                dbcsCode = this.defaultCharSingleByte;
            
            if (dbcsCode < 0x100) {
                newBuf[j++] = dbcsCode;
            }
            else if (dbcsCode < 0x10000) {
                newBuf[j++] = dbcsCode >> 8;   // high byte
                newBuf[j++] = dbcsCode & 0xFF; // low byte
            }
            else {
                newBuf[j++] = dbcsCode >> 16;
                newBuf[j++] = (dbcsCode >> 8) & 0xFF;
                newBuf[j++] = dbcsCode & 0xFF;
            }
        }
    
        this.seqObj = seqObj;
        this.leadSurrogate = leadSurrogate;
        return newBuf.slice(0, j);
    }
    
    function encoderDBCSEnd() {
        if (this.leadSurrogate === -1 && this.seqObj === undefined)
            return; // All clean. Most often case.
    
        var newBuf = new Buffer(10), j = 0;
    
        if (this.seqObj) { // We're in the sequence.
            var dbcsCode = this.seqObj[DEF_CHAR];
            if (dbcsCode !== undefined) { // Write beginning of the sequence.
                if (dbcsCode < 0x100) {
                    newBuf[j++] = dbcsCode;
                }
                else {
                    newBuf[j++] = dbcsCode >> 8;   // high byte
                    newBuf[j++] = dbcsCode & 0xFF; // low byte
                }
            } else {
                // See todo above.
            }
            this.seqObj = undefined;
        }
    
        if (this.leadSurrogate !== -1) {
            // Incomplete surrogate pair - only lead surrogate found.
            newBuf[j++] = this.defaultCharSingleByte;
            this.leadSurrogate = -1;
        }
        
        return newBuf.slice(0, j);
    }
    
    
    // == Actual Decoding ==========================================================
    
    
    function decoderDBCSWrite(buf) {
        var newBuf = new Buffer(buf.length*2),
            nodeIdx = this.nodeIdx, 
            prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length,
            seqStart = -this.prevBuf.length, // idx of the start of current parsed sequence.
            uCode;
    
        if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.
            prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);
        
        for (var i = 0, j = 0; i < buf.length; i++) {
            var curByte = (i >= 0) ? buf[i] : prevBuf[i + prevBufOffset];
    
            // Lookup in current trie node.
            var uCode = this.decodeTables[nodeIdx][curByte];
    
            if (uCode >= 0) { 
                // Normal character, just use it.
            }
            else if (uCode === UNASSIGNED) { // Unknown char.
                // TODO: Callback with seq.
                //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
                i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).
                uCode = this.defaultCharUnicode.charCodeAt(0);
            }
            else if (uCode === GB18030_CODE) {
                var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
                var ptr = (curSeq[0]-0x81)*12600 + (curSeq[1]-0x30)*1260 + (curSeq[2]-0x81)*10 + (curSeq[3]-0x30);
                var idx = findIdx(this.gb18030.gbChars, ptr);
                uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
            }
            else if (uCode <= NODE_START) { // Go to next trie node.
                nodeIdx = NODE_START - uCode;
                continue;
            }
            else if (uCode <= SEQ_START) { // Output a sequence of chars.
                var seq = this.decodeTableSeq[SEQ_START - uCode];
                for (var k = 0; k < seq.length - 1; k++) {
                    uCode = seq[k];
                    newBuf[j++] = uCode & 0xFF;
                    newBuf[j++] = uCode >> 8;
                }
                uCode = seq[seq.length-1];
            }
            else
                throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
    
            // Write the character to buffer, handling higher planes using surrogate pair.
            if (uCode > 0xFFFF) { 
                uCode -= 0x10000;
                var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);
                newBuf[j++] = uCodeLead & 0xFF;
                newBuf[j++] = uCodeLead >> 8;
    
                uCode = 0xDC00 + uCode % 0x400;
            }
            newBuf[j++] = uCode & 0xFF;
            newBuf[j++] = uCode >> 8;
    
            // Reset trie node.
            nodeIdx = 0; seqStart = i+1;
        }
    
        this.nodeIdx = nodeIdx;
        this.prevBuf = (seqStart >= 0) ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
        return newBuf.slice(0, j).toString('ucs2');
    }
    
    function decoderDBCSEnd() {
        var ret = '';
    
        // Try to parse all remaining chars.
        while (this.prevBuf.length > 0) {
            // Skip 1 character in the buffer.
            ret += this.defaultCharUnicode;
            var buf = this.prevBuf.slice(1);
    
            // Parse remaining as usual.
            this.prevBuf = new Buffer(0);
            this.nodeIdx = 0;
            if (buf.length > 0)
                ret += decoderDBCSWrite.call(this, buf);
        }
    
        this.nodeIdx = 0;
        return ret;
    }
    
    // Binary search for GB18030. Returns largest i such that table[i] <= val.
    function findIdx(table, val) {
        if (table[0] > val)
            return -1;
    
        var l = 0, r = table.length;
        while (l < r-1) { // always table[l] <= val < table[r]
            var mid = l + Math.floor((r-l+1)/2);
            if (table[mid] <= val)
                l = mid;
            else
                r = mid;
        }
        return l;
    }
    
    
  provide("iconv-lite/encodings/dbcs-codec", module.exports);
}(global));

// pakmanager:iconv-lite/encodings/dbcs-data
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Description of supported double byte encodings and aliases.
    // Tables are not require()-d until they are needed to speed up library load.
    // require()-s are direct to support Browserify.
    
    module.exports = {
        
        // == Japanese/ShiftJIS ====================================================
        // All japanese encodings are based on JIS X set of standards:
        // JIS X 0201 - Single-byte encoding of ASCII + ¥ + Kana chars at 0xA1-0xDF.
        // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
        //              Has several variations in 1978, 1983, 1990 and 1997.
        // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
        // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
        //              2 planes, first is superset of 0208, second - revised 0212.
        //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
    
        // Byte encodings are:
        //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
        //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
        //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
        //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
        //               0x00-0x7F       - lower part of 0201
        //               0x8E, 0xA1-0xDF - upper part of 0201
        //               (0xA1-0xFE)x2   - 0208 plane (94x94).
        //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
        //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
        //               Used as-is in ISO2022 family.
        //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
        //                0201-1976 Roman, 0208-1978, 0208-1983.
        //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
        //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
        //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
        //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
        //
        // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
        //
        // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
    
    
        'shiftjis': {
            type: '_dbcs',
            table: function() { return require('./tables/shiftjis.json') },
            encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
            encodeSkipVals: [{from: 0xED40, to: 0xF940}],
        },
        'csshiftjis': 'shiftjis',
        'mskanji': 'shiftjis',
        'sjis': 'shiftjis',
        'windows31j': 'shiftjis',
        'xsjis': 'shiftjis',
        'windows932': 'shiftjis',
        '932': 'shiftjis',
        'cp932': 'shiftjis',
    
        'eucjp': {
            type: '_dbcs',
            table: function() { return require('./tables/eucjp.json') },
            encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
        },
    
        // TODO: KDDI extension to Shift_JIS
        // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
        // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
    
        // == Chinese/GBK ==========================================================
        // http://en.wikipedia.org/wiki/GBK
    
        // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
        'gb2312': 'cp936',
        'gb231280': 'cp936',
        'gb23121980': 'cp936',
        'csgb2312': 'cp936',
        'csiso58gb231280': 'cp936',
        'euccn': 'cp936',
        'isoir58': 'gbk',
    
        // Microsoft's CP936 is a subset and approximation of GBK.
        // TODO: Euro = 0x80 in cp936, but not in GBK (where it's valid but undefined)
        'windows936': 'cp936',
        '936': 'cp936',
        'cp936': {
            type: '_dbcs',
            table: function() { return require('./tables/cp936.json') },
        },
    
        // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
        'gbk': {
            type: '_dbcs',
            table: function() { return require('./tables/cp936.json').concat(require('./tables/gbk-added.json')) },
        },
        'xgbk': 'gbk',
    
        // GB18030 is an algorithmic extension of GBK.
        'gb18030': {
            type: '_dbcs',
            table: function() { return require('./tables/cp936.json').concat(require('./tables/gbk-added.json')) },
            gb18030: function() { return require('./tables/gb18030-ranges.json') },
        },
    
        'chinese': 'gb18030',
    
        // TODO: Support GB18030 (~27000 chars + whole unicode mapping, cp54936)
        // http://icu-project.org/docs/papers/gb18030.html
        // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
        // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    
        // == Korean ===============================================================
        // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
        'windows949': 'cp949',
        '949': 'cp949',
        'cp949': {
            type: '_dbcs',
            table: function() { return require('./tables/cp949.json') },
        },
    
        'cseuckr': 'cp949',
        'csksc56011987': 'cp949',
        'euckr': 'cp949',
        'isoir149': 'cp949',
        'korean': 'cp949',
        'ksc56011987': 'cp949',
        'ksc56011989': 'cp949',
        'ksc5601': 'cp949',
    
    
        // == Big5/Taiwan/Hong Kong ================================================
        // There are lots of tables for Big5 and cp950. Please see the following links for history:
        // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
        // Variations, in roughly number of defined chars:
        //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
        //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
        //  * Big5-2003 (Taiwan standard) almost superset of cp950.
        //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
        //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
        //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
        //    Plus, it has 4 combining sequences.
        //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
        //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
        //    Implementations are not consistent within browsers; sometimes labeled as just big5.
        //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
        //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
        //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
        //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
        //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
        // 
        // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
        // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
    
        'windows950': 'cp950',
        '950': 'cp950',
        'cp950': {
            type: '_dbcs',
            table: function() { return require('./tables/cp950.json') },
        },
    
        // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
        'big5': 'big5hkscs',
        'big5hkscs': {
            type: '_dbcs',
            table: function() { return require('./tables/cp950.json').concat(require('./tables/big5-added.json')) },
        },
    
        'cnbig5': 'big5hkscs',
        'csbig5': 'big5hkscs',
        'xxbig5': 'big5hkscs',
    
    };
    
  provide("iconv-lite/encodings/dbcs-data", module.exports);
}(global));

// pakmanager:iconv-lite/encodings
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Update this array if you add/rename/remove files in this directory.
    // We support Browserify by skipping automatic module discovery and requiring modules directly.
    var modules = [
         require('iconv-lite/encodings/internal'),
         require('iconv-lite/encodings/utf16'),
         require('iconv-lite/encodings/utf7'),
         require('iconv-lite/encodings/sbcs-codec'),
         require('iconv-lite/encodings/sbcs-data'),
         require('iconv-lite/encodings/sbcs-data-generated'),
         require('iconv-lite/encodings/dbcs-codec'),
         require('iconv-lite/encodings/dbcs-data'),
    ];
    
    // Put all encoding/alias/codec definitions to single object and export it. 
    for (var i = 0; i < modules.length; i++) {
        var module = modules[i];
        for (var enc in module)
            if (Object.prototype.hasOwnProperty.call(module, enc))
                exports[enc] = module[enc];
    }
    
  provide("iconv-lite/encodings", module.exports);
}(global));

// pakmanager:iconv-lite/lib/streams
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Transform = require("stream").Transform;
    
    
    // == Exports ==================================================================
    module.exports = function(iconv) {
        
        // Additional Public API.
        iconv.encodeStream = function encodeStream(encoding, options) {
            return new IconvLiteEncoderStream(iconv.getCodec(encoding).encoder(options), options);
        }
    
        iconv.decodeStream = function decodeStream(encoding, options) {
            return new IconvLiteDecoderStream(iconv.getCodec(encoding).decoder(options), options);
        }
    
        iconv.supportsStreams = true;
    
    
        // Not published yet.
        iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
        iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
        iconv._collect = IconvLiteDecoderStream.prototype.collect;
    };
    
    
    // == Encoder stream =======================================================
    function IconvLiteEncoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.decodeStrings = false; // We accept only strings, so we don't need to decode them.
        Transform.call(this, options);
    }
    
    IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
        constructor: { value: IconvLiteEncoderStream }
    });
    
    IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
        if (typeof chunk != 'string')
            return done(new Error("Iconv encoding stream needs strings as its input."));
        try {
            var res = this.conv.write(chunk);
            if (res && res.length) this.push(res);
            done();
        }
        catch (e) {
            done(e);
        }
    }
    
    IconvLiteEncoderStream.prototype._flush = function(done) {
        try {
            var res = this.conv.end();
            if (res && res.length) this.push(res);
            done();
        }
        catch (e) {
            done(e);
        }
    }
    
    IconvLiteEncoderStream.prototype.collect = function(cb) {
        var chunks = [];
        this.on('error', cb);
        this.on('data', function(chunk) { chunks.push(chunk); });
        this.on('end', function() {
            cb(null, Buffer.concat(chunks));
        });
        return this;
    }
    
    
    // == Decoder stream =======================================================
    function IconvLiteDecoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.encoding = this.encoding = 'utf8'; // We output strings.
        Transform.call(this, options);
    }
    
    IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
        constructor: { value: IconvLiteDecoderStream }
    });
    
    IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
        if (!Buffer.isBuffer(chunk))
            return done(new Error("Iconv decoding stream needs buffers as its input."));
        try {
            var res = this.conv.write(chunk);
            if (res && res.length) this.push(res, this.encoding);
            done();
        }
        catch (e) {
            done(e);
        }
    }
    
    IconvLiteDecoderStream.prototype._flush = function(done) {
        try {
            var res = this.conv.end();
            if (res && res.length) this.push(res, this.encoding);                
            done();
        }
        catch (e) {
            done(e);
        }
    }
    
    IconvLiteDecoderStream.prototype.collect = function(cb) {
        var res = '';
        this.on('error', cb);
        this.on('data', function(chunk) { res += chunk; });
        this.on('end', function() {
            cb(null, res);
        });
        return this;
    }
    
    
  provide("iconv-lite/lib/streams", module.exports);
}(global));

// pakmanager:iconv-lite/lib/extend-node
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // == Extend Node primitives to use iconv-lite =================================
    
    module.exports = function (iconv) {
        var original = undefined; // Place to keep original methods.
    
        iconv.extendNodeEncodings = function extendNodeEncodings() {
            if (original) return;
            original = {};
    
            var nodeNativeEncodings = {
                'hex': true, 'utf8': true, 'utf-8': true, 'ascii': true, 'binary': true, 
                'base64': true, 'ucs2': true, 'ucs-2': true, 'utf16le': true, 'utf-16le': true,
            };
    
            Buffer.isNativeEncoding = function(enc) {
                return nodeNativeEncodings[enc && enc.toLowerCase()];
            }
    
            // -- SlowBuffer -----------------------------------------------------------
            var SlowBuffer = require('buffer').SlowBuffer;
    
            original.SlowBufferToString = SlowBuffer.prototype.toString;
            SlowBuffer.prototype.toString = function(encoding, start, end) {
                encoding = String(encoding || 'utf8').toLowerCase();
                start = +start || 0;
                if (typeof end !== 'number') end = this.length;
    
                // Fastpath empty strings
                if (+end == start)
                    return '';
    
                // Use native conversion when possible
                if (Buffer.isNativeEncoding(encoding))
                    return original.SlowBufferToString.call(this, encoding, start, end);
    
                // Otherwise, use our decoding method.
                if (typeof start == 'undefined') start = 0;
                if (typeof end == 'undefined') end = this.length;
                return iconv.decode(this.slice(start, end), encoding);
            }
    
            original.SlowBufferWrite = SlowBuffer.prototype.write;
            SlowBuffer.prototype.write = function(string, offset, length, encoding) {
                // Support both (string, offset, length, encoding)
                // and the legacy (string, encoding, offset, length)
                if (isFinite(offset)) {
                    if (!isFinite(length)) {
                        encoding = length;
                        length = undefined;
                    }
                } else {  // legacy
                    var swap = encoding;
                    encoding = offset;
                    offset = length;
                    length = swap;
                }
    
                offset = +offset || 0;
                var remaining = this.length - offset;
                if (!length) {
                    length = remaining;
                } else {
                    length = +length;
                    if (length > remaining) {
                        length = remaining;
                    }
                }
                encoding = String(encoding || 'utf8').toLowerCase();
    
                // Use native conversion when possible
                if (Buffer.isNativeEncoding(encoding))
                    return original.SlowBufferWrite.call(this, string, offset, length, encoding);
    
                if (string.length > 0 && (length < 0 || offset < 0))
                    throw new RangeError('attempt to write beyond buffer bounds');
    
                // Otherwise, use our encoding method.
                var buf = iconv.encode(string, encoding);
                if (buf.length < length) length = buf.length;
                buf.copy(this, offset, 0, length);
                return length;
            }
    
            // -- Buffer ---------------------------------------------------------------
    
            original.BufferIsEncoding = Buffer.isEncoding;
            Buffer.isEncoding = function(encoding) {
                return Buffer.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
            }
    
            original.BufferByteLength = Buffer.byteLength;
            Buffer.byteLength = SlowBuffer.byteLength = function(str, encoding) {
                encoding = String(encoding || 'utf8').toLowerCase();
    
                // Use native conversion when possible
                if (Buffer.isNativeEncoding(encoding))
                    return original.BufferByteLength.call(this, str, encoding);
    
                // Slow, I know, but we don't have a better way yet.
                return iconv.encode(str, encoding).length;
            }
    
            original.BufferToString = Buffer.prototype.toString;
            Buffer.prototype.toString = function(encoding, start, end) {
                encoding = String(encoding || 'utf8').toLowerCase();
    
                // Use native conversion when possible
                if (Buffer.isNativeEncoding(encoding))
                    return original.BufferToString.call(this, encoding, start, end);
    
                // Otherwise, use our decoding method.
                if (typeof start == 'undefined') start = 0;
                if (typeof end == 'undefined') end = this.length;
                return iconv.decode(this.slice(start, end), encoding);
            }
    
            original.BufferWrite = Buffer.prototype.write;
            Buffer.prototype.write = function(string, offset, length, encoding) {
                var _offset = offset, _length = length, _encoding = encoding;
                // Support both (string, offset, length, encoding)
                // and the legacy (string, encoding, offset, length)
                if (isFinite(offset)) {
                    if (!isFinite(length)) {
                        encoding = length;
                        length = undefined;
                    }
                } else {  // legacy
                    var swap = encoding;
                    encoding = offset;
                    offset = length;
                    length = swap;
                }
    
                encoding = String(encoding || 'utf8').toLowerCase();
    
                // Use native conversion when possible
                if (Buffer.isNativeEncoding(encoding))
                    return original.BufferWrite.call(this, string, _offset, _length, _encoding);
    
                offset = +offset || 0;
                var remaining = this.length - offset;
                if (!length) {
                    length = remaining;
                } else {
                    length = +length;
                    if (length > remaining) {
                        length = remaining;
                    }
                }
    
                if (string.length > 0 && (length < 0 || offset < 0))
                    throw new RangeError('attempt to write beyond buffer bounds');
    
                // Otherwise, use our encoding method.
                var buf = iconv.encode(string, encoding);
                if (buf.length < length) length = buf.length;
                buf.copy(this, offset, 0, length);
                return length;
    
                // TODO: Set _charsWritten.
            }
    
    
            // -- Readable -------------------------------------------------------------
            if (iconv.supportsStreams) {
                var Readable = require('stream').Readable;
    
                original.ReadableSetEncoding = Readable.prototype.setEncoding;
                Readable.prototype.setEncoding = function setEncoding(enc, options) {
                    // Try to use original function when possible.
                    if (Buffer.isNativeEncoding(enc))
                        return original.ReadableSetEncoding.call(this, enc);
    
                    // Try to use our own decoder, it has the same interface.
                    this._readableState.decoder = iconv.getCodec(enc).decoder(options);
                    this._readableState.encoding = enc;
                }
    
                Readable.prototype.collect = iconv._collect;
            }
        }
    
        // Remove iconv-lite Node primitive extensions.
        iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
            if (!original)
                throw new Error(" require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.")
    
            delete Buffer.isNativeEncoding;
    
            var SlowBuffer = require('buffer').SlowBuffer;
    
            SlowBuffer.prototype.toString = original.SlowBufferToString;
            SlowBuffer.prototype.write = original.SlowBufferWrite;
    
            Buffer.isEncoding = original.BufferIsEncoding;
            Buffer.byteLength = original.BufferByteLength;
            Buffer.prototype.toString = original.BufferToString;
            Buffer.prototype.write = original.BufferWrite;
    
            if (iconv.supportsStreams) {
                var Readable = require('stream').Readable;
    
                Readable.prototype.setEncoding = original.ReadableSetEncoding;
                delete Readable.prototype.collect;
            }
    
            original = undefined;
        }
    }
    
  provide("iconv-lite/lib/extend-node", module.exports);
}(global));

// pakmanager:iconv-lite
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    var iconv = module.exports;
    
    // All codecs and aliases are kept here, keyed by encoding name/alias.
    // They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
    iconv.encodings = null;
    
    // Characters emitted in case of error.
    iconv.defaultCharUnicode = '�';
    iconv.defaultCharSingleByte = '?';
    
    // Public API.
    iconv.encode = function encode(str, encoding, options) {
        str = "" + (str || ""); // Ensure string.
    
        var encoder = iconv.getCodec(encoding).encoder(options);
    
        var res = encoder.write(str);
        var trail = encoder.end();
        
        return (trail && trail.length > 0) ? Buffer.concat([res, trail]) : res;
    }
    
    iconv.decode = function decode(buf, encoding, options) {
        if (typeof buf === 'string') {
            if (!iconv.skipDecodeWarning) {
                console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
                iconv.skipDecodeWarning = true;
            }
    
            buf = new Buffer("" + (buf || ""), "binary"); // Ensure buffer.
        }
    
        var decoder = iconv.getCodec(encoding).decoder(options);
    
        var res = decoder.write(buf);
        var trail = decoder.end();
    
        return (trail && trail.length > 0) ? (res + trail) : res;
    }
    
    iconv.encodingExists = function encodingExists(enc) {
        try {
            iconv.getCodec(enc);
            return true;
        } catch (e) {
            return false;
        }
    }
    
    // Legacy aliases to convert functions
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;
    
    // Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
    iconv._codecDataCache = {};
    iconv.getCodec = function getCodec(encoding) {
        if (!iconv.encodings)
            iconv.encodings =  require('iconv-lite/encodings'); // Lazy load all encoding definitions.
        
        // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
        var enc = (''+encoding).toLowerCase().replace(/[^0-9a-z]|:\d{4}$/g, "");
    
        // Traverse iconv.encodings to find actual codec.
        var codecData, codecOptions;
        while (true) {
            codecData = iconv._codecDataCache[enc];
            if (codecData)
                return codecData;
    
            var codec = iconv.encodings[enc];
    
            switch (typeof codec) {
                case "string": // Direct alias to other encoding.
                    enc = codec;
                    break;
    
                case "object": // Alias with options. Can be layered.
                    if (!codecOptions) {
                        codecOptions = codec;
                        codecOptions.encodingName = enc;
                    }
                    else {
                        for (var key in codec)
                            codecOptions[key] = codec[key];
                    }
    
                    enc = codec.type;
                    break;
    
                case "function": // Codec itself.
                    if (!codecOptions)
                        codecOptions = { encodingName: enc };
                    codecOptions.iconv = iconv;
    
                    // The codec function must load all tables and return object with .encoder and .decoder methods.
                    // It'll be called only once (for each different options object).
                    codecData = codec.call(iconv.encodings, codecOptions);
    
                    iconv._codecDataCache[codecOptions.encodingName] = codecData; // Save it to be reused later.
                    return codecData;
    
                default:
                    throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '"+enc+"')");
            }
        }
    }
    
    // Load extensions in Node. All of them are omitted in Browserify build via 'browser' field in package.json.
    var nodeVer = typeof process !== 'undefined' && process.versions && process.versions.node;
    if (nodeVer) {
    
        // Load streaming support in Node v0.10+
        var nodeVerArr = nodeVer.split(".").map(Number);
        if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
             require('iconv-lite/lib/streams')(iconv);
        }
    
        // Load Node primitive extensions.
         require('iconv-lite/lib/extend-node')(iconv);
    }
    
    
  provide("iconv-lite", module.exports);
}(global));

// pakmanager:media-typer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * media-typer
     * Copyright(c) 2014 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    /**
     * RegExp to match *( ";" parameter ) in RFC 2616 sec 3.7
     *
     * parameter     = token "=" ( token | quoted-string )
     * token         = 1*<any CHAR except CTLs or separators>
     * separators    = "(" | ")" | "<" | ">" | "@"
     *               | "," | ";" | ":" | "\" | <">
     *               | "/" | "[" | "]" | "?" | "="
     *               | "{" | "}" | SP | HT
     * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
     * qdtext        = <any TEXT except <">>
     * quoted-pair   = "\" CHAR
     * CHAR          = <any US-ASCII character (octets 0 - 127)>
     * TEXT          = <any OCTET except CTLs, but including LWS>
     * LWS           = [CRLF] 1*( SP | HT )
     * CRLF          = CR LF
     * CR            = <US-ASCII CR, carriage return (13)>
     * LF            = <US-ASCII LF, linefeed (10)>
     * SP            = <US-ASCII SP, space (32)>
     * SHT           = <US-ASCII HT, horizontal-tab (9)>
     * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
     * OCTET         = <any 8-bit sequence of data>
     */
    var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
    var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/
    var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/
    
    /**
     * RegExp to match quoted-pair in RFC 2616
     *
     * quoted-pair = "\" CHAR
     * CHAR        = <any US-ASCII character (octets 0 - 127)>
     */
    var qescRegExp = /\\([\u0000-\u007f])/g;
    
    /**
     * RegExp to match chars that must be quoted-pair in RFC 2616
     */
    var quoteRegExp = /([\\"])/g;
    
    /**
     * RegExp to match type in RFC 6838
     *
     * type-name = restricted-name
     * subtype-name = restricted-name
     * restricted-name = restricted-name-first *126restricted-name-chars
     * restricted-name-first  = ALPHA / DIGIT
     * restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
     *                          "$" / "&" / "-" / "^" / "_"
     * restricted-name-chars =/ "." ; Characters before first dot always
     *                              ; specify a facet name
     * restricted-name-chars =/ "+" ; Characters after last plus always
     *                              ; specify a structured syntax suffix
     * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
     * DIGIT =  %x30-39             ; 0-9
     */
    var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/
    var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/
    var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
    
    /**
     * Module exports.
     */
    
    exports.format = format
    exports.parse = parse
    
    /**
     * Format object to media type.
     *
     * @param {object} obj
     * @return {string}
     * @api public
     */
    
    function format(obj) {
      if (!obj || typeof obj !== 'object') {
        throw new TypeError('argument obj is required')
      }
    
      var parameters = obj.parameters
      var subtype = obj.subtype
      var suffix = obj.suffix
      var type = obj.type
    
      if (!type || !typeNameRegExp.test(type)) {
        throw new TypeError('invalid type')
      }
    
      if (!subtype || !subtypeNameRegExp.test(subtype)) {
        throw new TypeError('invalid subtype')
      }
    
      // format as type/subtype
      var string = type + '/' + subtype
    
      // append +suffix
      if (suffix) {
        if (!typeNameRegExp.test(suffix)) {
          throw new TypeError('invalid suffix')
        }
    
        string += '+' + suffix
      }
    
      // append parameters
      if (parameters && typeof parameters === 'object') {
        var param
        var params = Object.keys(parameters).sort()
    
        for (var i = 0; i < params.length; i++) {
          param = params[i]
    
          if (!tokenRegExp.test(param)) {
            throw new TypeError('invalid parameter name')
          }
    
          string += '; ' + param + '=' + qstring(parameters[param])
        }
      }
    
      return string
    }
    
    /**
     * Parse media type to object.
     *
     * @param {string|object} string
     * @return {Object}
     * @api public
     */
    
    function parse(string) {
      if (!string) {
        throw new TypeError('argument string is required')
      }
    
      // support req/res-like objects as argument
      if (typeof string === 'object') {
        string = getcontenttype(string)
      }
    
      if (typeof string !== 'string') {
        throw new TypeError('argument string is required to be a string')
      }
    
      var index = string.indexOf(';')
      var type = index !== -1
        ? string.substr(0, index)
        : string
    
      var key
      var match
      var obj = splitType(type)
      var params = {}
      var value
    
      paramRegExp.lastIndex = index
    
      while (match = paramRegExp.exec(string)) {
        if (match.index !== index) {
          throw new TypeError('invalid parameter format')
        }
    
        index += match[0].length
        key = match[1].toLowerCase()
        value = match[2]
    
        if (value[0] === '"') {
          // remove quotes and escapes
          value = value
            .substr(1, value.length - 2)
            .replace(qescRegExp, '$1')
        }
    
        params[key] = value
      }
    
      if (index !== -1 && index !== string.length) {
        throw new TypeError('invalid parameter format')
      }
    
      obj.parameters = params
    
      return obj
    }
    
    /**
     * Get content-type from req/res objects.
     *
     * @param {object}
     * @return {Object}
     * @api private
     */
    
    function getcontenttype(obj) {
      if (typeof obj.getHeader === 'function') {
        // res-like
        return obj.getHeader('content-type')
      }
    
      if (typeof obj.headers === 'object') {
        // req-like
        return obj.headers && obj.headers['content-type']
      }
    }
    
    /**
     * Quote a string if necessary.
     *
     * @param {string} val
     * @return {string}
     * @api private
     */
    
    function qstring(val) {
      var str = String(val)
    
      // no need to quote tokens
      if (tokenRegExp.test(str)) {
        return str
      }
    
      if (str.length > 0 && !textRegExp.test(str)) {
        throw new TypeError('invalid parameter value')
      }
    
      return '"' + str.replace(quoteRegExp, '\\$1') + '"'
    }
    
    /**
     * Simply "type/subtype+siffx" into parts.
     *
     * @param {string} string
     * @return {Object}
     * @api private
     */
    
    function splitType(string) {
      var match = typeRegExp.exec(string.toLowerCase())
    
      if (!match) {
        throw new TypeError('invalid media type')
      }
    
      var type = match[1]
      var subtype = match[2]
      var suffix
    
      // suffix after last +
      var index = subtype.lastIndexOf('+')
      if (index !== -1) {
        suffix = subtype.substr(index + 1)
        subtype = subtype.substr(0, index)
      }
    
      var obj = {
        type: type,
        subtype: subtype,
        suffix: suffix
      }
    
      return obj
    }
    
  provide("media-typer", module.exports);
}(global));

// pakmanager:mime-types
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    var db = require('mime-db')
    
    // types[extension] = type
    exports.types = Object.create(null)
    // extensions[type] = [extensions]
    exports.extensions = Object.create(null)
    
    Object.keys(db).forEach(function (name) {
      var mime = db[name]
      var exts = mime.extensions
      if (!exts || !exts.length) return
      exports.extensions[name] = exts
      exts.forEach(function (ext) {
        exports.types[ext] = name
      })
    })
    
    exports.lookup = function (string) {
      if (!string || typeof string !== "string") return false
      // remove any leading paths, though we should just use path.basename
      string = string.replace(/.*[\.\/\\]/, '').toLowerCase()
      if (!string) return false
      return exports.types[string] || false
    }
    
    exports.extension = function (type) {
      if (!type || typeof type !== "string") return false
      // to do: use media-typer
      type = type.match(/^\s*([^;\s]*)(?:;|\s|$)/)
      if (!type) return false
      var exts = exports.extensions[type[1].toLowerCase()]
      if (!exts || !exts.length) return false
      return exts[0]
    }
    
    // type has to be an exact mime type
    exports.charset = function (type) {
      var mime = db[type]
      if (mime && mime.charset) return mime.charset
    
      // default text/* to utf-8
      if (/^text\//.test(type)) return 'UTF-8'
    
      return false
    }
    
    // backwards compatibility
    exports.charsets = {
      lookup: exports.charset
    }
    
    // to do: maybe use set-type module or something
    exports.contentType = function (type) {
      if (!type || typeof type !== "string") return false
      if (!~type.indexOf('/')) type = exports.lookup(type)
      if (!type) return false
      if (!~type.indexOf('charset')) {
        var charset = exports.charset(type)
        if (charset) type += '; charset=' + charset.toLowerCase()
      }
      return type
    }
    
  provide("mime-types", module.exports);
}(global));

// pakmanager:negotiator/lib/charset
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = preferredCharsets;
    preferredCharsets.preferredCharsets = preferredCharsets;
    
    function parseAcceptCharset(accept) {
      var accepts = accept.split(',');
    
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var charset = parseCharset(accepts[i].trim(), i);
    
        if (charset) {
          accepts[j++] = charset;
        }
      }
    
      // trim accepts
      accepts.length = j;
    
      return accepts;
    }
    
    function parseCharset(s, i) {
      var match = s.match(/^\s*(\S+?)\s*(?:;(.*))?$/);
      if (!match) return null;
    
      var charset = match[1];
      var q = 1;
      if (match[2]) {
        var params = match[2].split(';')
        for (var i = 0; i < params.length; i ++) {
          var p = params[i].trim().split('=');
          if (p[0] === 'q') {
            q = parseFloat(p[1]);
            break;
          }
        }
      }
    
      return {
        charset: charset,
        q: q,
        i: i
      };
    }
    
    function getCharsetPriority(charset, accepted, index) {
      var priority = {o: -1, q: 0, s: 0};
    
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(charset, accepted[i], index);
    
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
    
      return priority;
    }
    
    function specify(charset, spec, index) {
      var s = 0;
      if(spec.charset.toLowerCase() === charset.toLowerCase()){
        s |= 1;
      } else if (spec.charset !== '*' ) {
        return null
      }
    
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s: s
      }
    }
    
    function preferredCharsets(accept, provided) {
      // RFC 2616 sec 14.2: no header = *
      var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');
    
      if (!provided) {
        // sorted list of all charsets
        return accepts.filter(isQuality).sort(compareSpecs).map(function getCharset(spec) {
          return spec.charset;
        });
      }
    
      var priorities = provided.map(function getPriority(type, index) {
        return getCharsetPriority(type, accepts, index);
      });
    
      // sorted list of accepted charsets
      return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    
    function compareSpecs(a, b) {
      return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
    }
    
    function isQuality(spec) {
      return spec.q > 0;
    }
    
  provide("negotiator/lib/charset", module.exports);
}(global));

// pakmanager:negotiator/lib/encoding
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = preferredEncodings;
    preferredEncodings.preferredEncodings = preferredEncodings;
    
    function parseAcceptEncoding(accept) {
      var accepts = accept.split(',');
      var hasIdentity = false;
      var minQuality = 1;
    
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var encoding = parseEncoding(accepts[i].trim(), i);
    
        if (encoding) {
          accepts[j++] = encoding;
          hasIdentity = hasIdentity || specify('identity', encoding);
          minQuality = Math.min(minQuality, encoding.q || 1);
        }
      }
    
      if (!hasIdentity) {
        /*
         * If identity doesn't explicitly appear in the accept-encoding header,
         * it's added to the list of acceptable encoding with the lowest q
         */
        accepts[j++] = {
          encoding: 'identity',
          q: minQuality,
          i: i
        };
      }
    
      // trim accepts
      accepts.length = j;
    
      return accepts;
    }
    
    function parseEncoding(s, i) {
      var match = s.match(/^\s*(\S+?)\s*(?:;(.*))?$/);
    
      if (!match) return null;
    
      var encoding = match[1];
      var q = 1;
      if (match[2]) {
        var params = match[2].split(';');
        for (var i = 0; i < params.length; i ++) {
          var p = params[i].trim().split('=');
          if (p[0] === 'q') {
            q = parseFloat(p[1]);
            break;
          }
        }
      }
    
      return {
        encoding: encoding,
        q: q,
        i: i
      };
    }
    
    function getEncodingPriority(encoding, accepted, index) {
      var priority = {o: -1, q: 0, s: 0};
    
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(encoding, accepted[i], index);
    
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
    
      return priority;
    }
    
    function specify(encoding, spec, index) {
      var s = 0;
      if(spec.encoding.toLowerCase() === encoding.toLowerCase()){
        s |= 1;
      } else if (spec.encoding !== '*' ) {
        return null
      }
    
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s: s
      }
    };
    
    function preferredEncodings(accept, provided) {
      var accepts = parseAcceptEncoding(accept || '');
    
      if (!provided) {
        // sorted list of all encodings
        return accepts.filter(isQuality).sort(compareSpecs).map(function getEncoding(spec) {
          return spec.encoding;
        });
      }
    
      var priorities = provided.map(function getPriority(type, index) {
        return getEncodingPriority(type, accepts, index);
      });
    
      // sorted list of accepted encodings
      return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    
    function compareSpecs(a, b) {
      return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
    }
    
    function isQuality(spec) {
      return spec.q > 0;
    }
    
  provide("negotiator/lib/encoding", module.exports);
}(global));

// pakmanager:negotiator/lib/language
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = preferredLanguages;
    preferredLanguages.preferredLanguages = preferredLanguages;
    
    function parseAcceptLanguage(accept) {
      var accepts = accept.split(',');
    
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var langauge = parseLanguage(accepts[i].trim(), i);
    
        if (langauge) {
          accepts[j++] = langauge;
        }
      }
    
      // trim accepts
      accepts.length = j;
    
      return accepts;
    }
    
    function parseLanguage(s, i) {
      var match = s.match(/^\s*(\S+?)(?:-(\S+?))?\s*(?:;(.*))?$/);
      if (!match) return null;
    
      var prefix = match[1],
          suffix = match[2],
          full = prefix;
    
      if (suffix) full += "-" + suffix;
    
      var q = 1;
      if (match[3]) {
        var params = match[3].split(';')
        for (var i = 0; i < params.length; i ++) {
          var p = params[i].split('=');
          if (p[0] === 'q') q = parseFloat(p[1]);
        }
      }
    
      return {
        prefix: prefix,
        suffix: suffix,
        q: q,
        i: i,
        full: full
      };
    }
    
    function getLanguagePriority(language, accepted, index) {
      var priority = {o: -1, q: 0, s: 0};
    
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(language, accepted[i], index);
    
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
    
      return priority;
    }
    
    function specify(language, spec, index) {
      var p = parseLanguage(language)
      if (!p) return null;
      var s = 0;
      if(spec.full.toLowerCase() === p.full.toLowerCase()){
        s |= 4;
      } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
        s |= 2;
      } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
        s |= 1;
      } else if (spec.full !== '*' ) {
        return null
      }
    
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s: s
      }
    };
    
    function preferredLanguages(accept, provided) {
      // RFC 2616 sec 14.4: no header = *
      var accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');
    
      if (!provided) {
        // sorted list of all languages
        return accepts.filter(isQuality).sort(compareSpecs).map(function getLanguage(spec) {
          return spec.full;
        });
      }
    
      var priorities = provided.map(function getPriority(type, index) {
        return getLanguagePriority(type, accepts, index);
      });
    
      // sorted list of accepted languages
      return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    
    function compareSpecs(a, b) {
      return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
    }
    
    function isQuality(spec) {
      return spec.q > 0;
    }
    
  provide("negotiator/lib/language", module.exports);
}(global));

// pakmanager:negotiator/lib/mediaType
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * negotiator
     * Copyright(c) 2012 Isaac Z. Schlueter
     * Copyright(c) 2014 Federico Romero
     * Copyright(c) 2014-2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    module.exports = preferredMediaTypes;
    preferredMediaTypes.preferredMediaTypes = preferredMediaTypes;
    
    function parseAccept(accept) {
      var accepts = splitMediaTypes(accept);
    
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var mediaType = parseMediaType(accepts[i].trim(), i);
    
        if (mediaType) {
          accepts[j++] = mediaType;
        }
      }
    
      // trim accepts
      accepts.length = j;
    
      return accepts;
    };
    
    function parseMediaType(s, i) {
      var match = s.match(/\s*(\S+?)\/([^;\s]+)\s*(?:;(.*))?/);
      if (!match) return null;
    
      var type = match[1],
          subtype = match[2],
          full = "" + type + "/" + subtype,
          params = {},
          q = 1;
    
      if (match[3]) {
        params = match[3].split(';').map(function(s) {
          return s.trim().split('=');
        }).reduce(function (set, p) {
          var name = p[0].toLowerCase();
          var value = p[1];
    
          set[name] = value && value[0] === '"' && value[value.length - 1] === '"'
            ? value.substr(1, value.length - 2)
            : value;
    
          return set;
        }, params);
    
        if (params.q != null) {
          q = parseFloat(params.q);
          delete params.q;
        }
      }
    
      return {
        type: type,
        subtype: subtype,
        params: params,
        q: q,
        i: i,
        full: full
      };
    }
    
    function getMediaTypePriority(type, accepted, index) {
      var priority = {o: -1, q: 0, s: 0};
    
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(type, accepted[i], index);
    
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
    
      return priority;
    }
    
    function specify(type, spec, index) {
      var p = parseMediaType(type);
      var s = 0;
    
      if (!p) {
        return null;
      }
    
      if(spec.type.toLowerCase() == p.type.toLowerCase()) {
        s |= 4
      } else if(spec.type != '*') {
        return null;
      }
    
      if(spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
        s |= 2
      } else if(spec.subtype != '*') {
        return null;
      }
    
      var keys = Object.keys(spec.params);
      if (keys.length > 0) {
        if (keys.every(function (k) {
          return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
        })) {
          s |= 1
        } else {
          return null
        }
      }
    
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s: s,
      }
    
    }
    
    function preferredMediaTypes(accept, provided) {
      // RFC 2616 sec 14.2: no header = */*
      var accepts = parseAccept(accept === undefined ? '*/*' : accept || '');
    
      if (!provided) {
        // sorted list of all types
        return accepts.filter(isQuality).sort(compareSpecs).map(function getType(spec) {
          return spec.full;
        });
      }
    
      var priorities = provided.map(function getPriority(type, index) {
        return getMediaTypePriority(type, accepts, index);
      });
    
      // sorted list of accepted types
      return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    
    function compareSpecs(a, b) {
      return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
    }
    
    function isQuality(spec) {
      return spec.q > 0;
    }
    
    function quoteCount(string) {
      var count = 0;
      var index = 0;
    
      while ((index = string.indexOf('"', index)) !== -1) {
        count++;
        index++;
      }
    
      return count;
    }
    
    function splitMediaTypes(accept) {
      var accepts = accept.split(',');
    
      for (var i = 1, j = 0; i < accepts.length; i++) {
        if (quoteCount(accepts[j]) % 2 == 0) {
          accepts[++j] = accepts[i];
        } else {
          accepts[j] += ',' + accepts[i];
        }
      }
    
      // trim accepts
      accepts.length = j + 1;
    
      return accepts;
    }
    
  provide("negotiator/lib/mediaType", module.exports);
}(global));

// pakmanager:negotiator
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    var preferredCharsets =  require('negotiator/lib/charset');
    var preferredEncodings =  require('negotiator/lib/encoding');
    var preferredLanguages =  require('negotiator/lib/language');
    var preferredMediaTypes =  require('negotiator/lib/mediaType');
    
    module.exports = Negotiator;
    Negotiator.Negotiator = Negotiator;
    
    function Negotiator(request) {
      if (!(this instanceof Negotiator)) {
        return new Negotiator(request);
      }
    
      this.request = request;
    }
    
    Negotiator.prototype.charset = function charset(available) {
      var set = this.charsets(available);
      return set && set[0];
    };
    
    Negotiator.prototype.charsets = function charsets(available) {
      return preferredCharsets(this.request.headers['accept-charset'], available);
    };
    
    Negotiator.prototype.encoding = function encoding(available) {
      var set = this.encodings(available);
      return set && set[0];
    };
    
    Negotiator.prototype.encodings = function encodings(available) {
      return preferredEncodings(this.request.headers['accept-encoding'], available);
    };
    
    Negotiator.prototype.language = function language(available) {
      var set = this.languages(available);
      return set && set[0];
    };
    
    Negotiator.prototype.languages = function languages(available) {
      return preferredLanguages(this.request.headers['accept-language'], available);
    };
    
    Negotiator.prototype.mediaType = function mediaType(available) {
      var set = this.mediaTypes(available);
      return set && set[0];
    };
    
    Negotiator.prototype.mediaTypes = function mediaTypes(available) {
      return preferredMediaTypes(this.request.headers.accept, available);
    };
    
    // Backwards compatibility
    Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
    Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
    Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
    Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
    Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
    Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
    Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
    Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
    
  provide("negotiator", module.exports);
}(global));

// pakmanager:forwarded
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * forwarded
     * Copyright(c) 2014 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    /**
     * Module exports.
     */
    
    module.exports = forwarded
    
    /**
     * Get all addresses in the request, using the `X-Forwarded-For` header.
     *
     * @param {Object} req
     * @api public
     */
    
    function forwarded(req) {
      if (!req) {
        throw new TypeError('argument req is required')
      }
    
      // simple header parsing
      var proxyAddrs = (req.headers['x-forwarded-for'] || '')
        .split(/ *, */)
        .filter(Boolean)
        .reverse()
      var socketAddr = req.connection.remoteAddress
      var addrs = [socketAddr].concat(proxyAddrs)
    
      // return all addresses
      return addrs
    }
    
  provide("forwarded", module.exports);
}(global));

// pakmanager:ipaddr.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function() {
      var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root;
    
      ipaddr = {};
    
      root = this;
    
      if ((typeof module !== "undefined" && module !== null) && module.exports) {
        module.exports = ipaddr;
      } else {
        root['ipaddr'] = ipaddr;
      }
    
      matchCIDR = function(first, second, partSize, cidrBits) {
        var part, shift;
        if (first.length !== second.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        part = 0;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first[part] >> shift !== second[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      };
    
      ipaddr.subnetMatch = function(address, rangeList, defaultName) {
        var rangeName, rangeSubnets, subnet, _i, _len;
        if (defaultName == null) {
          defaultName = 'unicast';
        }
        for (rangeName in rangeList) {
          rangeSubnets = rangeList[rangeName];
          if (toString.call(rangeSubnets[0]) !== '[object Array]') {
            rangeSubnets = [rangeSubnets];
          }
          for (_i = 0, _len = rangeSubnets.length; _i < _len; _i++) {
            subnet = rangeSubnets[_i];
            if (address.match.apply(address, subnet)) {
              return rangeName;
            }
          }
        }
        return defaultName;
      };
    
      ipaddr.IPv4 = (function() {
        function IPv4(octets) {
          var octet, _i, _len;
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          for (_i = 0, _len = octets.length; _i < _len; _i++) {
            octet = octets[_i];
            if (!((0 <= octet && octet <= 255))) {
              throw new Error("ipaddr: ipv4 octet is a byte");
            }
          }
          this.octets = octets;
        }
    
        IPv4.prototype.kind = function() {
          return 'ipv4';
        };
    
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
    
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
    
        IPv4.prototype.match = function(other, cidrRange) {
          var _ref;
          if (cidrRange === void 0) {
            _ref = other, other = _ref[0], cidrRange = _ref[1];
          }
          if (other.kind() !== 'ipv4') {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
    
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
          reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
        };
    
        IPv4.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
    
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr.IPv6.parse("::ffff:" + (this.toString()));
        };
    
        return IPv4;
    
      })();
    
      ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
    
      ipv4Regexes = {
        fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
        longValue: new RegExp("^" + ipv4Part + "$", 'i')
      };
    
      ipaddr.IPv4.parser = function(string) {
        var match, parseIntAuto, part, shift, value;
        parseIntAuto = function(string) {
          if (string[0] === "0" && string[1] !== "x") {
            return parseInt(string, 8);
          } else {
            return parseInt(string);
          }
        };
        if (match = string.match(ipv4Regexes.fourOctet)) {
          return (function() {
            var _i, _len, _ref, _results;
            _ref = match.slice(1, 6);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              part = _ref[_i];
              _results.push(parseIntAuto(part));
            }
            return _results;
          })();
        } else if (match = string.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match[1]);
          if (value > 0xffffffff || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return ((function() {
            var _i, _results;
            _results = [];
            for (shift = _i = 0; _i <= 24; shift = _i += 8) {
              _results.push((value >> shift) & 0xff);
            }
            return _results;
          })()).reverse();
        } else {
          return null;
        }
      };
    
      ipaddr.IPv6 = (function() {
        function IPv6(parts) {
          var part, _i, _len;
          if (parts.length !== 8) {
            throw new Error("ipaddr: ipv6 part count should be 8");
          }
          for (_i = 0, _len = parts.length; _i < _len; _i++) {
            part = parts[_i];
            if (!((0 <= part && part <= 0xffff))) {
              throw new Error("ipaddr: ipv6 part should fit to two octets");
            }
          }
          this.parts = parts;
        }
    
        IPv6.prototype.kind = function() {
          return 'ipv6';
        };
    
        IPv6.prototype.toString = function() {
          var compactStringParts, part, pushPart, state, stringParts, _i, _len;
          stringParts = (function() {
            var _i, _len, _ref, _results;
            _ref = this.parts;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              part = _ref[_i];
              _results.push(part.toString(16));
            }
            return _results;
          }).call(this);
          compactStringParts = [];
          pushPart = function(part) {
            return compactStringParts.push(part);
          };
          state = 0;
          for (_i = 0, _len = stringParts.length; _i < _len; _i++) {
            part = stringParts[_i];
            switch (state) {
              case 0:
                if (part === '0') {
                  pushPart('');
                } else {
                  pushPart(part);
                }
                state = 1;
                break;
              case 1:
                if (part === '0') {
                  state = 2;
                } else {
                  pushPart(part);
                }
                break;
              case 2:
                if (part !== '0') {
                  pushPart('');
                  pushPart(part);
                  state = 3;
                }
                break;
              case 3:
                pushPart(part);
            }
          }
          if (state === 2) {
            pushPart('');
            pushPart('');
          }
          return compactStringParts.join(":");
        };
    
        IPv6.prototype.toByteArray = function() {
          var bytes, part, _i, _len, _ref;
          bytes = [];
          _ref = this.parts;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            part = _ref[_i];
            bytes.push(part >> 8);
            bytes.push(part & 0xff);
          }
          return bytes;
        };
    
        IPv6.prototype.toNormalizedString = function() {
          var part;
          return ((function() {
            var _i, _len, _ref, _results;
            _ref = this.parts;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              part = _ref[_i];
              _results.push(part.toString(16));
            }
            return _results;
          }).call(this)).join(":");
        };
    
        IPv6.prototype.match = function(other, cidrRange) {
          var _ref;
          if (cidrRange === void 0) {
            _ref = other, other = _ref[0], cidrRange = _ref[1];
          }
          if (other.kind() !== 'ipv6') {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
    
        IPv6.prototype.SpecialRanges = {
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],
          rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],
          rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],
          '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],
          teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],
          reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]
        };
    
        IPv6.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
    
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === 'ipv4Mapped';
        };
    
        IPv6.prototype.toIPv4Address = function() {
          var high, low, _ref;
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          _ref = this.parts.slice(-2), high = _ref[0], low = _ref[1];
          return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);
        };
    
        return IPv6;
    
      })();
    
      ipv6Part = "(?:[0-9a-f]+::?)+";
    
      ipv6Regexes = {
        "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?$", 'i'),
        transitional: new RegExp(("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)") + ("" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$"), 'i')
      };
    
      expandIPv6 = function(string, parts) {
        var colonCount, lastColon, part, replacement, replacementCount;
        if (string.indexOf('::') !== string.lastIndexOf('::')) {
          return null;
        }
        colonCount = 0;
        lastColon = -1;
        while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string[0] === ':') {
          colonCount--;
        }
        if (string[string.length - 1] === ':') {
          colonCount--;
        }
        if (colonCount > parts) {
          return null;
        }
        replacementCount = parts - colonCount;
        replacement = ':';
        while (replacementCount--) {
          replacement += '0:';
        }
        string = string.replace('::', replacement);
        if (string[0] === ':') {
          string = string.slice(1);
        }
        if (string[string.length - 1] === ':') {
          string = string.slice(0, -1);
        }
        return (function() {
          var _i, _len, _ref, _results;
          _ref = string.split(":");
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            part = _ref[_i];
            _results.push(parseInt(part, 16));
          }
          return _results;
        })();
      };
    
      ipaddr.IPv6.parser = function(string) {
        var match, parts;
        if (string.match(ipv6Regexes['native'])) {
          return expandIPv6(string, 8);
        } else if (match = string.match(ipv6Regexes['transitional'])) {
          parts = expandIPv6(match[1].slice(0, -1), 6);
          if (parts) {
            parts.push(parseInt(match[2]) << 8 | parseInt(match[3]));
            parts.push(parseInt(match[4]) << 8 | parseInt(match[5]));
            return parts;
          }
        }
        return null;
      };
    
      ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
        return this.parser(string) !== null;
      };
    
      ipaddr.IPv4.isValid = ipaddr.IPv6.isValid = function(string) {
        var e;
        try {
          new this(this.parser(string));
          return true;
        } catch (_error) {
          e = _error;
          return false;
        }
      };
    
      ipaddr.IPv4.parse = ipaddr.IPv6.parse = function(string) {
        var parts;
        parts = this.parser(string);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(parts);
      };
    
      ipaddr.IPv4.parseCIDR = ipaddr.IPv6.parseCIDR = function(string) {
        var match;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          return [this.parse(match[1]), parseInt(match[2])];
        }
        throw new Error("ipaddr: string is not formatted like a CIDR range");
      };
    
      ipaddr.isValid = function(string) {
        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
      };
    
      ipaddr.parse = function(string) {
        if (ipaddr.IPv6.isValid(string)) {
          return ipaddr.IPv6.parse(string);
        } else if (ipaddr.IPv4.isValid(string)) {
          return ipaddr.IPv4.parse(string);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
    
      ipaddr.parseCIDR = function(string) {
        var e;
        try {
          return ipaddr.IPv6.parseCIDR(string);
        } catch (_error) {
          e = _error;
          try {
            return ipaddr.IPv4.parseCIDR(string);
          } catch (_error) {
            e = _error;
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
    
      ipaddr.process = function(string) {
        var addr;
        addr = this.parse(string);
        if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
    
    }).call(this);
    
  provide("ipaddr.js", module.exports);
}(global));

// pakmanager:parseurl
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * parseurl
     * Copyright(c) 2014 Jonathan Ong
     * Copyright(c) 2014 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    /**
     * Module dependencies.
     */
    
    var url = require('url')
    var parse = url.parse
    var Url = url.Url
    
    /**
     * Pattern for a simple path case.
     * See: https://github.com/joyent/node/pull/7878
     */
    
    var simplePathRegExp = /^(\/\/?(?!\/)[^\?#\s]*)(\?[^#\s]*)?$/
    
    /**
     * Exports.
     */
    
    module.exports = parseurl
    module.exports.original = originalurl
    
    /**
     * Parse the `req` url with memoization.
     *
     * @param {ServerRequest} req
     * @return {Object}
     * @api public
     */
    
    function parseurl(req) {
      var url = req.url
    
      if (url === undefined) {
        // URL is undefined
        return undefined
      }
    
      var parsed = req._parsedUrl
    
      if (fresh(url, parsed)) {
        // Return cached URL parse
        return parsed
      }
    
      // Parse the URL
      parsed = fastparse(url)
      parsed._raw = url
    
      return req._parsedUrl = parsed
    };
    
    /**
     * Parse the `req` original url with fallback and memoization.
     *
     * @param {ServerRequest} req
     * @return {Object}
     * @api public
     */
    
    function originalurl(req) {
      var url = req.originalUrl
    
      if (typeof url !== 'string') {
        // Fallback
        return parseurl(req)
      }
    
      var parsed = req._parsedOriginalUrl
    
      if (fresh(url, parsed)) {
        // Return cached URL parse
        return parsed
      }
    
      // Parse the URL
      parsed = fastparse(url)
      parsed._raw = url
    
      return req._parsedOriginalUrl = parsed
    };
    
    /**
     * Parse the `str` url with fast-path short-cut.
     *
     * @param {string} str
     * @return {Object}
     * @api private
     */
    
    function fastparse(str) {
      // Try fast path regexp
      // See: https://github.com/joyent/node/pull/7878
      var simplePath = typeof str === 'string' && simplePathRegExp.exec(str)
    
      // Construct simple URL
      if (simplePath) {
        var pathname = simplePath[1]
        var search = simplePath[2] || null
        var url = Url !== undefined
          ? new Url()
          : {}
        url.path = str
        url.href = str
        url.pathname = pathname
        url.search = search
        url.query = search && search.substr(1)
    
        return url
      }
    
      return parse(str)
    }
    
    /**
     * Determine if parsed is still fresh for url.
     *
     * @param {string} url
     * @param {object} parsedUrl
     * @return {boolean}
     * @api private
     */
    
    function fresh(url, parsedUrl) {
      return typeof parsedUrl === 'object'
        && parsedUrl !== null
        && (Url === undefined || parsedUrl instanceof Url)
        && parsedUrl._raw === url
    }
    
  provide("parseurl", module.exports);
}(global));

// pakmanager:send
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * send
     * Copyright(c) 2012 TJ Holowaychuk
     * Copyright(c) 2014-2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    /**
     * Module dependencies.
     */
    
    var debug = require('debug')('send')
    var deprecate = require('depd')('send')
    var destroy = require('destroy')
    var escapeHtml = require('escape-html')
      , parseRange = require('range-parser')
      , Stream = require('stream')
      , mime = require('mime')
      , fresh = require('fresh')
      , path = require('path')
      , http = require('http')
      , fs = require('fs')
      , normalize = path.normalize
      , join = path.join
    var etag = require('etag')
    var EventEmitter = require('events').EventEmitter;
    var ms = require('ms');
    var onFinished = require('on-finished')
    
    /**
     * Variables.
     */
    var extname = path.extname
    var maxMaxAge = 60 * 60 * 24 * 365 * 1000; // 1 year
    var resolve = path.resolve
    var sep = path.sep
    var toString = Object.prototype.toString
    var upPathRegexp = /(?:^|[\\\/])\.\.(?:[\\\/]|$)/
    
    /**
     * Expose `send`.
     */
    
    exports = module.exports = send;
    
    /**
     * Expose mime module.
     */
    
    exports.mime = mime;
    
    /**
     * Shim EventEmitter.listenerCount for node.js < 0.10
     */
    
    /* istanbul ignore next */
    var listenerCount = EventEmitter.listenerCount
      || function(emitter, type){ return emitter.listeners(type).length; };
    
    /**
     * Return a `SendStream` for `req` and `path`.
     *
     * @param {Request} req
     * @param {String} path
     * @param {object} [options]
     * @return {SendStream}
     * @api public
     */
    
    function send(req, path, options) {
      return new SendStream(req, path, options);
    }
    
    /**
     * Initialize a `SendStream` with the given `path`.
     *
     * @param {Request} req
     * @param {String} path
     * @param {object} [options]
     * @api private
     */
    
    function SendStream(req, path, options) {
      var opts = options || {}
    
      this.options = opts
      this.path = path
      this.req = req
    
      this._etag = opts.etag !== undefined
        ? Boolean(opts.etag)
        : true
    
      this._dotfiles = opts.dotfiles !== undefined
        ? opts.dotfiles
        : 'ignore'
    
      if (['allow', 'deny', 'ignore'].indexOf(this._dotfiles) === -1) {
        throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"')
      }
    
      this._hidden = Boolean(opts.hidden)
    
      if (opts.hidden !== undefined) {
        deprecate('hidden: use dotfiles: \'' + (this._hidden ? 'allow' : 'ignore') + '\' instead')
      }
    
      // legacy support
      if (opts.dotfiles === undefined) {
        this._dotfiles = undefined
      }
    
      this._extensions = opts.extensions !== undefined
        ? normalizeList(opts.extensions, 'extensions option')
        : []
    
      this._index = opts.index !== undefined
        ? normalizeList(opts.index, 'index option')
        : ['index.html']
    
      this._lastModified = opts.lastModified !== undefined
        ? Boolean(opts.lastModified)
        : true
    
      this._maxage = opts.maxAge || opts.maxage
      this._maxage = typeof this._maxage === 'string'
        ? ms(this._maxage)
        : Number(this._maxage)
      this._maxage = !isNaN(this._maxage)
        ? Math.min(Math.max(0, this._maxage), maxMaxAge)
        : 0
    
      this._root = opts.root
        ? resolve(opts.root)
        : null
    
      if (!this._root && opts.from) {
        this.from(opts.from)
      }
    }
    
    /**
     * Inherits from `Stream.prototype`.
     */
    
    SendStream.prototype.__proto__ = Stream.prototype;
    
    /**
     * Enable or disable etag generation.
     *
     * @param {Boolean} val
     * @return {SendStream}
     * @api public
     */
    
    SendStream.prototype.etag = deprecate.function(function etag(val) {
      val = Boolean(val);
      debug('etag %s', val);
      this._etag = val;
      return this;
    }, 'send.etag: pass etag as option');
    
    /**
     * Enable or disable "hidden" (dot) files.
     *
     * @param {Boolean} path
     * @return {SendStream}
     * @api public
     */
    
    SendStream.prototype.hidden = deprecate.function(function hidden(val) {
      val = Boolean(val);
      debug('hidden %s', val);
      this._hidden = val;
      this._dotfiles = undefined
      return this;
    }, 'send.hidden: use dotfiles option');
    
    /**
     * Set index `paths`, set to a falsy
     * value to disable index support.
     *
     * @param {String|Boolean|Array} paths
     * @return {SendStream}
     * @api public
     */
    
    SendStream.prototype.index = deprecate.function(function index(paths) {
      var index = !paths ? [] : normalizeList(paths, 'paths argument');
      debug('index %o', paths);
      this._index = index;
      return this;
    }, 'send.index: pass index as option');
    
    /**
     * Set root `path`.
     *
     * @param {String} path
     * @return {SendStream}
     * @api public
     */
    
    SendStream.prototype.root = function(path){
      path = String(path);
      this._root = resolve(path)
      return this;
    };
    
    SendStream.prototype.from = deprecate.function(SendStream.prototype.root,
      'send.from: pass root as option');
    
    SendStream.prototype.root = deprecate.function(SendStream.prototype.root,
      'send.root: pass root as option');
    
    /**
     * Set max-age to `maxAge`.
     *
     * @param {Number} maxAge
     * @return {SendStream}
     * @api public
     */
    
    SendStream.prototype.maxage = deprecate.function(function maxage(maxAge) {
      maxAge = typeof maxAge === 'string'
        ? ms(maxAge)
        : Number(maxAge);
      if (isNaN(maxAge)) maxAge = 0;
      if (Infinity == maxAge) maxAge = 60 * 60 * 24 * 365 * 1000;
      debug('max-age %d', maxAge);
      this._maxage = maxAge;
      return this;
    }, 'send.maxage: pass maxAge as option');
    
    /**
     * Emit error with `status`.
     *
     * @param {Number} status
     * @api private
     */
    
    SendStream.prototype.error = function(status, err){
      var res = this.res;
      var msg = http.STATUS_CODES[status];
    
      err = err || new Error(msg);
      err.status = status;
    
      // emit if listeners instead of responding
      if (listenerCount(this, 'error') !== 0) {
        return this.emit('error', err);
      }
    
      // wipe all existing headers
      res._headers = undefined;
    
      res.statusCode = err.status;
      res.end(msg);
    };
    
    /**
     * Check if the pathname ends with "/".
     *
     * @return {Boolean}
     * @api private
     */
    
    SendStream.prototype.hasTrailingSlash = function(){
      return '/' == this.path[this.path.length - 1];
    };
    
    /**
     * Check if this is a conditional GET request.
     *
     * @return {Boolean}
     * @api private
     */
    
    SendStream.prototype.isConditionalGET = function(){
      return this.req.headers['if-none-match']
        || this.req.headers['if-modified-since'];
    };
    
    /**
     * Strip content-* header fields.
     *
     * @api private
     */
    
    SendStream.prototype.removeContentHeaderFields = function(){
      var res = this.res;
      Object.keys(res._headers).forEach(function(field){
        if (0 == field.indexOf('content')) {
          res.removeHeader(field);
        }
      });
    };
    
    /**
     * Respond with 304 not modified.
     *
     * @api private
     */
    
    SendStream.prototype.notModified = function(){
      var res = this.res;
      debug('not modified');
      this.removeContentHeaderFields();
      res.statusCode = 304;
      res.end();
    };
    
    /**
     * Raise error that headers already sent.
     *
     * @api private
     */
    
    SendStream.prototype.headersAlreadySent = function headersAlreadySent(){
      var err = new Error('Can\'t set headers after they are sent.');
      debug('headers already sent');
      this.error(500, err);
    };
    
    /**
     * Check if the request is cacheable, aka
     * responded with 2xx or 304 (see RFC 2616 section 14.2{5,6}).
     *
     * @return {Boolean}
     * @api private
     */
    
    SendStream.prototype.isCachable = function(){
      var res = this.res;
      return (res.statusCode >= 200 && res.statusCode < 300) || 304 == res.statusCode;
    };
    
    /**
     * Handle stat() error.
     *
     * @param {Error} err
     * @api private
     */
    
    SendStream.prototype.onStatError = function(err){
      var notfound = ['ENOENT', 'ENAMETOOLONG', 'ENOTDIR'];
      if (~notfound.indexOf(err.code)) return this.error(404, err);
      this.error(500, err);
    };
    
    /**
     * Check if the cache is fresh.
     *
     * @return {Boolean}
     * @api private
     */
    
    SendStream.prototype.isFresh = function(){
      return fresh(this.req.headers, this.res._headers);
    };
    
    /**
     * Check if the range is fresh.
     *
     * @return {Boolean}
     * @api private
     */
    
    SendStream.prototype.isRangeFresh = function isRangeFresh(){
      var ifRange = this.req.headers['if-range'];
    
      if (!ifRange) return true;
    
      return ~ifRange.indexOf('"')
        ? ~ifRange.indexOf(this.res._headers['etag'])
        : Date.parse(this.res._headers['last-modified']) <= Date.parse(ifRange);
    };
    
    /**
     * Redirect to `path`.
     *
     * @param {String} path
     * @api private
     */
    
    SendStream.prototype.redirect = function(path){
      if (listenerCount(this, 'directory') !== 0) {
        return this.emit('directory');
      }
    
      if (this.hasTrailingSlash()) return this.error(403);
      var res = this.res;
      path += '/';
      res.statusCode = 301;
      res.setHeader('Content-Type', 'text/html; charset=utf-8');
      res.setHeader('Location', path);
      res.end('Redirecting to <a href="' + escapeHtml(path) + '">' + escapeHtml(path) + '</a>\n');
    };
    
    /**
     * Pipe to `res.
     *
     * @param {Stream} res
     * @return {Stream} res
     * @api public
     */
    
    SendStream.prototype.pipe = function(res){
      var self = this
        , args = arguments
        , root = this._root;
    
      // references
      this.res = res;
    
      // decode the path
      var path = decode(this.path)
      if (path === -1) return this.error(400)
    
      // null byte(s)
      if (~path.indexOf('\0')) return this.error(400);
    
      var parts
      if (root !== null) {
        // malicious path
        if (upPathRegexp.test(normalize('.' + sep + path))) {
          debug('malicious path "%s"', path)
          return this.error(403)
        }
    
        // join / normalize from optional root dir
        path = normalize(join(root, path))
        root = normalize(root + sep)
    
        // explode path parts
        parts = path.substr(root.length).split(sep)
      } else {
        // ".." is malicious without "root"
        if (upPathRegexp.test(path)) {
          debug('malicious path "%s"', path)
          return this.error(403)
        }
    
        // explode path parts
        parts = normalize(path).split(sep)
    
        // resolve the path
        path = resolve(path)
      }
    
      // dotfile handling
      if (containsDotFile(parts)) {
        var access = this._dotfiles
    
        // legacy support
        if (access === undefined) {
          access = parts[parts.length - 1][0] === '.'
            ? (this._hidden ? 'allow' : 'ignore')
            : 'allow'
        }
    
        debug('%s dotfile "%s"', access, path)
        switch (access) {
          case 'allow':
            break
          case 'deny':
            return this.error(403)
          case 'ignore':
          default:
            return this.error(404)
        }
      }
    
      // index file support
      if (this._index.length && this.path[this.path.length - 1] === '/') {
        this.sendIndex(path);
        return res;
      }
    
      this.sendFile(path);
      return res;
    };
    
    /**
     * Transfer `path`.
     *
     * @param {String} path
     * @api public
     */
    
    SendStream.prototype.send = function(path, stat){
      var len = stat.size;
      var options = this.options
      var opts = {}
      var res = this.res;
      var req = this.req;
      var ranges = req.headers.range;
      var offset = options.start || 0;
    
      if (res._header) {
        // impossible to send now
        return this.headersAlreadySent();
      }
    
      debug('pipe "%s"', path)
    
      // set header fields
      this.setHeader(path, stat);
    
      // set content-type
      this.type(path);
    
      // conditional GET support
      if (this.isConditionalGET()
        && this.isCachable()
        && this.isFresh()) {
        return this.notModified();
      }
    
      // adjust len to start/end options
      len = Math.max(0, len - offset);
      if (options.end !== undefined) {
        var bytes = options.end - offset + 1;
        if (len > bytes) len = bytes;
      }
    
      // Range support
      if (ranges) {
        ranges = parseRange(len, ranges);
    
        // If-Range support
        if (!this.isRangeFresh()) {
          debug('range stale');
          ranges = -2;
        }
    
        // unsatisfiable
        if (-1 == ranges) {
          debug('range unsatisfiable');
          res.setHeader('Content-Range', 'bytes */' + stat.size);
          return this.error(416);
        }
    
        // valid (syntactically invalid/multiple ranges are treated as a regular response)
        if (-2 != ranges && ranges.length === 1) {
          debug('range %j', ranges);
    
          // Content-Range
          res.statusCode = 206;
          res.setHeader('Content-Range', 'bytes '
            + ranges[0].start
            + '-'
            + ranges[0].end
            + '/'
            + len);
    
          offset += ranges[0].start;
          len = ranges[0].end - ranges[0].start + 1;
        }
      }
    
      // clone options
      for (var prop in options) {
        opts[prop] = options[prop]
      }
    
      // set read options
      opts.start = offset
      opts.end = Math.max(offset, offset + len - 1)
    
      // content-length
      res.setHeader('Content-Length', len);
    
      // HEAD support
      if ('HEAD' == req.method) return res.end();
    
      this.stream(path, opts)
    };
    
    /**
     * Transfer file for `path`.
     *
     * @param {String} path
     * @api private
     */
    SendStream.prototype.sendFile = function sendFile(path) {
      var i = 0
      var self = this
    
      debug('stat "%s"', path);
      fs.stat(path, function onstat(err, stat) {
        if (err && err.code === 'ENOENT'
          && !extname(path)
          && path[path.length - 1] !== sep) {
          // not found, check extensions
          return next(err)
        }
        if (err) return self.onStatError(err)
        if (stat.isDirectory()) return self.redirect(self.path)
        self.emit('file', path, stat)
        self.send(path, stat)
      })
    
      function next(err) {
        if (self._extensions.length <= i) {
          return err
            ? self.onStatError(err)
            : self.error(404)
        }
    
        var p = path + '.' + self._extensions[i++]
    
        debug('stat "%s"', p)
        fs.stat(p, function (err, stat) {
          if (err) return next(err)
          if (stat.isDirectory()) return next()
          self.emit('file', p, stat)
          self.send(p, stat)
        })
      }
    }
    
    /**
     * Transfer index for `path`.
     *
     * @param {String} path
     * @api private
     */
    SendStream.prototype.sendIndex = function sendIndex(path){
      var i = -1;
      var self = this;
    
      function next(err){
        if (++i >= self._index.length) {
          if (err) return self.onStatError(err);
          return self.error(404);
        }
    
        var p = join(path, self._index[i]);
    
        debug('stat "%s"', p);
        fs.stat(p, function(err, stat){
          if (err) return next(err);
          if (stat.isDirectory()) return next();
          self.emit('file', p, stat);
          self.send(p, stat);
        });
      }
    
      next();
    };
    
    /**
     * Stream `path` to the response.
     *
     * @param {String} path
     * @param {Object} options
     * @api private
     */
    
    SendStream.prototype.stream = function(path, options){
      // TODO: this is all lame, refactor meeee
      var finished = false;
      var self = this;
      var res = this.res;
      var req = this.req;
    
      // pipe
      var stream = fs.createReadStream(path, options);
      this.emit('stream', stream);
      stream.pipe(res);
    
      // response finished, done with the fd
      onFinished(res, function onfinished(){
        finished = true;
        destroy(stream);
      });
    
      // error handling code-smell
      stream.on('error', function onerror(err){
        // request already finished
        if (finished) return;
    
        // clean up stream
        finished = true;
        destroy(stream);
    
        // error
        self.onStatError(err);
      });
    
      // end
      stream.on('end', function onend(){
        self.emit('end');
      });
    };
    
    /**
     * Set content-type based on `path`
     * if it hasn't been explicitly set.
     *
     * @param {String} path
     * @api private
     */
    
    SendStream.prototype.type = function(path){
      var res = this.res;
      if (res.getHeader('Content-Type')) return;
      var type = mime.lookup(path);
      var charset = mime.charsets.lookup(type);
      debug('content-type %s', type);
      res.setHeader('Content-Type', type + (charset ? '; charset=' + charset : ''));
    };
    
    /**
     * Set response header fields, most
     * fields may be pre-defined.
     *
     * @param {String} path
     * @param {Object} stat
     * @api private
     */
    
    SendStream.prototype.setHeader = function setHeader(path, stat){
      var res = this.res;
    
      this.emit('headers', res, path, stat);
    
      if (!res.getHeader('Accept-Ranges')) res.setHeader('Accept-Ranges', 'bytes');
      if (!res.getHeader('Date')) res.setHeader('Date', new Date().toUTCString());
      if (!res.getHeader('Cache-Control')) res.setHeader('Cache-Control', 'public, max-age=' + Math.floor(this._maxage / 1000));
    
      if (this._lastModified && !res.getHeader('Last-Modified')) {
        var modified = stat.mtime.toUTCString()
        debug('modified %s', modified)
        res.setHeader('Last-Modified', modified)
      }
    
      if (this._etag && !res.getHeader('ETag')) {
        var val = etag(stat)
        debug('etag %s', val)
        res.setHeader('ETag', val)
      }
    };
    
    /**
     * Determine if path parts contain a dotfile.
     *
     * @api private
     */
    
    function containsDotFile(parts) {
      for (var i = 0; i < parts.length; i++) {
        if (parts[i][0] === '.') {
          return true
        }
      }
    
      return false
    }
    
    /**
     * decodeURIComponent.
     *
     * Allows V8 to only deoptimize this fn instead of all
     * of send().
     *
     * @param {String} path
     * @api private
     */
    
    function decode(path) {
      try {
        return decodeURIComponent(path)
      } catch (err) {
        return -1
      }
    }
    
    /**
     * Normalize the index option into an array.
     *
     * @param {boolean|string|array} val
     * @param {string} name
     * @private
     */
    
    function normalizeList(val, name) {
      var list = [].concat(val || [])
    
      for (var i = 0; i < list.length; i++) {
        if (typeof list[i] !== 'string') {
          throw new TypeError(name + ' must be array of strings or false')
        }
      }
    
      return list
    }
    
  provide("send", module.exports);
}(global));

// pakmanager:utils-merge
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Merge object b with object a.
     *
     *     var a = { foo: 'bar' }
     *       , b = { bar: 'baz' };
     *
     *     merge(a, b);
     *     // => { foo: 'bar', bar: 'baz' }
     *
     * @param {Object} a
     * @param {Object} b
     * @return {Object}
     * @api public
     */
    
    exports = module.exports = function(a, b){
      if (a && b) {
        for (var key in b) {
          a[key] = b[key];
        }
      }
      return a;
    };
    
  provide("utils-merge", module.exports);
}(global));

// pakmanager:inflight
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var wrappy = require('wrappy')
    var reqs = Object.create(null)
    var once = require('once')
    
    module.exports = wrappy(inflight)
    
    function inflight (key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb)
        return null
      } else {
        reqs[key] = [cb]
        return makeres(key)
      }
    }
    
    function makeres (key) {
      return once(function RES () {
        var cbs = reqs[key]
        var len = cbs.length
        var args = slice(arguments)
        for (var i = 0; i < len; i++) {
          cbs[i].apply(null, args)
        }
        if (cbs.length > len) {
          // added more in the interim.
          // de-zalgo, just in case, but don't call again.
          cbs.splice(0, len)
          process.nextTick(function () {
            RES.apply(null, args)
          })
        } else {
          delete reqs[key]
        }
      })
    }
    
    function slice (args) {
      var length = args.length
      var array = []
    
      for (var i = 0; i < length; i++) array[i] = args[i]
      return array
    }
    
  provide("inflight", module.exports);
}(global));

// pakmanager:path-is-absolute
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    function posix(path) {
    	return path.charAt(0) === '/';
    };
    
    function win32(path) {
    	// https://github.com/joyent/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
    	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
    	var result = splitDeviceRe.exec(path);
    	var device = result[1] || '';
    	var isUnc = !!device && device.charAt(1) !== ':';
    
    	// UNC paths are always absolute
    	return !!result[2] || isUnc;
    };
    
    module.exports = process.platform === 'win32' ? win32 : posix;
    module.exports.posix = posix;
    module.exports.win32 = win32;
    
  provide("path-is-absolute", module.exports);
}(global));

// pakmanager:character-parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports = (module.exports = parse);
    exports.parse = parse;
    function parse(src, state, options) {
      options = options || {};
      state = state || exports.defaultState();
      var start = options.start || 0;
      var end = options.end || src.length;
      var index = start;
      while (index < end) {
        if (state.roundDepth < 0 || state.curlyDepth < 0 || state.squareDepth < 0) {
          throw new SyntaxError('Mismatched Bracket: ' + src[index - 1]);
        }
        exports.parseChar(src[index++], state);
      }
      return state;
    }
    
    exports.parseMax = parseMax;
    function parseMax(src, options) {
      options = options || {};
      var start = options.start || 0;
      var index = start;
      var state = exports.defaultState();
      while (state.roundDepth >= 0 && state.curlyDepth >= 0 && state.squareDepth >= 0) {
        if (index >= src.length) {
          throw new Error('The end of the string was reached with no closing bracket found.');
        }
        exports.parseChar(src[index++], state);
      }
      var end = index - 1;
      return {
        start: start,
        end: end,
        src: src.substring(start, end)
      };
    }
    
    exports.parseUntil = parseUntil;
    function parseUntil(src, delimiter, options) {
      options = options || {};
      var includeLineComment = options.includeLineComment || false;
      var start = options.start || 0;
      var index = start;
      var state = exports.defaultState();
      while (state.isString() || state.regexp || state.blockComment ||
             (!includeLineComment && state.lineComment) || !startsWith(src, delimiter, index)) {
        exports.parseChar(src[index++], state);
      }
      var end = index;
      return {
        start: start,
        end: end,
        src: src.substring(start, end)
      };
    }
    
    
    exports.parseChar = parseChar;
    function parseChar(character, state) {
      if (character.length !== 1) throw new Error('Character must be a string of length 1');
      state = state || exports.defaultState();
      state.src = state.src || '';
      state.src += character;
      var wasComment = state.blockComment || state.lineComment;
      var lastChar = state.history ? state.history[0] : '';
    
      if (state.regexpStart) {
        if (character === '/' || character == '*') {
          state.regexp = false;
        }
        state.regexpStart = false;
      }
      if (state.lineComment) {
        if (character === '\n') {
          state.lineComment = false;
        }
      } else if (state.blockComment) {
        if (state.lastChar === '*' && character === '/') {
          state.blockComment = false;
        }
      } else if (state.singleQuote) {
        if (character === '\'' && !state.escaped) {
          state.singleQuote = false;
        } else if (character === '\\' && !state.escaped) {
          state.escaped = true;
        } else {
          state.escaped = false;
        }
      } else if (state.doubleQuote) {
        if (character === '"' && !state.escaped) {
          state.doubleQuote = false;
        } else if (character === '\\' && !state.escaped) {
          state.escaped = true;
        } else {
          state.escaped = false;
        }
      } else if (state.regexp) {
        if (character === '/' && !state.escaped) {
          state.regexp = false;
        } else if (character === '\\' && !state.escaped) {
          state.escaped = true;
        } else {
          state.escaped = false;
        }
      } else if (lastChar === '/' && character === '/') {
        state.history = state.history.substr(1);
        state.lineComment = true;
      } else if (lastChar === '/' && character === '*') {
        state.history = state.history.substr(1);
        state.blockComment = true;
      } else if (character === '/' && isRegexp(state.history)) {
        state.regexp = true;
        state.regexpStart = true;
      } else if (character === '\'') {
        state.singleQuote = true;
      } else if (character === '"') {
        state.doubleQuote = true;
      } else if (character === '(') {
        state.roundDepth++;
      } else if (character === ')') {
        state.roundDepth--;
      } else if (character === '{') {
        state.curlyDepth++;
      } else if (character === '}') {
        state.curlyDepth--;
      } else if (character === '[') {
        state.squareDepth++;
      } else if (character === ']') {
        state.squareDepth--;
      }
      if (!state.blockComment && !state.lineComment && !wasComment) state.history = character + state.history;
      state.lastChar = character; // store last character for ending block comments
      return state;
    }
    
    exports.defaultState = function () { return new State() };
    function State() {
      this.lineComment = false;
      this.blockComment = false;
    
      this.singleQuote = false;
      this.doubleQuote = false;
      this.regexp = false;
    
      this.escaped = false;
    
      this.roundDepth = 0;
      this.curlyDepth = 0;
      this.squareDepth = 0;
    
      this.history = ''
      this.lastChar = ''
    }
    State.prototype.isString = function () {
      return this.singleQuote || this.doubleQuote;
    }
    State.prototype.isComment = function () {
      return this.lineComment || this.blockComment;
    }
    State.prototype.isNesting = function () {
      return this.isString() || this.isComment() || this.regexp || this.roundDepth > 0 || this.curlyDepth > 0 || this.squareDepth > 0
    }
    
    function startsWith(str, start, i) {
      return str.substr(i || 0, start.length) === start;
    }
    
    exports.isPunctuator = isPunctuator
    function isPunctuator(c) {
      if (!c) return true; // the start of a string is a punctuator
      var code = c.charCodeAt(0)
    
      switch (code) {
        case 46:   // . dot
        case 40:   // ( open bracket
        case 41:   // ) close bracket
        case 59:   // ; semicolon
        case 44:   // , comma
        case 123:  // { open curly brace
        case 125:  // } close curly brace
        case 91:   // [
        case 93:   // ]
        case 58:   // :
        case 63:   // ?
        case 126:  // ~
        case 37:   // %
        case 38:   // &
        case 42:   // *:
        case 43:   // +
        case 45:   // -
        case 47:   // /
        case 60:   // <
        case 62:   // >
        case 94:   // ^
        case 124:  // |
        case 33:   // !
        case 61:   // =
          return true;
        default:
          return false;
      }
    }
    exports.isKeyword = isKeyword
    function isKeyword(id) {
      return (id === 'if') || (id === 'in') || (id === 'do') || (id === 'var') || (id === 'for') || (id === 'new') ||
             (id === 'try') || (id === 'let') || (id === 'this') || (id === 'else') || (id === 'case') ||
             (id === 'void') || (id === 'with') || (id === 'enum') || (id === 'while') || (id === 'break') || (id === 'catch') ||
             (id === 'throw') || (id === 'const') || (id === 'yield') || (id === 'class') || (id === 'super') ||
             (id === 'return') || (id === 'typeof') || (id === 'delete') || (id === 'switch') || (id === 'export') ||
             (id === 'import') || (id === 'default') || (id === 'finally') || (id === 'extends') || (id === 'function') ||
             (id === 'continue') || (id === 'debugger') || (id === 'package') || (id === 'private') || (id === 'interface') ||
             (id === 'instanceof') || (id === 'implements') || (id === 'protected') || (id === 'public') || (id === 'static');
    }
    
    function isRegexp(history) {
      //could be start of regexp or divide sign
    
      history = history.replace(/^\s*/, '');
    
      //unless its an `if`, `while`, `for` or `with` it's a divide, so we assume it's a divide
      if (history[0] === ')') return false;
      //unless it's a function expression, it's a regexp, so we assume it's a regexp
      if (history[0] === '}') return true;
      //any punctuation means it's a regexp
      if (isPunctuator(history[0])) return true;
      //if the last thing was a keyword then it must be a regexp (e.g. `typeof /foo/`)
      if (/^\w+\b/.test(history) && isKeyword(/^\w+\b/.exec(history)[0].split('').reverse().join(''))) return true;
    
      return false;
    }
    
  provide("character-parser", module.exports);
}(global));

// pakmanager:commander
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var EventEmitter = require('events').EventEmitter;
    var spawn = require('child_process').spawn;
    var readlink = require('graceful-readlink').readlinkSync;
    var path = require('path');
    var dirname = path.dirname;
    var basename = path.basename;
    var fs = require('fs');
    
    /**
     * Expose the root command.
     */
    
    exports = module.exports = new Command();
    
    /**
     * Expose `Command`.
     */
    
    exports.Command = Command;
    
    /**
     * Expose `Option`.
     */
    
    exports.Option = Option;
    
    /**
     * Initialize a new `Option` with the given `flags` and `description`.
     *
     * @param {String} flags
     * @param {String} description
     * @api public
     */
    
    function Option(flags, description) {
      this.flags = flags;
      this.required = ~flags.indexOf('<');
      this.optional = ~flags.indexOf('[');
      this.bool = !~flags.indexOf('-no-');
      flags = flags.split(/[ ,|]+/);
      if (flags.length > 1 && !/^[[<]/.test(flags[1])) this.short = flags.shift();
      this.long = flags.shift();
      this.description = description || '';
    }
    
    /**
     * Return option name.
     *
     * @return {String}
     * @api private
     */
    
    Option.prototype.name = function() {
      return this.long
        .replace('--', '')
        .replace('no-', '');
    };
    
    /**
     * Check if `arg` matches the short or long flag.
     *
     * @param {String} arg
     * @return {Boolean}
     * @api private
     */
    
    Option.prototype.is = function(arg) {
      return arg == this.short || arg == this.long;
    };
    
    /**
     * Initialize a new `Command`.
     *
     * @param {String} name
     * @api public
     */
    
    function Command(name) {
      this.commands = [];
      this.options = [];
      this._execs = [];
      this._allowUnknownOption = false;
      this._args = [];
      this._name = name;
    }
    
    /**
     * Inherit from `EventEmitter.prototype`.
     */
    
    Command.prototype.__proto__ = EventEmitter.prototype;
    
    /**
     * Add command `name`.
     *
     * The `.action()` callback is invoked when the
     * command `name` is specified via __ARGV__,
     * and the remaining arguments are applied to the
     * function for access.
     *
     * When the `name` is "*" an un-matched command
     * will be passed as the first arg, followed by
     * the rest of __ARGV__ remaining.
     *
     * Examples:
     *
     *      program
     *        .version('0.0.1')
     *        .option('-C, --chdir <path>', 'change the working directory')
     *        .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf')
     *        .option('-T, --no-tests', 'ignore test hook')
     *
     *      program
     *        .command('setup')
     *        .description('run remote setup commands')
     *        .action(function() {
     *          console.log('setup');
     *        });
     *
     *      program
     *        .command('exec <cmd>')
     *        .description('run the given remote command')
     *        .action(function(cmd) {
     *          console.log('exec "%s"', cmd);
     *        });
     *
     *      program
     *        .command('teardown <dir> [otherDirs...]')
     *        .description('run teardown commands')
     *        .action(function(dir, otherDirs) {
     *          console.log('dir "%s"', dir);
     *          if (otherDirs) {
     *            otherDirs.forEach(function (oDir) {
     *              console.log('dir "%s"', oDir);
     *            });
     *          }
     *        });
     *
     *      program
     *        .command('*')
     *        .description('deploy the given env')
     *        .action(function(env) {
     *          console.log('deploying "%s"', env);
     *        });
     *
     *      program.parse(process.argv);
      *
     * @param {String} name
     * @param {String} [desc] for git-style sub-commands
     * @return {Command} the new command
     * @api public
     */
    
    Command.prototype.command = function(name, desc, opts) {
      opts = opts || {};
      var args = name.split(/ +/);
      var cmd = new Command(args.shift());
    
      if (desc) {
        cmd.description(desc);
        this.executables = true;
        this._execs[cmd._name] = true;
      }
    
      cmd._noHelp = !!opts.noHelp;
      this.commands.push(cmd);
      cmd.parseExpectedArgs(args);
      cmd.parent = this;
    
      if (desc) return this;
      return cmd;
    };
    
    /**
     * Define argument syntax for the top-level command.
     *
     * @api public
     */
    
    Command.prototype.arguments = function (desc) {
      return this.parseExpectedArgs(desc.split(/ +/));
    }
    
    /**
     * Add an implicit `help [cmd]` subcommand
     * which invokes `--help` for the given command.
     *
     * @api private
     */
    
    Command.prototype.addImplicitHelpCommand = function() {
      this.command('help [cmd]', 'display help for [cmd]');
    };
    
    /**
     * Parse expected `args`.
     *
     * For example `["[type]"]` becomes `[{ required: false, name: 'type' }]`.
     *
     * @param {Array} args
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.parseExpectedArgs = function(args) {
      if (!args.length) return;
      var self = this;
      args.forEach(function(arg) {
        var argDetails = {
          required: false,
          name: '',
          variadic: false
        };
    
        switch (arg[0]) {
          case '<':
            argDetails.required = true;
            argDetails.name = arg.slice(1, -1);
            break;
          case '[':
            argDetails.name = arg.slice(1, -1);
            break;
        }
    
        if (argDetails.name.length > 3 && argDetails.name.slice(-3) === '...') {
          argDetails.variadic = true;
          argDetails.name = argDetails.name.slice(0, -3);
        }
        if (argDetails.name) {
          self._args.push(argDetails);
        }
      });
      return this;
    };
    
    /**
     * Register callback `fn` for the command.
     *
     * Examples:
     *
     *      program
     *        .command('help')
     *        .description('display verbose help')
     *        .action(function() {
     *           // output help here
     *        });
     *
     * @param {Function} fn
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.action = function(fn) {
      var self = this;
      var listener = function(args, unknown) {
        // Parse any so-far unknown options
        args = args || [];
        unknown = unknown || [];
    
        var parsed = self.parseOptions(unknown);
    
        // Output help if necessary
        outputHelpIfNecessary(self, parsed.unknown);
    
        // If there are still any unknown options, then we simply
        // die, unless someone asked for help, in which case we give it
        // to them, and then we die.
        if (parsed.unknown.length > 0) {
          self.unknownOption(parsed.unknown[0]);
        }
    
        // Leftover arguments need to be pushed back. Fixes issue #56
        if (parsed.args.length) args = parsed.args.concat(args);
    
        self._args.forEach(function(arg, i) {
          if (arg.required && null == args[i]) {
            self.missingArgument(arg.name);
          } else if (arg.variadic) {
            if (i !== self._args.length - 1) {
              self.variadicArgNotLast(arg.name);
            }
    
            args[i] = args.splice(i);
          }
        });
    
        // Always append ourselves to the end of the arguments,
        // to make sure we match the number of arguments the user
        // expects
        if (self._args.length) {
          args[self._args.length] = self;
        } else {
          args.push(self);
        }
    
        fn.apply(self, args);
      };
      var parent = this.parent || this;
      var name = parent === this ? '*' : this._name;
      parent.on(name, listener);
      if (this._alias) parent.on(this._alias, listener);
      return this;
    };
    
    /**
     * Define option with `flags`, `description` and optional
     * coercion `fn`.
     *
     * The `flags` string should contain both the short and long flags,
     * separated by comma, a pipe or space. The following are all valid
     * all will output this way when `--help` is used.
     *
     *    "-p, --pepper"
     *    "-p|--pepper"
     *    "-p --pepper"
     *
     * Examples:
     *
     *     // simple boolean defaulting to false
     *     program.option('-p, --pepper', 'add pepper');
     *
     *     --pepper
     *     program.pepper
     *     // => Boolean
     *
     *     // simple boolean defaulting to true
     *     program.option('-C, --no-cheese', 'remove cheese');
     *
     *     program.cheese
     *     // => true
     *
     *     --no-cheese
     *     program.cheese
     *     // => false
     *
     *     // required argument
     *     program.option('-C, --chdir <path>', 'change the working directory');
     *
     *     --chdir /tmp
     *     program.chdir
     *     // => "/tmp"
     *
     *     // optional argument
     *     program.option('-c, --cheese [type]', 'add cheese [marble]');
     *
     * @param {String} flags
     * @param {String} description
     * @param {Function|Mixed} fn or default
     * @param {Mixed} defaultValue
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.option = function(flags, description, fn, defaultValue) {
      var self = this
        , option = new Option(flags, description)
        , oname = option.name()
        , name = camelcase(oname);
    
      // default as 3rd arg
      if (typeof fn != 'function') {
        if (fn instanceof RegExp) {
          var regex = fn;
          fn = function(val, def) {
            var m = regex.exec(val);
            return m ? m[0] : def;
          }
        }
        else {
          defaultValue = fn;
          fn = null;
        }
      }
    
      // preassign default value only for --no-*, [optional], or <required>
      if (false == option.bool || option.optional || option.required) {
        // when --no-* we make sure default is true
        if (false == option.bool) defaultValue = true;
        // preassign only if we have a default
        if (undefined !== defaultValue) self[name] = defaultValue;
      }
    
      // register the option
      this.options.push(option);
    
      // when it's passed assign the value
      // and conditionally invoke the callback
      this.on(oname, function(val) {
        // coercion
        if (null !== val && fn) val = fn(val, undefined === self[name]
          ? defaultValue
          : self[name]);
    
        // unassigned or bool
        if ('boolean' == typeof self[name] || 'undefined' == typeof self[name]) {
          // if no value, bool true, and we have a default, then use it!
          if (null == val) {
            self[name] = option.bool
              ? defaultValue || true
              : false;
          } else {
            self[name] = val;
          }
        } else if (null !== val) {
          // reassign
          self[name] = val;
        }
      });
    
      return this;
    };
    
    /**
     * Allow unknown options on the command line.
     *
     * @param {Boolean} arg if `true` or omitted, no error will be thrown
     * for unknown options.
     * @api public
     */
    Command.prototype.allowUnknownOption = function(arg) {
        this._allowUnknownOption = arguments.length === 0 || arg;
        return this;
    };
    
    /**
     * Parse `argv`, settings options and invoking commands when defined.
     *
     * @param {Array} argv
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.parse = function(argv) {
      // implicit help
      if (this.executables) this.addImplicitHelpCommand();
    
      // store raw args
      this.rawArgs = argv;
    
      // guess name
      this._name = this._name || basename(argv[1], '.js');
    
      // github-style sub-commands with no sub-command
      if (this.executables && argv.length < 3) {
        // this user needs help
        argv.push('--help');
      }
    
      // process argv
      var parsed = this.parseOptions(this.normalize(argv.slice(2)));
      var args = this.args = parsed.args;
    
      var result = this.parseArgs(this.args, parsed.unknown);
    
      // executable sub-commands
      var name = result.args[0];
      if (this._execs[name] && typeof this._execs[name] != "function") {
        return this.executeSubCommand(argv, args, parsed.unknown);
      }
    
      return result;
    };
    
    /**
     * Execute a sub-command executable.
     *
     * @param {Array} argv
     * @param {Array} args
     * @param {Array} unknown
     * @api private
     */
    
    Command.prototype.executeSubCommand = function(argv, args, unknown) {
      args = args.concat(unknown);
    
      if (!args.length) this.help();
      if ('help' == args[0] && 1 == args.length) this.help();
    
      // <cmd> --help
      if ('help' == args[0]) {
        args[0] = args[1];
        args[1] = '--help';
      }
    
      // executable
      var f = argv[1];
      // name of the subcommand, link `pm-install`
      var bin = basename(f, '.js') + '-' + args[0];
    
    
      // In case of globally installed, get the base dir where executable
      //  subcommand file should be located at
      var baseDir
        , link = readlink(f);
    
      // when symbolink is relative path
      if (link !== f && link.charAt(0) !== '/') {
        link = path.join(dirname(f), link)
      }
      baseDir = dirname(link);
    
      // prefer local `./<bin>` to bin in the $PATH
      var localBin = path.join(baseDir, bin);
    
      // whether bin file is a js script with explicit `.js` extension
      var isExplicitJS = false;
      if (exists(localBin + '.js')) {
        bin = localBin + '.js';
        isExplicitJS = true;
      } else if (exists(localBin)) {
        bin = localBin;
      }
    
      args = args.slice(1);
    
      var proc;
      if (process.platform !== 'win32') {
        if (isExplicitJS) {
          args.unshift(localBin);
          // add executable arguments to spawn
          args = (process.execArgv || []).concat(args);
    
          proc = spawn('node', args, { stdio: 'inherit', customFds: [0, 1, 2] });
        } else {
          proc = spawn(bin, args, { stdio: 'inherit', customFds: [0, 1, 2] });
        }
      } else {
        args.unshift(localBin);
        proc = spawn(process.execPath, args, { stdio: 'inherit'});
      }
    
      proc.on('close', process.exit.bind(process));
      proc.on('error', function(err) {
        if (err.code == "ENOENT") {
          console.error('\n  %s(1) does not exist, try --help\n', bin);
        } else if (err.code == "EACCES") {
          console.error('\n  %s(1) not executable. try chmod or run with root\n', bin);
        }
        process.exit(1);
      });
    
      this.runningCommand = proc;
    };
    
    /**
     * Normalize `args`, splitting joined short flags. For example
     * the arg "-abc" is equivalent to "-a -b -c".
     * This also normalizes equal sign and splits "--abc=def" into "--abc def".
     *
     * @param {Array} args
     * @return {Array}
     * @api private
     */
    
    Command.prototype.normalize = function(args) {
      var ret = []
        , arg
        , lastOpt
        , index;
    
      for (var i = 0, len = args.length; i < len; ++i) {
        arg = args[i];
        if (i > 0) {
          lastOpt = this.optionFor(args[i-1]);
        }
    
        if (arg === '--') {
          // Honor option terminator
          ret = ret.concat(args.slice(i));
          break;
        } else if (lastOpt && lastOpt.required) {
          ret.push(arg);
        } else if (arg.length > 1 && '-' == arg[0] && '-' != arg[1]) {
          arg.slice(1).split('').forEach(function(c) {
            ret.push('-' + c);
          });
        } else if (/^--/.test(arg) && ~(index = arg.indexOf('='))) {
          ret.push(arg.slice(0, index), arg.slice(index + 1));
        } else {
          ret.push(arg);
        }
      }
    
      return ret;
    };
    
    /**
     * Parse command `args`.
     *
     * When listener(s) are available those
     * callbacks are invoked, otherwise the "*"
     * event is emitted and those actions are invoked.
     *
     * @param {Array} args
     * @return {Command} for chaining
     * @api private
     */
    
    Command.prototype.parseArgs = function(args, unknown) {
      var name;
    
      if (args.length) {
        name = args[0];
        if (this.listeners(name).length) {
          this.emit(args.shift(), args, unknown);
        } else {
          this.emit('*', args);
        }
      } else {
        outputHelpIfNecessary(this, unknown);
    
        // If there were no args and we have unknown options,
        // then they are extraneous and we need to error.
        if (unknown.length > 0) {
          this.unknownOption(unknown[0]);
        }
      }
    
      return this;
    };
    
    /**
     * Return an option matching `arg` if any.
     *
     * @param {String} arg
     * @return {Option}
     * @api private
     */
    
    Command.prototype.optionFor = function(arg) {
      for (var i = 0, len = this.options.length; i < len; ++i) {
        if (this.options[i].is(arg)) {
          return this.options[i];
        }
      }
    };
    
    /**
     * Parse options from `argv` returning `argv`
     * void of these options.
     *
     * @param {Array} argv
     * @return {Array}
     * @api public
     */
    
    Command.prototype.parseOptions = function(argv) {
      var args = []
        , len = argv.length
        , literal
        , option
        , arg;
    
      var unknownOptions = [];
    
      // parse options
      for (var i = 0; i < len; ++i) {
        arg = argv[i];
    
        // literal args after --
        if ('--' == arg) {
          literal = true;
          continue;
        }
    
        if (literal) {
          args.push(arg);
          continue;
        }
    
        // find matching Option
        option = this.optionFor(arg);
    
        // option is defined
        if (option) {
          // requires arg
          if (option.required) {
            arg = argv[++i];
            if (null == arg) return this.optionMissingArgument(option);
            this.emit(option.name(), arg);
          // optional arg
          } else if (option.optional) {
            arg = argv[i+1];
            if (null == arg || ('-' == arg[0] && '-' != arg)) {
              arg = null;
            } else {
              ++i;
            }
            this.emit(option.name(), arg);
          // bool
          } else {
            this.emit(option.name());
          }
          continue;
        }
    
        // looks like an option
        if (arg.length > 1 && '-' == arg[0]) {
          unknownOptions.push(arg);
    
          // If the next argument looks like it might be
          // an argument for this option, we pass it on.
          // If it isn't, then it'll simply be ignored
          if (argv[i+1] && '-' != argv[i+1][0]) {
            unknownOptions.push(argv[++i]);
          }
          continue;
        }
    
        // arg
        args.push(arg);
      }
    
      return { args: args, unknown: unknownOptions };
    };
    
    /**
     * Return an object containing options as key-value pairs
     *
     * @return {Object}
     * @api public
     */
    Command.prototype.opts = function() {
      var result = {}
        , len = this.options.length;
    
      for (var i = 0 ; i < len; i++) {
        var key = camelcase(this.options[i].name());
        result[key] = key === 'version' ? this._version : this[key];
      }
      return result;
    };
    
    /**
     * Argument `name` is missing.
     *
     * @param {String} name
     * @api private
     */
    
    Command.prototype.missingArgument = function(name) {
      console.error();
      console.error("  error: missing required argument `%s'", name);
      console.error();
      process.exit(1);
    };
    
    /**
     * `Option` is missing an argument, but received `flag` or nothing.
     *
     * @param {String} option
     * @param {String} flag
     * @api private
     */
    
    Command.prototype.optionMissingArgument = function(option, flag) {
      console.error();
      if (flag) {
        console.error("  error: option `%s' argument missing, got `%s'", option.flags, flag);
      } else {
        console.error("  error: option `%s' argument missing", option.flags);
      }
      console.error();
      process.exit(1);
    };
    
    /**
     * Unknown option `flag`.
     *
     * @param {String} flag
     * @api private
     */
    
    Command.prototype.unknownOption = function(flag) {
      if (this._allowUnknownOption) return;
      console.error();
      console.error("  error: unknown option `%s'", flag);
      console.error();
      process.exit(1);
    };
    
    /**
     * Variadic argument with `name` is not the last argument as required.
     *
     * @param {String} name
     * @api private
     */
    
    Command.prototype.variadicArgNotLast = function(name) {
      console.error();
      console.error("  error: variadic arguments must be last `%s'", name);
      console.error();
      process.exit(1);
    };
    
    /**
     * Set the program version to `str`.
     *
     * This method auto-registers the "-V, --version" flag
     * which will print the version number when passed.
     *
     * @param {String} str
     * @param {String} flags
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.version = function(str, flags) {
      if (0 == arguments.length) return this._version;
      this._version = str;
      flags = flags || '-V, --version';
      this.option(flags, 'output the version number');
      this.on('version', function() {
        process.stdout.write(str + '\n');
        process.exit(0);
      });
      return this;
    };
    
    /**
     * Set the description to `str`.
     *
     * @param {String} str
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.description = function(str) {
      if (0 == arguments.length) return this._description;
      this._description = str;
      return this;
    };
    
    /**
     * Set an alias for the command
     *
     * @param {String} alias
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.alias = function(alias) {
      if (0 == arguments.length) return this._alias;
      this._alias = alias;
      return this;
    };
    
    /**
     * Set / get the command usage `str`.
     *
     * @param {String} str
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.usage = function(str) {
      var args = this._args.map(function(arg) {
        return humanReadableArgName(arg);
      });
    
      var usage = '[options]'
        + (this.commands.length ? ' [command]' : '')
        + (this._args.length ? ' ' + args.join(' ') : '');
    
      if (0 == arguments.length) return this._usage || usage;
      this._usage = str;
    
      return this;
    };
    
    /**
     * Get the name of the command
     *
     * @param {String} name
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.name = function() {
      return this._name;
    };
    
    /**
     * Return the largest option length.
     *
     * @return {Number}
     * @api private
     */
    
    Command.prototype.largestOptionLength = function() {
      return this.options.reduce(function(max, option) {
        return Math.max(max, option.flags.length);
      }, 0);
    };
    
    /**
     * Return help for options.
     *
     * @return {String}
     * @api private
     */
    
    Command.prototype.optionHelp = function() {
      var width = this.largestOptionLength();
    
      // Prepend the help information
      return [pad('-h, --help', width) + '  ' + 'output usage information']
        .concat(this.options.map(function(option) {
          return pad(option.flags, width) + '  ' + option.description;
          }))
        .join('\n');
    };
    
    /**
     * Return command help documentation.
     *
     * @return {String}
     * @api private
     */
    
    Command.prototype.commandHelp = function() {
      if (!this.commands.length) return '';
    
      var commands = this.commands.filter(function(cmd) {
        return !cmd._noHelp;
      }).map(function(cmd) {
        var args = cmd._args.map(function(arg) {
          return humanReadableArgName(arg);
        }).join(' ');
    
        return [
          cmd._name
            + (cmd._alias
              ? '|' + cmd._alias
              : '')
            + (cmd.options.length
              ? ' [options]'
              : '')
            + ' ' + args
        , cmd.description()
        ];
      });
    
      var width = commands.reduce(function(max, command) {
        return Math.max(max, command[0].length);
      }, 0);
    
      return [
          ''
        , '  Commands:'
        , ''
        , commands.map(function(cmd) {
          return pad(cmd[0], width) + '  ' + cmd[1];
        }).join('\n').replace(/^/gm, '    ')
        , ''
      ].join('\n');
    };
    
    /**
     * Return program help documentation.
     *
     * @return {String}
     * @api private
     */
    
    Command.prototype.helpInformation = function() {
      var desc = [];
      if (this._description) {
        desc = [
          '  ' + this._description
          , ''
        ];
      }
    
      var cmdName = this._name;
      if (this._alias) {
        cmdName = cmdName + '|' + this._alias;
      }
      var usage = [
        ''
        ,'  Usage: ' + cmdName + ' ' + this.usage()
        , ''
      ];
    
      var cmds = [];
      var commandHelp = this.commandHelp();
      if (commandHelp) cmds = [commandHelp];
    
      var options = [
        '  Options:'
        , ''
        , '' + this.optionHelp().replace(/^/gm, '    ')
        , ''
        , ''
      ];
    
      return usage
        .concat(cmds)
        .concat(desc)
        .concat(options)
        .join('\n');
    };
    
    /**
     * Output help information for this command
     *
     * @api public
     */
    
    Command.prototype.outputHelp = function() {
      process.stdout.write(this.helpInformation());
      this.emit('--help');
    };
    
    /**
     * Output help information and exit.
     *
     * @api public
     */
    
    Command.prototype.help = function() {
      this.outputHelp();
      process.exit();
    };
    
    /**
     * Camel-case the given `flag`
     *
     * @param {String} flag
     * @return {String}
     * @api private
     */
    
    function camelcase(flag) {
      return flag.split('-').reduce(function(str, word) {
        return str + word[0].toUpperCase() + word.slice(1);
      });
    }
    
    /**
     * Pad `str` to `width`.
     *
     * @param {String} str
     * @param {Number} width
     * @return {String}
     * @api private
     */
    
    function pad(str, width) {
      var len = Math.max(0, width - str.length);
      return str + Array(len + 1).join(' ');
    }
    
    /**
     * Output help information if necessary
     *
     * @param {Command} command to output help for
     * @param {Array} array of options to search for -h or --help
     * @api private
     */
    
    function outputHelpIfNecessary(cmd, options) {
      options = options || [];
      for (var i = 0; i < options.length; i++) {
        if (options[i] == '--help' || options[i] == '-h') {
          cmd.outputHelp();
          process.exit(0);
        }
      }
    }
    
    /**
     * Takes an argument an returns its human readable equivalent for help usage.
     *
     * @param {Object} arg
     * @return {String}
     * @api private
     */
    
    function humanReadableArgName(arg) {
      var nameOutput = arg.name + (arg.variadic === true ? '...' : '');
    
      return arg.required
        ? '<' + nameOutput + '>'
        : '[' + nameOutput + ']'
    }
    
    // for versions before node v0.8 when there weren't `fs.existsSync`
    function exists(file) {
      try {
        if (fs.statSync(file).isFile()) {
          return true;
        }
      } catch (e) {
        return false;
      }
    }
    
    
  provide("commander", module.exports);
}(global));

// pakmanager:constantinople
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    var detect = require('acorn-globals');
    
    var lastSRC = '(null)';
    var lastRes = true;
    var lastConstants = undefined;
    
    module.exports = isConstant;
    function isConstant(src, constants) {
      src = '(' + src + ')';
      if (lastSRC === src && lastConstants === constants) return lastRes;
      lastSRC = src;
      lastConstants = constants;
      try {
        isExpression(src);
        return lastRes = (detect(src).filter(function (key) {
          return !constants || !(key.name in constants);
        }).length === 0);
      } catch (ex) {
        return lastRes = false;
      }
    }
    isConstant.isConstant = isConstant;
    
    isConstant.toConstant = toConstant;
    function toConstant(src, constants) {
      if (!isConstant(src, constants)) throw new Error(JSON.stringify(src) + ' is not constant.');
      return Function(Object.keys(constants || {}).join(','), 'return (' + src + ')').apply(null, Object.keys(constants || {}).map(function (key) {
        return constants[key];
      }));
    }
    
    function isExpression(src) {
      try {
        eval('throw "STOP"; (function () { return (' + src + '); })()');
        return false;
      }
      catch (err) {
        return err === 'STOP';
      }
    }
    
  provide("constantinople", module.exports);
}(global));

// pakmanager:mkdirp
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var path = require('path');
    var fs = require('fs');
    var _0777 = parseInt('0777', 8);
    
    module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
    
    function mkdirP (p, opts, f, made) {
        if (typeof opts === 'function') {
            f = opts;
            opts = {};
        }
        else if (!opts || typeof opts !== 'object') {
            opts = { mode: opts };
        }
        
        var mode = opts.mode;
        var xfs = opts.fs || fs;
        
        if (mode === undefined) {
            mode = _0777 & (~process.umask());
        }
        if (!made) made = null;
        
        var cb = f || function () {};
        p = path.resolve(p);
        
        xfs.mkdir(p, mode, function (er) {
            if (!er) {
                made = made || p;
                return cb(null, made);
            }
            switch (er.code) {
                case 'ENOENT':
                    mkdirP(path.dirname(p), opts, function (er, made) {
                        if (er) cb(er, made);
                        else mkdirP(p, opts, cb, made);
                    });
                    break;
    
                // In the case of any other error, just see if there's a dir
                // there already.  If so, then hooray!  If not, then something
                // is borked.
                default:
                    xfs.stat(p, function (er2, stat) {
                        // if the stat fails, then that's super weird.
                        // let the original error be the failure reason.
                        if (er2 || !stat.isDirectory()) cb(er, made)
                        else cb(null, made);
                    });
                    break;
            }
        });
    }
    
    mkdirP.sync = function sync (p, opts, made) {
        if (!opts || typeof opts !== 'object') {
            opts = { mode: opts };
        }
        
        var mode = opts.mode;
        var xfs = opts.fs || fs;
        
        if (mode === undefined) {
            mode = _0777 & (~process.umask());
        }
        if (!made) made = null;
    
        p = path.resolve(p);
    
        try {
            xfs.mkdirSync(p, mode);
            made = made || p;
        }
        catch (err0) {
            switch (err0.code) {
                case 'ENOENT' :
                    made = sync(path.dirname(p), opts, made);
                    sync(p, opts, made);
                    break;
    
                // In the case of any other error, just see if there's a dir
                // there already.  If so, then hooray!  If not, then something
                // is borked.
                default:
                    var stat;
                    try {
                        stat = xfs.statSync(p);
                    }
                    catch (err1) {
                        throw err0;
                    }
                    if (!stat.isDirectory()) throw err0;
                    break;
            }
        }
    
        return made;
    };
    
  provide("mkdirp", module.exports);
}(global));

// pakmanager:transformers/lib/shared
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var fs = require('fs');
    var path = require('path');
    var normalize = path.normalize;
    var Promise = require('promise');
    var clone = require('clone');
    
    var minifiers = {};
    
    module.exports = Transformer;
    function Transformer(obj) {
      this.name = obj.name;
      this.engines = obj.engines;
      this.isBinary = obj.isBinary || false;
      this.isMinifier = obj.isMinifier || false;
      this.outputFormat = obj.outputFormat;
      this._cache = {};
      if (typeof obj.async === 'function') {
        this._renderAsync = obj.async;
        this.sudoSync = obj.sudoSync || false;
      }
      if (typeof obj.sync === 'function') {
        this._renderSync = obj.sync;
        this.sync = true;
      } else {
        this.sync = obj.sudoSync || false;
      }
    
      if (this.isMinifier)
        minifiers[this.outputFormat] = this;
      else {
        var minifier = minifiers[this.outputFormat];
        if (minifier) {
          this.minify = function(str, options) {
            if (options && options.minify)
              return minifier.renderSync(str, typeof options.minify === 'object' && options.minify || {});
            return str;
          };
        }
      }
    }
    
    Transformer.prototype.cache = function (options, data) {
      if (options.cache && options.filename) {
        if (data) return this.cache[options.filename] = data;
        else return this.cache[options.filename];
      } else {
        return data;
      }
    };
    Transformer.prototype.loadModule = function () {
      if (this.engine) return this.engine;
      for (var i = 0; i < this.engines.length; i++) {
        try {
          var res = this.engines[i] === '.' ? null : (this.engine = require(this.engines[i]));
          this.engineName = this.engines[i];
          return res;
        } catch (ex) {
          if (this.engines.length === 1) {
            throw ex;
          }
        }
      }
      throw new Error('In order to apply the transform ' + this.name + ' you must install one of ' + this.engines.map(function (e) { return '"' + e + '"'; }).join());
    };
    Transformer.prototype.minify = function(str, options) {
      return str;
    };
    Transformer.prototype.renderSync = function (str, options) {
      options = options || {};
      options = clone(options);
      this.loadModule();
      if (this._renderSync) {
        return this.minify(this._renderSync((this.isBinary ? str : fixString(str)), options), options);
      } else if (this.sudoSync) {
        options.sudoSync = true;
        var res, err;
        this._renderAsync((this.isBinary ? str : fixString(str)), options, function (e, val) {
          if (e) err = e;
          else res = val;
        });
        if (err) throw err;
        else if (res !== undefined) return this.minify(res, options);
        else if (typeof this.sudoSync === 'string') throw new Error(this.sudoSync.replace(/FILENAME/g, options.filename || ''));
        else throw new Error('There was a problem transforming ' + (options.filename || '') + ' synchronously using ' + this.name);
      } else {
        throw new Error(this.name + ' does not support transforming synchronously.');
      }
    };
    Transformer.prototype.render = function (str, options, cb) {
      options = options || {};
      var self = this;
      return new Promise(function (resolve, reject) {
        self.loadModule();
        if (self._renderAsync) {
          self._renderAsync((self.isBinary ? str : fixString(str)), clone(options), function (err, val) {
            if (err) reject(err);
            else resolve(self.minify(val, options));
          });
        } else {
          resolve(self.renderSync(str, options));
        }
      })
      .nodeify(cb);
    };
    Transformer.prototype.renderFile = function (path, options, cb) {
      options = options || {};
      var self = this;
      return new Promise(function (resolve, reject) {
        options.filename = (path = normalize(path));
        if (self._cache[path])
          resolve(null);
        else
          fs.readFile(path, function (err, data) {
            if (err) reject(err);
            else resolve(data);
          });
      })
      .then(function (str) {
        return self.render(str, options);
      })
      .nodeify(cb);
    };
    Transformer.prototype.renderFileSync = function (path, options) {
      options = options || {};
      options.filename = (path = normalize(path));
      return this.renderSync((this._cache[path] ? null : fs.readFileSync(path)), options);
    };
    function fixString(str) {
      if (str === null) return str;
      //convert buffer to string
      str = str.toString();
      // Strip UTF-8 BOM if it exists
      str = (0xFEFF === str.charCodeAt(0) ? str.substring(1) : str);
      //remove `\r` added by windows
      return str.replace(/\r/g, '');
    }
    
  provide("transformers/lib/shared", module.exports);
}(global));

// pakmanager:transformers
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var dirname = require('path').dirname;
    var clone = require('clone');
    var Transformer =  require('transformers/lib/shared');
    
    /**
     * minifiers must be first in order to be incorporated inside instances of
     * respective output formats
     */
    
    var uglifyJS = require('uglify-js');
    exports.uglify = exports.uglifyJS = exports['uglify-js'] = new Transformer({
      name: 'uglify-js',
      engines: ['.'],
      outputFormat: 'js',
      isMinifier: true,
      sync: function (str, options) {
        options.fromString = true;
        return this.cache(options) || this.cache(options, uglifyJS.minify(str, options).code);
      }
    });
    
    var uglifyCSS = require('css');
    exports.uglifyCSS = exports['uglify-css'] = new Transformer({
      name: 'uglify-css',
      engines: ['.'],
      outputFormat: 'css',
      isMinifier: true,
      sync: function (str, options) {
        options.compress = options.compress !== false && options.beautify !== true;
        return this.cache(options) || this.cache(options, uglifyCSS.stringify(uglifyCSS.parse(str), options));
      }
    });
    
    exports.uglifyJSON = exports['uglify-json'] = new Transformer({
      name: 'uglify-json',
      engines: ['.'],
      outputFormat: 'json',
      isMinifier: true,
      sync: function (str, options) {
        return JSON.stringify(JSON.parse(str), null, options.beautify);
      }
    });
    
    /**
     * Synchronous Templating Languages
     */
    
    function sync(str, options) {
      var tmpl = this.cache(options) || this.cache(options, this.engine.compile(str, options));
      return tmpl(options);
    }
    
    exports.live = exports.LiveScript = exports.ls = exports.livescript = new Transformer({
      name: 'LiveScript',
      engines: ['LiveScript'],
      outputFormat: 'js',
      sync: function (str, options) {
        return this.cache(options) || this.cache(options, this.engine.compile(str, options));
      }
    });
    
    exports.swig = new Transformer({
      name: 'swig',
      engines: ['swig'],
      outputFormat: 'xml',
      sync: sync
    });
    
    exports.atpl = new Transformer({
      name: 'atpl',
      engines: ['atpl'],
      outputFormat: 'xml',
      sync: function sync(str, options) {
        var tmpl = this.cache(options);
        if (!tmpl) {
          var cInfo = {cache: options.cache, filename: options.filename};
          if (options.filename) {
            delete options.filename; //atpl can't handle absolute windows file paths properly
          }
          tmpl = this.cache(cInfo, this.engine.compile(str, options));
        }
        return tmpl(options);
      }
    });
    
    exports.dot = new Transformer({
      name: 'dot',
      engines: ['dot'],
      outputFormat: 'xml',
      sync: function sync(str, options) {
        var tmpl = this.cache(options) || this.cache(options, this.engine.template(str));
        return tmpl(options);
      }
    });
    
    exports.liquor = new Transformer({
      name: 'liquor',
      engines: ['liquor'],
      outputFormat: 'xml',
      sync: sync
    });
    
    exports.ejs = new Transformer({
      name: 'ejs',
      engines: ['ejs'],
      outputFormat: 'xml',
      sync: sync
    });
    
    exports.eco = new Transformer({
      name: 'eco',
      engines: ['eco'],
      outputFormat: 'xml',
      sync: sync//N.B. eco's internal this.cache isn't quite right but this bypasses it
    });
    
    exports.jqtpl = new Transformer({
      name: 'jqtpl',
      engines: ['jqtpl'],
      outputFormat: 'xml',
      sync: function (str, options) {
        var engine = this.engine;
        var key = (options.cache && options.filename) ? options.filename : '@';
        engine.compile(str, key);
        var res = this.engine.render(key, options);
        if (!(options.cache && options.filename)) {
          delete engine.cache[key];
        }
        this.cache(options, true); // caching handled internally
        return res;
      }
    });
    
    exports.haml = new Transformer({
      name: 'haml',
      engines: ['hamljs'],
      outputFormat: 'xml',
      sync: sync
    });
    
    exports['haml-coffee'] = new Transformer({
      name: 'haml-coffee',
      engines: ['haml-coffee'],
      outputFormat: 'xml',
      sync: function (str, options) {
        // https://github.com/netzpirat/haml-coffee/issues/91
        if (global.CoffeeScript) delete global.CoffeeScript; //prevent global leak
        var tmpl = this.cache(options) || this.cache(options, this.engine.compile(str, options));
        return tmpl(options);
      }
    });
    
    exports.whiskers = new Transformer({
      name: 'whiskers',
      engines: ['whiskers'],
      outputFormat: 'xml',
      sync: sync
    });
    
    exports.hogan = new Transformer({
      name: 'hogan',
      engines: ['hogan.js'],
      outputFormat: 'xml',
      sync: function(str, options){
        var tmpl = this.cache(options) || this.cache(options, this.engine.compile(str, options));
        return tmpl.render(options, options.partials);
      }
    });
    
    exports.handlebars = new Transformer({
      name: 'handlebars',
      engines: ['handlebars'],
      outputFormat: 'xml',
      sync: function(str, options){
        for (var partial in options.partials) {
          this.engine.registerPartial(partial, options.partials[partial]);
        }
        for (var helper in options.helpers) {
          this.engine.registerHelper(helper, options.helpers[helper]);
        }
        var tmpl = this.cache(options) || this.cache(options, this.engine.compile(str, options));
        return tmpl(options);
      }
    });
    
    exports.underscore = new Transformer({
      name: 'underscore',
      engines: ['underscore'],
      outputFormat: 'xml',
      sync: function(str, options){
        var tmpl = this.cache(options) || this.cache(options, this.engine.template(str));
        return tmpl(options);
      }
    });
    
    exports.walrus = new Transformer({
      name: 'walrus',
      engines: ['walrus'],
      outputFormat: 'xml',
      sync: function(str, options){
        var tmpl = this.cache(options) || this.cache(options, this.engine.parse(str));
        return tmpl.compile(options);
      }
    });
    
    exports.mustache = new Transformer({
      name: 'mustache',
      engines: ['mustache'],
      outputFormat: 'xml',
      sync: function(str, options){
        str = this.cache(options) || this.cache(options, str);
        return this.engine.to_html(str, options, options.partials);
      }
    });
    
    exports.templayed = new Transformer({
      name: 'templayed',
      engines: ['templayed'],
      outputFormat: 'xml',
      sync: function(str, options){
        var tmpl = this.cache(options) || this.cache(options, this.engine(str));
        return tmpl(options);
      }
    });
    
    exports.plates = new Transformer({
      name: 'plates',
      engines: ['plates'],
      outputFormat: 'xml',
      sync: function(str, options){
        str = this.cache(options) || this.cache(options, str);
        return this.engine.bind(str, options, options.map);
      }
    });
    
    exports.mote = new Transformer({
      name: 'mote',
      engines: ['mote'],
      outputFormat: 'xml',
      sync: sync
    });
    
    exports.toffee = new Transformer({
      name: 'toffee',
      engines: ['toffee'],
      outputFormat: 'xml',
      sync: function (str, options) {
        var View = this.engine.view;
        var v = this.cache(options) || this.cache(options, new View(str, options));
        var res = v.run(options, require('vm').createContext({}));
        if (res[0]) throw res[0];
        else return res[1];
      }
    });
    
    exports.coffeekup = exports.coffeecup = new Transformer({
      name: 'coffeecup',
      engines: ['coffeecup', 'coffeekup'],
      outputFormat: 'xml',
      sync: function (str, options) {
        var compiled = this.cache(options) || this.cache(options, this.engine.compile(str, options));
        return compiled(options);
      }
    });
    
    /**
     * Asynchronous Templating Languages
     */
    
    exports.just = new Transformer({
      name: 'just',
      engines: ['just'],
      outputFormat: 'xml',
      sudoSync: true,
      async: function (str, options, cb) {
        var JUST = this.engine;
        var tmpl = this.cache(options) || this.cache(options, new JUST({ root: { page: str }}));
        tmpl.render('page', options, cb);
      }
    });
    
    exports.ect = new Transformer({
      name: 'ect',
      engines: ['ect'],
      outputFormat: 'xml',
      sudoSync: true, // Always runs synchronously
      async: function (str, options, cb) {
        var ECT = this.engine;
        var tmpl = this.cache(options) || this.cache(options, new ECT({ root: { page: str }}));
        tmpl.render('page', options, cb);
      }
    });
    
    exports.jade = new Transformer({
      name: 'jade',
      engines: ['jade', 'then-jade'],
      outputFormat: 'xml',
      sudoSync: 'The jade file FILENAME could not be rendered synchronously.  N.B. then-jade does not support synchronous rendering.',
      async: function (str, options, cb) {
        this.cache(options, true);//jade handles this.cache internally
        this.engine.render(str, options, cb);
      }
    });
    
    exports.dust = new Transformer({
      name: 'dust',
      engines: ['dust', 'dustjs-linkedin'],
      outputFormat: 'xml',
      sudoSync: false,
      async: function (str, options, cb) {
        var ext = 'dust',
            views = '.';
    
        if (options) {
          if (options.ext) ext = options.ext;
          if (options.views) views = options.views;
          if (options.settings && options.settings.views) views = options.settings.views;
        }
    
        this.engine.onLoad = function(path, callback){
          if ('' === extname(path)) path += '.' + ext;
          if ('/' !== path[0]) path = views + '/' + path;
          read(path, options, callback);
        };
    
        var tmpl = this.cache(options) || this.cache(options, this.engine.compileFn(str));
        if (options && !options.cache) this.engine.cache = {};//invalidate dust's internal cache
        tmpl(options, cb);
      }
    });
    
    exports.jazz = new Transformer({
      name: 'jazz',
      engines: ['jazz'],
      outputFormat: 'xml',
      sudoSync: true, // except when an async function is passed to locals
      async: function (str, options, cb) {
        var tmpl = this.cache(options) || this.cache(options, this.engine.compile(str, options));
        tmpl.eval(options, function(str){
          cb(null, str);
        });
      }
    });
    
    exports.qejs = new Transformer({
      name: 'qejs',
      engines: ['qejs'],
      outputFormat: 'xml',
      sudoSync: false,
      async: function (str, options, cb) {
        var tmpl = this.cache(options) || this.cache(options, this.engine.compile(str, options));
        tmpl(options).done(function (result) {
            cb(null, result);
        }, function (err) {
            cb(err);
        });
      }
    });
    
    /**
     * Stylesheet Languages
     */
    
    exports.less = new Transformer({
      name: 'less',
      engines: ['less'],
      outputFormat: 'css',
      sudoSync: 'The less file FILENAME could not be rendered synchronously.  This is usually because the file contains `@import url` statements.',
      async: function (str, options, cb) {
        var self = this;
        if (self.cache(options)) return cb(null, self.cache(options));
        if (options.filename) {
          options.paths = options.paths || [dirname(options.filename)];
        }
        //If this.cache is enabled, compress by default
        if (options.compress !== true && options.compress !== false) {
          options.compress = options.cache || false;
        }
        if (options.sudoSync) {
          options.syncImport = true;
        }
        var parser = new(this.engine.Parser)(options);
        parser.parse(str, function (err, tree) {
          try {
            if (err) throw err;
            var res = tree.toCSS(options);
            self.cache(options, res);
            cb(null, res);
          } catch (ex) {
            if (ex.constructor.name === 'LessError' && typeof ex === 'object') {
              ex.filename = ex.filename || '"Unkown Source"';
              var err = new Error(self.engine.formatError(ex, options).replace(/^[^:]+:/, ''), ex.filename, ex.line);
              err.name = ex.type;
              ex = err;
            }
            return cb(ex);
          }
        });
      }
    });
    
    exports.styl = exports.stylus = new Transformer({
      name: 'stylus',
      engines: ['stylus'],
      outputFormat: 'css',
      sudoSync: true,// always runs synchronously
      async: function (str, options, cb) {
        var self = this;
        if (self.cache(options)) return cb(null, self.cache(options));
        if (options.filename) {
          options.paths = options.paths || [dirname(options.filename)];
        }
    
        // If this.cache is enabled, compress by default
        if (options.compress !== true && options.compress !== false) {
          options.compress = options.cache || false;
        }
    
        var initial = this.engine(str);
    
        // Special handling for stylus js api functions
        // given { define: { foo: 'bar', baz: 'quux' } }
        // runs initial.define('foo', 'bar').define('baz', 'quux')
    
        var allowed = ['set', 'include', 'import', 'define', 'use'];
        var special = {}
        var normal = clone(options);
        for (var v in options) {
          if (allowed.indexOf(v) > -1) { special[v] = options[v]; delete normal[v]; }
        }
    
        // special options through their function names
        for (var k in special) {
          for (var v in special[k]) { initial[k](v, special[k][v]); }
        }
    
        // normal options through set()
        for (var k in normal) {
          for (var v in normal[k]) { initial['set'](v, normal[k][v]); }
        }
    
        initial.render(function (err, res) {
          if (err) return cb(err);
          self.cache(options, res);
          cb(null, res);
        });
      }
    });
    
    exports.sass = new Transformer({
      name: 'sass',
      engines: ['sass'],
      outputFormat: 'css',
      sync: function (str, options) {
        try {
          return this.cache(options) || this.cache(options, this.engine.render(str));
        } catch (ex) {
          if (options.filename) ex.message += ' in ' + options.filename;
          throw ex;
        }
      }
    });
    
    /**
     * Miscellaneous
     */
    
    exports.md = exports.markdown = new Transformer({
      name: 'markdown',
      engines: ['marked', 'supermarked', 'markdown-js', 'markdown'],
      outputFormat: 'html',
      sync: function (str, options) {
        var arg = options;
        if (this.engineName === 'markdown') arg = options.dialect; //even if undefined
        return this.cache(options) || this.cache(options, this.engine.parse(str, arg));
      }
    });
    
    exports.coffee = exports['coffee-script'] = exports.coffeescript = exports.coffeeScript = new Transformer({
      name: 'coffee-script',
      engines: ['coffee-script'],
      outputFormat: 'js',
      sync: function (str, options) {
        return this.cache(options) || this.cache(options, this.engine.compile(str, options));
      }
    });
    
    exports.cson = new Transformer({
      name: 'cson',
      engines: ['cson'],
      outputFormat: 'json',
      sync: function (str, options) {
        return this.cache(options) || this.cache(options, JSON.stringify(this.engine.parseSync(str)));
      }
    });
    
    exports.cdata = new Transformer({
      name: 'cdata',
      engines: ['.'],// `.` means "no dependency"
      outputFormat: 'xml',
      sync: function (str, options) {
        var escaped = str.replace(/\]\]>/g, "]]]]><![CDATA[>");
        return this.cache(options) || this.cache(options, '<![CDATA[' + escaped + ']]>');
      }
    });
    
    exports["cdata-js"] = new Transformer({
      name: 'cdata-js',
      engines: ['.'],// `.` means "no dependency"
      outputFormat: 'xml',
      sync: function (str, options) {
        var escaped = str.replace(/\]\]>/g, "]]]]><![CDATA[>");
        return this.cache(options) || this.cache(options, '//<![CDATA[\n' + escaped + '\n//]]>');
      }
    });
    
    exports["cdata-css"] = new Transformer({
      name: 'cdata-css',
      engines: ['.'],// `.` means "no dependency"
      outputFormat: 'xml',
      sync: function (str, options) {
        var escaped = str.replace(/\]\]>/g, "]]]]><![CDATA[>");
        return this.cache(options) || this.cache(options, '/*<![CDATA[*/\n' + escaped + '\n/*]]>*/');
      }
    });
    
    exports.verbatim = new Transformer({
      name: 'verbatim',
      engines: ['.'],// `.` means "no dependency"
      outputFormat: 'xml',
      sync: function (str, options) {
        return this.cache(options) || this.cache(options, str);
      }
    });
    
    exports["escape-html"] = new Transformer({
      name: 'escape-html',
      engines: ['.'],// `.` means "no dependency"
      outputFormat: 'xml',
      sync: function (str, options) {
        var escaped = str.replace(/&/g, '&amp;')
                         .replace(/</g, '&lt;')
                         .replace(/>/g, '&gt;')
                         .replace(/"/g, '&quot;')
                         .replace(/'/g, '&#x27;');
    
        return this.cache(options) || this.cache(options, escaped);
      }
    });
    
    exports['highlight'] = new Transformer({
      name: 'highlight',
      engines: ['highlight.js'],
      outputFormat: 'xml',
      sync: function (str, options, cb) {
        if (this.cache(options)) return this.cache(options);
        if (options.lang) {
          try {
            return this.cache(options, this.engine.highlight(options.lang, str).value);
          } catch (ex) {}
        }
        if (options.auto || !options.lang) {
          try {
            return this.cache(options, this.engine.highlightAuto(str).value);
          } catch (ex) {}
        }
        return this.cache(options, str);
      }
    });
    
    /**
     * Marker transformers (they don't actually apply a transformation, but let you declare the 'outputFormat')
     */
    
    exports.css = new Transformer({
      name: 'css',
      engines: ['.'],// `.` means "no dependency"
      outputFormat: 'css',
      sync: function (str, options) {
        return this.cache(options) || this.cache(options, str);
      }
    });
    
    exports.js = new Transformer({
      name: 'js',
      engines: ['.'],// `.` means "no dependency"
      outputFormat: 'js',
      sync: function (str, options) {
        return this.cache(options) || this.cache(options, str);
      }
    });
    
  provide("transformers", module.exports);
}(global));

// pakmanager:void-elements
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * This file automatically generated from `pre-publish.js`.
     * Do not manually edit.
     */
    
    module.exports = {
      "area": true,
      "base": true,
      "br": true,
      "col": true,
      "embed": true,
      "hr": true,
      "img": true,
      "input": true,
      "keygen": true,
      "link": true,
      "menuitem": true,
      "meta": true,
      "param": true,
      "source": true,
      "track": true,
      "wbr": true
    };
    
  provide("void-elements", module.exports);
}(global));

// pakmanager:with
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var detect = require('acorn-globals');
    var acorn = require('acorn');
    var walk = require('acorn/dist/walk');
    
    // polyfill for https://github.com/marijnh/acorn/pull/231
    walk.base.ExportNamedDeclaration = walk.base.ExportDefaultDeclaration = function (node, st, c) {
      return c(node.declaration, st);
    };
    walk.base.ImportDefaultSpecifier = walk.base.ImportNamespaceSpecifier = function () {};
    
    // hacky fix for https://github.com/marijnh/acorn/issues/227
    function reallyParse(source) {
      try {
        return acorn.parse(source, {
          ecmaVersion: 5,
          allowReturnOutsideFunction: true
        });
      } catch (ex) {
        if (ex.name !== 'SyntaxError') {
          throw ex;
        }
        return acorn.parse(source, {
          ecmaVersion: 6,
          allowReturnOutsideFunction: true
        });
      }
    }
    
    module.exports = addWith
    
    /**
     * Mimic `with` as far as possible but at compile time
     *
     * @param {String} obj The object part of a with expression
     * @param {String} src The body of the with expression
     * @param {Array.<String>} exclude A list of variable names to explicitly exclude
     */
    function addWith(obj, src, exclude) {
      obj = obj + ''
      src = src + ''
      exclude = exclude || []
      exclude = exclude.concat(detect(obj).map(function (global) { return global.name; }))
      var vars = detect(src).map(function (global) { return global.name; })
        .filter(function (v) {
          return exclude.indexOf(v) === -1
            && v !== 'undefined'
        })
    
      if (vars.length === 0) return src
    
      var declareLocal = ''
      var local = 'locals_for_with'
      var result = 'result_of_with'
      if (/^[a-zA-Z0-9$_]+$/.test(obj)) {
        local = obj
      } else {
        while (vars.indexOf(local) != -1 || exclude.indexOf(local) != -1) {
          local += '_'
        }
        declareLocal = 'var ' + local + ' = (' + obj + ')'
      }
      while (vars.indexOf(result) != -1 || exclude.indexOf(result) != -1) {
        result += '_'
      }
    
      var inputVars = vars.map(function (v) {
        return JSON.stringify(v) + ' in ' + local + '?' +
          local + '.' + v + ':' +
          'typeof ' + v + '!=="undefined"?' + v + ':undefined'
      })
    
      src = '(function (' + vars.join(', ') + ') {' +
        src +
        '}.call(this' + inputVars.map(function (v) { return ',' + v; }).join('') + '))'
    
      return ';' + declareLocal + ';' + unwrapReturns(src, result) + ';'
    }
    
    /**
     * Take a self calling function, and unwrap it such that return inside the function
     * results in return outside the function
     *
     * @param {String} src    Some JavaScript code representing a self-calling function
     * @param {String} result A temporary variable to store the result in
     */
    function unwrapReturns(src, result) {
      var originalSource = src
      var hasReturn = false
      var ast = reallyParse(src)
      var ref
      src = src.split('')
    
      // get a reference to the function that was inserted to add an inner context
      if ((ref = ast.body).length !== 1
       || (ref = ref[0]).type !== 'ExpressionStatement'
       || (ref = ref.expression).type !== 'CallExpression'
       || (ref = ref.callee).type !== 'MemberExpression' || ref.computed !== false || ref.property.name !== 'call'
       || (ref = ref.object).type !== 'FunctionExpression')
        throw new Error('AST does not seem to represent a self-calling function')
      var fn = ref
    
      walk.recursive(ast, null, {
        Function: function (node, st, c) {
          if (node === fn) {
            c(node.body, st, "ScopeBody");
          }
        },
        ReturnStatement: function (node) {
          hasReturn = true
          replace(node, 'return {value: ' + source(node.argument) + '};');
        }
      });
      function source(node) {
        return src.slice(node.start, node.end).join('')
      }
      function replace(node, str) {
        for (var i = node.start; i < node.end; i++) {
          src[i] = ''
        }
        src[node.start] = str
      }
      if (!hasReturn) return originalSource
      else return 'var ' + result + '=' + src.join('') + ';if (' + result + ') return ' + result + '.value'
    }
    
  provide("with", module.exports);
}(global));

// pakmanager:anymatch
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var arrify = require('arrify');
    var micromatch = require('micromatch');
    var path = require('path');
    
    var anymatch = function(criteria, value, returnIndex, startIndex, endIndex) {
      criteria = arrify(criteria);
      value = arrify(value);
      if (arguments.length === 1) {
        return anymatch.bind(null, criteria.map(function(criterion) {
          return typeof criterion === 'string' && criterion[0] !== '!' ?
            micromatch.matcher(criterion) : criterion;
        }));
      }
      startIndex = startIndex || 0;
      var string = value[0];
      var altString;
      var matched = false;
      var matchIndex = -1;
      function testCriteria (criterion, index) {
        var result;
        switch (toString.call(criterion)) {
        case '[object String]':
          result = string === criterion || altString && altString === criterion;
          result = result || micromatch.isMatch(string, criterion);
          break;
        case '[object RegExp]':
          result = criterion.test(string) || altString && criterion.test(altString);
          break;
        case '[object Function]':
          result = criterion.apply(null, value);
          break;
        default:
          result = false;
        }
        if (result) {
          matchIndex = index + startIndex;
        }
        return result;
      }
      var crit = criteria;
      var negGlobs = crit.reduce(function(arr, criterion, index) {
        if (typeof criterion === 'string' && criterion[0] === '!') {
          if (crit === criteria) {
            // make a copy before modifying
            crit = crit.slice();
          }
          crit[index] = null;
          arr.push(criterion.substr(1));
        }
        return arr;
      }, []);
      if (!negGlobs.length || !micromatch.any(string, negGlobs)) {
        if (path.sep === '\\' && typeof string === 'string') {
          altString = string.split('\\').join('/');
          altString = altString === string ? null : altString;
        }
        matched = crit.slice(startIndex, endIndex).some(testCriteria);
      }
      return returnIndex === true ? matchIndex : matched;
    };
    
    module.exports = anymatch;
    
  provide("anymatch", module.exports);
}(global));

// pakmanager:async-each
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // async-each MIT license (by Paul Miller from http://paulmillr.com).
    (function(globals) {
      'use strict';
      var each = function(items, next, callback) {
        if (!Array.isArray(items)) throw new TypeError('each() expects array as first argument');
        if (typeof next !== 'function') throw new TypeError('each() expects function as second argument');
        if (typeof callback !== 'function') callback = Function.prototype; // no-op
    
        if (items.length === 0) return callback(undefined, items);
    
        var transformed = new Array(items.length);
        var count = 0;
        var returned = false;
    
        items.forEach(function(item, index) {
          next(item, function(error, transformedItem) {
            if (returned) return;
            if (error) {
              returned = true;
              return callback(error);
            }
            transformed[index] = transformedItem;
            count += 1;
            if (count === items.length) return callback(undefined, transformed);
          });
        });
      };
    
      if (typeof define !== 'undefined' && define.amd) {
        define([], function() {
          return each;
        }); // RequireJS
      } else if (typeof module !== 'undefined' && module.exports) {
        module.exports = each; // CommonJS
      } else {
        globals.asyncEach = each; // <script>
      }
    })(this);
    
  provide("async-each", module.exports);
}(global));

// pakmanager:is-binary-path
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var path = require('path');
    var binaryExtensions = require('binary-extensions');
    var exts = Object.create(null);
    
    binaryExtensions.forEach(function (el) {
    	exts[el] = true;
    });
    
    module.exports = function (filepath) {
    	var ext = path.extname(filepath).slice(1);
    
    	if (ext === '') {
    		return false;
    	}
    
    	return ext in exts;
    };
    
  provide("is-binary-path", module.exports);
}(global));

// pakmanager:readdirp/stream-api
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var si = typeof setImmediate !== 'undefined' ? setImmediate : function (fn) { setTimeout(fn, 0) };
    
    var stream = require('readable-stream');
    var util = require('util');
    
    var Readable = stream.Readable;
    
    module.exports = ReaddirpReadable;
    
    util.inherits(ReaddirpReadable, Readable);
    
    function ReaddirpReadable (opts) {
      if (!(this instanceof ReaddirpReadable)) return new ReaddirpReadable(opts);
    
      opts = opts || {};
      
      opts.objectMode = true;
      Readable.call(this, opts);
    
      // backpressure not implemented at this point
      this.highWaterMark = Infinity;
    
      this._destroyed = false;
      this._paused = false;
      this._warnings = [];
      this._errors = [];
    
      this._pauseResumeErrors();
    }
    
    var proto = ReaddirpReadable.prototype;
    
    proto._pauseResumeErrors = function () {
      var self = this;
      self.on('pause', function () { self._paused = true });
      self.on('resume', function () {
        if (self._destroyed) return;
        self._paused = false;
    
        self._warnings.forEach(function (err) { self.emit('warn', err) });
        self._warnings.length = 0;
    
        self._errors.forEach(function (err) { self.emit('error', err) });
        self._errors.length = 0;
      })
    }
    
    // called for each entry
    proto._processEntry = function (entry) {
      if (this._destroyed) return;
      this.push(entry);
    }
    
    proto._read = function () { }
    
    proto.destroy = function () {
      // when stream is destroyed it will emit nothing further, not even errors or warnings
      this.push(null);
      this.readable = false;
      this._destroyed = true;
      this.emit('close');
    }
    
    proto._done = function () {
      this.push(null);
    }
    
    // we emit errors and warnings async since we may handle errors like invalid args
    // within the initial event loop before any event listeners subscribed
    proto._handleError = function (err) {
      var self = this;
      si(function () { 
        if (self._paused) return self._warnings.push(err);
        if (!self._destroyed) self.emit('warn', err);
      });
    }
    
    proto._handleFatalError = function (err) {
      var self = this;
      si(function () { 
        if (self._paused) return self._errors.push(err);
        if (!self._destroyed) self.emit('error', err);
      });
    }
    
    function createStreamAPI () {
      var stream = new ReaddirpReadable();
    
      return { 
          stream           :  stream
        , processEntry     :  stream._processEntry.bind(stream)
        , done             :  stream._done.bind(stream)
        , handleError      :  stream._handleError.bind(stream)
        , handleFatalError :  stream._handleFatalError.bind(stream)
      };
    }
    
    module.exports = createStreamAPI;
    
  provide("readdirp/stream-api", module.exports);
}(global));

// pakmanager:readdirp
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var fs        =  require('graceful-fs')
      , path      =  require('path')
      , minimatch =  require('minimatch')
      , toString  =  Object.prototype.toString
      ;
    
    // Standard helpers
    function isFunction (obj) {
      return toString.call(obj) === '[object Function]';
    }
    
    function isString (obj) {
      return toString.call(obj) === '[object String]';
    }
    
    function isRegExp (obj) {
      return toString.call(obj) === '[object RegExp]';
    }
    
    function isUndefined (obj) {
      return obj === void 0;
    }
    
    /** 
     * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.
     * @param { Object }   opts     Options to specify root (start directory), filters and recursion depth
     * @param { function } callback1  When callback2 is given calls back for each processed file - function (fileInfo) { ... },
     *                                when callback2 is not given, it behaves like explained in callback2
     * @param { function } callback2  Calls back once all files have been processed with an array of errors and file infos
     *                                function (err, fileInfos) { ... }
     */
    function readdir(opts, callback1, callback2) {
      var stream
        , handleError
        , handleFatalError
        , pending = 0
        , errors = []
        , readdirResult = {
            directories: []
          , files: []
        }
        , fileProcessed
        , allProcessed
        , realRoot
        , aborted = false
        ;
    
      // If no callbacks were given we will use a streaming interface
      if (isUndefined(callback1)) {
        var api          =   require('readdirp/stream-api')();
        stream           =  api.stream;
        callback1        =  api.processEntry;
        callback2        =  api.done;
        handleError      =  api.handleError;
        handleFatalError =  api.handleFatalError;
    
        stream.on('close', function () { aborted = true; });
      } else {
        handleError      =  function (err) { errors.push(err); };
        handleFatalError =  function (err) {
          handleError(err);
          allProcessed(errors, null);
        };
      }
    
      if (isUndefined(opts)){
        handleFatalError(new Error (
          'Need to pass at least one argument: opts! \n' +
          'https://github.com/thlorenz/readdirp#options'
          )
        );
        return stream;
      }
    
      opts.root            =  opts.root            || '.';
      opts.fileFilter      =  opts.fileFilter      || function() { return true; };
      opts.directoryFilter =  opts.directoryFilter || function() { return true; };
      opts.depth           =  typeof opts.depth === 'undefined' ? 999999999 : opts.depth;
      opts.entryType       =  opts.entryType       || 'files';
    
      var statfn = opts.lstat === true ? fs.lstat.bind(fs) : fs.stat.bind(fs);
    
      if (isUndefined(callback2)) {
        fileProcessed = function() { };
        allProcessed = callback1;
      } else {
        fileProcessed = callback1;
        allProcessed = callback2;
      }
    
      function normalizeFilter (filter) {
    
        if (isUndefined(filter)) return undefined;
    
        function isNegated (filters) {
    
          function negated(f) { 
            return f.indexOf('!') === 0; 
          }
    
          var some = filters.some(negated);
          if (!some) {
            return false;
          } else {
            if (filters.every(negated)) {
              return true;
            } else {
              // if we detect illegal filters, bail out immediately
              throw new Error(
                'Cannot mix negated with non negated glob filters: ' + filters + '\n' +
                'https://github.com/thlorenz/readdirp#filters'
              );
            }
          }
        }
    
        // Turn all filters into a function
        if (isFunction(filter)) {
    
          return filter;
    
        } else if (isString(filter)) {
    
          return function (entryInfo) {
            return minimatch(entryInfo.name, filter.trim());
          };
    
        } else if (filter && Array.isArray(filter)) {
    
          if (filter) filter = filter.map(function (f) {
            return f.trim();
          });
    
          return isNegated(filter) ?
            // use AND to concat multiple negated filters
            function (entryInfo) {
              return filter.every(function (f) {
                return minimatch(entryInfo.name, f);
              });
            }
            :
            // use OR to concat multiple inclusive filters
            function (entryInfo) {
              return filter.some(function (f) {
                return minimatch(entryInfo.name, f);
              });
            };
        }
      }
    
      function processDir(currentDir, entries, callProcessed) {
        if (aborted) return;
        var total = entries.length
          , processed = 0
          , entryInfos = []
          ;
    
        fs.realpath(currentDir, function(err, realCurrentDir) {
          if (aborted) return;
          if (err) {
            handleError(err);
            callProcessed(entryInfos);
            return;
          }
    
          var relDir = path.relative(realRoot, realCurrentDir);
    
          if (entries.length === 0) {
            callProcessed([]);
          } else {
            entries.forEach(function (entry) { 
    
              var fullPath = path.join(realCurrentDir, entry)
                , relPath  = path.join(relDir, entry);
    
              statfn(fullPath, function (err, stat) {
                if (err) {
                  handleError(err);
                } else {
                  entryInfos.push({
                      name          :  entry
                    , path          :  relPath   // relative to root
                    , fullPath      :  fullPath
    
                    , parentDir     :  relDir    // relative to root
                    , fullParentDir :  realCurrentDir
    
                    , stat          :  stat
                  });
                }
                processed++;
                if (processed === total) callProcessed(entryInfos);
              });
            });
          }
        });
      }
    
      function readdirRec(currentDir, depth, callCurrentDirProcessed) {
        if (aborted) return;
    
        fs.readdir(currentDir, function (err, entries) {
          if (err) {
            handleError(err);
            callCurrentDirProcessed();
            return;
          }
    
          processDir(currentDir, entries, function(entryInfos) {
    
            var subdirs = entryInfos
              .filter(function (ei) { return ei.stat.isDirectory() && opts.directoryFilter(ei); });
    
            subdirs.forEach(function (di) {
              if(opts.entryType === 'directories' || opts.entryType === 'both' || opts.entryType === 'all') {
                fileProcessed(di);
              }
              readdirResult.directories.push(di); 
            });
    
            entryInfos
              .filter(function(ei) {
                var isCorrectType = opts.entryType === 'all' ?
                  !ei.stat.isDirectory() : ei.stat.isFile() || ei.stat.isSymbolicLink();
                return isCorrectType && opts.fileFilter(ei);
              })
              .forEach(function (fi) {
                if(opts.entryType === 'files' || opts.entryType === 'both' || opts.entryType === 'all') {
                  fileProcessed(fi);
                }
                readdirResult.files.push(fi); 
              });
    
            var pendingSubdirs = subdirs.length;
    
            // Be done if no more subfolders exist or we reached the maximum desired depth
            if(pendingSubdirs === 0 || depth === opts.depth) {
              callCurrentDirProcessed();
            } else {
              // recurse into subdirs, keeping track of which ones are done 
              // and call back once all are processed
              subdirs.forEach(function (subdir) {
                readdirRec(subdir.fullPath, depth + 1, function () {
                  pendingSubdirs = pendingSubdirs - 1;
                  if(pendingSubdirs === 0) { 
                    callCurrentDirProcessed();
                  }
                });
              });
            }
          });
        });
      }
    
      // Validate and normalize filters
      try {
        opts.fileFilter = normalizeFilter(opts.fileFilter);
        opts.directoryFilter = normalizeFilter(opts.directoryFilter);
      } catch (err) {
        // if we detect illegal filters, bail out immediately
        handleFatalError(err);
        return stream;
      }
    
      // If filters were valid get on with the show
      fs.realpath(opts.root, function(err, res) {
        if (err) {
          handleFatalError(err);
          return stream;
        }
    
        realRoot = res;
        readdirRec(opts.root, 0, function () { 
          // All errors are collected into the errors array
          if (errors.length > 0) {
            allProcessed(errors, readdirResult); 
          } else {
            allProcessed(null, readdirResult);
          }
        });
      });
    
      return stream;
    }
    
    module.exports = readdir;
    
  provide("readdirp", module.exports);
}(global));

// pakmanager:fsevents
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     ** © 2014 by Philipp Dunkel <pip@pipobscure.com>
     ** Licensed under MIT License.
     */
    
    /* jshint node:true */
    'use strict';
    
    var Native = require('./build/Release/fse');
    var EventEmitter = require('events').EventEmitter;
    var fs = require('fs');
    var inherits = require('util').inherits;
    
    function FSEvents(path, handler) {
      EventEmitter.call(this);
    
      Object.defineProperty(this, '_impl', {
        value: new Native.FSEvents(String(path || ''), handler),
        enumerable: false,
        writable: false
      });
    }
    
    inherits(FSEvents, EventEmitter);
    proxies(FSEvents, Native.FSEvents);
    
    module.exports = watch;
    module.exports.getInfo = getInfo;
    module.exports.FSEvents = Native.FSEvents;
    module.exports.Constants = Native.Constants;
    
    var defer = global.setImmediate || process.nextTick;
    
    function watch(path) {
      var fse = new FSEvents(String(path || ''), handler);
      EventEmitter.call(fse);
      return fse;
    
      function handler(path, flags, id) {
        defer(function() {
          fse.emit('fsevent', path, flags, id);
          var info = getInfo(path, flags);
          info.id = id;
          if (info.event === 'moved') {
            fs.stat(info.path, function(err, stat) {
              info.event = (err || !stat) ? 'moved-out' : 'moved-in';
              fse.emit('change', path, info);
              fse.emit(info.event, path, info);
            });
          } else {
            fse.emit('change', path, info);
            fse.emit(info.event, path, info);
          }
        });
      }
    }
    
    function proxies(ctor, target) {
      Object.keys(target.prototype).filter(function(key) {
        return typeof target.prototype[key] === 'function';
      }).forEach(function(key) {
        ctor.prototype[key] = function() {
          this._impl[key].apply(this._impl, arguments);
          return this;
        }
      });
    }
    
    function getFileType(flags) {
      if (Native.Constants.kFSEventStreamEventFlagItemIsFile & flags) return 'file';
      if (Native.Constants.kFSEventStreamEventFlagItemIsDir & flags) return 'directory';
      if (Native.Constants.kFSEventStreamEventFlagItemIsSymlink & flags) return 'symlink';
    }
    
    function getEventType(flags) {
      if (Native.Constants.kFSEventStreamEventFlagItemRemoved & flags) return 'deleted';
      if (Native.Constants.kFSEventStreamEventFlagItemRenamed & flags) return 'moved';
      if (Native.Constants.kFSEventStreamEventFlagItemCreated & flags) return 'created';
      if (Native.Constants.kFSEventStreamEventFlagItemModified & flags) return 'modified';
      if (Native.Constants.kFSEventStreamEventFlagRootChanged & flags) return 'root-changed';
    
      return 'unknown';
    }
    
    function getFileChanges(flags) {
      return {
        inode: !! (Native.Constants.kFSEventStreamEventFlagItemInodeMetaMod & flags),
        finder: !! (Native.Constants.kFSEventStreamEventFlagItemFinderInfoMod & flags),
        access: !! (Native.Constants.kFSEventStreamEventFlagItemChangeOwner & flags),
        xattrs: !! (Native.Constants.kFSEventStreamEventFlagItemXattrMod & flags)
      };
    }
    
    function getInfo(path, flags) {
      return {
        path: path,
        event: getEventType(flags),
        type: getFileType(flags),
        changes: getFileChanges(flags),
        flags: flags
      };
    }
    
  provide("fsevents", module.exports);
}(global));

// pakmanager:content-type
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * content-type
     * Copyright(c) 2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    /**
     * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
     *
     * parameter     = token "=" ( token / quoted-string )
     * token         = 1*tchar
     * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
     *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
     *               / DIGIT / ALPHA
     *               ; any VCHAR, except delimiters
     * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
     * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
     * obs-text      = %x80-FF
     * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
     */
    var paramRegExp = /; *([!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+) */g
    var textRegExp = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/
    var tokenRegExp = /^[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+$/
    
    /**
     * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
     *
     * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
     * obs-text    = %x80-FF
     */
    var qescRegExp = /\\([\u000b\u0020-\u00ff])/g
    
    /**
     * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
     */
    var quoteRegExp = /([\\"])/g
    
    /**
     * RegExp to match type in RFC 6838
     *
     * media-type = type "/" subtype
     * type       = token
     * subtype    = token
     */
    var typeRegExp = /^[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+\/[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+$/
    
    /**
     * Module exports.
     * @public
     */
    
    exports.format = format
    exports.parse = parse
    
    /**
     * Format object to media type.
     *
     * @param {object} obj
     * @return {string}
     * @public
     */
    
    function format(obj) {
      if (!obj || typeof obj !== 'object') {
        throw new TypeError('argument obj is required')
      }
    
      var parameters = obj.parameters
      var type = obj.type
    
      if (!type || !typeRegExp.test(type)) {
        throw new TypeError('invalid type')
      }
    
      var string = type
    
      // append parameters
      if (parameters && typeof parameters === 'object') {
        var param
        var params = Object.keys(parameters).sort()
    
        for (var i = 0; i < params.length; i++) {
          param = params[i]
    
          if (!tokenRegExp.test(param)) {
            throw new TypeError('invalid parameter name')
          }
    
          string += '; ' + param + '=' + qstring(parameters[param])
        }
      }
    
      return string
    }
    
    /**
     * Parse media type to object.
     *
     * @param {string|object} string
     * @return {Object}
     * @public
     */
    
    function parse(string) {
      if (!string) {
        throw new TypeError('argument string is required')
      }
    
      if (typeof string === 'object') {
        // support req/res-like objects as argument
        string = getcontenttype(string)
    
        if (typeof string !== 'string') {
          throw new TypeError('content-type header is missing from object');
        }
      }
    
      if (typeof string !== 'string') {
        throw new TypeError('argument string is required to be a string')
      }
    
      var index = string.indexOf(';')
      var type = index !== -1
        ? string.substr(0, index).trim()
        : string.trim()
    
      if (!typeRegExp.test(type)) {
        throw new TypeError('invalid media type')
      }
    
      var key
      var match
      var obj = new ContentType(type.toLowerCase())
      var value
    
      paramRegExp.lastIndex = index
    
      while (match = paramRegExp.exec(string)) {
        if (match.index !== index) {
          throw new TypeError('invalid parameter format')
        }
    
        index += match[0].length
        key = match[1].toLowerCase()
        value = match[2]
    
        if (value[0] === '"') {
          // remove quotes and escapes
          value = value
            .substr(1, value.length - 2)
            .replace(qescRegExp, '$1')
        }
    
        obj.parameters[key] = value
      }
    
      if (index !== -1 && index !== string.length) {
        throw new TypeError('invalid parameter format')
      }
    
      return obj
    }
    
    /**
     * Get content-type from req/res objects.
     *
     * @param {object}
     * @return {Object}
     * @private
     */
    
    function getcontenttype(obj) {
      if (typeof obj.getHeader === 'function') {
        // res-like
        return obj.getHeader('content-type')
      }
    
      if (typeof obj.headers === 'object') {
        // req-like
        return obj.headers && obj.headers['content-type']
      }
    }
    
    /**
     * Quote a string if necessary.
     *
     * @param {string} val
     * @return {string}
     * @private
     */
    
    function qstring(val) {
      var str = String(val)
    
      // no need to quote tokens
      if (tokenRegExp.test(str)) {
        return str
      }
    
      if (str.length > 0 && !textRegExp.test(str)) {
        throw new TypeError('invalid parameter value')
      }
    
      return '"' + str.replace(quoteRegExp, '\\$1') + '"'
    }
    
    /**
     * Class to represent a content type.
     * @private
     */
    function ContentType(type) {
      this.parameters = Object.create(null)
      this.type = type
    }
    
  provide("content-type", module.exports);
}(global));

// pakmanager:qs
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = require('./lib/');
    
  provide("qs", module.exports);
}(global));

// pakmanager:raw-body
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * raw-body
     * Copyright(c) 2013-2014 Jonathan Ong
     * Copyright(c) 2014-2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict'
    
    /**
     * Module dependencies.
     * @private
     */
    
    var bytes = require('bytes')
    var iconv = require('iconv-lite')
    
    /**
     * Module exports.
     * @public
     */
    
    module.exports = getRawBody
    
    /**
     * Get the decoder for a given encoding.
     *
     * @param {string} encoding
     * @private
     */
    
    function getDecoder(encoding) {
      if (!encoding) return null
    
      try {
        return iconv.getCodec(encoding).decoder()
      } catch (e) {
        var err = makeError('specified encoding unsupported', 'encoding.unsupported')
        err.status = err.statusCode = 415
        err.encoding = encoding
        throw err
      }
    }
    
    /**
     * Get the raw body of a stream (typically HTTP).
     *
     * @param {object} stream
     * @param {object|string|function} [options]
     * @param {function} [callback]
     * @public
     */
    
    function getRawBody(stream, options, callback) {
      var done = callback
      var opts = options || {}
    
      if (options === true || typeof options === 'string') {
        // short cut for encoding
        opts = {
          encoding: options
        }
      }
    
      if (typeof options === 'function') {
        done = options
        opts = {}
      }
    
      // validate callback is a function, if provided
      if (done !== undefined && typeof done !== 'function') {
        throw new TypeError('argument callback must be a function')
      }
    
      // require the callback without promises
      if (!done && !global.Promise) {
        throw new TypeError('argument callback is required')
      }
    
      // get encoding
      var encoding = opts.encoding !== true
        ? opts.encoding
        : 'utf-8'
    
      // convert the limit to an integer
      var limit = typeof opts.limit === 'number' ? opts.limit
        : typeof opts.limit === 'string' ? bytes(opts.limit)
        : null
    
      // convert the expected length to an integer
      var length = opts.length != null && !isNaN(opts.length)
        ? parseInt(opts.length, 10)
        : null
    
      if (done) {
        // classic callback style
        return readStream(stream, encoding, length, limit, done)
      }
    
      return new Promise(function executor(resolve, reject) {
        readStream(stream, encoding, length, limit, function onRead(err, buf) {
          if (err) return reject(err)
          resolve(buf)
        })
      })
    }
    
    /**
     * Halt a stream.
     *
     * @param {Object} stream
     * @private
     */
    
    function halt(stream) {
      // unpipe everything from the stream
      unpipe(stream)
    
      // pause stream
      if (typeof stream.pause === 'function') {
        stream.pause()
      }
    }
    
    /**
     * Determine if there are Node.js pipe-like data listeners.
     */
    
    /* istanbul ignore next: implementation differs between versions */
    function hasPipeDataListeners(stream) {
      var listeners = stream.listeners('data')
    
      for (var i = 0; i < listeners.length; i++) {
        if (listeners[i].name === 'ondata') {
          return true
        }
      }
    
      return false
    }
    
    /**
     * Make a serializable error object.
     *
     * To create serializable errors you must re-set message so
     * that it is enumerable and you must re configure the type
     * property so that is writable and enumerable.
     *
     * @param {string} message
     * @param {string} type
     * @param {object} props
     * @private
     */
    
    function makeError(message, type, props) {
      var error = new Error()
    
      for (var prop in props) {
        error[prop] = props[prop]
      }
    
      error.message = message
    
      Object.defineProperty(error, 'type', {
        value: type,
        enumerable: true,
        writable: true,
        configurable: true
      })
    
      return error
    }
    
    /**
     * Read the data from the stream.
     *
     * @param {object} stream
     * @param {string} encoding
     * @param {number} length
     * @param {number} limit
     * @param {function} callback
     * @public
     */
    
    function readStream(stream, encoding, length, limit, callback) {
      // check the length and limit options.
      // note: we intentionally leave the stream paused,
      // so users should handle the stream themselves.
      if (limit !== null && length !== null && length > limit) {
        var err = makeError('request entity too large', 'entity.too.large', {
          expected: length,
          length: length,
          limit: limit,
          status: 413,
          statusCode: 413
        })
    
        return process.nextTick(function () {
          done(err)
        })
      }
    
      // streams1: assert request encoding is buffer.
      // streams2+: assert the stream encoding is buffer.
      //   stream._decoder: streams1
      //   state.encoding: streams2
      //   state.decoder: streams2, specifically < 0.10.6
      var state = stream._readableState
      if (stream._decoder || (state && (state.encoding || state.decoder))) {
        // developer error
        var err = makeError('stream encoding should not be set', 'stream.encoding.set', {
          status: 500,
          statusCode: 500
        })
    
        return process.nextTick(function () {
          done(err)
        })
      }
    
      var received = 0
      var decoder
    
      try {
        decoder = getDecoder(encoding)
      } catch (err) {
        return process.nextTick(function () {
          done(err)
        })
      }
    
      var buffer = decoder
        ? ''
        : []
    
      stream.on('aborted', onAborted)
      stream.on('data', onData)
      stream.once('end', onEnd)
      stream.once('error', onEnd)
      stream.once('close', cleanup)
    
      function done(err) {
        cleanup()
    
        if (err) {
          // halt the stream on error
          halt(stream)
        }
    
        callback.apply(this, arguments)
      }
    
      function onAborted() {
        done(makeError('request aborted', 'request.aborted', {
          code: 'ECONNABORTED',
          expected: length,
          length: length,
          received: received,
          status: 400,
          statusCode: 400
        }))
      }
    
      function onData(chunk) {
        received += chunk.length
        decoder
          ? buffer += decoder.write(chunk)
          : buffer.push(chunk)
    
        if (limit !== null && received > limit) {
          done(makeError('request entity too large', 'entity.too.large', {
            limit: limit,
            received: received,
            status: 413,
            statusCode: 413
          }))
        }
      }
    
      function onEnd(err) {
        if (err) return done(err)
    
        if (length !== null && received !== length) {
          done(makeError('request size did not match content length', 'request.size.invalid', {
            expected: length,
            length: length,
            received: received,
            status: 400,
            statusCode: 400
          }))
        } else {
          var string = decoder
            ? buffer + (decoder.end() || '')
            : Buffer.concat(buffer)
          cleanup()
          done(null, string)
        }
      }
    
      function cleanup() {
        received = buffer = null
    
        stream.removeListener('aborted', onAborted)
        stream.removeListener('data', onData)
        stream.removeListener('end', onEnd)
        stream.removeListener('error', onEnd)
        stream.removeListener('close', cleanup)
      }
    }
    
    /**
     * Unpipe everything from a stream.
     *
     * @param {Object} stream
     * @private
     */
    
    /* istanbul ignore next: implementation differs between versions */
    function unpipe(stream) {
      if (typeof stream.unpipe === 'function') {
        // new-style
        stream.unpipe()
        return
      }
    
      // Node.js 0.8 hack
      if (!hasPipeDataListeners(stream)) {
        return
      }
    
      var listener
      var listeners = stream.listeners('close')
    
      for (var i = 0; i < listeners.length; i++) {
        listener = listeners[i]
    
        if (listener.name !== 'cleanup' && listener.name !== 'onclose') {
          continue
        }
    
        // invoke the listener
        listener.call(stream)
      }
    }
    
  provide("raw-body", module.exports);
}(global));

// pakmanager:type-is
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    var typer = require('media-typer')
    var mime = require('mime-types')
    
    module.exports = typeofrequest;
    typeofrequest.is = typeis;
    typeofrequest.hasBody = hasbody;
    typeofrequest.normalize = normalize;
    typeofrequest.match = mimeMatch;
    
    /**
     * Compare a `value` content-type with `types`.
     * Each `type` can be an extension like `html`,
     * a special shortcut like `multipart` or `urlencoded`,
     * or a mime type.
     *
     * If no types match, `false` is returned.
     * Otherwise, the first `type` that matches is returned.
     *
     * @param {String} value
     * @param {Array} types
     * @return String
     */
    
    function typeis(value, types_) {
      var i
      var types = types_
    
      // remove parameters and normalize
      var val = typenormalize(value)
    
      // no type or invalid
      if (!val) {
        return false
      }
    
      // support flattened arguments
      if (types && !Array.isArray(types)) {
        types = new Array(arguments.length - 1)
        for (i = 0; i < types.length; i++) {
          types[i] = arguments[i + 1]
        }
      }
    
      // no types, return the content type
      if (!types || !types.length) {
        return val
      }
    
      var type
      for (i = 0; i < types.length; i++) {
        if (mimeMatch(normalize(type = types[i]), val)) {
          return type[0] === '+' || ~type.indexOf('*')
            ? val
            : type
        }
      }
    
      // no matches
      return false;
    }
    
    /**
     * Check if a request has a request body.
     * A request with a body __must__ either have `transfer-encoding`
     * or `content-length` headers set.
     * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
     *
     * @param {Object} request
     * @return {Boolean}
     * @api public
     */
    
    function hasbody(req) {
      return req.headers['transfer-encoding'] !== undefined
        || !isNaN(req.headers['content-length'])
    }
    
    /**
     * Check if the incoming request contains the "Content-Type"
     * header field, and it contains any of the give mime `type`s.
     * If there is no request body, `null` is returned.
     * If there is no content type, `false` is returned.
     * Otherwise, it returns the first `type` that matches.
     *
     * Examples:
     *
     *     // With Content-Type: text/html; charset=utf-8
     *     this.is('html'); // => 'html'
     *     this.is('text/html'); // => 'text/html'
     *     this.is('text/*', 'application/json'); // => 'text/html'
     *
     *     // When Content-Type is application/json
     *     this.is('json', 'urlencoded'); // => 'json'
     *     this.is('application/json'); // => 'application/json'
     *     this.is('html', 'application/*'); // => 'application/json'
     *
     *     this.is('html'); // => false
     *
     * @param {String|Array} types...
     * @return {String|false|null}
     * @api public
     */
    
    function typeofrequest(req, types_) {
      var types = types_
    
      // no body
      if (!hasbody(req)) {
        return null
      }
    
      // support flattened arguments
      if (arguments.length > 2) {
        types = new Array(arguments.length - 1)
        for (var i = 0; i < types.length; i++) {
          types[i] = arguments[i + 1]
        }
      }
    
      // request content type
      var value = req.headers['content-type']
    
      return typeis(value, types);
    }
    
    /**
     * Normalize a mime type.
     * If it's a shorthand, expand it to a valid mime type.
     *
     * In general, you probably want:
     *
     *   var type = is(req, ['urlencoded', 'json', 'multipart']);
     *
     * Then use the appropriate body parsers.
     * These three are the most common request body types
     * and are thus ensured to work.
     *
     * @param {String} type
     * @api private
     */
    
    function normalize(type) {
      switch (type) {
        case 'urlencoded':
          type = 'application/x-www-form-urlencoded'
          break
        case 'multipart':
          type = 'multipart/*'
          break
      }
    
      if (type[0] === '+') {
        // "+json" -> "*/*+json" expando
        type = '*/*' + type
      }
    
      return type.indexOf('/') === -1
        ? mime.lookup(type)
        : type
    }
    
    /**
     * Check if `exected` mime type
     * matches `actual` mime type with
     * wildcard and +suffix support.
     *
     * @param {String} expected
     * @param {String} actual
     * @return {Boolean}
     * @api private
     */
    
    function mimeMatch(expected, actual) {
      // invalid type
      if (expected === false) {
        return false
      }
    
      // split types
      var actualParts = actual.split('/')
      var expectedParts = expected.split('/')
    
      // invalid format
      if (actualParts.length !== 2 || expectedParts.length !== 2) {
        return false
      }
    
      // validate type
      if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {
        return false
      }
    
      // validate suffix wildcard
      if (expectedParts[1].substr(0, 2) === '*+') {
        return expectedParts[1].length <= actualParts[1].length + 1
          && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length)
      }
    
      // validate subtype
      if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {
        return false
      }
    
      return true
    }
    
    /**
     * Normalize a type and remove parameters.
     *
     * @param {string} value
     * @return {string}
     * @api private
     */
    
    function typenormalize(value) {
      try {
        var type = typer.parse(value)
        delete type.parameters
        return typer.format(type)
      } catch (err) {
        return null
      }
    }
    
  provide("type-is", module.exports);
}(global));

// pakmanager:cookie
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * cookie
     * Copyright(c) 2012-2014 Roman Shtylman
     * MIT Licensed
     */
    
    /**
     * Module exports.
     * @public
     */
    
    exports.parse = parse;
    exports.serialize = serialize;
    
    /**
     * Module variables.
     * @private
     */
    
    var decode = decodeURIComponent;
    var encode = encodeURIComponent;
    
    /**
     * Parse a cookie header.
     *
     * Parse the given cookie header string into an object
     * The object has the various cookies as keys(names) => values
     *
     * @param {string} str
     * @param {object} [options]
     * @return {string}
     * @public
     */
    
    function parse(str, options) {
      var obj = {}
      var opt = options || {};
      var pairs = str.split(/; */);
      var dec = opt.decode || decode;
    
      pairs.forEach(function(pair) {
        var eq_idx = pair.indexOf('=')
    
        // skip things that don't look like key=value
        if (eq_idx < 0) {
          return;
        }
    
        var key = pair.substr(0, eq_idx).trim()
        var val = pair.substr(++eq_idx, pair.length).trim();
    
        // quoted values
        if ('"' == val[0]) {
          val = val.slice(1, -1);
        }
    
        // only assign once
        if (undefined == obj[key]) {
          obj[key] = tryDecode(val, dec);
        }
      });
    
      return obj;
    }
    
    /**
     * Serialize data into a cookie header.
     *
     * Serialize the a name value pair into a cookie string suitable for
     * http headers. An optional options object specified cookie parameters.
     *
     * serialize('foo', 'bar', { httpOnly: true })
     *   => "foo=bar; httpOnly"
     *
     * @param {string} name
     * @param {string} val
     * @param {object} [options]
     * @return {string}
     * @public
     */
    
    function serialize(name, val, options) {
      var opt = options || {};
      var enc = opt.encode || encode;
      var pairs = [name + '=' + enc(val)];
    
      if (null != opt.maxAge) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge)) throw new Error('maxAge should be a Number');
        pairs.push('Max-Age=' + maxAge);
      }
    
      if (opt.domain) pairs.push('Domain=' + opt.domain);
      if (opt.path) pairs.push('Path=' + opt.path);
      if (opt.expires) pairs.push('Expires=' + opt.expires.toUTCString());
      if (opt.httpOnly) pairs.push('HttpOnly');
      if (opt.secure) pairs.push('Secure');
    
      return pairs.join('; ');
    }
    
    /**
     * Try decoding a string using a decoding function.
     *
     * @param {string} str
     * @param {function} decode
     * @private
     */
    
    function tryDecode(str, decode) {
      try {
        return decode(str);
      } catch (e) {
        return str;
      }
    }
    
  provide("cookie", module.exports);
}(global));

// pakmanager:cookie-signature
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var crypto = require('crypto');
    
    /**
     * Sign the given `val` with `secret`.
     *
     * @param {String} val
     * @param {String} secret
     * @return {String}
     * @api private
     */
    
    exports.sign = function(val, secret){
      if ('string' != typeof val) throw new TypeError("Cookie value must be provided as a string.");
      if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
      return val + '.' + crypto
        .createHmac('sha256', secret)
        .update(val)
        .digest('base64')
        .replace(/\=+$/, '');
    };
    
    /**
     * Unsign and decode the given `val` with `secret`,
     * returning `false` if the signature is invalid.
     *
     * @param {String} val
     * @param {String} secret
     * @return {String|Boolean}
     * @api private
     */
    
    exports.unsign = function(val, secret){
      if ('string' != typeof val) throw new TypeError("Signed cookie string must be provided.");
      if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
      var str = val.slice(0, val.lastIndexOf('.'))
        , mac = exports.sign(str, secret);
      
      return sha1(mac) == sha1(val) ? str : false;
    };
    
    /**
     * Private
     */
    
    function sha1(str){
      return crypto.createHash('sha1').update(str).digest('hex');
    }
    
  provide("cookie-signature", module.exports);
}(global));

// pakmanager:accepts
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Negotiator = require('negotiator')
    var mime = require('mime-types')
    
    var slice = [].slice
    
    module.exports = Accepts
    
    function Accepts(req) {
      if (!(this instanceof Accepts))
        return new Accepts(req)
    
      this.headers = req.headers
      this.negotiator = Negotiator(req)
    }
    
    /**
     * Check if the given `type(s)` is acceptable, returning
     * the best match when true, otherwise `undefined`, in which
     * case you should respond with 406 "Not Acceptable".
     *
     * The `type` value may be a single mime type string
     * such as "application/json", the extension name
     * such as "json" or an array `["json", "html", "text/plain"]`. When a list
     * or array is given the _best_ match, if any is returned.
     *
     * Examples:
     *
     *     // Accept: text/html
     *     this.types('html');
     *     // => "html"
     *
     *     // Accept: text/*, application/json
     *     this.types('html');
     *     // => "html"
     *     this.types('text/html');
     *     // => "text/html"
     *     this.types('json', 'text');
     *     // => "json"
     *     this.types('application/json');
     *     // => "application/json"
     *
     *     // Accept: text/*, application/json
     *     this.types('image/png');
     *     this.types('png');
     *     // => undefined
     *
     *     // Accept: text/*;q=.5, application/json
     *     this.types(['html', 'json']);
     *     this.types('html', 'json');
     *     // => "json"
     *
     * @param {String|Array} type(s)...
     * @return {String|Array|Boolean}
     * @api public
     */
    
    Accepts.prototype.type =
    Accepts.prototype.types = function (types) {
      if (!Array.isArray(types)) types = slice.call(arguments);
      var n = this.negotiator;
      if (!types.length) return n.mediaTypes();
      if (!this.headers.accept) return types[0];
      var mimes = types.map(extToMime);
      var accepts = n.mediaTypes(mimes.filter(validMime));
      var first = accepts[0];
      if (!first) return false;
      return types[mimes.indexOf(first)];
    }
    
    /**
     * Return accepted encodings or best fit based on `encodings`.
     *
     * Given `Accept-Encoding: gzip, deflate`
     * an array sorted by quality is returned:
     *
     *     ['gzip', 'deflate']
     *
     * @param {String|Array} encoding(s)...
     * @return {String|Array}
     * @api public
     */
    
    Accepts.prototype.encoding =
    Accepts.prototype.encodings = function (encodings) {
      if (!Array.isArray(encodings)) encodings = slice.call(arguments);
      var n = this.negotiator;
      if (!encodings.length) return n.encodings();
      return n.encodings(encodings)[0] || false;
    }
    
    /**
     * Return accepted charsets or best fit based on `charsets`.
     *
     * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
     * an array sorted by quality is returned:
     *
     *     ['utf-8', 'utf-7', 'iso-8859-1']
     *
     * @param {String|Array} charset(s)...
     * @return {String|Array}
     * @api public
     */
    
    Accepts.prototype.charset =
    Accepts.prototype.charsets = function (charsets) {
      if (!Array.isArray(charsets)) charsets = [].slice.call(arguments);
      var n = this.negotiator;
      if (!charsets.length) return n.charsets();
      if (!this.headers['accept-charset']) return charsets[0];
      return n.charsets(charsets)[0] || false;
    }
    
    /**
     * Return accepted languages or best fit based on `langs`.
     *
     * Given `Accept-Language: en;q=0.8, es, pt`
     * an array sorted by quality is returned:
     *
     *     ['es', 'pt', 'en']
     *
     * @param {String|Array} lang(s)...
     * @return {Array|String}
     * @api public
     */
    
    Accepts.prototype.lang =
    Accepts.prototype.langs =
    Accepts.prototype.language =
    Accepts.prototype.languages = function (langs) {
      if (!Array.isArray(langs)) langs = slice.call(arguments);
      var n = this.negotiator;
      if (!langs.length) return n.languages();
      if (!this.headers['accept-language']) return langs[0];
      return n.languages(langs)[0] || false;
    }
    
    /**
     * Convert extnames to mime.
     *
     * @param {String} type
     * @return {String}
     * @api private
     */
    
    function extToMime(type) {
      if (~type.indexOf('/')) return type;
      return mime.lookup(type);
    }
    
    /**
     * Check if mime is valid.
     *
     * @param {String} type
     * @return {String}
     * @api private
     */
    
    function validMime(type) {
      return typeof type === 'string';
    }
    
  provide("accepts", module.exports);
}(global));

// pakmanager:content-disposition
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * content-disposition
     * Copyright(c) 2014 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    /**
     * Module exports.
     */
    
    module.exports = contentDisposition
    module.exports.parse = parse
    
    /**
     * Module dependencies.
     */
    
    var basename = require('path').basename
    
    /**
     * RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including "%")
     */
    
    var encodeUriAttrCharRegExp = /[\x00-\x20"'\(\)*,\/:;<=>?@\[\\\]\{\}\x7f]/g
    
    /**
     * RegExp to match percent encoding escape.
     */
    
    var hexEscapeRegExp = /%[0-9A-Fa-f]{2}/
    var hexEscapeReplaceRegExp = /%([0-9A-Fa-f]{2})/g
    
    /**
     * RegExp to match non-latin1 characters.
     */
    
    var nonLatin1RegExp = /[^\x20-\x7e\xa0-\xff]/g
    
    /**
     * RegExp to match quoted-pair in RFC 2616
     *
     * quoted-pair = "\" CHAR
     * CHAR        = <any US-ASCII character (octets 0 - 127)>
     */
    
    var qescRegExp = /\\([\u0000-\u007f])/g;
    
    /**
     * RegExp to match chars that must be quoted-pair in RFC 2616
     */
    
    var quoteRegExp = /([\\"])/g
    
    /**
     * RegExp for various RFC 2616 grammar
     *
     * parameter     = token "=" ( token | quoted-string )
     * token         = 1*<any CHAR except CTLs or separators>
     * separators    = "(" | ")" | "<" | ">" | "@"
     *               | "," | ";" | ":" | "\" | <">
     *               | "/" | "[" | "]" | "?" | "="
     *               | "{" | "}" | SP | HT
     * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
     * qdtext        = <any TEXT except <">>
     * quoted-pair   = "\" CHAR
     * CHAR          = <any US-ASCII character (octets 0 - 127)>
     * TEXT          = <any OCTET except CTLs, but including LWS>
     * LWS           = [CRLF] 1*( SP | HT )
     * CRLF          = CR LF
     * CR            = <US-ASCII CR, carriage return (13)>
     * LF            = <US-ASCII LF, linefeed (10)>
     * SP            = <US-ASCII SP, space (32)>
     * HT            = <US-ASCII HT, horizontal-tab (9)>
     * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
     * OCTET         = <any 8-bit sequence of data>
     */
    
    var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g
    var textRegExp = /^[\x20-\x7e\x80-\xff]+$/
    var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/
    
    /**
     * RegExp for various RFC 5987 grammar
     *
     * ext-value     = charset  "'" [ language ] "'" value-chars
     * charset       = "UTF-8" / "ISO-8859-1" / mime-charset
     * mime-charset  = 1*mime-charsetc
     * mime-charsetc = ALPHA / DIGIT
     *               / "!" / "#" / "$" / "%" / "&"
     *               / "+" / "-" / "^" / "_" / "`"
     *               / "{" / "}" / "~"
     * language      = ( 2*3ALPHA [ extlang ] )
     *               / 4ALPHA
     *               / 5*8ALPHA
     * extlang       = *3( "-" 3ALPHA )
     * value-chars   = *( pct-encoded / attr-char )
     * pct-encoded   = "%" HEXDIG HEXDIG
     * attr-char     = ALPHA / DIGIT
     *               / "!" / "#" / "$" / "&" / "+" / "-" / "."
     *               / "^" / "_" / "`" / "|" / "~"
     */
    
    var extValueRegExp = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+\-\.^_`|~])+)$/
    
    /**
     * RegExp for various RFC 6266 grammar
     *
     * disposition-type = "inline" | "attachment" | disp-ext-type
     * disp-ext-type    = token
     * disposition-parm = filename-parm | disp-ext-parm
     * filename-parm    = "filename" "=" value
     *                  | "filename*" "=" ext-value
     * disp-ext-parm    = token "=" value
     *                  | ext-token "=" ext-value
     * ext-token        = <the characters in token, followed by "*">
     */
    
    var dispositionTypeRegExp = /^([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *(?:$|;)/
    
    /**
     * Create an attachment Content-Disposition header.
     *
     * @param {string} [filename]
     * @param {object} [options]
     * @param {string} [options.type=attachment]
     * @param {string|boolean} [options.fallback=true]
     * @return {string}
     * @api public
     */
    
    function contentDisposition(filename, options) {
      var opts = options || {}
    
      // get type
      var type = opts.type || 'attachment'
    
      // get parameters
      var params = createparams(filename, opts.fallback)
    
      // format into string
      return format(new ContentDisposition(type, params))
    }
    
    /**
     * Create parameters object from filename and fallback.
     *
     * @param {string} [filename]
     * @param {string|boolean} [fallback=true]
     * @return {object}
     * @api private
     */
    
    function createparams(filename, fallback) {
      if (filename === undefined) {
        return
      }
    
      var params = {}
    
      if (typeof filename !== 'string') {
        throw new TypeError('filename must be a string')
      }
    
      // fallback defaults to true
      if (fallback === undefined) {
        fallback = true
      }
    
      if (typeof fallback !== 'string' && typeof fallback !== 'boolean') {
        throw new TypeError('fallback must be a string or boolean')
      }
    
      if (typeof fallback === 'string' && nonLatin1RegExp.test(fallback)) {
        throw new TypeError('fallback must be ISO-8859-1 string')
      }
    
      // restrict to file base name
      var name = basename(filename)
    
      // determine if name is suitable for quoted string
      var isQuotedString = textRegExp.test(name)
    
      // generate fallback name
      var fallbackName = typeof fallback !== 'string'
        ? fallback && getlatin1(name)
        : basename(fallback)
      var hasFallback = typeof fallbackName === 'string' && fallbackName !== name
    
      // set extended filename parameter
      if (hasFallback || !isQuotedString || hexEscapeRegExp.test(name)) {
        params['filename*'] = name
      }
    
      // set filename parameter
      if (isQuotedString || hasFallback) {
        params.filename = hasFallback
          ? fallbackName
          : name
      }
    
      return params
    }
    
    /**
     * Format object to Content-Disposition header.
     *
     * @param {object} obj
     * @param {string} obj.type
     * @param {object} [obj.parameters]
     * @return {string}
     * @api private
     */
    
    function format(obj) {
      var parameters = obj.parameters
      var type = obj.type
    
      if (!type || typeof type !== 'string' || !tokenRegExp.test(type)) {
        throw new TypeError('invalid type')
      }
    
      // start with normalized type
      var string = String(type).toLowerCase()
    
      // append parameters
      if (parameters && typeof parameters === 'object') {
        var param
        var params = Object.keys(parameters).sort()
    
        for (var i = 0; i < params.length; i++) {
          param = params[i]
    
          var val = param.substr(-1) === '*'
            ? ustring(parameters[param])
            : qstring(parameters[param])
    
          string += '; ' + param + '=' + val
        }
      }
    
      return string
    }
    
    /**
     * Decode a RFC 6987 field value (gracefully).
     *
     * @param {string} str
     * @return {string}
     * @api private
     */
    
    function decodefield(str) {
      var match = extValueRegExp.exec(str)
    
      if (!match) {
        throw new TypeError('invalid extended field value')
      }
    
      var charset = match[1].toLowerCase()
      var encoded = match[2]
      var value
    
      // to binary string
      var binary = encoded.replace(hexEscapeReplaceRegExp, pdecode)
    
      switch (charset) {
        case 'iso-8859-1':
          value = getlatin1(binary)
          break
        case 'utf-8':
          value = new Buffer(binary, 'binary').toString('utf8')
          break
        default:
          throw new TypeError('unsupported charset in extended field')
      }
    
      return value
    }
    
    /**
     * Get ISO-8859-1 version of string.
     *
     * @param {string} val
     * @return {string}
     * @api private
     */
    
    function getlatin1(val) {
      // simple Unicode -> ISO-8859-1 transformation
      return String(val).replace(nonLatin1RegExp, '?')
    }
    
    /**
     * Parse Content-Disposition header string.
     *
     * @param {string} string
     * @return {object}
     * @api private
     */
    
    function parse(string) {
      if (!string || typeof string !== 'string') {
        throw new TypeError('argument string is required')
      }
    
      var match = dispositionTypeRegExp.exec(string)
    
      if (!match) {
        throw new TypeError('invalid type format')
      }
    
      // normalize type
      var index = match[0].length
      var type = match[1].toLowerCase()
    
      var key
      var names = []
      var params = {}
      var value
    
      // calculate index to start at
      index = paramRegExp.lastIndex = match[0].substr(-1) === ';'
        ? index - 1
        : index
    
      // match parameters
      while (match = paramRegExp.exec(string)) {
        if (match.index !== index) {
          throw new TypeError('invalid parameter format')
        }
    
        index += match[0].length
        key = match[1].toLowerCase()
        value = match[2]
    
        if (names.indexOf(key) !== -1) {
          throw new TypeError('invalid duplicate parameter')
        }
    
        names.push(key)
    
        if (key.indexOf('*') + 1 === key.length) {
          // decode extended value
          key = key.slice(0, -1)
          value = decodefield(value)
    
          // overwrite existing value
          params[key] = value
          continue
        }
    
        if (typeof params[key] === 'string') {
          continue
        }
    
        if (value[0] === '"') {
          // remove quotes and escapes
          value = value
            .substr(1, value.length - 2)
            .replace(qescRegExp, '$1')
        }
    
        params[key] = value
      }
    
      if (index !== -1 && index !== string.length) {
        throw new TypeError('invalid parameter format')
      }
    
      return new ContentDisposition(type, params)
    }
    
    /**
     * Percent decode a single character.
     *
     * @param {string} str
     * @param {string} hex
     * @return {string}
     * @api private
     */
    
    function pdecode(str, hex) {
      return String.fromCharCode(parseInt(hex, 16))
    }
    
    /**
     * Percent encode a single character.
     *
     * @param {string} char
     * @return {string}
     * @api private
     */
    
    function pencode(char) {
      var hex = String(char)
        .charCodeAt(0)
        .toString(16)
        .toUpperCase()
      return hex.length === 1
        ? '%0' + hex
        : '%' + hex
    }
    
    /**
     * Quote a string for HTTP.
     *
     * @param {string} val
     * @return {string}
     * @api private
     */
    
    function qstring(val) {
      var str = String(val)
    
      return '"' + str.replace(quoteRegExp, '\\$1') + '"'
    }
    
    /**
     * Encode a Unicode string for HTTP (RFC 5987).
     *
     * @param {string} val
     * @return {string}
     * @api private
     */
    
    function ustring(val) {
      var str = String(val)
    
      // percent encode as UTF-8
      var encoded = encodeURIComponent(str)
        .replace(encodeUriAttrCharRegExp, pencode)
    
      return 'UTF-8\'\'' + encoded
    }
    
    /**
     * Class for parsed Content-Disposition header for v8 optimization
     */
    
    function ContentDisposition(type, parameters) {
      this.type = type
      this.parameters = parameters
    }
    
  provide("content-disposition", module.exports);
}(global));

// pakmanager:finalhandler
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * finalhandler
     * Copyright(c) 2014 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    /**
     * Module dependencies.
     */
    
    var debug = require('debug')('finalhandler')
    var escapeHtml = require('escape-html')
    var http = require('http')
    var onFinished = require('on-finished')
    
    /**
     * Variables.
     */
    
    /* istanbul ignore next */
    var defer = typeof setImmediate === 'function'
      ? setImmediate
      : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }
    var isFinished = onFinished.isFinished
    
    /**
     * Module exports.
     */
    
    module.exports = finalhandler
    
    /**
     * Final handler:
     *
     * @param {Request} req
     * @param {Response} res
     * @param {Object} [options]
     * @return {Function}
     * @api public
     */
    
    function finalhandler(req, res, options) {
      options = options || {}
    
      // get environment
      var env = options.env || process.env.NODE_ENV || 'development'
    
      // get error callback
      var onerror = options.onerror
    
      return function (err) {
        var msg
    
        // ignore 404 on in-flight response
        if (!err && res._header) {
          debug('cannot 404 after headers sent')
          return
        }
    
        // unhandled error
        if (err) {
          // default status code to 500
          if (!res.statusCode || res.statusCode < 400) {
            res.statusCode = 500
          }
    
          // respect err.status
          if (err.status) {
            res.statusCode = err.status
          }
    
          // production gets a basic error message
          var msg = env === 'production'
            ? http.STATUS_CODES[res.statusCode]
            : err.stack || err.toString()
          msg = escapeHtml(msg)
            .replace(/\n/g, '<br>')
            .replace(/  /g, ' &nbsp;') + '\n'
        } else {
          res.statusCode = 404
          msg = 'Cannot ' + escapeHtml(req.method) + ' ' + escapeHtml(req.originalUrl || req.url) + '\n'
        }
    
        debug('default %s', res.statusCode)
    
        // schedule onerror callback
        if (err && onerror) {
          defer(onerror, err, req, res)
        }
    
        // cannot actually respond
        if (res._header) {
          return req.socket.destroy()
        }
    
        send(req, res, res.statusCode, msg)
      }
    }
    
    /**
     * Send response.
     *
     * @param {IncomingMessage} req
     * @param {OutgoingMessage} res
     * @param {number} status
     * @param {string} body
     * @api private
     */
    
    function send(req, res, status, body) {
      function write() {
        res.statusCode = status
    
        // security header for content sniffing
        res.setHeader('X-Content-Type-Options', 'nosniff')
    
        // standard headers
        res.setHeader('Content-Type', 'text/html; charset=utf-8')
        res.setHeader('Content-Length', Buffer.byteLength(body, 'utf8'))
    
        if (req.method === 'HEAD') {
          res.end()
          return
        }
    
        res.end(body, 'utf8')
      }
    
      if (isFinished(req)) {
        write()
        return
      }
    
      // unpipe everything from the request
      unpipe(req)
    
      // flush the request
      onFinished(req, write)
      req.resume()
    }
    
    /**
     * Unpipe everything from a stream.
     *
     * @param {Object} stream
     * @api private
     */
    
    /* istanbul ignore next: implementation differs between versions */
    function unpipe(stream) {
      if (typeof stream.unpipe === 'function') {
        // new-style
        stream.unpipe()
        return
      }
    
      // Node.js 0.8 hack
      var listener
      var listeners = stream.listeners('close')
    
      for (var i = 0; i < listeners.length; i++) {
        listener = listeners[i]
    
        if (listener.name !== 'cleanup' && listener.name !== 'onclose') {
          continue
        }
    
        // invoke the listener
        listener.call(stream)
      }
    }
    
  provide("finalhandler", module.exports);
}(global));

// pakmanager:merge-descriptors
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * merge-descriptors
     * Copyright(c) 2014 Jonathan Ong
     * MIT Licensed
     */
    
    /**
     * Module exports.
     * @public
     */
    
    module.exports = merge
    
    /**
     * Module variables.
     * @private
     */
    
    var hasOwnProperty = Object.prototype.hasOwnProperty
    
    /**
     * Merge the property descriptors of `src` into `dest`
     *
     * @param {object} dest Object to add descriptors to
     * @param {object} src Object to clone descriptors from
     * @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties
     * @returns {object} Reference to dest
     * @public
     */
    
    function merge(dest, src, redefine) {
      if (!dest) {
        throw new TypeError('argument dest is required')
      }
    
      if (!src) {
        throw new TypeError('argument src is required')
      }
    
      if (redefine === undefined) {
        // Default to true
        redefine = true
      }
    
      Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {
        if (!redefine && hasOwnProperty.call(dest, name)) {
          // Skip desriptor
          return
        }
    
        // Copy descriptor
        var descriptor = Object.getOwnPropertyDescriptor(src, name)
        Object.defineProperty(dest, name, descriptor)
      })
    
      return dest
    }
    
  provide("merge-descriptors", module.exports);
}(global));

// pakmanager:methods
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    var http = require('http');
    
    /* istanbul ignore next: implementation differs on version */
    if (http.METHODS) {
    
      module.exports = http.METHODS.map(function(method){
        return method.toLowerCase();
      });
    
    } else {
    
      module.exports = [
        'get',
        'post',
        'put',
        'head',
        'delete',
        'options',
        'trace',
        'copy',
        'lock',
        'mkcol',
        'move',
        'purge',
        'propfind',
        'proppatch',
        'unlock',
        'report',
        'mkactivity',
        'checkout',
        'merge',
        'm-search',
        'notify',
        'subscribe',
        'unsubscribe',
        'patch',
        'search',
        'connect'
      ];
    
    }
    
  provide("methods", module.exports);
}(global));

// pakmanager:path-to-regexp
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var isarray = require('isarray')
    
    /**
     * Expose `pathToRegexp`.
     */
    module.exports = pathToRegexp
    module.exports.parse = parse
    module.exports.compile = compile
    module.exports.tokensToFunction = tokensToFunction
    module.exports.tokensToRegExp = tokensToRegExp
    
    /**
     * The main path matching regexp utility.
     *
     * @type {RegExp}
     */
    var PATH_REGEXP = new RegExp([
      // Match escaped characters that would otherwise appear in future matches.
      // This allows the user to escape special characters that won't transform.
      '(\\\\.)',
      // Match Express-style parameters and un-named parameters with a prefix
      // and optional suffixes. Matches appear as:
      //
      // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
      // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
      // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
      '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^()])+)\\))?|\\(((?:\\\\.|[^()])+)\\))([+*?])?|(\\*))'
    ].join('|'), 'g')
    
    /**
     * Parse a string for the raw tokens.
     *
     * @param  {String} str
     * @return {Array}
     */
    function parse (str) {
      var tokens = []
      var key = 0
      var index = 0
      var path = ''
      var res
    
      while ((res = PATH_REGEXP.exec(str)) != null) {
        var m = res[0]
        var escaped = res[1]
        var offset = res.index
        path += str.slice(index, offset)
        index = offset + m.length
    
        // Ignore already escaped sequences.
        if (escaped) {
          path += escaped[1]
          continue
        }
    
        // Push the current path onto the tokens.
        if (path) {
          tokens.push(path)
          path = ''
        }
    
        var prefix = res[2]
        var name = res[3]
        var capture = res[4]
        var group = res[5]
        var suffix = res[6]
        var asterisk = res[7]
    
        var repeat = suffix === '+' || suffix === '*'
        var optional = suffix === '?' || suffix === '*'
        var delimiter = prefix || '/'
        var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')
    
        tokens.push({
          name: name || key++,
          prefix: prefix || '',
          delimiter: delimiter,
          optional: optional,
          repeat: repeat,
          pattern: escapeGroup(pattern)
        })
      }
    
      // Match any characters still remaining.
      if (index < str.length) {
        path += str.substr(index)
      }
    
      // If the path exists, push it onto the end.
      if (path) {
        tokens.push(path)
      }
    
      return tokens
    }
    
    /**
     * Compile a string to a template function for the path.
     *
     * @param  {String}   str
     * @return {Function}
     */
    function compile (str) {
      return tokensToFunction(parse(str))
    }
    
    /**
     * Expose a method for transforming tokens into the path function.
     */
    function tokensToFunction (tokens) {
      // Compile all the tokens into regexps.
      var matches = new Array(tokens.length)
    
      // Compile all the patterns before compilation.
      for (var i = 0; i < tokens.length; i++) {
        if (typeof tokens[i] === 'object') {
          matches[i] = new RegExp('^' + tokens[i].pattern + '$')
        }
      }
    
      return function (obj) {
        var path = ''
    
        obj = obj || {}
    
        for (var i = 0; i < tokens.length; i++) {
          var key = tokens[i]
    
          if (typeof key === 'string') {
            path += key
    
            continue
          }
    
          var value = obj[key.name]
    
          if (value == null) {
            if (key.optional) {
              continue
            } else {
              throw new TypeError('Expected "' + key.name + '" to be defined')
            }
          }
    
          if (isarray(value)) {
            if (!key.repeat) {
              throw new TypeError('Expected "' + key.name + '" to not repeat')
            }
    
            if (value.length === 0) {
              if (key.optional) {
                continue
              } else {
                throw new TypeError('Expected "' + key.name + '" to not be empty')
              }
            }
    
            for (var j = 0; j < value.length; j++) {
              if (!matches[i].test(value[j])) {
                throw new TypeError('Expected all "' + key.name + '" to match "' + key.pattern + '"')
              }
    
              path += (j === 0 ? key.prefix : key.delimiter) + encodeURIComponent(value[j])
            }
    
            continue
          }
    
          if (!matches[i].test(value)) {
            throw new TypeError('Expected "' + key.name + '" to match "' + key.pattern + '"')
          }
    
          path += key.prefix + encodeURIComponent(value)
        }
    
        return path
      }
    }
    
    /**
     * Escape a regular expression string.
     *
     * @param  {String} str
     * @return {String}
     */
    function escapeString (str) {
      return str.replace(/([.+*?=^!:${}()[\]|\/])/g, '\\$1')
    }
    
    /**
     * Escape the capturing group by escaping special characters and meaning.
     *
     * @param  {String} group
     * @return {String}
     */
    function escapeGroup (group) {
      return group.replace(/([=!:$\/()])/g, '\\$1')
    }
    
    /**
     * Attach the keys as a property of the regexp.
     *
     * @param  {RegExp} re
     * @param  {Array}  keys
     * @return {RegExp}
     */
    function attachKeys (re, keys) {
      re.keys = keys
      return re
    }
    
    /**
     * Get the flags for a regexp from the options.
     *
     * @param  {Object} options
     * @return {String}
     */
    function flags (options) {
      return options.sensitive ? '' : 'i'
    }
    
    /**
     * Pull out keys from a regexp.
     *
     * @param  {RegExp} path
     * @param  {Array}  keys
     * @return {RegExp}
     */
    function regexpToRegexp (path, keys) {
      // Use a negative lookahead to match only capturing groups.
      var groups = path.source.match(/\((?!\?)/g)
    
      if (groups) {
        for (var i = 0; i < groups.length; i++) {
          keys.push({
            name: i,
            prefix: null,
            delimiter: null,
            optional: false,
            repeat: false,
            pattern: null
          })
        }
      }
    
      return attachKeys(path, keys)
    }
    
    /**
     * Transform an array into a regexp.
     *
     * @param  {Array}  path
     * @param  {Array}  keys
     * @param  {Object} options
     * @return {RegExp}
     */
    function arrayToRegexp (path, keys, options) {
      var parts = []
    
      for (var i = 0; i < path.length; i++) {
        parts.push(pathToRegexp(path[i], keys, options).source)
      }
    
      var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))
    
      return attachKeys(regexp, keys)
    }
    
    /**
     * Create a path regexp from string input.
     *
     * @param  {String} path
     * @param  {Array}  keys
     * @param  {Object} options
     * @return {RegExp}
     */
    function stringToRegexp (path, keys, options) {
      var tokens = parse(path)
      var re = tokensToRegExp(tokens, options)
    
      // Attach keys back to the regexp.
      for (var i = 0; i < tokens.length; i++) {
        if (typeof tokens[i] !== 'string') {
          keys.push(tokens[i])
        }
      }
    
      return attachKeys(re, keys)
    }
    
    /**
     * Expose a function for taking tokens and returning a RegExp.
     *
     * @param  {Array}  tokens
     * @param  {Array}  keys
     * @param  {Object} options
     * @return {RegExp}
     */
    function tokensToRegExp (tokens, options) {
      options = options || {}
    
      var strict = options.strict
      var end = options.end !== false
      var route = ''
      var lastToken = tokens[tokens.length - 1]
      var endsWithSlash = typeof lastToken === 'string' && /\/$/.test(lastToken)
    
      // Iterate over the tokens and create our regexp string.
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i]
    
        if (typeof token === 'string') {
          route += escapeString(token)
        } else {
          var prefix = escapeString(token.prefix)
          var capture = token.pattern
    
          if (token.repeat) {
            capture += '(?:' + prefix + capture + ')*'
          }
    
          if (token.optional) {
            if (prefix) {
              capture = '(?:' + prefix + '(' + capture + '))?'
            } else {
              capture = '(' + capture + ')?'
            }
          } else {
            capture = prefix + '(' + capture + ')'
          }
    
          route += capture
        }
      }
    
      // In non-strict mode we allow a slash at the end of match. If the path to
      // match already ends with a slash, we remove it for consistency. The slash
      // is valid at the end of a path match, not in the middle. This is important
      // in non-ending mode, where "/test/" shouldn't match "/test//route".
      if (!strict) {
        route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?'
      }
    
      if (end) {
        route += '$'
      } else {
        // In non-ending mode, we need the capturing groups to match as much as
        // possible by using a positive lookahead to the end or next path segment.
        route += strict && endsWithSlash ? '' : '(?=\\/|$)'
      }
    
      return new RegExp('^' + route, flags(options))
    }
    
    /**
     * Normalize the given path string, returning a regular expression.
     *
     * An empty array can be passed in for the keys, which will hold the
     * placeholder key descriptions. For example, using `/user/:id`, `keys` will
     * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
     *
     * @param  {(String|RegExp|Array)} path
     * @param  {Array}                 [keys]
     * @param  {Object}                [options]
     * @return {RegExp}
     */
    function pathToRegexp (path, keys, options) {
      keys = keys || []
    
      if (!isarray(keys)) {
        options = keys
        keys = []
      } else if (!options) {
        options = {}
      }
    
      if (path instanceof RegExp) {
        return regexpToRegexp(path, keys, options)
      }
    
      if (isarray(path)) {
        return arrayToRegexp(path, keys, options)
      }
    
      return stringToRegexp(path, keys, options)
    }
    
  provide("path-to-regexp", module.exports);
}(global));

// pakmanager:proxy-addr
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * proxy-addr
     * Copyright(c) 2014 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    /**
     * Module exports.
     */
    
    module.exports = proxyaddr;
    module.exports.all = alladdrs;
    module.exports.compile = compile;
    
    /**
     * Module dependencies.
     */
    
    var forwarded = require('forwarded');
    var ipaddr = require('ipaddr.js');
    
    /**
     * Variables.
     */
    
    var digitre = /^[0-9]+$/;
    var isip = ipaddr.isValid;
    var parseip = ipaddr.parse;
    
    /**
     * Pre-defined IP ranges.
     */
    
    var ipranges = {
      linklocal: ['169.254.0.0/16', 'fe80::/10'],
      loopback: ['127.0.0.1/8', '::1/128'],
      uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']
    };
    
    /**
     * Get all addresses in the request, optionally stopping
     * at the first untrusted.
     *
     * @param {Object} request
     * @param {Function|Array|String} [trust]
     * @api public
     */
    
    function alladdrs(req, trust) {
      // get addresses
      var addrs = forwarded(req);
    
      if (!trust) {
        // Return all addresses
        return addrs;
      }
    
      if (typeof trust !== 'function') {
        trust = compile(trust);
      }
    
      for (var i = 0; i < addrs.length - 1; i++) {
        if (trust(addrs[i], i)) continue;
    
        addrs.length = i + 1;
      }
    
      return addrs;
    }
    
    /**
     * Compile argument into trust function.
     *
     * @param {Array|String} val
     * @api private
     */
    
    function compile(val) {
      if (!val) {
        throw new TypeError('argument is required');
      }
    
      var trust = typeof val === 'string'
        ? [val]
        : val;
    
      if (!Array.isArray(trust)) {
        throw new TypeError('unsupported trust argument');
      }
    
      for (var i = 0; i < trust.length; i++) {
        val = trust[i];
    
        if (!ipranges.hasOwnProperty(val)) {
          continue;
        }
    
        // Splice in pre-defined range
        val = ipranges[val];
        trust.splice.apply(trust, [i, 1].concat(val));
        i += val.length - 1;
      }
    
      return compileTrust(compileRangeSubnets(trust));
    }
    
    /**
     * Compile `arr` elements into range subnets.
     *
     * @param {Array} arr
     * @api private
     */
    
    function compileRangeSubnets(arr) {
      var rangeSubnets = new Array(arr.length);
    
      for (var i = 0; i < arr.length; i++) {
        rangeSubnets[i] = parseipNotation(arr[i]);
      }
    
      return rangeSubnets;
    }
    
    /**
     * Compile range subnet array into trust function.
     *
     * @param {Array} rangeSubnets
     * @api private
     */
    
    function compileTrust(rangeSubnets) {
      // Return optimized function based on length
      var len = rangeSubnets.length;
      return len === 0
        ? trustNone
        : len === 1
        ? trustSingle(rangeSubnets[0])
        : trustMulti(rangeSubnets);
    }
    
    /**
     * Parse IP notation string into range subnet.
     *
     * @param {String} note
     * @api private
     */
    
    function parseipNotation(note) {
      var ip;
      var kind;
      var max;
      var pos = note.lastIndexOf('/');
      var range;
    
      ip = pos !== -1
        ? note.substring(0, pos)
        : note;
    
      if (!isip(ip)) {
        throw new TypeError('invalid IP address: ' + ip);
      }
    
      ip = parseip(ip);
    
      kind = ip.kind();
      max = kind === 'ipv6'
        ? 128
        : 32;
    
      range = pos !== -1
        ? note.substring(pos + 1, note.length)
        : max;
    
      if (typeof range !== 'number') {
        range = digitre.test(range)
          ? parseInt(range, 10)
          : isip(range)
          ? parseNetmask(range)
          : 0;
      }
    
      if (ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {
        // Store as IPv4
        ip = ip.toIPv4Address();
        range = range <= max
          ? range - 96
          : range;
      }
    
      if (range <= 0 || range > max) {
        throw new TypeError('invalid range on address: ' + note);
      }
    
      return [ip, range];
    }
    
    /**
     * Parse netmask string into CIDR range.
     *
     * @param {String} note
     * @api private
     */
    
    function parseNetmask(netmask) {
      var ip = parseip(netmask);
      var parts;
      var size;
    
      switch (ip.kind()) {
        case 'ipv4':
          parts = ip.octets;
          size = 8;
          break;
        case 'ipv6':
          parts = ip.parts;
          size = 16;
          break;
      }
    
      var max = Math.pow(2, size) - 1;
      var part;
      var range = 0;
    
      for (var i = 0; i < parts.length; i++) {
        part = parts[i] & max;
    
        if (part === max) {
          range += size;
          continue;
        }
    
        while (part) {
          part = (part << 1) & max;
          range += 1;
        }
    
        break;
      }
    
      return range;
    }
    
    /**
     * Determine address of proxied request.
     *
     * @param {Object} request
     * @param {Function|Array|String} trust
     * @api public
     */
    
    function proxyaddr(req, trust) {
      if (!req) {
        throw new TypeError('req argument is required');
      }
    
      if (!trust) {
        throw new TypeError('trust argument is required');
      }
    
      var addrs = alladdrs(req, trust);
      var addr = addrs[addrs.length - 1];
    
      return addr;
    }
    
    /**
     * Static trust function to trust nothing.
     *
     * @api private
     */
    
    function trustNone() {
      return false;
    }
    
    /**
     * Compile trust function for multiple subnets.
     *
     * @param {Array} subnets
     * @api private
     */
    
    function trustMulti(subnets) {
      return function trust(addr) {
        if (!isip(addr)) return false;
    
        var ip = parseip(addr);
        var ipv4;
        var kind = ip.kind();
        var subnet;
        var subnetip;
        var subnetkind;
        var subnetrange;
        var trusted;
    
        for (var i = 0; i < subnets.length; i++) {
          subnet = subnets[i];
          subnetip = subnet[0];
          subnetkind = subnetip.kind();
          subnetrange = subnet[1];
          trusted = ip;
    
          if (kind !== subnetkind) {
            if (kind !== 'ipv6' || subnetkind !== 'ipv4' || !ip.isIPv4MappedAddress()) {
              continue;
            }
    
            // Store addr as IPv4
            ipv4 = ipv4 || ip.toIPv4Address();
            trusted = ipv4;
          }
    
          if (trusted.match(subnetip, subnetrange)) return true;
        }
    
        return false;
      };
    }
    
    /**
     * Compile trust function for single subnet.
     *
     * @param {Object} subnet
     * @api private
     */
    
    function trustSingle(subnet) {
      var subnetip = subnet[0];
      var subnetkind = subnetip.kind();
      var subnetisipv4 = subnetkind === 'ipv4';
      var subnetrange = subnet[1];
    
      return function trust(addr) {
        if (!isip(addr)) return false;
    
        var ip = parseip(addr);
        var kind = ip.kind();
    
        return kind === subnetkind
          ? ip.match(subnetip, subnetrange)
          : subnetisipv4 && kind === 'ipv6' && ip.isIPv4MappedAddress()
          ? ip.toIPv4Address().match(subnetip, subnetrange)
          : false;
      };
    }
    
  provide("proxy-addr", module.exports);
}(global));

// pakmanager:serve-static
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * serve-static
     * Copyright(c) 2010 Sencha Inc.
     * Copyright(c) 2011 TJ Holowaychuk
     * Copyright(c) 2014 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    /**
     * Module dependencies.
     */
    
    var escapeHtml = require('escape-html');
    var merge = require('utils-merge');
    var parseurl = require('parseurl');
    var resolve = require('path').resolve;
    var send = require('send');
    var url = require('url');
    
    /**
     * @param {String} root
     * @param {Object} options
     * @return {Function}
     * @api public
     */
    
    exports = module.exports = function serveStatic(root, options) {
      if (!root) {
        throw new TypeError('root path required')
      }
    
      if (typeof root !== 'string') {
        throw new TypeError('root path must be a string')
      }
    
      // copy options object
      options = merge({}, options)
    
      // resolve root to absolute
      root = resolve(root)
    
      // default redirect
      var redirect = options.redirect !== false
    
      // headers listener
      var setHeaders = options.setHeaders
      delete options.setHeaders
    
      if (setHeaders && typeof setHeaders !== 'function') {
        throw new TypeError('option setHeaders must be function')
      }
    
      // setup options for send
      options.maxage = options.maxage || options.maxAge || 0
      options.root = root
    
      return function serveStatic(req, res, next) {
        if (req.method !== 'GET' && req.method !== 'HEAD') {
          return next()
        }
    
        var opts = merge({}, options)
        var originalUrl = parseurl.original(req)
        var path = parseurl(req).pathname
        var hasTrailingSlash = originalUrl.pathname[originalUrl.pathname.length - 1] === '/'
    
        if (path === '/' && !hasTrailingSlash) {
          // make sure redirect occurs at mount
          path = ''
        }
    
        // create send stream
        var stream = send(req, path, opts)
    
        if (redirect) {
          // redirect relative to originalUrl
          stream.on('directory', function redirect() {
            if (hasTrailingSlash) {
              return next()
            }
    
            // append trailing slash
            originalUrl.path = null
            originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + '/')
    
            // reformat the URL
            var target = url.format(originalUrl)
    
            // send redirect response
            res.statusCode = 303
            res.setHeader('Content-Type', 'text/html; charset=utf-8')
            res.setHeader('Location', target)
            res.end('Redirecting to <a href="' + escapeHtml(target) + '">' + escapeHtml(target) + '</a>\n')
          })
        } else {
          // forward to next middleware on directory
          stream.on('directory', next)
        }
    
        // add headers listener
        if (setHeaders) {
          stream.on('headers', setHeaders)
        }
    
        // forward non-404 errors
        stream.on('error', function error(err) {
          next(err.status === 404 ? null : err)
        })
    
        // pipe
        stream.pipe(res)
      }
    }
    
    /**
     * Expose mime module.
     *
     * If you wish to extend the mime table use this
     * reference to the "mime" module in the npm registry.
     */
    
    exports.mime = send.mime
    
    /**
     * Collapse all leading slashes into a single slash
     * @private
     */
    function collapseLeadingSlashes(str) {
      for (var i = 0; i < str.length; i++) {
        if (str[i] !== '/') {
          break
        }
      }
    
      return i > 1
        ? '/' + str.substr(i)
        : str
    }
    
  provide("serve-static", module.exports);
}(global));

// pakmanager:vary
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * vary
     * Copyright(c) 2014 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    /**
     * Module exports.
     */
    
    module.exports = vary;
    module.exports.append = append;
    
    /**
     * Variables.
     */
    
    var separators = /[\(\)<>@,;:\\"\/\[\]\?=\{\}\u0020\u0009]/;
    
    /**
     * Append a field to a vary header.
     *
     * @param {String} header
     * @param {String|Array} field
     * @return {String}
     * @api public
     */
    
    function append(header, field) {
      if (typeof header !== 'string') {
        throw new TypeError('header argument is required');
      }
    
      if (!field) {
        throw new TypeError('field argument is required');
      }
    
      // get fields array
      var fields = !Array.isArray(field)
        ? parse(String(field))
        : field;
    
      // assert on invalid fields
      for (var i = 0; i < fields.length; i++) {
        if (separators.test(fields[i])) {
          throw new TypeError('field argument contains an invalid header');
        }
      }
    
      // existing, unspecified vary
      if (header === '*') {
        return header;
      }
    
      // enumerate current values
      var vals = parse(header.toLowerCase());
    
      // unspecified vary
      if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {
        return '*';
      }
    
      for (var i = 0; i < fields.length; i++) {
        field = fields[i].toLowerCase();
    
        // append value (case-preserving)
        if (vals.indexOf(field) === -1) {
          vals.push(field);
          header = header
            ? header + ', ' + fields[i]
            : fields[i];
        }
      }
    
      return header;
    }
    
    /**
     * Parse a vary header into an array.
     *
     * @param {String} header
     * @return {Array}
     * @api private
     */
    
    function parse(header) {
      return header.trim().split(/ *, */);
    }
    
    /**
     * Mark that a request is varied on a header field.
     *
     * @param {Object} res
     * @param {String|Array} field
     * @api public
     */
    
    function vary(res, field) {
      if (!res || !res.getHeader || !res.setHeader) {
        // quack quack
        throw new TypeError('res argument is required');
      }
    
      // get existing header
      var val = res.getHeader('Vary') || ''
      var header = Array.isArray(val)
        ? val.join(', ')
        : String(val);
    
      // set new header
      res.setHeader('Vary', append(header, field));
    }
    
  provide("vary", module.exports);
}(global));

// pakmanager:diff
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* See LICENSE file for terms of use */
    
    /*
     * Text diff implementation.
     *
     * This library supports the following APIS:
     * JsDiff.diffChars: Character by character diff
     * JsDiff.diffWords: Word (as defined by \b regex) diff which ignores whitespace
     * JsDiff.diffLines: Line based diff
     *
     * JsDiff.diffCss: Diff targeted at CSS content
     *
     * These methods are based on the implementation proposed in
     * "An O(ND) Difference Algorithm and its Variations" (Myers, 1986).
     * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927
     */
    (function(global, undefined) {
      var objectPrototypeToString = Object.prototype.toString;
    
      /*istanbul ignore next*/
      function map(arr, mapper, that) {
        if (Array.prototype.map) {
          return Array.prototype.map.call(arr, mapper, that);
        }
    
        var other = new Array(arr.length);
    
        for (var i = 0, n = arr.length; i < n; i++) {
          other[i] = mapper.call(that, arr[i], i, arr);
        }
        return other;
      }
      function clonePath(path) {
        return { newPos: path.newPos, components: path.components.slice(0) };
      }
      function removeEmpty(array) {
        var ret = [];
        for (var i = 0; i < array.length; i++) {
          if (array[i]) {
            ret.push(array[i]);
          }
        }
        return ret;
      }
      function escapeHTML(s) {
        var n = s;
        n = n.replace(/&/g, '&amp;');
        n = n.replace(/</g, '&lt;');
        n = n.replace(/>/g, '&gt;');
        n = n.replace(/"/g, '&quot;');
    
        return n;
      }
    
      // This function handles the presence of circular references by bailing out when encountering an
      // object that is already on the "stack" of items being processed.
      function canonicalize(obj, stack, replacementStack) {
        stack = stack || [];
        replacementStack = replacementStack || [];
    
        var i;
    
        for (i = 0; i < stack.length; i += 1) {
          if (stack[i] === obj) {
            return replacementStack[i];
          }
        }
    
        var canonicalizedObj;
    
        if ('[object Array]' === objectPrototypeToString.call(obj)) {
          stack.push(obj);
          canonicalizedObj = new Array(obj.length);
          replacementStack.push(canonicalizedObj);
          for (i = 0; i < obj.length; i += 1) {
            canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack);
          }
          stack.pop();
          replacementStack.pop();
        } else if (typeof obj === 'object' && obj !== null) {
          stack.push(obj);
          canonicalizedObj = {};
          replacementStack.push(canonicalizedObj);
          var sortedKeys = [],
              key;
          for (key in obj) {
            sortedKeys.push(key);
          }
          sortedKeys.sort();
          for (i = 0; i < sortedKeys.length; i += 1) {
            key = sortedKeys[i];
            canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack);
          }
          stack.pop();
          replacementStack.pop();
        } else {
          canonicalizedObj = obj;
        }
        return canonicalizedObj;
      }
    
      function buildValues(components, newString, oldString, useLongestToken) {
        var componentPos = 0,
            componentLen = components.length,
            newPos = 0,
            oldPos = 0;
    
        for (; componentPos < componentLen; componentPos++) {
          var component = components[componentPos];
          if (!component.removed) {
            if (!component.added && useLongestToken) {
              var value = newString.slice(newPos, newPos + component.count);
              value = map(value, function(value, i) {
                var oldValue = oldString[oldPos + i];
                return oldValue.length > value.length ? oldValue : value;
              });
    
              component.value = value.join('');
            } else {
              component.value = newString.slice(newPos, newPos + component.count).join('');
            }
            newPos += component.count;
    
            // Common case
            if (!component.added) {
              oldPos += component.count;
            }
          } else {
            component.value = oldString.slice(oldPos, oldPos + component.count).join('');
            oldPos += component.count;
    
            // Reverse add and remove so removes are output first to match common convention
            // The diffing algorithm is tied to add then remove output and this is the simplest
            // route to get the desired output with minimal overhead.
            if (componentPos && components[componentPos - 1].added) {
              var tmp = components[componentPos - 1];
              components[componentPos - 1] = components[componentPos];
              components[componentPos] = tmp;
            }
          }
        }
    
        return components;
      }
    
      function Diff(ignoreWhitespace) {
        this.ignoreWhitespace = ignoreWhitespace;
      }
      Diff.prototype = {
        diff: function(oldString, newString, callback) {
          var self = this;
    
          function done(value) {
            if (callback) {
              setTimeout(function() { callback(undefined, value); }, 0);
              return true;
            } else {
              return value;
            }
          }
    
          // Handle the identity case (this is due to unrolling editLength == 0
          if (newString === oldString) {
            return done([{ value: newString }]);
          }
          if (!newString) {
            return done([{ value: oldString, removed: true }]);
          }
          if (!oldString) {
            return done([{ value: newString, added: true }]);
          }
    
          newString = this.tokenize(newString);
          oldString = this.tokenize(oldString);
    
          var newLen = newString.length, oldLen = oldString.length;
          var editLength = 1;
          var maxEditLength = newLen + oldLen;
          var bestPath = [{ newPos: -1, components: [] }];
    
          // Seed editLength = 0, i.e. the content starts with the same values
          var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
          if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
            // Identity per the equality and tokenizer
            return done([{value: newString.join('')}]);
          }
    
          // Main worker method. checks all permutations of a given edit length for acceptance.
          function execEditLength() {
            for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
              var basePath;
              var addPath = bestPath[diagonalPath - 1],
                  removePath = bestPath[diagonalPath + 1],
                  oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
              if (addPath) {
                // No one else is going to attempt to use this value, clear it
                bestPath[diagonalPath - 1] = undefined;
              }
    
              var canAdd = addPath && addPath.newPos + 1 < newLen,
                  canRemove = removePath && 0 <= oldPos && oldPos < oldLen;
              if (!canAdd && !canRemove) {
                // If this path is a terminal then prune
                bestPath[diagonalPath] = undefined;
                continue;
              }
    
              // Select the diagonal that we want to branch from. We select the prior
              // path whose position in the new string is the farthest from the origin
              // and does not pass the bounds of the diff graph
              if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {
                basePath = clonePath(removePath);
                self.pushComponent(basePath.components, undefined, true);
              } else {
                basePath = addPath;   // No need to clone, we've pulled it from the list
                basePath.newPos++;
                self.pushComponent(basePath.components, true, undefined);
              }
    
              oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);
    
              // If we have hit the end of both strings, then we are done
              if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
                return done(buildValues(basePath.components, newString, oldString, self.useLongestToken));
              } else {
                // Otherwise track this path as a potential candidate and continue.
                bestPath[diagonalPath] = basePath;
              }
            }
    
            editLength++;
          }
    
          // Performs the length of edit iteration. Is a bit fugly as this has to support the
          // sync and async mode which is never fun. Loops over execEditLength until a value
          // is produced.
          if (callback) {
            (function exec() {
              setTimeout(function() {
                // This should not happen, but we want to be safe.
                /*istanbul ignore next */
                if (editLength > maxEditLength) {
                  return callback();
                }
    
                if (!execEditLength()) {
                  exec();
                }
              }, 0);
            }());
          } else {
            while (editLength <= maxEditLength) {
              var ret = execEditLength();
              if (ret) {
                return ret;
              }
            }
          }
        },
    
        pushComponent: function(components, added, removed) {
          var last = components[components.length - 1];
          if (last && last.added === added && last.removed === removed) {
            // We need to clone here as the component clone operation is just
            // as shallow array clone
            components[components.length - 1] = {count: last.count + 1, added: added, removed: removed };
          } else {
            components.push({count: 1, added: added, removed: removed });
          }
        },
        extractCommon: function(basePath, newString, oldString, diagonalPath) {
          var newLen = newString.length,
              oldLen = oldString.length,
              newPos = basePath.newPos,
              oldPos = newPos - diagonalPath,
    
              commonCount = 0;
          while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
            newPos++;
            oldPos++;
            commonCount++;
          }
    
          if (commonCount) {
            basePath.components.push({count: commonCount});
          }
    
          basePath.newPos = newPos;
          return oldPos;
        },
    
        equals: function(left, right) {
          var reWhitespace = /\S/;
          return left === right || (this.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right));
        },
        tokenize: function(value) {
          return value.split('');
        }
      };
    
      var CharDiff = new Diff();
    
      var WordDiff = new Diff(true);
      var WordWithSpaceDiff = new Diff();
      WordDiff.tokenize = WordWithSpaceDiff.tokenize = function(value) {
        return removeEmpty(value.split(/(\s+|\b)/));
      };
    
      var CssDiff = new Diff(true);
      CssDiff.tokenize = function(value) {
        return removeEmpty(value.split(/([{}:;,]|\s+)/));
      };
    
      var LineDiff = new Diff();
    
      var TrimmedLineDiff = new Diff();
      TrimmedLineDiff.ignoreTrim = true;
    
      LineDiff.tokenize = TrimmedLineDiff.tokenize = function(value) {
        var retLines = [],
            lines = value.split(/^/m);
        for (var i = 0; i < lines.length; i++) {
          var line = lines[i],
              lastLine = lines[i - 1],
              lastLineLastChar = lastLine && lastLine[lastLine.length - 1];
    
          // Merge lines that may contain windows new lines
          if (line === '\n' && lastLineLastChar === '\r') {
              retLines[retLines.length - 1] = retLines[retLines.length - 1].slice(0, -1) + '\r\n';
          } else {
            if (this.ignoreTrim) {
              line = line.trim();
              // add a newline unless this is the last line.
              if (i < lines.length - 1) {
                line += '\n';
              }
            }
            retLines.push(line);
          }
        }
    
        return retLines;
      };
    
      var PatchDiff = new Diff();
      PatchDiff.tokenize = function(value) {
        var ret = [],
            linesAndNewlines = value.split(/(\n|\r\n)/);
    
        // Ignore the final empty token that occurs if the string ends with a new line
        if (!linesAndNewlines[linesAndNewlines.length - 1]) {
          linesAndNewlines.pop();
        }
    
        // Merge the content and line separators into single tokens
        for (var i = 0; i < linesAndNewlines.length; i++) {
          var line = linesAndNewlines[i];
    
          if (i % 2) {
            ret[ret.length - 1] += line;
          } else {
            ret.push(line);
          }
        }
        return ret;
      };
    
      var SentenceDiff = new Diff();
      SentenceDiff.tokenize = function(value) {
        return removeEmpty(value.split(/(\S.+?[.!?])(?=\s+|$)/));
      };
    
      var JsonDiff = new Diff();
      // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
      // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:
      JsonDiff.useLongestToken = true;
      JsonDiff.tokenize = LineDiff.tokenize;
      JsonDiff.equals = function(left, right) {
        return LineDiff.equals(left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'));
      };
    
      var JsDiff = {
        Diff: Diff,
    
        diffChars: function(oldStr, newStr, callback) { return CharDiff.diff(oldStr, newStr, callback); },
        diffWords: function(oldStr, newStr, callback) { return WordDiff.diff(oldStr, newStr, callback); },
        diffWordsWithSpace: function(oldStr, newStr, callback) { return WordWithSpaceDiff.diff(oldStr, newStr, callback); },
        diffLines: function(oldStr, newStr, callback) { return LineDiff.diff(oldStr, newStr, callback); },
        diffTrimmedLines: function(oldStr, newStr, callback) { return TrimmedLineDiff.diff(oldStr, newStr, callback); },
    
        diffSentences: function(oldStr, newStr, callback) { return SentenceDiff.diff(oldStr, newStr, callback); },
    
        diffCss: function(oldStr, newStr, callback) { return CssDiff.diff(oldStr, newStr, callback); },
        diffJson: function(oldObj, newObj, callback) {
          return JsonDiff.diff(
            typeof oldObj === 'string' ? oldObj : JSON.stringify(canonicalize(oldObj), undefined, '  '),
            typeof newObj === 'string' ? newObj : JSON.stringify(canonicalize(newObj), undefined, '  '),
            callback
          );
        },
    
        createTwoFilesPatch: function(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader) {
          var ret = [];
    
          if (oldFileName == newFileName) {
            ret.push('Index: ' + oldFileName);
          }
          ret.push('===================================================================');
          ret.push('--- ' + oldFileName + (typeof oldHeader === 'undefined' ? '' : '\t' + oldHeader));
          ret.push('+++ ' + newFileName + (typeof newHeader === 'undefined' ? '' : '\t' + newHeader));
    
          var diff = PatchDiff.diff(oldStr, newStr);
          diff.push({value: '', lines: []});   // Append an empty value to make cleanup easier
    
          // Formats a given set of lines for printing as context lines in a patch
          function contextLines(lines) {
            return map(lines, function(entry) { return ' ' + entry; });
          }
    
          // Outputs the no newline at end of file warning if needed
          function eofNL(curRange, i, current) {
            var last = diff[diff.length - 2],
                isLast = i === diff.length - 2,
                isLastOfType = i === diff.length - 3 && current.added !== last.added;
    
            // Figure out if this is the last line for the given file and missing NL
            if (!(/\n$/.test(current.value)) && (isLast || isLastOfType)) {
              curRange.push('\\ No newline at end of file');
            }
          }
    
          var oldRangeStart = 0, newRangeStart = 0, curRange = [],
              oldLine = 1, newLine = 1;
          for (var i = 0; i < diff.length; i++) {
            var current = diff[i],
                lines = current.lines || current.value.replace(/\n$/, '').split('\n');
            current.lines = lines;
    
            if (current.added || current.removed) {
              // If we have previous context, start with that
              if (!oldRangeStart) {
                var prev = diff[i - 1];
                oldRangeStart = oldLine;
                newRangeStart = newLine;
    
                if (prev) {
                  curRange = contextLines(prev.lines.slice(-4));
                  oldRangeStart -= curRange.length;
                  newRangeStart -= curRange.length;
                }
              }
    
              // Output our changes
              curRange.push.apply(curRange, map(lines, function(entry) {
                return (current.added ? '+' : '-') + entry;
              }));
              eofNL(curRange, i, current);
    
              // Track the updated file position
              if (current.added) {
                newLine += lines.length;
              } else {
                oldLine += lines.length;
              }
            } else {
              // Identical context lines. Track line changes
              if (oldRangeStart) {
                // Close out any changes that have been output (or join overlapping)
                if (lines.length <= 8 && i < diff.length - 2) {
                  // Overlapping
                  curRange.push.apply(curRange, contextLines(lines));
                } else {
                  // end the range and output
                  var contextSize = Math.min(lines.length, 4);
                  ret.push(
                      '@@ -' + oldRangeStart + ',' + (oldLine - oldRangeStart + contextSize)
                      + ' +' + newRangeStart + ',' + (newLine - newRangeStart + contextSize)
                      + ' @@');
                  ret.push.apply(ret, curRange);
                  ret.push.apply(ret, contextLines(lines.slice(0, contextSize)));
                  if (lines.length <= 4) {
                    eofNL(ret, i, current);
                  }
    
                  oldRangeStart = 0;
                  newRangeStart = 0;
                  curRange = [];
                }
              }
              oldLine += lines.length;
              newLine += lines.length;
            }
          }
    
          return ret.join('\n') + '\n';
        },
    
        createPatch: function(fileName, oldStr, newStr, oldHeader, newHeader) {
          return JsDiff.createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader);
        },
    
        applyPatch: function(oldStr, uniDiff) {
          var diffstr = uniDiff.split('\n'),
              hunks = [],
              i = 0,
              remEOFNL = false,
              addEOFNL = false;
    
          // Skip to the first change hunk
          while (i < diffstr.length && !(/^@@/.test(diffstr[i]))) {
            i++;
          }
    
          // Parse the unified diff
          for (; i < diffstr.length; i++) {
            if (diffstr[i][0] === '@') {
              var chnukHeader = diffstr[i].split(/@@ -(\d+),(\d+) \+(\d+),(\d+) @@/);
              hunks.unshift({
                start: chnukHeader[3],
                oldlength: +chnukHeader[2],
                removed: [],
                newlength: chnukHeader[4],
                added: []
              });
            } else if (diffstr[i][0] === '+') {
              hunks[0].added.push(diffstr[i].substr(1));
            } else if (diffstr[i][0] === '-') {
              hunks[0].removed.push(diffstr[i].substr(1));
            } else if (diffstr[i][0] === ' ') {
              hunks[0].added.push(diffstr[i].substr(1));
              hunks[0].removed.push(diffstr[i].substr(1));
            } else if (diffstr[i][0] === '\\') {
              if (diffstr[i - 1][0] === '+') {
                remEOFNL = true;
              } else if (diffstr[i - 1][0] === '-') {
                addEOFNL = true;
              }
            }
          }
    
          // Apply the diff to the input
          var lines = oldStr.split('\n');
          for (i = hunks.length - 1; i >= 0; i--) {
            var hunk = hunks[i];
            // Sanity check the input string. Bail if we don't match.
            for (var j = 0; j < hunk.oldlength; j++) {
              if (lines[hunk.start - 1 + j] !== hunk.removed[j]) {
                return false;
              }
            }
            Array.prototype.splice.apply(lines, [hunk.start - 1, hunk.oldlength].concat(hunk.added));
          }
    
          // Handle EOFNL insertion/removal
          if (remEOFNL) {
            while (!lines[lines.length - 1]) {
              lines.pop();
            }
          } else if (addEOFNL) {
            lines.push('');
          }
          return lines.join('\n');
        },
    
        convertChangesToXML: function(changes) {
          var ret = [];
          for (var i = 0; i < changes.length; i++) {
            var change = changes[i];
            if (change.added) {
              ret.push('<ins>');
            } else if (change.removed) {
              ret.push('<del>');
            }
    
            ret.push(escapeHTML(change.value));
    
            if (change.added) {
              ret.push('</ins>');
            } else if (change.removed) {
              ret.push('</del>');
            }
          }
          return ret.join('');
        },
    
        // See: http://code.google.com/p/google-diff-match-patch/wiki/API
        convertChangesToDMP: function(changes) {
          var ret = [],
              change,
              operation;
          for (var i = 0; i < changes.length; i++) {
            change = changes[i];
            if (change.added) {
              operation = 1;
            } else if (change.removed) {
              operation = -1;
            } else {
              operation = 0;
            }
    
            ret.push([operation, change.value]);
          }
          return ret;
        },
    
        canonicalize: canonicalize
      };
    
      /*istanbul ignore next */
      /*global module */
      if (typeof module !== 'undefined' && module.exports) {
        module.exports = JsDiff;
      } else if (typeof define === 'function' && define.amd) {
        /*global define */
        define([], function() { return JsDiff; });
      } else if (typeof global.JsDiff === 'undefined') {
        global.JsDiff = JsDiff;
      }
    }(this));
    
  provide("diff", module.exports);
}(global));

// pakmanager:escape-string-regexp
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    
    module.exports = function (str) {
    	if (typeof str !== 'string') {
    		throw new TypeError('Expected a string');
    	}
    
    	return str.replace(matchOperatorsRe,  '\\$&');
    };
    
  provide("escape-string-regexp", module.exports);
}(global));

// pakmanager:glob/common.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports.alphasort = alphasort
    exports.alphasorti = alphasorti
    exports.setopts = setopts
    exports.ownProp = ownProp
    exports.makeAbs = makeAbs
    exports.finish = finish
    exports.mark = mark
    exports.isIgnored = isIgnored
    exports.childrenIgnored = childrenIgnored
    
    function ownProp (obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field)
    }
    
    var path = require("path")
    var minimatch = require("minimatch")
    var isAbsolute = require("path-is-absolute")
    var Minimatch = minimatch.Minimatch
    
    function alphasorti (a, b) {
      return a.toLowerCase().localeCompare(b.toLowerCase())
    }
    
    function alphasort (a, b) {
      return a.localeCompare(b)
    }
    
    function setupIgnores (self, options) {
      self.ignore = options.ignore || []
    
      if (!Array.isArray(self.ignore))
        self.ignore = [self.ignore]
    
      if (self.ignore.length) {
        self.ignore = self.ignore.map(ignoreMap)
      }
    }
    
    function ignoreMap (pattern) {
      var gmatcher = null
      if (pattern.slice(-3) === '/**') {
        var gpattern = pattern.replace(/(\/\*\*)+$/, '')
        gmatcher = new Minimatch(gpattern)
      }
    
      return {
        matcher: new Minimatch(pattern),
        gmatcher: gmatcher
      }
    }
    
    function setopts (self, pattern, options) {
      if (!options)
        options = {}
    
      // base-matching: just use globstar for that.
      if (options.matchBase && -1 === pattern.indexOf("/")) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar")
        }
        pattern = "**/" + pattern
      }
    
      self.silent = !!options.silent
      self.pattern = pattern
      self.strict = options.strict !== false
      self.realpath = !!options.realpath
      self.realpathCache = options.realpathCache || Object.create(null)
      self.follow = !!options.follow
      self.dot = !!options.dot
      self.mark = !!options.mark
      self.nodir = !!options.nodir
      if (self.nodir)
        self.mark = true
      self.sync = !!options.sync
      self.nounique = !!options.nounique
      self.nonull = !!options.nonull
      self.nosort = !!options.nosort
      self.nocase = !!options.nocase
      self.stat = !!options.stat
      self.noprocess = !!options.noprocess
    
      self.maxLength = options.maxLength || Infinity
      self.cache = options.cache || Object.create(null)
      self.statCache = options.statCache || Object.create(null)
      self.symlinks = options.symlinks || Object.create(null)
    
      setupIgnores(self, options)
    
      self.changedCwd = false
      var cwd = process.cwd()
      if (!ownProp(options, "cwd"))
        self.cwd = cwd
      else {
        self.cwd = options.cwd
        self.changedCwd = path.resolve(options.cwd) !== cwd
      }
    
      self.root = options.root || path.resolve(self.cwd, "/")
      self.root = path.resolve(self.root)
      if (process.platform === "win32")
        self.root = self.root.replace(/\\/g, "/")
    
      self.nomount = !!options.nomount
    
      // disable comments and negation unless the user explicitly
      // passes in false as the option.
      options.nonegate = options.nonegate === false ? false : true
      options.nocomment = options.nocomment === false ? false : true
      deprecationWarning(options)
    
      self.minimatch = new Minimatch(pattern, options)
      self.options = self.minimatch.options
    }
    
    // TODO(isaacs): remove entirely in v6
    // exported to reset in tests
    exports.deprecationWarned
    function deprecationWarning(options) {
      if (!options.nonegate || !options.nocomment) {
        if (process.noDeprecation !== true && !exports.deprecationWarned) {
          var msg = 'glob WARNING: comments and negation will be disabled in v6'
          if (process.throwDeprecation)
            throw new Error(msg)
          else if (process.traceDeprecation)
            console.trace(msg)
          else
            console.error(msg)
    
          exports.deprecationWarned = true
        }
      }
    }
    
    function finish (self) {
      var nou = self.nounique
      var all = nou ? [] : Object.create(null)
    
      for (var i = 0, l = self.matches.length; i < l; i ++) {
        var matches = self.matches[i]
        if (!matches || Object.keys(matches).length === 0) {
          if (self.nonull) {
            // do like the shell, and spit out the literal glob
            var literal = self.minimatch.globSet[i]
            if (nou)
              all.push(literal)
            else
              all[literal] = true
          }
        } else {
          // had matches
          var m = Object.keys(matches)
          if (nou)
            all.push.apply(all, m)
          else
            m.forEach(function (m) {
              all[m] = true
            })
        }
      }
    
      if (!nou)
        all = Object.keys(all)
    
      if (!self.nosort)
        all = all.sort(self.nocase ? alphasorti : alphasort)
    
      // at *some* point we statted all of these
      if (self.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self._mark(all[i])
        }
        if (self.nodir) {
          all = all.filter(function (e) {
            return !(/\/$/.test(e))
          })
        }
      }
    
      if (self.ignore.length)
        all = all.filter(function(m) {
          return !isIgnored(self, m)
        })
    
      self.found = all
    }
    
    function mark (self, p) {
      var abs = makeAbs(self, p)
      var c = self.cache[abs]
      var m = p
      if (c) {
        var isDir = c === 'DIR' || Array.isArray(c)
        var slash = p.slice(-1) === '/'
    
        if (isDir && !slash)
          m += '/'
        else if (!isDir && slash)
          m = m.slice(0, -1)
    
        if (m !== p) {
          var mabs = makeAbs(self, m)
          self.statCache[mabs] = self.statCache[abs]
          self.cache[mabs] = self.cache[abs]
        }
      }
    
      return m
    }
    
    // lotta situps...
    function makeAbs (self, f) {
      var abs = f
      if (f.charAt(0) === '/') {
        abs = path.join(self.root, f)
      } else if (isAbsolute(f) || f === '') {
        abs = f
      } else if (self.changedCwd) {
        abs = path.resolve(self.cwd, f)
      } else {
        abs = path.resolve(f)
      }
      return abs
    }
    
    
    // Return true, if pattern ends with globstar '**', for the accompanying parent directory.
    // Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
    function isIgnored (self, path) {
      if (!self.ignore.length)
        return false
    
      return self.ignore.some(function(item) {
        return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
      })
    }
    
    function childrenIgnored (self, path) {
      if (!self.ignore.length)
        return false
    
      return self.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path))
      })
    }
    
  provide("glob/common.js", module.exports);
}(global));

// pakmanager:glob/glob.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Approach:
    //
    // 1. Get the minimatch set
    // 2. For each pattern in the set, PROCESS(pattern, false)
    // 3. Store matches per-set, then uniq them
    //
    // PROCESS(pattern, inGlobStar)
    // Get the first [n] items from pattern that are all strings
    // Join these together.  This is PREFIX.
    //   If there is no more remaining, then stat(PREFIX) and
    //   add to matches if it succeeds.  END.
    //
    // If inGlobStar and PREFIX is symlink and points to dir
    //   set ENTRIES = []
    // else readdir(PREFIX) as ENTRIES
    //   If fail, END
    //
    // with ENTRIES
    //   If pattern[n] is GLOBSTAR
    //     // handle the case where the globstar match is empty
    //     // by pruning it out, and testing the resulting pattern
    //     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
    //     // handle other cases.
    //     for ENTRY in ENTRIES (not dotfiles)
    //       // attach globstar + tail onto the entry
    //       // Mark that this entry is a globstar match
    //       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
    //
    //   else // not globstar
    //     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
    //       Test ENTRY against pattern[n]
    //       If fails, continue
    //       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
    //
    // Caveat:
    //   Cache all stats and readdirs results to minimize syscall.  Since all
    //   we ever care about is existence and directory-ness, we can just keep
    //   `true` for files, and [children,...] for directories, or `false` for
    //   things that don't exist.
    
    module.exports = glob
    
    var fs = require('fs')
    var minimatch = require('minimatch')
    var Minimatch = minimatch.Minimatch
    var inherits = require('inherits')
    var EE = require('events').EventEmitter
    var path = require('path')
    var assert = require('assert')
    var isAbsolute = require('path-is-absolute')
    var globSync =  require('glob/sync.js')
    var common =  require('glob/common.js')
    var alphasort = common.alphasort
    var alphasorti = common.alphasorti
    var setopts = common.setopts
    var ownProp = common.ownProp
    var inflight = require('inflight')
    var util = require('util')
    var childrenIgnored = common.childrenIgnored
    
    var once = require('once')
    
    function glob (pattern, options, cb) {
      if (typeof options === 'function') cb = options, options = {}
      if (!options) options = {}
    
      if (options.sync) {
        if (cb)
          throw new TypeError('callback provided to sync glob')
        return globSync(pattern, options)
      }
    
      return new Glob(pattern, options, cb)
    }
    
    glob.sync = globSync
    var GlobSync = glob.GlobSync = globSync.GlobSync
    
    // old api surface
    glob.glob = glob
    
    glob.hasMagic = function (pattern, options_) {
      var options = util._extend({}, options_)
      options.noprocess = true
    
      var g = new Glob(pattern, options)
      var set = g.minimatch.set
      if (set.length > 1)
        return true
    
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== 'string')
          return true
      }
    
      return false
    }
    
    glob.Glob = Glob
    inherits(Glob, EE)
    function Glob (pattern, options, cb) {
      if (typeof options === 'function') {
        cb = options
        options = null
      }
    
      if (options && options.sync) {
        if (cb)
          throw new TypeError('callback provided to sync glob')
        return new GlobSync(pattern, options)
      }
    
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb)
    
      setopts(this, pattern, options)
      this._didRealPath = false
    
      // process each pattern in the minimatch set
      var n = this.minimatch.set.length
    
      // The matches are stored as {<filename>: true,...} so that
      // duplicates are automagically pruned.
      // Later, we do an Object.keys() on these.
      // Keep them as a list so we can fill in when nonull is set.
      this.matches = new Array(n)
    
      if (typeof cb === 'function') {
        cb = once(cb)
        this.on('error', cb)
        this.on('end', function (matches) {
          cb(null, matches)
        })
      }
    
      var self = this
      var n = this.minimatch.set.length
      this._processing = 0
      this.matches = new Array(n)
    
      this._emitQueue = []
      this._processQueue = []
      this.paused = false
    
      if (this.noprocess)
        return this
    
      if (n === 0)
        return done()
    
      for (var i = 0; i < n; i ++) {
        this._process(this.minimatch.set[i], i, false, done)
      }
    
      function done () {
        --self._processing
        if (self._processing <= 0)
          self._finish()
      }
    }
    
    Glob.prototype._finish = function () {
      assert(this instanceof Glob)
      if (this.aborted)
        return
    
      if (this.realpath && !this._didRealpath)
        return this._realpath()
    
      common.finish(this)
      this.emit('end', this.found)
    }
    
    Glob.prototype._realpath = function () {
      if (this._didRealpath)
        return
    
      this._didRealpath = true
    
      var n = this.matches.length
      if (n === 0)
        return this._finish()
    
      var self = this
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next)
    
      function next () {
        if (--n === 0)
          self._finish()
      }
    }
    
    Glob.prototype._realpathSet = function (index, cb) {
      var matchset = this.matches[index]
      if (!matchset)
        return cb()
    
      var found = Object.keys(matchset)
      var self = this
      var n = found.length
    
      if (n === 0)
        return cb()
    
      var set = this.matches[index] = Object.create(null)
      found.forEach(function (p, i) {
        // If there's a problem with the stat, then it means that
        // one or more of the links in the realpath couldn't be
        // resolved.  just return the abs value in that case.
        p = self._makeAbs(p)
        fs.realpath(p, self.realpathCache, function (er, real) {
          if (!er)
            set[real] = true
          else if (er.syscall === 'stat')
            set[p] = true
          else
            self.emit('error', er) // srsly wtf right here
    
          if (--n === 0) {
            self.matches[index] = set
            cb()
          }
        })
      })
    }
    
    Glob.prototype._mark = function (p) {
      return common.mark(this, p)
    }
    
    Glob.prototype._makeAbs = function (f) {
      return common.makeAbs(this, f)
    }
    
    Glob.prototype.abort = function () {
      this.aborted = true
      this.emit('abort')
    }
    
    Glob.prototype.pause = function () {
      if (!this.paused) {
        this.paused = true
        this.emit('pause')
      }
    }
    
    Glob.prototype.resume = function () {
      if (this.paused) {
        this.emit('resume')
        this.paused = false
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0)
          this._emitQueue.length = 0
          for (var i = 0; i < eq.length; i ++) {
            var e = eq[i]
            this._emitMatch(e[0], e[1])
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0)
          this._processQueue.length = 0
          for (var i = 0; i < pq.length; i ++) {
            var p = pq[i]
            this._processing--
            this._process(p[0], p[1], p[2], p[3])
          }
        }
      }
    }
    
    Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob)
      assert(typeof cb === 'function')
    
      if (this.aborted)
        return
    
      this._processing++
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb])
        return
      }
    
      //console.error('PROCESS %d', this._processing, pattern)
    
      // Get the first [n] parts of pattern that are all strings.
      var n = 0
      while (typeof pattern[n] === 'string') {
        n ++
      }
      // now n is the index of the first one that is *not* a string.
    
      // see if there's anything else
      var prefix
      switch (n) {
        // if not, then this is rather simple
        case pattern.length:
          this._processSimple(pattern.join('/'), index, cb)
          return
    
        case 0:
          // pattern *starts* with some non-trivial item.
          // going to readdir(cwd), but not include the prefix in matches.
          prefix = null
          break
    
        default:
          // pattern has some string bits in the front.
          // whatever it starts with, whether that's 'absolute' like /foo/bar,
          // or 'relative' like '../baz'
          prefix = pattern.slice(0, n).join('/')
          break
      }
    
      var remain = pattern.slice(n)
    
      // get the list of entries.
      var read
      if (prefix === null)
        read = '.'
      else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = '/' + prefix
        read = prefix
      } else
        read = prefix
    
      var abs = this._makeAbs(read)
    
      //if ignored, skip _processing
      if (childrenIgnored(this, read))
        return cb()
    
      var isGlobStar = remain[0] === minimatch.GLOBSTAR
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
    }
    
    Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this
      this._readdir(abs, inGlobStar, function (er, entries) {
        return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
      })
    }
    
    Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    
      // if the abs isn't a dir, then nothing can match!
      if (!entries)
        return cb()
    
      // It will only match dot entries if it starts with a dot, or if
      // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
      var pn = remain[0]
      var negate = !!this.minimatch.negate
      var rawGlob = pn._glob
      var dotOk = this.dot || rawGlob.charAt(0) === '.'
    
      var matchedEntries = []
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i]
        if (e.charAt(0) !== '.' || dotOk) {
          var m
          if (negate && !prefix) {
            m = !e.match(pn)
          } else {
            m = e.match(pn)
          }
          if (m)
            matchedEntries.push(e)
        }
      }
    
      //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)
    
      var len = matchedEntries.length
      // If there are no matched entries, then nothing matches.
      if (len === 0)
        return cb()
    
      // if this is the last remaining pattern bit, then no need for
      // an additional stat *unless* the user has specified mark or
      // stat explicitly.  We know they exist, since readdir returned
      // them.
    
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null)
    
        for (var i = 0; i < len; i ++) {
          var e = matchedEntries[i]
          if (prefix) {
            if (prefix !== '/')
              e = prefix + '/' + e
            else
              e = prefix + e
          }
    
          if (e.charAt(0) === '/' && !this.nomount) {
            e = path.join(this.root, e)
          }
          this._emitMatch(index, e)
        }
        // This was the last one, and no stats were needed
        return cb()
      }
    
      // now test all matched entries as stand-ins for that part
      // of the pattern.
      remain.shift()
      for (var i = 0; i < len; i ++) {
        var e = matchedEntries[i]
        var newPattern
        if (prefix) {
          if (prefix !== '/')
            e = prefix + '/' + e
          else
            e = prefix + e
        }
        this._process([e].concat(remain), index, inGlobStar, cb)
      }
      cb()
    }
    
    Glob.prototype._emitMatch = function (index, e) {
      if (this.aborted)
        return
    
      if (this.matches[index][e])
        return
    
      if (this.paused) {
        this._emitQueue.push([index, e])
        return
      }
    
      var abs = this._makeAbs(e)
    
      if (this.nodir) {
        var c = this.cache[abs]
        if (c === 'DIR' || Array.isArray(c))
          return
      }
    
      if (this.mark)
        e = this._mark(e)
    
      this.matches[index][e] = true
    
      var st = this.statCache[abs]
      if (st)
        this.emit('stat', e, st)
    
      this.emit('match', e)
    }
    
    Glob.prototype._readdirInGlobStar = function (abs, cb) {
      if (this.aborted)
        return
    
      // follow all symlinked directories forever
      // just proceed as if this is a non-globstar situation
      if (this.follow)
        return this._readdir(abs, false, cb)
    
      var lstatkey = 'lstat\0' + abs
      var self = this
      var lstatcb = inflight(lstatkey, lstatcb_)
    
      if (lstatcb)
        fs.lstat(abs, lstatcb)
    
      function lstatcb_ (er, lstat) {
        if (er)
          return cb()
    
        var isSym = lstat.isSymbolicLink()
        self.symlinks[abs] = isSym
    
        // If it's not a symlink or a dir, then it's definitely a regular file.
        // don't bother doing a readdir in that case.
        if (!isSym && !lstat.isDirectory()) {
          self.cache[abs] = 'FILE'
          cb()
        } else
          self._readdir(abs, false, cb)
      }
    }
    
    Glob.prototype._readdir = function (abs, inGlobStar, cb) {
      if (this.aborted)
        return
    
      cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
      if (!cb)
        return
    
      //console.error('RD %j %j', +inGlobStar, abs)
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb)
    
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs]
        if (!c || c === 'FILE')
          return cb()
    
        if (Array.isArray(c))
          return cb(null, c)
      }
    
      var self = this
      fs.readdir(abs, readdirCb(this, abs, cb))
    }
    
    function readdirCb (self, abs, cb) {
      return function (er, entries) {
        if (er)
          self._readdirError(abs, er, cb)
        else
          self._readdirEntries(abs, entries, cb)
      }
    }
    
    Glob.prototype._readdirEntries = function (abs, entries, cb) {
      if (this.aborted)
        return
    
      // if we haven't asked to stat everything, then just
      // assume that everything in there exists, so we can avoid
      // having to stat it a second time.
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i ++) {
          var e = entries[i]
          if (abs === '/')
            e = abs + e
          else
            e = abs + '/' + e
          this.cache[e] = true
        }
      }
    
      this.cache[abs] = entries
      return cb(null, entries)
    }
    
    Glob.prototype._readdirError = function (f, er, cb) {
      if (this.aborted)
        return
    
      // handle errors, and cache the information
      switch (er.code) {
        case 'ENOTDIR': // totally normal. means it *does* exist.
          this.cache[this._makeAbs(f)] = 'FILE'
          break
    
        case 'ENOENT': // not terribly unusual
        case 'ELOOP':
        case 'ENAMETOOLONG':
        case 'UNKNOWN':
          this.cache[this._makeAbs(f)] = false
          break
    
        default: // some unusual error.  Treat as failure.
          this.cache[this._makeAbs(f)] = false
          if (this.strict) {
            this.emit('error', er)
            // If the error is handled, then we abort
            // if not, we threw out of here
            this.abort()
          }
          if (!this.silent)
            console.error('glob error', er)
          break
      }
    
      return cb()
    }
    
    Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this
      this._readdir(abs, inGlobStar, function (er, entries) {
        self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
      })
    }
    
    
    Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      //console.error('pgs2', prefix, remain[0], entries)
    
      // no entries means not a dir, so it can never have matches
      // foo.txt/** doesn't match foo.txt
      if (!entries)
        return cb()
    
      // test without the globstar, and with every child both below
      // and replacing the globstar.
      var remainWithoutGlobStar = remain.slice(1)
      var gspref = prefix ? [ prefix ] : []
      var noGlobStar = gspref.concat(remainWithoutGlobStar)
    
      // the noGlobStar pattern exits the inGlobStar state
      this._process(noGlobStar, index, false, cb)
    
      var isSym = this.symlinks[abs]
      var len = entries.length
    
      // If it's a symlink, and we're in a globstar, then stop
      if (isSym && inGlobStar)
        return cb()
    
      for (var i = 0; i < len; i++) {
        var e = entries[i]
        if (e.charAt(0) === '.' && !this.dot)
          continue
    
        // these two cases enter the inGlobStar state
        var instead = gspref.concat(entries[i], remainWithoutGlobStar)
        this._process(instead, index, true, cb)
    
        var below = gspref.concat(entries[i], remain)
        this._process(below, index, true, cb)
      }
    
      cb()
    }
    
    Glob.prototype._processSimple = function (prefix, index, cb) {
      // XXX review this.  Shouldn't it be doing the mounting etc
      // before doing stat?  kinda weird?
      var self = this
      this._stat(prefix, function (er, exists) {
        self._processSimple2(prefix, index, er, exists, cb)
      })
    }
    Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {
    
      //console.error('ps2', prefix, exists)
    
      if (!this.matches[index])
        this.matches[index] = Object.create(null)
    
      // If it doesn't exist, then just mark the lack of results
      if (!exists)
        return cb()
    
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix)
        if (prefix.charAt(0) === '/') {
          prefix = path.join(this.root, prefix)
        } else {
          prefix = path.resolve(this.root, prefix)
          if (trail)
            prefix += '/'
        }
      }
    
      if (process.platform === 'win32')
        prefix = prefix.replace(/\\/g, '/')
    
      // Mark this as a match
      this._emitMatch(index, prefix)
      cb()
    }
    
    // Returns either 'DIR', 'FILE', or false
    Glob.prototype._stat = function (f, cb) {
      var abs = this._makeAbs(f)
      var needDir = f.slice(-1) === '/'
    
      if (f.length > this.maxLength)
        return cb()
    
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs]
    
        if (Array.isArray(c))
          c = 'DIR'
    
        // It exists, but maybe not how we need it
        if (!needDir || c === 'DIR')
          return cb(null, c)
    
        if (needDir && c === 'FILE')
          return cb()
    
        // otherwise we have to stat, because maybe c=true
        // if we know it exists, but not what it is.
      }
    
      var exists
      var stat = this.statCache[abs]
      if (stat !== undefined) {
        if (stat === false)
          return cb(null, stat)
        else {
          var type = stat.isDirectory() ? 'DIR' : 'FILE'
          if (needDir && type === 'FILE')
            return cb()
          else
            return cb(null, type, stat)
        }
      }
    
      var self = this
      var statcb = inflight('stat\0' + abs, lstatcb_)
      if (statcb)
        fs.lstat(abs, statcb)
    
      function lstatcb_ (er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          // If it's a symlink, then treat it as the target, unless
          // the target does not exist, then treat it as a file.
          return fs.stat(abs, function (er, stat) {
            if (er)
              self._stat2(f, abs, null, lstat, cb)
            else
              self._stat2(f, abs, er, stat, cb)
          })
        } else {
          self._stat2(f, abs, er, lstat, cb)
        }
      }
    }
    
    Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
      if (er) {
        this.statCache[abs] = false
        return cb()
      }
    
      var needDir = f.slice(-1) === '/'
      this.statCache[abs] = stat
    
      if (abs.slice(-1) === '/' && !stat.isDirectory())
        return cb(null, false, stat)
    
      var c = stat.isDirectory() ? 'DIR' : 'FILE'
      this.cache[abs] = this.cache[abs] || c
    
      if (needDir && c !== 'DIR')
        return cb()
    
      return cb(null, c, stat)
    }
    
  provide("glob/glob.js", module.exports);
}(global));

// pakmanager:glob/sync.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = globSync
    globSync.GlobSync = GlobSync
    
    var fs = require('fs')
    var minimatch = require('minimatch')
    var Minimatch = minimatch.Minimatch
    var Glob =  require('glob/glob.js').Glob
    var util = require('util')
    var path = require('path')
    var assert = require('assert')
    var isAbsolute = require('path-is-absolute')
    var common =  require('glob/common.js')
    var alphasort = common.alphasort
    var alphasorti = common.alphasorti
    var setopts = common.setopts
    var ownProp = common.ownProp
    var childrenIgnored = common.childrenIgnored
    
    function globSync (pattern, options) {
      if (typeof options === 'function' || arguments.length === 3)
        throw new TypeError('callback provided to sync glob\n'+
                            'See: https://github.com/isaacs/node-glob/issues/167')
    
      return new GlobSync(pattern, options).found
    }
    
    function GlobSync (pattern, options) {
      if (!pattern)
        throw new Error('must provide pattern')
    
      if (typeof options === 'function' || arguments.length === 3)
        throw new TypeError('callback provided to sync glob\n'+
                            'See: https://github.com/isaacs/node-glob/issues/167')
    
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options)
    
      setopts(this, pattern, options)
    
      if (this.noprocess)
        return this
    
      var n = this.minimatch.set.length
      this.matches = new Array(n)
      for (var i = 0; i < n; i ++) {
        this._process(this.minimatch.set[i], i, false)
      }
      this._finish()
    }
    
    GlobSync.prototype._finish = function () {
      assert(this instanceof GlobSync)
      if (this.realpath) {
        var self = this
        this.matches.forEach(function (matchset, index) {
          var set = self.matches[index] = Object.create(null)
          for (var p in matchset) {
            try {
              p = self._makeAbs(p)
              var real = fs.realpathSync(p, this.realpathCache)
              set[real] = true
            } catch (er) {
              if (er.syscall === 'stat')
                set[self._makeAbs(p)] = true
              else
                throw er
            }
          }
        })
      }
      common.finish(this)
    }
    
    
    GlobSync.prototype._process = function (pattern, index, inGlobStar) {
      assert(this instanceof GlobSync)
    
      // Get the first [n] parts of pattern that are all strings.
      var n = 0
      while (typeof pattern[n] === 'string') {
        n ++
      }
      // now n is the index of the first one that is *not* a string.
    
      // See if there's anything else
      var prefix
      switch (n) {
        // if not, then this is rather simple
        case pattern.length:
          this._processSimple(pattern.join('/'), index)
          return
    
        case 0:
          // pattern *starts* with some non-trivial item.
          // going to readdir(cwd), but not include the prefix in matches.
          prefix = null
          break
    
        default:
          // pattern has some string bits in the front.
          // whatever it starts with, whether that's 'absolute' like /foo/bar,
          // or 'relative' like '../baz'
          prefix = pattern.slice(0, n).join('/')
          break
      }
    
      var remain = pattern.slice(n)
    
      // get the list of entries.
      var read
      if (prefix === null)
        read = '.'
      else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = '/' + prefix
        read = prefix
      } else
        read = prefix
    
      var abs = this._makeAbs(read)
    
      //if ignored, skip processing
      if (childrenIgnored(this, read))
        return
    
      var isGlobStar = remain[0] === minimatch.GLOBSTAR
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
    }
    
    
    GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar)
    
      // if the abs isn't a dir, then nothing can match!
      if (!entries)
        return
    
      // It will only match dot entries if it starts with a dot, or if
      // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
      var pn = remain[0]
      var negate = !!this.minimatch.negate
      var rawGlob = pn._glob
      var dotOk = this.dot || rawGlob.charAt(0) === '.'
    
      var matchedEntries = []
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i]
        if (e.charAt(0) !== '.' || dotOk) {
          var m
          if (negate && !prefix) {
            m = !e.match(pn)
          } else {
            m = e.match(pn)
          }
          if (m)
            matchedEntries.push(e)
        }
      }
    
      var len = matchedEntries.length
      // If there are no matched entries, then nothing matches.
      if (len === 0)
        return
    
      // if this is the last remaining pattern bit, then no need for
      // an additional stat *unless* the user has specified mark or
      // stat explicitly.  We know they exist, since readdir returned
      // them.
    
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null)
    
        for (var i = 0; i < len; i ++) {
          var e = matchedEntries[i]
          if (prefix) {
            if (prefix.slice(-1) !== '/')
              e = prefix + '/' + e
            else
              e = prefix + e
          }
    
          if (e.charAt(0) === '/' && !this.nomount) {
            e = path.join(this.root, e)
          }
          this.matches[index][e] = true
        }
        // This was the last one, and no stats were needed
        return
      }
    
      // now test all matched entries as stand-ins for that part
      // of the pattern.
      remain.shift()
      for (var i = 0; i < len; i ++) {
        var e = matchedEntries[i]
        var newPattern
        if (prefix)
          newPattern = [prefix, e]
        else
          newPattern = [e]
        this._process(newPattern.concat(remain), index, inGlobStar)
      }
    }
    
    
    GlobSync.prototype._emitMatch = function (index, e) {
      var abs = this._makeAbs(e)
      if (this.mark)
        e = this._mark(e)
    
      if (this.matches[index][e])
        return
    
      if (this.nodir) {
        var c = this.cache[this._makeAbs(e)]
        if (c === 'DIR' || Array.isArray(c))
          return
      }
    
      this.matches[index][e] = true
      if (this.stat)
        this._stat(e)
    }
    
    
    GlobSync.prototype._readdirInGlobStar = function (abs) {
      // follow all symlinked directories forever
      // just proceed as if this is a non-globstar situation
      if (this.follow)
        return this._readdir(abs, false)
    
      var entries
      var lstat
      var stat
      try {
        lstat = fs.lstatSync(abs)
      } catch (er) {
        // lstat failed, doesn't exist
        return null
      }
    
      var isSym = lstat.isSymbolicLink()
      this.symlinks[abs] = isSym
    
      // If it's not a symlink or a dir, then it's definitely a regular file.
      // don't bother doing a readdir in that case.
      if (!isSym && !lstat.isDirectory())
        this.cache[abs] = 'FILE'
      else
        entries = this._readdir(abs, false)
    
      return entries
    }
    
    GlobSync.prototype._readdir = function (abs, inGlobStar) {
      var entries
    
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs)
    
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs]
        if (!c || c === 'FILE')
          return null
    
        if (Array.isArray(c))
          return c
      }
    
      try {
        return this._readdirEntries(abs, fs.readdirSync(abs))
      } catch (er) {
        this._readdirError(abs, er)
        return null
      }
    }
    
    GlobSync.prototype._readdirEntries = function (abs, entries) {
      // if we haven't asked to stat everything, then just
      // assume that everything in there exists, so we can avoid
      // having to stat it a second time.
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i ++) {
          var e = entries[i]
          if (abs === '/')
            e = abs + e
          else
            e = abs + '/' + e
          this.cache[e] = true
        }
      }
    
      this.cache[abs] = entries
    
      // mark and cache dir-ness
      return entries
    }
    
    GlobSync.prototype._readdirError = function (f, er) {
      // handle errors, and cache the information
      switch (er.code) {
        case 'ENOTDIR': // totally normal. means it *does* exist.
          this.cache[this._makeAbs(f)] = 'FILE'
          break
    
        case 'ENOENT': // not terribly unusual
        case 'ELOOP':
        case 'ENAMETOOLONG':
        case 'UNKNOWN':
          this.cache[this._makeAbs(f)] = false
          break
    
        default: // some unusual error.  Treat as failure.
          this.cache[this._makeAbs(f)] = false
          if (this.strict)
            throw er
          if (!this.silent)
            console.error('glob error', er)
          break
      }
    }
    
    GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {
    
      var entries = this._readdir(abs, inGlobStar)
    
      // no entries means not a dir, so it can never have matches
      // foo.txt/** doesn't match foo.txt
      if (!entries)
        return
    
      // test without the globstar, and with every child both below
      // and replacing the globstar.
      var remainWithoutGlobStar = remain.slice(1)
      var gspref = prefix ? [ prefix ] : []
      var noGlobStar = gspref.concat(remainWithoutGlobStar)
    
      // the noGlobStar pattern exits the inGlobStar state
      this._process(noGlobStar, index, false)
    
      var len = entries.length
      var isSym = this.symlinks[abs]
    
      // If it's a symlink, and we're in a globstar, then stop
      if (isSym && inGlobStar)
        return
    
      for (var i = 0; i < len; i++) {
        var e = entries[i]
        if (e.charAt(0) === '.' && !this.dot)
          continue
    
        // these two cases enter the inGlobStar state
        var instead = gspref.concat(entries[i], remainWithoutGlobStar)
        this._process(instead, index, true)
    
        var below = gspref.concat(entries[i], remain)
        this._process(below, index, true)
      }
    }
    
    GlobSync.prototype._processSimple = function (prefix, index) {
      // XXX review this.  Shouldn't it be doing the mounting etc
      // before doing stat?  kinda weird?
      var exists = this._stat(prefix)
    
      if (!this.matches[index])
        this.matches[index] = Object.create(null)
    
      // If it doesn't exist, then just mark the lack of results
      if (!exists)
        return
    
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix)
        if (prefix.charAt(0) === '/') {
          prefix = path.join(this.root, prefix)
        } else {
          prefix = path.resolve(this.root, prefix)
          if (trail)
            prefix += '/'
        }
      }
    
      if (process.platform === 'win32')
        prefix = prefix.replace(/\\/g, '/')
    
      // Mark this as a match
      this.matches[index][prefix] = true
    }
    
    // Returns either 'DIR', 'FILE', or false
    GlobSync.prototype._stat = function (f) {
      var abs = this._makeAbs(f)
      var needDir = f.slice(-1) === '/'
    
      if (f.length > this.maxLength)
        return false
    
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs]
    
        if (Array.isArray(c))
          c = 'DIR'
    
        // It exists, but maybe not how we need it
        if (!needDir || c === 'DIR')
          return c
    
        if (needDir && c === 'FILE')
          return false
    
        // otherwise we have to stat, because maybe c=true
        // if we know it exists, but not what it is.
      }
    
      var exists
      var stat = this.statCache[abs]
      if (!stat) {
        var lstat
        try {
          lstat = fs.lstatSync(abs)
        } catch (er) {
          return false
        }
    
        if (lstat.isSymbolicLink()) {
          try {
            stat = fs.statSync(abs)
          } catch (er) {
            stat = lstat
          }
        } else {
          stat = lstat
        }
      }
    
      this.statCache[abs] = stat
    
      var c = stat.isDirectory() ? 'DIR' : 'FILE'
      this.cache[abs] = this.cache[abs] || c
    
      if (needDir && c !== 'DIR')
        return false
    
      return c
    }
    
    GlobSync.prototype._mark = function (p) {
      return common.mark(this, p)
    }
    
    GlobSync.prototype._makeAbs = function (f) {
      return common.makeAbs(this, f)
    }
    
  provide("glob/sync.js", module.exports);
}(global));

// pakmanager:glob
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Approach:
    //
    // 1. Get the minimatch set
    // 2. For each pattern in the set, PROCESS(pattern, false)
    // 3. Store matches per-set, then uniq them
    //
    // PROCESS(pattern, inGlobStar)
    // Get the first [n] items from pattern that are all strings
    // Join these together.  This is PREFIX.
    //   If there is no more remaining, then stat(PREFIX) and
    //   add to matches if it succeeds.  END.
    //
    // If inGlobStar and PREFIX is symlink and points to dir
    //   set ENTRIES = []
    // else readdir(PREFIX) as ENTRIES
    //   If fail, END
    //
    // with ENTRIES
    //   If pattern[n] is GLOBSTAR
    //     // handle the case where the globstar match is empty
    //     // by pruning it out, and testing the resulting pattern
    //     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
    //     // handle other cases.
    //     for ENTRY in ENTRIES (not dotfiles)
    //       // attach globstar + tail onto the entry
    //       // Mark that this entry is a globstar match
    //       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
    //
    //   else // not globstar
    //     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
    //       Test ENTRY against pattern[n]
    //       If fails, continue
    //       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
    //
    // Caveat:
    //   Cache all stats and readdirs results to minimize syscall.  Since all
    //   we ever care about is existence and directory-ness, we can just keep
    //   `true` for files, and [children,...] for directories, or `false` for
    //   things that don't exist.
    
    module.exports = glob
    
    var fs = require('fs')
    var minimatch = require('minimatch')
    var Minimatch = minimatch.Minimatch
    var inherits = require('inherits')
    var EE = require('events').EventEmitter
    var path = require('path')
    var assert = require('assert')
    var isAbsolute = require('path-is-absolute')
    var globSync =  require('glob/sync.js')
    var common =  require('glob/common.js')
    var alphasort = common.alphasort
    var alphasorti = common.alphasorti
    var setopts = common.setopts
    var ownProp = common.ownProp
    var inflight = require('inflight')
    var util = require('util')
    var childrenIgnored = common.childrenIgnored
    
    var once = require('once')
    
    function glob (pattern, options, cb) {
      if (typeof options === 'function') cb = options, options = {}
      if (!options) options = {}
    
      if (options.sync) {
        if (cb)
          throw new TypeError('callback provided to sync glob')
        return globSync(pattern, options)
      }
    
      return new Glob(pattern, options, cb)
    }
    
    glob.sync = globSync
    var GlobSync = glob.GlobSync = globSync.GlobSync
    
    // old api surface
    glob.glob = glob
    
    glob.hasMagic = function (pattern, options_) {
      var options = util._extend({}, options_)
      options.noprocess = true
    
      var g = new Glob(pattern, options)
      var set = g.minimatch.set
      if (set.length > 1)
        return true
    
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== 'string')
          return true
      }
    
      return false
    }
    
    glob.Glob = Glob
    inherits(Glob, EE)
    function Glob (pattern, options, cb) {
      if (typeof options === 'function') {
        cb = options
        options = null
      }
    
      if (options && options.sync) {
        if (cb)
          throw new TypeError('callback provided to sync glob')
        return new GlobSync(pattern, options)
      }
    
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb)
    
      setopts(this, pattern, options)
      this._didRealPath = false
    
      // process each pattern in the minimatch set
      var n = this.minimatch.set.length
    
      // The matches are stored as {<filename>: true,...} so that
      // duplicates are automagically pruned.
      // Later, we do an Object.keys() on these.
      // Keep them as a list so we can fill in when nonull is set.
      this.matches = new Array(n)
    
      if (typeof cb === 'function') {
        cb = once(cb)
        this.on('error', cb)
        this.on('end', function (matches) {
          cb(null, matches)
        })
      }
    
      var self = this
      var n = this.minimatch.set.length
      this._processing = 0
      this.matches = new Array(n)
    
      this._emitQueue = []
      this._processQueue = []
      this.paused = false
    
      if (this.noprocess)
        return this
    
      if (n === 0)
        return done()
    
      for (var i = 0; i < n; i ++) {
        this._process(this.minimatch.set[i], i, false, done)
      }
    
      function done () {
        --self._processing
        if (self._processing <= 0)
          self._finish()
      }
    }
    
    Glob.prototype._finish = function () {
      assert(this instanceof Glob)
      if (this.aborted)
        return
    
      if (this.realpath && !this._didRealpath)
        return this._realpath()
    
      common.finish(this)
      this.emit('end', this.found)
    }
    
    Glob.prototype._realpath = function () {
      if (this._didRealpath)
        return
    
      this._didRealpath = true
    
      var n = this.matches.length
      if (n === 0)
        return this._finish()
    
      var self = this
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next)
    
      function next () {
        if (--n === 0)
          self._finish()
      }
    }
    
    Glob.prototype._realpathSet = function (index, cb) {
      var matchset = this.matches[index]
      if (!matchset)
        return cb()
    
      var found = Object.keys(matchset)
      var self = this
      var n = found.length
    
      if (n === 0)
        return cb()
    
      var set = this.matches[index] = Object.create(null)
      found.forEach(function (p, i) {
        // If there's a problem with the stat, then it means that
        // one or more of the links in the realpath couldn't be
        // resolved.  just return the abs value in that case.
        p = self._makeAbs(p)
        fs.realpath(p, self.realpathCache, function (er, real) {
          if (!er)
            set[real] = true
          else if (er.syscall === 'stat')
            set[p] = true
          else
            self.emit('error', er) // srsly wtf right here
    
          if (--n === 0) {
            self.matches[index] = set
            cb()
          }
        })
      })
    }
    
    Glob.prototype._mark = function (p) {
      return common.mark(this, p)
    }
    
    Glob.prototype._makeAbs = function (f) {
      return common.makeAbs(this, f)
    }
    
    Glob.prototype.abort = function () {
      this.aborted = true
      this.emit('abort')
    }
    
    Glob.prototype.pause = function () {
      if (!this.paused) {
        this.paused = true
        this.emit('pause')
      }
    }
    
    Glob.prototype.resume = function () {
      if (this.paused) {
        this.emit('resume')
        this.paused = false
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0)
          this._emitQueue.length = 0
          for (var i = 0; i < eq.length; i ++) {
            var e = eq[i]
            this._emitMatch(e[0], e[1])
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0)
          this._processQueue.length = 0
          for (var i = 0; i < pq.length; i ++) {
            var p = pq[i]
            this._processing--
            this._process(p[0], p[1], p[2], p[3])
          }
        }
      }
    }
    
    Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob)
      assert(typeof cb === 'function')
    
      if (this.aborted)
        return
    
      this._processing++
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb])
        return
      }
    
      //console.error('PROCESS %d', this._processing, pattern)
    
      // Get the first [n] parts of pattern that are all strings.
      var n = 0
      while (typeof pattern[n] === 'string') {
        n ++
      }
      // now n is the index of the first one that is *not* a string.
    
      // see if there's anything else
      var prefix
      switch (n) {
        // if not, then this is rather simple
        case pattern.length:
          this._processSimple(pattern.join('/'), index, cb)
          return
    
        case 0:
          // pattern *starts* with some non-trivial item.
          // going to readdir(cwd), but not include the prefix in matches.
          prefix = null
          break
    
        default:
          // pattern has some string bits in the front.
          // whatever it starts with, whether that's 'absolute' like /foo/bar,
          // or 'relative' like '../baz'
          prefix = pattern.slice(0, n).join('/')
          break
      }
    
      var remain = pattern.slice(n)
    
      // get the list of entries.
      var read
      if (prefix === null)
        read = '.'
      else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = '/' + prefix
        read = prefix
      } else
        read = prefix
    
      var abs = this._makeAbs(read)
    
      //if ignored, skip _processing
      if (childrenIgnored(this, read))
        return cb()
    
      var isGlobStar = remain[0] === minimatch.GLOBSTAR
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
    }
    
    Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this
      this._readdir(abs, inGlobStar, function (er, entries) {
        return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
      })
    }
    
    Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    
      // if the abs isn't a dir, then nothing can match!
      if (!entries)
        return cb()
    
      // It will only match dot entries if it starts with a dot, or if
      // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
      var pn = remain[0]
      var negate = !!this.minimatch.negate
      var rawGlob = pn._glob
      var dotOk = this.dot || rawGlob.charAt(0) === '.'
    
      var matchedEntries = []
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i]
        if (e.charAt(0) !== '.' || dotOk) {
          var m
          if (negate && !prefix) {
            m = !e.match(pn)
          } else {
            m = e.match(pn)
          }
          if (m)
            matchedEntries.push(e)
        }
      }
    
      //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)
    
      var len = matchedEntries.length
      // If there are no matched entries, then nothing matches.
      if (len === 0)
        return cb()
    
      // if this is the last remaining pattern bit, then no need for
      // an additional stat *unless* the user has specified mark or
      // stat explicitly.  We know they exist, since readdir returned
      // them.
    
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null)
    
        for (var i = 0; i < len; i ++) {
          var e = matchedEntries[i]
          if (prefix) {
            if (prefix !== '/')
              e = prefix + '/' + e
            else
              e = prefix + e
          }
    
          if (e.charAt(0) === '/' && !this.nomount) {
            e = path.join(this.root, e)
          }
          this._emitMatch(index, e)
        }
        // This was the last one, and no stats were needed
        return cb()
      }
    
      // now test all matched entries as stand-ins for that part
      // of the pattern.
      remain.shift()
      for (var i = 0; i < len; i ++) {
        var e = matchedEntries[i]
        var newPattern
        if (prefix) {
          if (prefix !== '/')
            e = prefix + '/' + e
          else
            e = prefix + e
        }
        this._process([e].concat(remain), index, inGlobStar, cb)
      }
      cb()
    }
    
    Glob.prototype._emitMatch = function (index, e) {
      if (this.aborted)
        return
    
      if (this.matches[index][e])
        return
    
      if (this.paused) {
        this._emitQueue.push([index, e])
        return
      }
    
      var abs = this._makeAbs(e)
    
      if (this.nodir) {
        var c = this.cache[abs]
        if (c === 'DIR' || Array.isArray(c))
          return
      }
    
      if (this.mark)
        e = this._mark(e)
    
      this.matches[index][e] = true
    
      var st = this.statCache[abs]
      if (st)
        this.emit('stat', e, st)
    
      this.emit('match', e)
    }
    
    Glob.prototype._readdirInGlobStar = function (abs, cb) {
      if (this.aborted)
        return
    
      // follow all symlinked directories forever
      // just proceed as if this is a non-globstar situation
      if (this.follow)
        return this._readdir(abs, false, cb)
    
      var lstatkey = 'lstat\0' + abs
      var self = this
      var lstatcb = inflight(lstatkey, lstatcb_)
    
      if (lstatcb)
        fs.lstat(abs, lstatcb)
    
      function lstatcb_ (er, lstat) {
        if (er)
          return cb()
    
        var isSym = lstat.isSymbolicLink()
        self.symlinks[abs] = isSym
    
        // If it's not a symlink or a dir, then it's definitely a regular file.
        // don't bother doing a readdir in that case.
        if (!isSym && !lstat.isDirectory()) {
          self.cache[abs] = 'FILE'
          cb()
        } else
          self._readdir(abs, false, cb)
      }
    }
    
    Glob.prototype._readdir = function (abs, inGlobStar, cb) {
      if (this.aborted)
        return
    
      cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
      if (!cb)
        return
    
      //console.error('RD %j %j', +inGlobStar, abs)
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb)
    
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs]
        if (!c || c === 'FILE')
          return cb()
    
        if (Array.isArray(c))
          return cb(null, c)
      }
    
      var self = this
      fs.readdir(abs, readdirCb(this, abs, cb))
    }
    
    function readdirCb (self, abs, cb) {
      return function (er, entries) {
        if (er)
          self._readdirError(abs, er, cb)
        else
          self._readdirEntries(abs, entries, cb)
      }
    }
    
    Glob.prototype._readdirEntries = function (abs, entries, cb) {
      if (this.aborted)
        return
    
      // if we haven't asked to stat everything, then just
      // assume that everything in there exists, so we can avoid
      // having to stat it a second time.
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i ++) {
          var e = entries[i]
          if (abs === '/')
            e = abs + e
          else
            e = abs + '/' + e
          this.cache[e] = true
        }
      }
    
      this.cache[abs] = entries
      return cb(null, entries)
    }
    
    Glob.prototype._readdirError = function (f, er, cb) {
      if (this.aborted)
        return
    
      // handle errors, and cache the information
      switch (er.code) {
        case 'ENOTDIR': // totally normal. means it *does* exist.
          this.cache[this._makeAbs(f)] = 'FILE'
          break
    
        case 'ENOENT': // not terribly unusual
        case 'ELOOP':
        case 'ENAMETOOLONG':
        case 'UNKNOWN':
          this.cache[this._makeAbs(f)] = false
          break
    
        default: // some unusual error.  Treat as failure.
          this.cache[this._makeAbs(f)] = false
          if (this.strict) {
            this.emit('error', er)
            // If the error is handled, then we abort
            // if not, we threw out of here
            this.abort()
          }
          if (!this.silent)
            console.error('glob error', er)
          break
      }
    
      return cb()
    }
    
    Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this
      this._readdir(abs, inGlobStar, function (er, entries) {
        self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
      })
    }
    
    
    Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      //console.error('pgs2', prefix, remain[0], entries)
    
      // no entries means not a dir, so it can never have matches
      // foo.txt/** doesn't match foo.txt
      if (!entries)
        return cb()
    
      // test without the globstar, and with every child both below
      // and replacing the globstar.
      var remainWithoutGlobStar = remain.slice(1)
      var gspref = prefix ? [ prefix ] : []
      var noGlobStar = gspref.concat(remainWithoutGlobStar)
    
      // the noGlobStar pattern exits the inGlobStar state
      this._process(noGlobStar, index, false, cb)
    
      var isSym = this.symlinks[abs]
      var len = entries.length
    
      // If it's a symlink, and we're in a globstar, then stop
      if (isSym && inGlobStar)
        return cb()
    
      for (var i = 0; i < len; i++) {
        var e = entries[i]
        if (e.charAt(0) === '.' && !this.dot)
          continue
    
        // these two cases enter the inGlobStar state
        var instead = gspref.concat(entries[i], remainWithoutGlobStar)
        this._process(instead, index, true, cb)
    
        var below = gspref.concat(entries[i], remain)
        this._process(below, index, true, cb)
      }
    
      cb()
    }
    
    Glob.prototype._processSimple = function (prefix, index, cb) {
      // XXX review this.  Shouldn't it be doing the mounting etc
      // before doing stat?  kinda weird?
      var self = this
      this._stat(prefix, function (er, exists) {
        self._processSimple2(prefix, index, er, exists, cb)
      })
    }
    Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {
    
      //console.error('ps2', prefix, exists)
    
      if (!this.matches[index])
        this.matches[index] = Object.create(null)
    
      // If it doesn't exist, then just mark the lack of results
      if (!exists)
        return cb()
    
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix)
        if (prefix.charAt(0) === '/') {
          prefix = path.join(this.root, prefix)
        } else {
          prefix = path.resolve(this.root, prefix)
          if (trail)
            prefix += '/'
        }
      }
    
      if (process.platform === 'win32')
        prefix = prefix.replace(/\\/g, '/')
    
      // Mark this as a match
      this._emitMatch(index, prefix)
      cb()
    }
    
    // Returns either 'DIR', 'FILE', or false
    Glob.prototype._stat = function (f, cb) {
      var abs = this._makeAbs(f)
      var needDir = f.slice(-1) === '/'
    
      if (f.length > this.maxLength)
        return cb()
    
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs]
    
        if (Array.isArray(c))
          c = 'DIR'
    
        // It exists, but maybe not how we need it
        if (!needDir || c === 'DIR')
          return cb(null, c)
    
        if (needDir && c === 'FILE')
          return cb()
    
        // otherwise we have to stat, because maybe c=true
        // if we know it exists, but not what it is.
      }
    
      var exists
      var stat = this.statCache[abs]
      if (stat !== undefined) {
        if (stat === false)
          return cb(null, stat)
        else {
          var type = stat.isDirectory() ? 'DIR' : 'FILE'
          if (needDir && type === 'FILE')
            return cb()
          else
            return cb(null, type, stat)
        }
      }
    
      var self = this
      var statcb = inflight('stat\0' + abs, lstatcb_)
      if (statcb)
        fs.lstat(abs, statcb)
    
      function lstatcb_ (er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          // If it's a symlink, then treat it as the target, unless
          // the target does not exist, then treat it as a file.
          return fs.stat(abs, function (er, stat) {
            if (er)
              self._stat2(f, abs, null, lstat, cb)
            else
              self._stat2(f, abs, er, stat, cb)
          })
        } else {
          self._stat2(f, abs, er, lstat, cb)
        }
      }
    }
    
    Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
      if (er) {
        this.statCache[abs] = false
        return cb()
      }
    
      var needDir = f.slice(-1) === '/'
      this.statCache[abs] = stat
    
      if (abs.slice(-1) === '/' && !stat.isDirectory())
        return cb(null, false, stat)
    
      var c = stat.isDirectory() ? 'DIR' : 'FILE'
      this.cache[abs] = this.cache[abs] || c
    
      if (needDir && c !== 'DIR')
        return cb()
    
      return cb(null, c, stat)
    }
    
  provide("glob", module.exports);
}(global));

// pakmanager:growl
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Growl - Copyright TJ Holowaychuk <tj@vision-media.ca> (MIT Licensed)
    
    /**
     * Module dependencies.
     */
    
    var exec = require('child_process').exec
      , fs = require('fs')
      , path = require('path')
      , exists = fs.existsSync || path.existsSync
      , os = require('os')
      , quote = JSON.stringify
      , cmd;
    
    function which(name) {
      var paths = process.env.PATH.split(':');
      var loc;
      
      for (var i = 0, len = paths.length; i < len; ++i) {
        loc = path.join(paths[i], name);
        if (exists(loc)) return loc;
      }
    }
    
    switch(os.type()) {
      case 'Darwin':
        if (which('terminal-notifier')) {
          cmd = {
              type: "Darwin-NotificationCenter"
            , pkg: "terminal-notifier"
            , msg: '-message'
            , title: '-title'
            , subtitle: '-subtitle'
            , priority: {
                  cmd: '-execute'
                , range: []
              }
          };
        } else {
          cmd = {
              type: "Darwin-Growl"
            , pkg: "growlnotify"
            , msg: '-m'
            , sticky: '--sticky'
            , priority: {
                  cmd: '--priority'
                , range: [
                    -2
                  , -1
                  , 0
                  , 1
                  , 2
                  , "Very Low"
                  , "Moderate"
                  , "Normal"
                  , "High"
                  , "Emergency"
                ]
              }
          };
        }
        break;
      case 'Linux':
        cmd = {
            type: "Linux"
          , pkg: "notify-send"
          , msg: ''
          , sticky: '-t 0'
          , icon: '-i'
          , priority: {
              cmd: '-u'
            , range: [
                "low"
              , "normal"
              , "critical"
            ]
          }
        };
        break;
      case 'Windows_NT':
        cmd = {
            type: "Windows"
          , pkg: "growlnotify"
          , msg: ''
          , sticky: '/s:true'
          , title: '/t:'
          , icon: '/i:'
          , priority: {
                cmd: '/p:'
              , range: [
                  -2
                , -1
                , 0
                , 1
                , 2
              ]
            }
        };
        break;
    }
    
    /**
     * Expose `growl`.
     */
    
    exports = module.exports = growl;
    
    /**
     * Node-growl version.
     */
    
    exports.version = '1.4.1'
    
    /**
     * Send growl notification _msg_ with _options_.
     *
     * Options:
     *
     *  - title   Notification title
     *  - sticky  Make the notification stick (defaults to false)
     *  - priority  Specify an int or named key (default is 0)
     *  - name    Application name (defaults to growlnotify)
     *  - image
     *    - path to an icon sets --iconpath
     *    - path to an image sets --image
     *    - capitalized word sets --appIcon
     *    - filename uses extname as --icon
     *    - otherwise treated as --icon
     *
     * Examples:
     *
     *   growl('New email')
     *   growl('5 new emails', { title: 'Thunderbird' })
     *   growl('Email sent', function(){
     *     // ... notification sent
     *   })
     *
     * @param {string} msg
     * @param {object} options
     * @param {function} fn
     * @api public
     */
    
    function growl(msg, options, fn) {
      var image
        , args
        , options = options || {}
        , fn = fn || function(){};
    
      // noop
      if (!cmd) return fn(new Error('growl not supported on this platform'));
      args = [cmd.pkg];
    
      // image
      if (image = options.image) {
        switch(cmd.type) {
          case 'Darwin-Growl':
            var flag, ext = path.extname(image).substr(1)
            flag = flag || ext == 'icns' && 'iconpath'
            flag = flag || /^[A-Z]/.test(image) && 'appIcon'
            flag = flag || /^png|gif|jpe?g$/.test(ext) && 'image'
            flag = flag || ext && (image = ext) && 'icon'
            flag = flag || 'icon'
            args.push('--' + flag, quote(image))
            break;
          case 'Linux':
            args.push(cmd.icon, quote(image));
            // libnotify defaults to sticky, set a hint for transient notifications
            if (!options.sticky) args.push('--hint=int:transient:1');
            break;
          case 'Windows':
            args.push(cmd.icon + quote(image));
            break;
        }
      }
    
      // sticky
      if (options.sticky) args.push(cmd.sticky);
    
      // priority
      if (options.priority) {
        var priority = options.priority + '';
        var checkindexOf = cmd.priority.range.indexOf(priority);
        if (~cmd.priority.range.indexOf(priority)) {
          args.push(cmd.priority, options.priority);
        }
      }
    
      // name
      if (options.name && cmd.type === "Darwin-Growl") {
        args.push('--name', options.name);
      }
    
      switch(cmd.type) {
        case 'Darwin-Growl':
          args.push(cmd.msg);
          args.push(quote(msg));
          if (options.title) args.push(quote(options.title));
          break;
        case 'Darwin-NotificationCenter':
          args.push(cmd.msg);
          args.push(quote(msg));
          if (options.title) {
            args.push(cmd.title);
            args.push(quote(options.title));
          }
          if (options.subtitle) {
            args.push(cmd.subtitle);
            args.push(quote(options.subtitle));
          }
          break;
        case 'Darwin-Growl':
          args.push(cmd.msg);
          args.push(quote(msg));
          if (options.title) args.push(quote(options.title));
          break;
        case 'Linux':
          if (options.title) {
            args.push(quote(options.title));
            args.push(cmd.msg);
            args.push(quote(msg));
          } else {
            args.push(quote(msg));
          }
          break;
        case 'Windows':
          args.push(quote(msg));
          if (options.title) args.push(cmd.title + quote(options.title));
          break;
      }
    
      // execute
      exec(args.join(' '), fn);
    };
    
  provide("growl", module.exports);
}(global));

// pakmanager:jade/lib/nodes/node
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node = module.exports = function Node(){};
    
    /**
     * Clone this node (return itself)
     *
     * @return {Node}
     * @api private
     */
    
    Node.prototype.clone = function(){
      var err = new Error('node.clone is deprecated and will be removed in v2.0.0');
      console.warn(err.stack);
      return this;
    };
    
    Node.prototype.type = '';
    
  provide("jade/lib/nodes/node", module.exports);
}(global));

// pakmanager:jade/lib/nodes/attrs
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node =  require('jade/lib/nodes/node');
    
    /**
     * Initialize a `Attrs` node.
     *
     * @api public
     */
    
    var Attrs = module.exports = function Attrs() {
      this.attributeNames = [];
      this.attrs = [];
      this.attributeBlocks = [];
    };
    
    // Inherit from `Node`.
    Attrs.prototype = Object.create(Node.prototype);
    Attrs.prototype.constructor = Attrs;
    
    Attrs.prototype.type = 'Attrs';
    
    /**
     * Set attribute `name` to `val`, keep in mind these become
     * part of a raw js object literal, so to quote a value you must
     * '"quote me"', otherwise or example 'user.name' is literal JavaScript.
     *
     * @param {String} name
     * @param {String} val
     * @param {Boolean} escaped
     * @return {Tag} for chaining
     * @api public
     */
    
    Attrs.prototype.setAttribute = function(name, val, escaped){
      if (name !== 'class' && this.attributeNames.indexOf(name) !== -1) {
        throw new Error('Duplicate attribute "' + name + '" is not allowed.');
      }
      this.attributeNames.push(name);
      this.attrs.push({ name: name, val: val, escaped: escaped });
      return this;
    };
    
    /**
     * Remove attribute `name` when present.
     *
     * @param {String} name
     * @api public
     */
    
    Attrs.prototype.removeAttribute = function(name){
      var err = new Error('attrs.removeAttribute is deprecated and will be removed in v2.0.0');
      console.warn(err.stack);
    
      for (var i = 0, len = this.attrs.length; i < len; ++i) {
        if (this.attrs[i] && this.attrs[i].name == name) {
          delete this.attrs[i];
        }
      }
    };
    
    /**
     * Get attribute value by `name`.
     *
     * @param {String} name
     * @return {String}
     * @api public
     */
    
    Attrs.prototype.getAttribute = function(name){
      var err = new Error('attrs.getAttribute is deprecated and will be removed in v2.0.0');
      console.warn(err.stack);
    
      for (var i = 0, len = this.attrs.length; i < len; ++i) {
        if (this.attrs[i] && this.attrs[i].name == name) {
          return this.attrs[i].val;
        }
      }
    };
    
    Attrs.prototype.addAttributes = function (src) {
      this.attributeBlocks.push(src);
    };
    
  provide("jade/lib/nodes/attrs", module.exports);
}(global));

// pakmanager:jade/lib/nodes/block
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node =  require('jade/lib/nodes/node');
    
    /**
     * Initialize a new `Block` with an optional `node`.
     *
     * @param {Node} node
     * @api public
     */
    
    var Block = module.exports = function Block(node){
      this.nodes = [];
      if (node) this.push(node);
    };
    
    // Inherit from `Node`.
    Block.prototype = Object.create(Node.prototype);
    Block.prototype.constructor = Block;
    
    Block.prototype.type = 'Block';
    
    /**
     * Block flag.
     */
    
    Block.prototype.isBlock = true;
    
    /**
     * Replace the nodes in `other` with the nodes
     * in `this` block.
     *
     * @param {Block} other
     * @api private
     */
    
    Block.prototype.replace = function(other){
      var err = new Error('block.replace is deprecated and will be removed in v2.0.0');
      console.warn(err.stack);
    
      other.nodes = this.nodes;
    };
    
    /**
     * Push the given `node`.
     *
     * @param {Node} node
     * @return {Number}
     * @api public
     */
    
    Block.prototype.push = function(node){
      return this.nodes.push(node);
    };
    
    /**
     * Check if this block is empty.
     *
     * @return {Boolean}
     * @api public
     */
    
    Block.prototype.isEmpty = function(){
      return 0 == this.nodes.length;
    };
    
    /**
     * Unshift the given `node`.
     *
     * @param {Node} node
     * @return {Number}
     * @api public
     */
    
    Block.prototype.unshift = function(node){
      return this.nodes.unshift(node);
    };
    
    /**
     * Return the "last" block, or the first `yield` node.
     *
     * @return {Block}
     * @api private
     */
    
    Block.prototype.includeBlock = function(){
      var ret = this
        , node;
    
      for (var i = 0, len = this.nodes.length; i < len; ++i) {
        node = this.nodes[i];
        if (node.yield) return node;
        else if (node.textOnly) continue;
        else if (node.includeBlock) ret = node.includeBlock();
        else if (node.block && !node.block.isEmpty()) ret = node.block.includeBlock();
        if (ret.yield) return ret;
      }
    
      return ret;
    };
    
    /**
     * Return a clone of this block.
     *
     * @return {Block}
     * @api private
     */
    
    Block.prototype.clone = function(){
      var err = new Error('block.clone is deprecated and will be removed in v2.0.0');
      console.warn(err.stack);
    
      var clone = new Block;
      for (var i = 0, len = this.nodes.length; i < len; ++i) {
        clone.push(this.nodes[i].clone());
      }
      return clone;
    };
    
  provide("jade/lib/nodes/block", module.exports);
}(global));

// pakmanager:jade/lib/inline-tags
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    module.exports = [
        'a'
      , 'abbr'
      , 'acronym'
      , 'b'
      , 'br'
      , 'code'
      , 'em'
      , 'font'
      , 'i'
      , 'img'
      , 'ins'
      , 'kbd'
      , 'map'
      , 'samp'
      , 'small'
      , 'span'
      , 'strong'
      , 'sub'
      , 'sup'
    ];
  provide("jade/lib/inline-tags", module.exports);
}(global));

// pakmanager:jade/lib/utils
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    /**
     * Merge `b` into `a`.
     *
     * @param {Object} a
     * @param {Object} b
     * @return {Object}
     * @api public
     */
    
    exports.merge = function(a, b) {
      for (var key in b) a[key] = b[key];
      return a;
    };
    
    exports.stringify = function(str) {
      return JSON.stringify(str)
                 .replace(/\u2028/g, '\\u2028')
                 .replace(/\u2029/g, '\\u2029');
    };
    
    exports.walkAST = function walkAST(ast, before, after) {
      before && before(ast);
      switch (ast.type) {
        case 'Block':
          ast.nodes.forEach(function (node) {
            walkAST(node, before, after);
          });
          break;
        case 'Case':
        case 'Each':
        case 'Mixin':
        case 'Tag':
        case 'When':
        case 'Code':
          ast.block && walkAST(ast.block, before, after);
          break;
        case 'Attrs':
        case 'BlockComment':
        case 'Comment':
        case 'Doctype':
        case 'Filter':
        case 'Literal':
        case 'MixinBlock':
        case 'Text':
          break;
        default:
          throw new Error('Unexpected node type ' + ast.type);
          break;
      }
      after && after(ast);
    };
    
  provide("jade/lib/utils", module.exports);
}(global));

// pakmanager:jade/lib/nodes/tag
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Attrs =  require('jade/lib/nodes/attrs');
    var Block =  require('jade/lib/nodes/block');
    var inlineTags =  require('jade/lib/inline-tags');
    
    /**
     * Initialize a `Tag` node with the given tag `name` and optional `block`.
     *
     * @param {String} name
     * @param {Block} block
     * @api public
     */
    
    var Tag = module.exports = function Tag(name, block) {
      Attrs.call(this);
      this.name = name;
      this.block = block || new Block;
    };
    
    // Inherit from `Attrs`.
    Tag.prototype = Object.create(Attrs.prototype);
    Tag.prototype.constructor = Tag;
    
    Tag.prototype.type = 'Tag';
    
    /**
     * Clone this tag.
     *
     * @return {Tag}
     * @api private
     */
    
    Tag.prototype.clone = function(){
      var err = new Error('tag.clone is deprecated and will be removed in v2.0.0');
      console.warn(err.stack);
    
      var clone = new Tag(this.name, this.block.clone());
      clone.line = this.line;
      clone.attrs = this.attrs;
      clone.textOnly = this.textOnly;
      return clone;
    };
    
    /**
     * Check if this tag is an inline tag.
     *
     * @return {Boolean}
     * @api private
     */
    
    Tag.prototype.isInline = function(){
      return ~inlineTags.indexOf(this.name);
    };
    
    /**
     * Check if this tag's contents can be inlined.  Used for pretty printing.
     *
     * @return {Boolean}
     * @api private
     */
    
    Tag.prototype.canInline = function(){
      var nodes = this.block.nodes;
    
      function isInline(node){
        // Recurse if the node is a block
        if (node.isBlock) return node.nodes.every(isInline);
        return node.isText || (node.isInline && node.isInline());
      }
    
      // Empty tag
      if (!nodes.length) return true;
    
      // Text-only or inline-only tag
      if (1 == nodes.length) return isInline(nodes[0]);
    
      // Multi-line inline-only tag
      if (this.block.nodes.every(isInline)) {
        for (var i = 1, len = nodes.length; i < len; ++i) {
          if (nodes[i-1].isText && nodes[i].isText)
            return false;
        }
        return true;
      }
    
      // Mixed tag
      return false;
    };
    
  provide("jade/lib/nodes/tag", module.exports);
}(global));

// pakmanager:jade/lib/nodes/code
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node =  require('jade/lib/nodes/node');
    
    /**
     * Initialize a `Code` node with the given code `val`.
     * Code may also be optionally buffered and escaped.
     *
     * @param {String} val
     * @param {Boolean} buffer
     * @param {Boolean} escape
     * @api public
     */
    
    var Code = module.exports = function Code(val, buffer, escape) {
      this.val = val;
      this.buffer = buffer;
      this.escape = escape;
      if (val.match(/^ *else/)) this.debug = false;
    };
    
    // Inherit from `Node`.
    Code.prototype = Object.create(Node.prototype);
    Code.prototype.constructor = Code;
    
    Code.prototype.type = 'Code'; // prevent the minifiers removing this
  provide("jade/lib/nodes/code", module.exports);
}(global));

// pakmanager:jade/lib/nodes/each
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node =  require('jade/lib/nodes/node');
    
    /**
     * Initialize an `Each` node, representing iteration
     *
     * @param {String} obj
     * @param {String} val
     * @param {String} key
     * @param {Block} block
     * @api public
     */
    
    var Each = module.exports = function Each(obj, val, key, block) {
      this.obj = obj;
      this.val = val;
      this.key = key;
      this.block = block;
    };
    
    // Inherit from `Node`.
    Each.prototype = Object.create(Node.prototype);
    Each.prototype.constructor = Each;
    
    Each.prototype.type = 'Each';
    
  provide("jade/lib/nodes/each", module.exports);
}(global));

// pakmanager:jade/lib/nodes/case
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node =  require('jade/lib/nodes/node');
    
    /**
     * Initialize a new `Case` with `expr`.
     *
     * @param {String} expr
     * @api public
     */
    
    var Case = exports = module.exports = function Case(expr, block){
      this.expr = expr;
      this.block = block;
    };
    
    // Inherit from `Node`.
    Case.prototype = Object.create(Node.prototype);
    Case.prototype.constructor = Case;
    
    Case.prototype.type = 'Case';
    
    var When = exports.When = function When(expr, block){
      this.expr = expr;
      this.block = block;
      this.debug = false;
    };
    
    // Inherit from `Node`.
    When.prototype = Object.create(Node.prototype);
    When.prototype.constructor = When;
    
    When.prototype.type = 'When';
    
  provide("jade/lib/nodes/case", module.exports);
}(global));

// pakmanager:jade/lib/nodes/text
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node =  require('jade/lib/nodes/node');
    
    /**
     * Initialize a `Text` node with optional `line`.
     *
     * @param {String} line
     * @api public
     */
    
    var Text = module.exports = function Text(line) {
      this.val = line;
    };
    
    // Inherit from `Node`.
    Text.prototype = Object.create(Node.prototype);
    Text.prototype.constructor = Text;
    
    Text.prototype.type = 'Text';
    
    /**
     * Flag as text.
     */
    
    Text.prototype.isText = true;
  provide("jade/lib/nodes/text", module.exports);
}(global));

// pakmanager:jade/lib/nodes/mixin-block
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node =  require('jade/lib/nodes/node');
    
    /**
     * Initialize a new `Block` with an optional `node`.
     *
     * @param {Node} node
     * @api public
     */
    
    var MixinBlock = module.exports = function MixinBlock(){};
    
    // Inherit from `Node`.
    MixinBlock.prototype = Object.create(Node.prototype);
    MixinBlock.prototype.constructor = MixinBlock;
    
    MixinBlock.prototype.type = 'MixinBlock';
    
  provide("jade/lib/nodes/mixin-block", module.exports);
}(global));

// pakmanager:jade/lib/nodes/mixin
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Attrs =  require('jade/lib/nodes/attrs');
    
    /**
     * Initialize a new `Mixin` with `name` and `block`.
     *
     * @param {String} name
     * @param {String} args
     * @param {Block} block
     * @api public
     */
    
    var Mixin = module.exports = function Mixin(name, args, block, call){
      Attrs.call(this);
      this.name = name;
      this.args = args;
      this.block = block;
      this.call = call;
    };
    
    // Inherit from `Attrs`.
    Mixin.prototype = Object.create(Attrs.prototype);
    Mixin.prototype.constructor = Mixin;
    
    Mixin.prototype.type = 'Mixin';
    
  provide("jade/lib/nodes/mixin", module.exports);
}(global));

// pakmanager:jade/lib/nodes/filter
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node =  require('jade/lib/nodes/node');
    
    /**
     * Initialize a `Filter` node with the given
     * filter `name` and `block`.
     *
     * @param {String} name
     * @param {Block|Node} block
     * @api public
     */
    
    var Filter = module.exports = function Filter(name, block, attrs) {
      this.name = name;
      this.block = block;
      this.attrs = attrs;
    };
    
    // Inherit from `Node`.
    Filter.prototype = Object.create(Node.prototype);
    Filter.prototype.constructor = Filter;
    
    Filter.prototype.type = 'Filter';
    
  provide("jade/lib/nodes/filter", module.exports);
}(global));

// pakmanager:jade/lib/nodes/comment
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node =  require('jade/lib/nodes/node');
    
    /**
     * Initialize a `Comment` with the given `val`, optionally `buffer`,
     * otherwise the comment may render in the output.
     *
     * @param {String} val
     * @param {Boolean} buffer
     * @api public
     */
    
    var Comment = module.exports = function Comment(val, buffer) {
      this.val = val;
      this.buffer = buffer;
    };
    
    // Inherit from `Node`.
    Comment.prototype = Object.create(Node.prototype);
    Comment.prototype.constructor = Comment;
    
    Comment.prototype.type = 'Comment';
    
  provide("jade/lib/nodes/comment", module.exports);
}(global));

// pakmanager:jade/lib/nodes/literal
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node =  require('jade/lib/nodes/node');
    
    /**
     * Initialize a `Literal` node with the given `str.
     *
     * @param {String} str
     * @api public
     */
    
    var Literal = module.exports = function Literal(str) {
      this.str = str;
    };
    
    // Inherit from `Node`.
    Literal.prototype = Object.create(Node.prototype);
    Literal.prototype.constructor = Literal;
    
    Literal.prototype.type = 'Literal';
    
  provide("jade/lib/nodes/literal", module.exports);
}(global));

// pakmanager:jade/lib/nodes/block-comment
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node =  require('jade/lib/nodes/node');
    
    /**
     * Initialize a `BlockComment` with the given `block`.
     *
     * @param {String} val
     * @param {Block} block
     * @param {Boolean} buffer
     * @api public
     */
    
    var BlockComment = module.exports = function BlockComment(val, block, buffer) {
      this.block = block;
      this.val = val;
      this.buffer = buffer;
    };
    
    // Inherit from `Node`.
    BlockComment.prototype = Object.create(Node.prototype);
    BlockComment.prototype.constructor = BlockComment;
    
    BlockComment.prototype.type = 'BlockComment';
    
  provide("jade/lib/nodes/block-comment", module.exports);
}(global));

// pakmanager:jade/lib/nodes/doctype
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node =  require('jade/lib/nodes/node');
    
    /**
     * Initialize a `Doctype` with the given `val`. 
     *
     * @param {String} val
     * @api public
     */
    
    var Doctype = module.exports = function Doctype(val) {
      this.val = val;
    };
    
    // Inherit from `Node`.
    Doctype.prototype = Object.create(Node.prototype);
    Doctype.prototype.constructor = Doctype;
    
    Doctype.prototype.type = 'Doctype';
    
  provide("jade/lib/nodes/doctype", module.exports);
}(global));

// pakmanager:jade/lib/lexer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var utils =  require('jade/lib/utils');
    var characterParser = require('character-parser');
    
    
    /**
     * Initialize `Lexer` with the given `str`.
     *
     * @param {String} str
     * @param {String} filename
     * @api private
     */
    
    var Lexer = module.exports = function Lexer(str, filename) {
      this.input = str.replace(/\r\n|\r/g, '\n');
      this.filename = filename;
      this.deferredTokens = [];
      this.lastIndents = 0;
      this.lineno = 1;
      this.stash = [];
      this.indentStack = [];
      this.indentRe = null;
      this.pipeless = false;
    };
    
    
    function assertExpression(exp) {
      //this verifies that a JavaScript expression is valid
      Function('', 'return (' + exp + ')');
    }
    function assertNestingCorrect(exp) {
      //this verifies that code is properly nested, but allows
      //invalid JavaScript such as the contents of `attributes`
      var res = characterParser(exp)
      if (res.isNesting()) {
        throw new Error('Nesting must match on expression `' + exp + '`')
      }
    }
    
    /**
     * Lexer prototype.
     */
    
    Lexer.prototype = {
    
      /**
       * Construct a token with the given `type` and `val`.
       *
       * @param {String} type
       * @param {String} val
       * @return {Object}
       * @api private
       */
    
      tok: function(type, val){
        return {
            type: type
          , line: this.lineno
          , val: val
        }
      },
    
      /**
       * Consume the given `len` of input.
       *
       * @param {Number} len
       * @api private
       */
    
      consume: function(len){
        this.input = this.input.substr(len);
      },
    
      /**
       * Scan for `type` with the given `regexp`.
       *
       * @param {String} type
       * @param {RegExp} regexp
       * @return {Object}
       * @api private
       */
    
      scan: function(regexp, type){
        var captures;
        if (captures = regexp.exec(this.input)) {
          this.consume(captures[0].length);
          return this.tok(type, captures[1]);
        }
      },
    
      /**
       * Defer the given `tok`.
       *
       * @param {Object} tok
       * @api private
       */
    
      defer: function(tok){
        this.deferredTokens.push(tok);
      },
    
      /**
       * Lookahead `n` tokens.
       *
       * @param {Number} n
       * @return {Object}
       * @api private
       */
    
      lookahead: function(n){
        var fetch = n - this.stash.length;
        while (fetch-- > 0) this.stash.push(this.next());
        return this.stash[--n];
      },
    
      /**
       * Return the indexOf `(` or `{` or `[` / `)` or `}` or `]` delimiters.
       *
       * @return {Number}
       * @api private
       */
    
      bracketExpression: function(skip){
        skip = skip || 0;
        var start = this.input[skip];
        if (start != '(' && start != '{' && start != '[') throw new Error('unrecognized start character');
        var end = ({'(': ')', '{': '}', '[': ']'})[start];
        var range = characterParser.parseMax(this.input, {start: skip + 1});
        if (this.input[range.end] !== end) throw new Error('start character ' + start + ' does not match end character ' + this.input[range.end]);
        return range;
      },
    
      /**
       * Stashed token.
       */
    
      stashed: function() {
        return this.stash.length
          && this.stash.shift();
      },
    
      /**
       * Deferred token.
       */
    
      deferred: function() {
        return this.deferredTokens.length
          && this.deferredTokens.shift();
      },
    
      /**
       * end-of-source.
       */
    
      eos: function() {
        if (this.input.length) return;
        if (this.indentStack.length) {
          this.indentStack.shift();
          return this.tok('outdent');
        } else {
          return this.tok('eos');
        }
      },
    
      /**
       * Blank line.
       */
    
      blank: function() {
        var captures;
        if (captures = /^\n *\n/.exec(this.input)) {
          this.consume(captures[0].length - 1);
          ++this.lineno;
          if (this.pipeless) return this.tok('text', '');
          return this.next();
        }
      },
    
      /**
       * Comment.
       */
    
      comment: function() {
        var captures;
        if (captures = /^\/\/(-)?([^\n]*)/.exec(this.input)) {
          this.consume(captures[0].length);
          var tok = this.tok('comment', captures[2]);
          tok.buffer = '-' != captures[1];
          this.pipeless = true;
          return tok;
        }
      },
    
      /**
       * Interpolated tag.
       */
    
      interpolation: function() {
        if (/^#\{/.test(this.input)) {
          var match = this.bracketExpression(1);
    
          this.consume(match.end + 1);
          return this.tok('interpolation', match.src);
        }
      },
    
      /**
       * Tag.
       */
    
      tag: function() {
        var captures;
        if (captures = /^(\w[-:\w]*)(\/?)/.exec(this.input)) {
          this.consume(captures[0].length);
          var tok, name = captures[1];
          if (':' == name[name.length - 1]) {
            name = name.slice(0, -1);
            tok = this.tok('tag', name);
            this.defer(this.tok(':'));
            if (this.input[0] !== ' ') {
              console.warn('Warning: space required after `:` on line ' + this.lineno +
                  ' of jade file "' + this.filename + '"');
            }
            while (' ' == this.input[0]) this.input = this.input.substr(1);
          } else {
            tok = this.tok('tag', name);
          }
          tok.selfClosing = !!captures[2];
          return tok;
        }
      },
    
      /**
       * Filter.
       */
    
      filter: function() {
        var tok = this.scan(/^:([\w\-]+)/, 'filter');
        if (tok) {
          this.pipeless = true;
          return tok;
        }
      },
    
      /**
       * Doctype.
       */
    
      doctype: function() {
        if (this.scan(/^!!! *([^\n]+)?/, 'doctype')) {
          throw new Error('`!!!` is deprecated, you must now use `doctype`');
        }
        var node = this.scan(/^(?:doctype) *([^\n]+)?/, 'doctype');
        if (node && node.val && node.val.trim() === '5') {
          throw new Error('`doctype 5` is deprecated, you must now use `doctype html`');
        }
        return node;
      },
    
      /**
       * Id.
       */
    
      id: function() {
        return this.scan(/^#([\w-]+)/, 'id');
      },
    
      /**
       * Class.
       */
    
      className: function() {
        return this.scan(/^\.([\w-]+)/, 'class');
      },
    
      /**
       * Text.
       */
    
      text: function() {
        return this.scan(/^(?:\| ?| )([^\n]+)/, 'text') ||
          this.scan(/^\|?( )/, 'text') ||
          this.scan(/^(<[^\n]*)/, 'text');
      },
    
      textFail: function () {
        var tok;
        if (tok = this.scan(/^([^\.\n][^\n]+)/, 'text')) {
          console.warn('Warning: missing space before text for line ' + this.lineno +
              ' of jade file "' + this.filename + '"');
          return tok;
        }
      },
    
      /**
       * Dot.
       */
    
      dot: function() {
        var match;
        if (match = this.scan(/^\./, 'dot')) {
          this.pipeless = true;
          return match;
        }
      },
    
      /**
       * Extends.
       */
    
      "extends": function() {
        return this.scan(/^extends? +([^\n]+)/, 'extends');
      },
    
      /**
       * Block prepend.
       */
    
      prepend: function() {
        var captures;
        if (captures = /^prepend +([^\n]+)/.exec(this.input)) {
          this.consume(captures[0].length);
          var mode = 'prepend'
            , name = captures[1]
            , tok = this.tok('block', name);
          tok.mode = mode;
          return tok;
        }
      },
    
      /**
       * Block append.
       */
    
      append: function() {
        var captures;
        if (captures = /^append +([^\n]+)/.exec(this.input)) {
          this.consume(captures[0].length);
          var mode = 'append'
            , name = captures[1]
            , tok = this.tok('block', name);
          tok.mode = mode;
          return tok;
        }
      },
    
      /**
       * Block.
       */
    
      block: function() {
        var captures;
        if (captures = /^block\b *(?:(prepend|append) +)?([^\n]+)/.exec(this.input)) {
          this.consume(captures[0].length);
          var mode = captures[1] || 'replace'
            , name = captures[2]
            , tok = this.tok('block', name);
    
          tok.mode = mode;
          return tok;
        }
      },
    
      /**
       * Mixin Block.
       */
    
      mixinBlock: function() {
        var captures;
        if (captures = /^block[ \t]*(\n|$)/.exec(this.input)) {
          this.consume(captures[0].length - captures[1].length);
          return this.tok('mixin-block');
        }
      },
    
      /**
       * Yield.
       */
    
      'yield': function() {
        return this.scan(/^yield */, 'yield');
      },
    
      /**
       * Include.
       */
    
      include: function() {
        return this.scan(/^include +([^\n]+)/, 'include');
      },
    
      /**
       * Include with filter
       */
    
      includeFiltered: function() {
        var captures;
        if (captures = /^include:([\w\-]+)([\( ])/.exec(this.input)) {
          this.consume(captures[0].length - 1);
          var filter = captures[1];
          var attrs = captures[2] === '(' ? this.attrs() : null;
          if (!(captures[2] === ' ' || this.input[0] === ' ')) {
            throw new Error('expected space after include:filter but got ' + utils.stringify(this.input[0]));
          }
          captures = /^ *([^\n]+)/.exec(this.input);
          if (!captures || captures[1].trim() === '') {
            throw new Error('missing path for include:filter');
          }
          this.consume(captures[0].length);
          var path = captures[1];
          var tok = this.tok('include', path);
          tok.filter = filter;
          tok.attrs = attrs;
          return tok;
        }
      },
    
      /**
       * Case.
       */
    
      "case": function() {
        return this.scan(/^case +([^\n]+)/, 'case');
      },
    
      /**
       * When.
       */
    
      when: function() {
        return this.scan(/^when +([^:\n]+)/, 'when');
      },
    
      /**
       * Default.
       */
    
      "default": function() {
        return this.scan(/^default */, 'default');
      },
    
      /**
       * Call mixin.
       */
    
      call: function(){
    
        var tok, captures;
        if (captures = /^\+(\s*)(([-\w]+)|(#\{))/.exec(this.input)) {
          // try to consume simple or interpolated call
          if (captures[3]) {
            // simple call
            this.consume(captures[0].length);
            tok = this.tok('call', captures[3]);
          } else {
            // interpolated call
            var match = this.bracketExpression(2 + captures[1].length);
            this.consume(match.end + 1);
            assertExpression(match.src);
            tok = this.tok('call', '#{'+match.src+'}');
          }
    
          // Check for args (not attributes)
          if (captures = /^ *\(/.exec(this.input)) {
            var range = this.bracketExpression(captures[0].length - 1);
            if (!/^\s*[-\w]+ *=/.test(range.src)) { // not attributes
              this.consume(range.end + 1);
              tok.args = range.src;
            }
            if (tok.args) {
              assertExpression('[' + tok.args + ']');
            }
          }
    
          return tok;
        }
      },
    
      /**
       * Mixin.
       */
    
      mixin: function(){
        var captures;
        if (captures = /^mixin +([-\w]+)(?: *\((.*)\))? */.exec(this.input)) {
          this.consume(captures[0].length);
          var tok = this.tok('mixin', captures[1]);
          tok.args = captures[2];
          return tok;
        }
      },
    
      /**
       * Conditional.
       */
    
      conditional: function() {
        var captures;
        if (captures = /^(if|unless|else if|else)\b([^\n]*)/.exec(this.input)) {
          this.consume(captures[0].length);
          var type = captures[1]
          var js = captures[2];
          var isIf = false;
          var isElse = false;
    
          switch (type) {
            case 'if':
              assertExpression(js)
              js = 'if (' + js + ')';
              isIf = true;
              break;
            case 'unless':
              assertExpression(js)
              js = 'if (!(' + js + '))';
              isIf = true;
              break;
            case 'else if':
              assertExpression(js)
              js = 'else if (' + js + ')';
              isIf = true;
              isElse = true;
              break;
            case 'else':
              if (js && js.trim()) {
                throw new Error('`else` cannot have a condition, perhaps you meant `else if`');
              }
              js = 'else';
              isElse = true;
              break;
          }
          var tok = this.tok('code', js);
          tok.isElse = isElse;
          tok.isIf = isIf;
          tok.requiresBlock = true;
          return tok;
        }
      },
    
      /**
       * While.
       */
    
      "while": function() {
        var captures;
        if (captures = /^while +([^\n]+)/.exec(this.input)) {
          this.consume(captures[0].length);
          assertExpression(captures[1])
          var tok = this.tok('code', 'while (' + captures[1] + ')');
          tok.requiresBlock = true;
          return tok;
        }
      },
    
      /**
       * Each.
       */
    
      each: function() {
        var captures;
        if (captures = /^(?:- *)?(?:each|for) +([a-zA-Z_$][\w$]*)(?: *, *([a-zA-Z_$][\w$]*))? * in *([^\n]+)/.exec(this.input)) {
          this.consume(captures[0].length);
          var tok = this.tok('each', captures[1]);
          tok.key = captures[2] || '$index';
          assertExpression(captures[3])
          tok.code = captures[3];
          return tok;
        }
      },
    
      /**
       * Code.
       */
    
      code: function() {
        var captures;
        if (captures = /^(!?=|-)[ \t]*([^\n]+)/.exec(this.input)) {
          this.consume(captures[0].length);
          var flags = captures[1];
          captures[1] = captures[2];
          var tok = this.tok('code', captures[1]);
          tok.escape = flags.charAt(0) === '=';
          tok.buffer = flags.charAt(0) === '=' || flags.charAt(1) === '=';
          if (tok.buffer) assertExpression(captures[1])
          return tok;
        }
      },
    
      /**
       * Attributes.
       */
    
      attrs: function() {
        if ('(' == this.input.charAt(0)) {
          var index = this.bracketExpression().end
            , str = this.input.substr(1, index-1)
            , tok = this.tok('attrs');
    
          assertNestingCorrect(str);
    
          var quote = '';
          var interpolate = function (attr) {
            return attr.replace(/(\\)?#\{(.+)/g, function(_, escape, expr){
              if (escape) return _;
              try {
                var range = characterParser.parseMax(expr);
                if (expr[range.end] !== '}') return _.substr(0, 2) + interpolate(_.substr(2));
                assertExpression(range.src)
                return quote + " + (" + range.src + ") + " + quote + interpolate(expr.substr(range.end + 1));
              } catch (ex) {
                return _.substr(0, 2) + interpolate(_.substr(2));
              }
            });
          }
    
          this.consume(index + 1);
          tok.attrs = [];
    
          var escapedAttr = true
          var key = '';
          var val = '';
          var interpolatable = '';
          var state = characterParser.defaultState();
          var loc = 'key';
          var isEndOfAttribute = function (i) {
            if (key.trim() === '') return false;
            if (i === str.length) return true;
            if (loc === 'key') {
              if (str[i] === ' ' || str[i] === '\n') {
                for (var x = i; x < str.length; x++) {
                  if (str[x] != ' ' && str[x] != '\n') {
                    if (str[x] === '=' || str[x] === '!' || str[x] === ',') return false;
                    else return true;
                  }
                }
              }
              return str[i] === ','
            } else if (loc === 'value' && !state.isNesting()) {
              try {
                assertExpression(val);
                if (str[i] === ' ' || str[i] === '\n') {
                  for (var x = i; x < str.length; x++) {
                    if (str[x] != ' ' && str[x] != '\n') {
                      if (characterParser.isPunctuator(str[x]) && str[x] != '"' && str[x] != "'") return false;
                      else return true;
                    }
                  }
                }
                return str[i] === ',';
              } catch (ex) {
                return false;
              }
            }
          }
    
          this.lineno += str.split("\n").length - 1;
    
          for (var i = 0; i <= str.length; i++) {
            if (isEndOfAttribute(i)) {
              val = val.trim();
              if (val) assertExpression(val)
              key = key.trim();
              key = key.replace(/^['"]|['"]$/g, '');
              tok.attrs.push({
                name: key,
                val: '' == val ? true : val,
                escaped: escapedAttr
              });
              key = val = '';
              loc = 'key';
              escapedAttr = false;
            } else {
              switch (loc) {
                case 'key-char':
                  if (str[i] === quote) {
                    loc = 'key';
                    if (i + 1 < str.length && [' ', ',', '!', '=', '\n'].indexOf(str[i + 1]) === -1)
                      throw new Error('Unexpected character ' + str[i + 1] + ' expected ` `, `\\n`, `,`, `!` or `=`');
                  } else {
                    key += str[i];
                  }
                  break;
                case 'key':
                  if (key === '' && (str[i] === '"' || str[i] === "'")) {
                    loc = 'key-char';
                    quote = str[i];
                  } else if (str[i] === '!' || str[i] === '=') {
                    escapedAttr = str[i] !== '!';
                    if (str[i] === '!') i++;
                    if (str[i] !== '=') throw new Error('Unexpected character ' + str[i] + ' expected `=`');
                    loc = 'value';
                    state = characterParser.defaultState();
                  } else {
                    key += str[i]
                  }
                  break;
                case 'value':
                  state = characterParser.parseChar(str[i], state);
                  if (state.isString()) {
                    loc = 'string';
                    quote = str[i];
                    interpolatable = str[i];
                  } else {
                    val += str[i];
                  }
                  break;
                case 'string':
                  state = characterParser.parseChar(str[i], state);
                  interpolatable += str[i];
                  if (!state.isString()) {
                    loc = 'value';
                    val += interpolate(interpolatable);
                  }
                  break;
              }
            }
          }
    
          if ('/' == this.input.charAt(0)) {
            this.consume(1);
            tok.selfClosing = true;
          }
    
          return tok;
        }
      },
    
      /**
       * &attributes block
       */
      attributesBlock: function () {
        var captures;
        if (/^&attributes\b/.test(this.input)) {
          this.consume(11);
          var args = this.bracketExpression();
          this.consume(args.end + 1);
          return this.tok('&attributes', args.src);
        }
      },
    
      /**
       * Indent | Outdent | Newline.
       */
    
      indent: function() {
        var captures, re;
    
        // established regexp
        if (this.indentRe) {
          captures = this.indentRe.exec(this.input);
        // determine regexp
        } else {
          // tabs
          re = /^\n(\t*) */;
          captures = re.exec(this.input);
    
          // spaces
          if (captures && !captures[1].length) {
            re = /^\n( *)/;
            captures = re.exec(this.input);
          }
    
          // established
          if (captures && captures[1].length) this.indentRe = re;
        }
    
        if (captures) {
          var tok
            , indents = captures[1].length;
    
          ++this.lineno;
          this.consume(indents + 1);
    
          if (' ' == this.input[0] || '\t' == this.input[0]) {
            throw new Error('Invalid indentation, you can use tabs or spaces but not both');
          }
    
          // blank line
          if ('\n' == this.input[0]) {
            this.pipeless = false;
            return this.tok('newline');
          }
    
          // outdent
          if (this.indentStack.length && indents < this.indentStack[0]) {
            while (this.indentStack.length && this.indentStack[0] > indents) {
              this.stash.push(this.tok('outdent'));
              this.indentStack.shift();
            }
            tok = this.stash.pop();
          // indent
          } else if (indents && indents != this.indentStack[0]) {
            this.indentStack.unshift(indents);
            tok = this.tok('indent', indents);
          // newline
          } else {
            tok = this.tok('newline');
          }
    
          this.pipeless = false;
          return tok;
        }
      },
    
      /**
       * Pipe-less text consumed only when
       * pipeless is true;
       */
    
      pipelessText: function() {
        if (!this.pipeless) return;
        var captures, re;
    
        // established regexp
        if (this.indentRe) {
          captures = this.indentRe.exec(this.input);
        // determine regexp
        } else {
          // tabs
          re = /^\n(\t*) */;
          captures = re.exec(this.input);
    
          // spaces
          if (captures && !captures[1].length) {
            re = /^\n( *)/;
            captures = re.exec(this.input);
          }
    
          // established
          if (captures && captures[1].length) this.indentRe = re;
        }
    
        var indents = captures && captures[1].length;
        if (indents && (this.indentStack.length === 0 || indents > this.indentStack[0])) {
          var indent = captures[1];
          var line;
          var tokens = [];
          var isMatch;
          do {
            // text has `\n` as a prefix
            var i = this.input.substr(1).indexOf('\n');
            if (-1 == i) i = this.input.length - 1;
            var str = this.input.substr(1, i);
            isMatch = str.substr(0, indent.length) === indent || !str.trim();
            if (isMatch) {
              // consume test along with `\n` prefix if match
              this.consume(str.length + 1);
              tokens.push(str.substr(indent.length));
            }
          } while(this.input.length && isMatch);
          while (this.input.length === 0 && tokens[tokens.length - 1] === '') tokens.pop();
          return this.tok('pipeless-text', tokens);
        }
      },
    
      /**
       * ':'
       */
    
      colon: function() {
        var good = /^: +/.test(this.input);
        var res = this.scan(/^: */, ':');
        if (res && !good) {
          console.warn('Warning: space required after `:` on line ' + this.lineno +
              ' of jade file "' + this.filename + '"');
        }
        return res;
      },
    
      fail: function () {
        throw new Error('unexpected text ' + this.input.substr(0, 5));
      },
    
      /**
       * Return the next token object, or those
       * previously stashed by lookahead.
       *
       * @return {Object}
       * @api private
       */
    
      advance: function(){
        return this.stashed()
          || this.next();
      },
    
      /**
       * Return the next token object.
       *
       * @return {Object}
       * @api private
       */
    
      next: function() {
        return this.deferred()
          || this.blank()
          || this.eos()
          || this.pipelessText()
          || this.yield()
          || this.doctype()
          || this.interpolation()
          || this["case"]()
          || this.when()
          || this["default"]()
          || this["extends"]()
          || this.append()
          || this.prepend()
          || this.block()
          || this.mixinBlock()
          || this.include()
          || this.includeFiltered()
          || this.mixin()
          || this.call()
          || this.conditional()
          || this.each()
          || this["while"]()
          || this.tag()
          || this.filter()
          || this.code()
          || this.id()
          || this.className()
          || this.attrs()
          || this.attributesBlock()
          || this.indent()
          || this.text()
          || this.comment()
          || this.colon()
          || this.dot()
          || this.textFail()
          || this.fail();
      }
    };
    
  provide("jade/lib/lexer", module.exports);
}(global));

// pakmanager:jade/lib/nodes
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    exports.Node =  require('jade/lib/nodes/node');
    exports.Tag =  require('jade/lib/nodes/tag');
    exports.Code =  require('jade/lib/nodes/code');
    exports.Each =  require('jade/lib/nodes/each');
    exports.Case =  require('jade/lib/nodes/case');
    exports.Text =  require('jade/lib/nodes/text');
    exports.Block =  require('jade/lib/nodes/block');
    exports.MixinBlock =  require('jade/lib/nodes/mixin-block');
    exports.Mixin =  require('jade/lib/nodes/mixin');
    exports.Filter =  require('jade/lib/nodes/filter');
    exports.Comment =  require('jade/lib/nodes/comment');
    exports.Literal =  require('jade/lib/nodes/literal');
    exports.BlockComment =  require('jade/lib/nodes/block-comment');
    exports.Doctype =  require('jade/lib/nodes/doctype');
    
  provide("jade/lib/nodes", module.exports);
}(global));

// pakmanager:jade/lib/filters
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var transformers = require('transformers');
    
    module.exports = filter;
    function filter(name, str, options) {
      if (typeof filter[name] === 'function') {
        return filter[name](str, options);
      } else if (transformers[name]) {
        return transformers[name].renderSync(str, options);
      } else {
        throw new Error('unknown filter ":' + name + '"');
      }
    }
    
  provide("jade/lib/filters", module.exports);
}(global));

// pakmanager:jade/lib/doctypes
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    module.exports = {
        'default': '<!DOCTYPE html>'
      , 'xml': '<?xml version="1.0" encoding="utf-8" ?>'
      , 'transitional': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'
      , 'strict': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">'
      , 'frameset': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">'
      , '1.1': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">'
      , 'basic': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.1//EN" "http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd">'
      , 'mobile': '<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.2//EN" "http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd">'
    };
  provide("jade/lib/doctypes", module.exports);
}(global));

// pakmanager:jade/lib/runtime
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    /**
     * Merge two attribute objects giving precedence
     * to values in object `b`. Classes are special-cased
     * allowing for arrays and merging/joining appropriately
     * resulting in a string.
     *
     * @param {Object} a
     * @param {Object} b
     * @return {Object} a
     * @api private
     */
    
    exports.merge = function merge(a, b) {
      if (arguments.length === 1) {
        var attrs = a[0];
        for (var i = 1; i < a.length; i++) {
          attrs = merge(attrs, a[i]);
        }
        return attrs;
      }
      var ac = a['class'];
      var bc = b['class'];
    
      if (ac || bc) {
        ac = ac || [];
        bc = bc || [];
        if (!Array.isArray(ac)) ac = [ac];
        if (!Array.isArray(bc)) bc = [bc];
        a['class'] = ac.concat(bc).filter(nulls);
      }
    
      for (var key in b) {
        if (key != 'class') {
          a[key] = b[key];
        }
      }
    
      return a;
    };
    
    /**
     * Filter null `val`s.
     *
     * @param {*} val
     * @return {Boolean}
     * @api private
     */
    
    function nulls(val) {
      return val != null && val !== '';
    }
    
    /**
     * join array as classes.
     *
     * @param {*} val
     * @return {String}
     */
    exports.joinClasses = joinClasses;
    function joinClasses(val) {
      return (Array.isArray(val) ? val.map(joinClasses) :
        (val && typeof val === 'object') ? Object.keys(val).filter(function (key) { return val[key]; }) :
        [val]).filter(nulls).join(' ');
    }
    
    /**
     * Render the given classes.
     *
     * @param {Array} classes
     * @param {Array.<Boolean>} escaped
     * @return {String}
     */
    exports.cls = function cls(classes, escaped) {
      var buf = [];
      for (var i = 0; i < classes.length; i++) {
        if (escaped && escaped[i]) {
          buf.push(exports.escape(joinClasses([classes[i]])));
        } else {
          buf.push(joinClasses(classes[i]));
        }
      }
      var text = joinClasses(buf);
      if (text.length) {
        return ' class="' + text + '"';
      } else {
        return '';
      }
    };
    
    
    exports.style = function (val) {
      if (val && typeof val === 'object') {
        return Object.keys(val).map(function (style) {
          return style + ':' + val[style];
        }).join(';');
      } else {
        return val;
      }
    };
    /**
     * Render the given attribute.
     *
     * @param {String} key
     * @param {String} val
     * @param {Boolean} escaped
     * @param {Boolean} terse
     * @return {String}
     */
    exports.attr = function attr(key, val, escaped, terse) {
      if (key === 'style') {
        val = exports.style(val);
      }
      if ('boolean' == typeof val || null == val) {
        if (val) {
          return ' ' + (terse ? key : key + '="' + key + '"');
        } else {
          return '';
        }
      } else if (0 == key.indexOf('data') && 'string' != typeof val) {
        if (JSON.stringify(val).indexOf('&') !== -1) {
          console.warn('Since Jade 2.0.0, ampersands (`&`) in data attributes ' +
                       'will be escaped to `&amp;`');
        };
        if (val && typeof val.toISOString === 'function') {
          console.warn('Jade will eliminate the double quotes around dates in ' +
                       'ISO form after 2.0.0');
        }
        return ' ' + key + "='" + JSON.stringify(val).replace(/'/g, '&apos;') + "'";
      } else if (escaped) {
        if (val && typeof val.toISOString === 'function') {
          console.warn('Jade will stringify dates in ISO form after 2.0.0');
        }
        return ' ' + key + '="' + exports.escape(val) + '"';
      } else {
        if (val && typeof val.toISOString === 'function') {
          console.warn('Jade will stringify dates in ISO form after 2.0.0');
        }
        return ' ' + key + '="' + val + '"';
      }
    };
    
    /**
     * Render the given attributes object.
     *
     * @param {Object} obj
     * @param {Object} escaped
     * @return {String}
     */
    exports.attrs = function attrs(obj, terse){
      var buf = [];
    
      var keys = Object.keys(obj);
    
      if (keys.length) {
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i]
            , val = obj[key];
    
          if ('class' == key) {
            if (val = joinClasses(val)) {
              buf.push(' ' + key + '="' + val + '"');
            }
          } else {
            buf.push(exports.attr(key, val, false, terse));
          }
        }
      }
    
      return buf.join('');
    };
    
    /**
     * Escape the given string of `html`.
     *
     * @param {String} html
     * @return {String}
     * @api private
     */
    
    exports.escape = function escape(html){
      var result = String(html)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
      if (result === '' + html) return html;
      else return result;
    };
    
    /**
     * Re-throw the given `err` in context to the
     * the jade in `filename` at the given `lineno`.
     *
     * @param {Error} err
     * @param {String} filename
     * @param {String} lineno
     * @api private
     */
    
    exports.rethrow = function rethrow(err, filename, lineno, str){
      if (!(err instanceof Error)) throw err;
      if ((typeof window != 'undefined' || !filename) && !str) {
        err.message += ' on line ' + lineno;
        throw err;
      }
      try {
        str = str || require('fs').readFileSync(filename, 'utf8')
      } catch (ex) {
        rethrow(err, null, lineno)
      }
      var context = 3
        , lines = str.split('\n')
        , start = Math.max(lineno - context, 0)
        , end = Math.min(lines.length, lineno + context);
    
      // Error context
      var context = lines.slice(start, end).map(function(line, i){
        var curr = i + start + 1;
        return (curr == lineno ? '  > ' : '    ')
          + curr
          + '| '
          + line;
      }).join('\n');
    
      // Alter exception message
      err.path = filename;
      err.message = (filename || 'Jade') + ':' + lineno
        + '\n' + context + '\n\n' + err.message;
      throw err;
    };
    
  provide("jade/lib/runtime", module.exports);
}(global));

// pakmanager:jade/lib/parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Lexer =  require('jade/lib/lexer');
    var nodes =  require('jade/lib/nodes');
    var utils =  require('jade/lib/utils');
    var filters =  require('jade/lib/filters');
    var path = require('path');
    var constantinople = require('constantinople');
    var parseJSExpression = require('character-parser').parseMax;
    var extname = path.extname;
    
    /**
     * Initialize `Parser` with the given input `str` and `filename`.
     *
     * @param {String} str
     * @param {String} filename
     * @param {Object} options
     * @api public
     */
    
    var Parser = exports = module.exports = function Parser(str, filename, options){
      //Strip any UTF-8 BOM off of the start of `str`, if it exists.
      this.input = str.replace(/^\uFEFF/, '');
      this.lexer = new Lexer(this.input, filename);
      this.filename = filename;
      this.blocks = {};
      this.mixins = {};
      this.options = options;
      this.contexts = [this];
      this.inMixin = 0;
      this.dependencies = [];
      this.inBlock = 0;
    };
    
    /**
     * Parser prototype.
     */
    
    Parser.prototype = {
    
      /**
       * Save original constructor
       */
    
      constructor: Parser,
    
      /**
       * Push `parser` onto the context stack,
       * or pop and return a `Parser`.
       */
    
      context: function(parser){
        if (parser) {
          this.contexts.push(parser);
        } else {
          return this.contexts.pop();
        }
      },
    
      /**
       * Return the next token object.
       *
       * @return {Object}
       * @api private
       */
    
      advance: function(){
        return this.lexer.advance();
      },
    
      /**
       * Single token lookahead.
       *
       * @return {Object}
       * @api private
       */
    
      peek: function() {
        return this.lookahead(1);
      },
    
      /**
       * Return lexer lineno.
       *
       * @return {Number}
       * @api private
       */
    
      line: function() {
        return this.lexer.lineno;
      },
    
      /**
       * `n` token lookahead.
       *
       * @param {Number} n
       * @return {Object}
       * @api private
       */
    
      lookahead: function(n){
        return this.lexer.lookahead(n);
      },
    
      /**
       * Parse input returning a string of js for evaluation.
       *
       * @return {String}
       * @api public
       */
    
      parse: function(){
        var block = new nodes.Block, parser;
        block.line = 0;
        block.filename = this.filename;
    
        while ('eos' != this.peek().type) {
          if ('newline' == this.peek().type) {
            this.advance();
          } else {
            var next = this.peek();
            var expr = this.parseExpr();
            expr.filename = expr.filename || this.filename;
            expr.line = next.line;
            block.push(expr);
          }
        }
    
        if (parser = this.extending) {
          this.context(parser);
          var ast = parser.parse();
          this.context();
    
          // hoist mixins
          for (var name in this.mixins)
            ast.unshift(this.mixins[name]);
          return ast;
        }
    
        if (!this.extending && !this.included && Object.keys(this.blocks).length){
          var blocks = [];
          utils.walkAST(block, function (node) {
            if (node.type === 'Block' && node.name) {
              blocks.push(node.name);
            }
          });
          Object.keys(this.blocks).forEach(function (name) {
            if (blocks.indexOf(name) === -1 && !this.blocks[name].isSubBlock) {
              console.warn('Warning: Unexpected block "'
                           + name
                           + '" '
                           + ' on line '
                           + this.blocks[name].line
                           + ' of '
                           + (this.blocks[name].filename)
                           + '. This block is never used. This warning will be an error in v2.0.0');
            }
          }.bind(this));
        }
    
        return block;
      },
    
      /**
       * Expect the given type, or throw an exception.
       *
       * @param {String} type
       * @api private
       */
    
      expect: function(type){
        if (this.peek().type === type) {
          return this.advance();
        } else {
          throw new Error('expected "' + type + '", but got "' + this.peek().type + '"');
        }
      },
    
      /**
       * Accept the given `type`.
       *
       * @param {String} type
       * @api private
       */
    
      accept: function(type){
        if (this.peek().type === type) {
          return this.advance();
        }
      },
    
      /**
       *   tag
       * | doctype
       * | mixin
       * | include
       * | filter
       * | comment
       * | text
       * | each
       * | code
       * | yield
       * | id
       * | class
       * | interpolation
       */
    
      parseExpr: function(){
        switch (this.peek().type) {
          case 'tag':
            return this.parseTag();
          case 'mixin':
            return this.parseMixin();
          case 'block':
            return this.parseBlock();
          case 'mixin-block':
            return this.parseMixinBlock();
          case 'case':
            return this.parseCase();
          case 'extends':
            return this.parseExtends();
          case 'include':
            return this.parseInclude();
          case 'doctype':
            return this.parseDoctype();
          case 'filter':
            return this.parseFilter();
          case 'comment':
            return this.parseComment();
          case 'text':
            return this.parseText();
          case 'each':
            return this.parseEach();
          case 'code':
            return this.parseCode();
          case 'call':
            return this.parseCall();
          case 'interpolation':
            return this.parseInterpolation();
          case 'yield':
            this.advance();
            var block = new nodes.Block;
            block.yield = true;
            return block;
          case 'id':
          case 'class':
            var tok = this.advance();
            this.lexer.defer(this.lexer.tok('tag', 'div'));
            this.lexer.defer(tok);
            return this.parseExpr();
          default:
            throw new Error('unexpected token "' + this.peek().type + '"');
        }
      },
    
      /**
       * Text
       */
    
      parseText: function(){
        var tok = this.expect('text');
        var tokens = this.parseInlineTagsInText(tok.val);
        if (tokens.length === 1) return tokens[0];
        var node = new nodes.Block;
        for (var i = 0; i < tokens.length; i++) {
          node.push(tokens[i]);
        };
        return node;
      },
    
      /**
       *   ':' expr
       * | block
       */
    
      parseBlockExpansion: function(){
        if (':' == this.peek().type) {
          this.advance();
          return new nodes.Block(this.parseExpr());
        } else {
          return this.block();
        }
      },
    
      /**
       * case
       */
    
      parseCase: function(){
        var val = this.expect('case').val;
        var node = new nodes.Case(val);
        node.line = this.line();
    
        var block = new nodes.Block;
        block.line = this.line();
        block.filename = this.filename;
        this.expect('indent');
        while ('outdent' != this.peek().type) {
          switch (this.peek().type) {
            case 'comment':
            case 'newline':
              this.advance();
              break;
            case 'when':
              block.push(this.parseWhen());
              break;
            case 'default':
              block.push(this.parseDefault());
              break;
            default:
              throw new Error('Unexpected token "' + this.peek().type
                              + '", expected "when", "default" or "newline"');
          }
        }
        this.expect('outdent');
    
        node.block = block;
    
        return node;
      },
    
      /**
       * when
       */
    
      parseWhen: function(){
        var val = this.expect('when').val;
        if (this.peek().type !== 'newline')
          return new nodes.Case.When(val, this.parseBlockExpansion());
        else
          return new nodes.Case.When(val);
      },
    
      /**
       * default
       */
    
      parseDefault: function(){
        this.expect('default');
        return new nodes.Case.When('default', this.parseBlockExpansion());
      },
    
      /**
       * code
       */
    
      parseCode: function(afterIf){
        var tok = this.expect('code');
        var node = new nodes.Code(tok.val, tok.buffer, tok.escape);
        var block;
        node.line = this.line();
    
        // throw an error if an else does not have an if
        if (tok.isElse && !tok.hasIf) {
          throw new Error('Unexpected else without if');
        }
    
        // handle block
        block = 'indent' == this.peek().type;
        if (block) {
          node.block = this.block();
        }
    
        // handle missing block
        if (tok.requiresBlock && !block) {
          node.block = new nodes.Block();
        }
    
        // mark presense of if for future elses
        if (tok.isIf && this.peek().isElse) {
          this.peek().hasIf = true;
        } else if (tok.isIf && this.peek().type === 'newline' && this.lookahead(2).isElse) {
          this.lookahead(2).hasIf = true;
        }
    
        return node;
      },
    
      /**
       * comment
       */
    
      parseComment: function(){
        var tok = this.expect('comment');
        var node;
    
        var block;
        if (block = this.parseTextBlock()) {
          node = new nodes.BlockComment(tok.val, block, tok.buffer);
        } else {
          node = new nodes.Comment(tok.val, tok.buffer);
        }
    
        node.line = this.line();
        return node;
      },
    
      /**
       * doctype
       */
    
      parseDoctype: function(){
        var tok = this.expect('doctype');
        var node = new nodes.Doctype(tok.val);
        node.line = this.line();
        return node;
      },
    
      /**
       * filter attrs? text-block
       */
    
      parseFilter: function(){
        var tok = this.expect('filter');
        var attrs = this.accept('attrs');
        var block;
    
        block = this.parseTextBlock() || new nodes.Block();
    
        var options = {};
        if (attrs) {
          attrs.attrs.forEach(function (attribute) {
            options[attribute.name] = constantinople.toConstant(attribute.val);
          });
        }
    
        var node = new nodes.Filter(tok.val, block, options);
        node.line = this.line();
        return node;
      },
    
      /**
       * each block
       */
    
      parseEach: function(){
        var tok = this.expect('each');
        var node = new nodes.Each(tok.code, tok.val, tok.key);
        node.line = this.line();
        node.block = this.block();
        if (this.peek().type == 'code' && this.peek().val == 'else') {
          this.advance();
          node.alternative = this.block();
        }
        return node;
      },
    
      /**
       * Resolves a path relative to the template for use in
       * includes and extends
       *
       * @param {String}  path
       * @param {String}  purpose  Used in error messages.
       * @return {String}
       * @api private
       */
    
      resolvePath: function (path, purpose) {
        var p = require('path');
        var dirname = p.dirname;
        var basename = p.basename;
        var join = p.join;
    
        if (path[0] !== '/' && !this.filename)
          throw new Error('the "filename" option is required to use "' + purpose + '" with "relative" paths');
    
        if (path[0] === '/' && !this.options.basedir)
          throw new Error('the "basedir" option is required to use "' + purpose + '" with "absolute" paths');
    
        path = join(path[0] === '/' ? this.options.basedir : dirname(this.filename), path);
    
        if (basename(path).indexOf('.') === -1) path += '.jade';
    
        return path;
      },
    
      /**
       * 'extends' name
       */
    
      parseExtends: function(){
        var fs = require('fs');
    
        var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');
        if ('.jade' != path.substr(-5)) path += '.jade';
    
        this.dependencies.push(path);
        var str = fs.readFileSync(path, 'utf8');
        var parser = new this.constructor(str, path, this.options);
        parser.dependencies = this.dependencies;
    
        parser.blocks = this.blocks;
        parser.included = this.included;
        parser.contexts = this.contexts;
        this.extending = parser;
    
        // TODO: null node
        return new nodes.Literal('');
      },
    
      /**
       * 'block' name block
       */
    
      parseBlock: function(){
        var block = this.expect('block');
        var mode = block.mode;
        var name = block.val.trim();
    
        var line = block.line;
    
        this.inBlock++;
        block = 'indent' == this.peek().type
          ? this.block()
          : new nodes.Block(new nodes.Literal(''));
        this.inBlock--;
        block.name = name;
        block.line = line;
    
        var prev = this.blocks[name] || {prepended: [], appended: []}
        if (prev.mode === 'replace') return this.blocks[name] = prev;
    
        var allNodes = prev.prepended.concat(block.nodes).concat(prev.appended);
    
        switch (mode) {
          case 'append':
            prev.appended = prev.parser === this ?
                            prev.appended.concat(block.nodes) :
                            block.nodes.concat(prev.appended);
            break;
          case 'prepend':
            prev.prepended = prev.parser === this ?
                             block.nodes.concat(prev.prepended) :
                             prev.prepended.concat(block.nodes);
            break;
        }
        block.nodes = allNodes;
        block.appended = prev.appended;
        block.prepended = prev.prepended;
        block.mode = mode;
        block.parser = this;
    
        block.isSubBlock = this.inBlock > 0;
    
        return this.blocks[name] = block;
      },
    
      parseMixinBlock: function () {
        var block = this.expect('mixin-block');
        if (!this.inMixin) {
          throw new Error('Anonymous blocks are not allowed unless they are part of a mixin.');
        }
        return new nodes.MixinBlock();
      },
    
      /**
       * include block?
       */
    
      parseInclude: function(){
        var fs = require('fs');
        var tok = this.expect('include');
    
        var path = this.resolvePath(tok.val.trim(), 'include');
        this.dependencies.push(path);
        // has-filter
        if (tok.filter) {
          var str = fs.readFileSync(path, 'utf8').replace(/\r/g, '');
          var options = {filename: path};
          if (tok.attrs) {
            tok.attrs.attrs.forEach(function (attribute) {
              options[attribute.name] = constantinople.toConstant(attribute.val);
            });
          }
          str = filters(tok.filter, str, options);
          return new nodes.Literal(str);
        }
    
        // non-jade
        if ('.jade' != path.substr(-5)) {
          var str = fs.readFileSync(path, 'utf8').replace(/\r/g, '');
          return new nodes.Literal(str);
        }
    
        var str = fs.readFileSync(path, 'utf8');
        var parser = new this.constructor(str, path, this.options);
        parser.dependencies = this.dependencies;
    
        parser.blocks = utils.merge({}, this.blocks);
        parser.included = true;
    
        parser.mixins = this.mixins;
    
        this.context(parser);
        var ast = parser.parse();
        this.context();
        ast.filename = path;
    
        if ('indent' == this.peek().type) {
          ast.includeBlock().push(this.block());
        }
    
        return ast;
      },
    
      /**
       * call ident block
       */
    
      parseCall: function(){
        var tok = this.expect('call');
        var name = tok.val;
        var args = tok.args;
        var mixin = new nodes.Mixin(name, args, new nodes.Block, true);
    
        this.tag(mixin);
        if (mixin.code) {
          mixin.block.push(mixin.code);
          mixin.code = null;
        }
        if (mixin.block.isEmpty()) mixin.block = null;
        return mixin;
      },
    
      /**
       * mixin block
       */
    
      parseMixin: function(){
        var tok = this.expect('mixin');
        var name = tok.val;
        var args = tok.args;
        var mixin;
    
        // definition
        if ('indent' == this.peek().type) {
          this.inMixin++;
          mixin = new nodes.Mixin(name, args, this.block(), false);
          this.mixins[name] = mixin;
          this.inMixin--;
          return mixin;
        // call
        } else {
          return new nodes.Mixin(name, args, null, true);
        }
      },
    
      parseInlineTagsInText: function (str) {
        var line = this.line();
    
        var match = /(\\)?#\[((?:.|\n)*)$/.exec(str);
        if (match) {
          if (match[1]) { // escape
            var text = new nodes.Text(str.substr(0, match.index) + '#[');
            text.line = line;
            var rest = this.parseInlineTagsInText(match[2]);
            if (rest[0].type === 'Text') {
              text.val += rest[0].val;
              rest.shift();
            }
            return [text].concat(rest);
          } else {
            var text = new nodes.Text(str.substr(0, match.index));
            text.line = line;
            var buffer = [text];
            var rest = match[2];
            var range = parseJSExpression(rest);
            var inner = new Parser(range.src, this.filename, this.options);
            buffer.push(inner.parse());
            return buffer.concat(this.parseInlineTagsInText(rest.substr(range.end + 1)));
          }
        } else {
          var text = new nodes.Text(str);
          text.line = line;
          return [text];
        }
      },
    
      /**
       * indent (text | newline)* outdent
       */
    
      parseTextBlock: function(){
        var block = new nodes.Block;
        block.line = this.line();
        var body = this.peek();
        if (body.type !== 'pipeless-text') return;
        this.advance();
        block.nodes = body.val.reduce(function (accumulator, text) {
          return accumulator.concat(this.parseInlineTagsInText(text));
        }.bind(this), []);
        return block;
      },
    
      /**
       * indent expr* outdent
       */
    
      block: function(){
        var block = new nodes.Block;
        block.line = this.line();
        block.filename = this.filename;
        this.expect('indent');
        while ('outdent' != this.peek().type) {
          if ('newline' == this.peek().type) {
            this.advance();
          } else {
            var expr = this.parseExpr();
            expr.filename = this.filename;
            block.push(expr);
          }
        }
        this.expect('outdent');
        return block;
      },
    
      /**
       * interpolation (attrs | class | id)* (text | code | ':')? newline* block?
       */
    
      parseInterpolation: function(){
        var tok = this.advance();
        var tag = new nodes.Tag(tok.val);
        tag.buffer = true;
        return this.tag(tag);
      },
    
      /**
       * tag (attrs | class | id)* (text | code | ':')? newline* block?
       */
    
      parseTag: function(){
        var tok = this.advance();
        var tag = new nodes.Tag(tok.val);
    
        tag.selfClosing = tok.selfClosing;
    
        return this.tag(tag);
      },
    
      /**
       * Parse tag.
       */
    
      tag: function(tag){
        tag.line = this.line();
    
        var seenAttrs = false;
        // (attrs | class | id)*
        out:
          while (true) {
            switch (this.peek().type) {
              case 'id':
              case 'class':
                var tok = this.advance();
                tag.setAttribute(tok.type, "'" + tok.val + "'");
                continue;
              case 'attrs':
                if (seenAttrs) {
                  console.warn(this.filename + ', line ' + this.peek().line + ':\nYou should not have jade tags with multiple attributes.');
                }
                seenAttrs = true;
                var tok = this.advance();
                var attrs = tok.attrs;
    
                if (tok.selfClosing) tag.selfClosing = true;
    
                for (var i = 0; i < attrs.length; i++) {
                  tag.setAttribute(attrs[i].name, attrs[i].val, attrs[i].escaped);
                }
                continue;
              case '&attributes':
                var tok = this.advance();
                tag.addAttributes(tok.val);
                break;
              default:
                break out;
            }
          }
    
        // check immediate '.'
        if ('dot' == this.peek().type) {
          tag.textOnly = true;
          this.advance();
        }
    
        // (text | code | ':')?
        switch (this.peek().type) {
          case 'text':
            tag.block.push(this.parseText());
            break;
          case 'code':
            tag.code = this.parseCode();
            break;
          case ':':
            this.advance();
            tag.block = new nodes.Block;
            tag.block.push(this.parseExpr());
            break;
          case 'newline':
          case 'indent':
          case 'outdent':
          case 'eos':
          case 'pipeless-text':
            break;
          default:
            throw new Error('Unexpected token `' + this.peek().type + '` expected `text`, `code`, `:`, `newline` or `eos`')
        }
    
        // newline*
        while ('newline' == this.peek().type) this.advance();
    
        // block?
        if (tag.textOnly) {
          tag.block = this.parseTextBlock() || new nodes.Block();
        } else if ('indent' == this.peek().type) {
          var block = this.block();
          for (var i = 0, len = block.nodes.length; i < len; ++i) {
            tag.block.push(block.nodes[i]);
          }
        }
    
        return tag;
      }
    };
    
  provide("jade/lib/parser", module.exports);
}(global));

// pakmanager:jade/lib/compiler
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var nodes =  require('jade/lib/nodes');
    var filters =  require('jade/lib/filters');
    var doctypes =  require('jade/lib/doctypes');
    var runtime =  require('jade/lib/runtime');
    var utils =  require('jade/lib/utils');
    var selfClosing = require('void-elements');
    var parseJSExpression = require('character-parser').parseMax;
    var constantinople = require('constantinople');
    
    function isConstant(src) {
      return constantinople(src, {jade: runtime, 'jade_interp': undefined});
    }
    function toConstant(src) {
      return constantinople.toConstant(src, {jade: runtime, 'jade_interp': undefined});
    }
    function errorAtNode(node, error) {
      error.line = node.line;
      error.filename = node.filename;
      return error;
    }
    
    /**
     * Initialize `Compiler` with the given `node`.
     *
     * @param {Node} node
     * @param {Object} options
     * @api public
     */
    
    var Compiler = module.exports = function Compiler(node, options) {
      this.options = options = options || {};
      this.node = node;
      this.hasCompiledDoctype = false;
      this.hasCompiledTag = false;
      this.pp = options.pretty || false;
      if (this.pp && typeof this.pp !== 'string') {
        this.pp = '  ';
      }
      this.debug = false !== options.compileDebug;
      this.indents = 0;
      this.parentIndents = 0;
      this.terse = false;
      this.mixins = {};
      this.dynamicMixins = false;
      if (options.doctype) this.setDoctype(options.doctype);
    };
    
    /**
     * Compiler prototype.
     */
    
    Compiler.prototype = {
    
      /**
       * Compile parse tree to JavaScript.
       *
       * @api public
       */
    
      compile: function(){
        this.buf = [];
        if (this.pp) this.buf.push("var jade_indent = [];");
        this.lastBufferedIdx = -1;
        this.visit(this.node);
        if (!this.dynamicMixins) {
          // if there are no dynamic mixins we can remove any un-used mixins
          var mixinNames = Object.keys(this.mixins);
          for (var i = 0; i < mixinNames.length; i++) {
            var mixin = this.mixins[mixinNames[i]];
            if (!mixin.used) {
              for (var x = 0; x < mixin.instances.length; x++) {
                for (var y = mixin.instances[x].start; y < mixin.instances[x].end; y++) {
                  this.buf[y] = '';
                }
              }
            }
          }
        }
        return this.buf.join('\n');
      },
    
      /**
       * Sets the default doctype `name`. Sets terse mode to `true` when
       * html 5 is used, causing self-closing tags to end with ">" vs "/>",
       * and boolean attributes are not mirrored.
       *
       * @param {string} name
       * @api public
       */
    
      setDoctype: function(name){
        this.doctype = doctypes[name.toLowerCase()] || '<!DOCTYPE ' + name + '>';
        this.terse = this.doctype.toLowerCase() == '<!doctype html>';
        this.xml = 0 == this.doctype.indexOf('<?xml');
      },
    
      /**
       * Buffer the given `str` exactly as is or with interpolation
       *
       * @param {String} str
       * @param {Boolean} interpolate
       * @api public
       */
    
      buffer: function (str, interpolate) {
        var self = this;
        if (interpolate) {
          var match = /(\\)?([#!]){((?:.|\n)*)$/.exec(str);
          if (match) {
            this.buffer(str.substr(0, match.index), false);
            if (match[1]) { // escape
              this.buffer(match[2] + '{', false);
              this.buffer(match[3], true);
              return;
            } else {
              var rest = match[3];
              var range = parseJSExpression(rest);
              var code = ('!' == match[2] ? '' : 'jade.escape') + "((jade_interp = " + range.src + ") == null ? '' : jade_interp)";
              this.bufferExpression(code);
              this.buffer(rest.substr(range.end + 1), true);
              return;
            }
          }
        }
    
        str = utils.stringify(str);
        str = str.substr(1, str.length - 2);
    
        if (this.lastBufferedIdx == this.buf.length) {
          if (this.lastBufferedType === 'code') this.lastBuffered += ' + "';
          this.lastBufferedType = 'text';
          this.lastBuffered += str;
          this.buf[this.lastBufferedIdx - 1] = 'buf.push(' + this.bufferStartChar + this.lastBuffered + '");'
        } else {
          this.buf.push('buf.push("' + str + '");');
          this.lastBufferedType = 'text';
          this.bufferStartChar = '"';
          this.lastBuffered = str;
          this.lastBufferedIdx = this.buf.length;
        }
      },
    
      /**
       * Buffer the given `src` so it is evaluated at run time
       *
       * @param {String} src
       * @api public
       */
    
      bufferExpression: function (src) {
        if (isConstant(src)) {
          return this.buffer(toConstant(src) + '', false)
        }
        if (this.lastBufferedIdx == this.buf.length) {
          if (this.lastBufferedType === 'text') this.lastBuffered += '"';
          this.lastBufferedType = 'code';
          this.lastBuffered += ' + (' + src + ')';
          this.buf[this.lastBufferedIdx - 1] = 'buf.push(' + this.bufferStartChar + this.lastBuffered + ');'
        } else {
          this.buf.push('buf.push(' + src + ');');
          this.lastBufferedType = 'code';
          this.bufferStartChar = '';
          this.lastBuffered = '(' + src + ')';
          this.lastBufferedIdx = this.buf.length;
        }
      },
    
      /**
       * Buffer an indent based on the current `indent`
       * property and an additional `offset`.
       *
       * @param {Number} offset
       * @param {Boolean} newline
       * @api public
       */
    
      prettyIndent: function(offset, newline){
        offset = offset || 0;
        newline = newline ? '\n' : '';
        this.buffer(newline + Array(this.indents + offset).join(this.pp));
        if (this.parentIndents)
          this.buf.push("buf.push.apply(buf, jade_indent);");
      },
    
      /**
       * Visit `node`.
       *
       * @param {Node} node
       * @api public
       */
    
      visit: function(node){
        var debug = this.debug;
    
        if (debug) {
          this.buf.push('jade_debug.unshift({ lineno: ' + node.line
            + ', filename: ' + (node.filename
              ? utils.stringify(node.filename)
              : 'jade_debug[0].filename')
            + ' });');
        }
    
        // Massive hack to fix our context
        // stack for - else[ if] etc
        if (false === node.debug && this.debug) {
          this.buf.pop();
          this.buf.pop();
        }
    
        this.visitNode(node);
    
        if (debug) this.buf.push('jade_debug.shift();');
      },
    
      /**
       * Visit `node`.
       *
       * @param {Node} node
       * @api public
       */
    
      visitNode: function(node){
        return this['visit' + node.type](node);
      },
    
      /**
       * Visit case `node`.
       *
       * @param {Literal} node
       * @api public
       */
    
      visitCase: function(node){
        var _ = this.withinCase;
        this.withinCase = true;
        this.buf.push('switch (' + node.expr + '){');
        this.visit(node.block);
        this.buf.push('}');
        this.withinCase = _;
      },
    
      /**
       * Visit when `node`.
       *
       * @param {Literal} node
       * @api public
       */
    
      visitWhen: function(node){
        if ('default' == node.expr) {
          this.buf.push('default:');
        } else {
          this.buf.push('case ' + node.expr + ':');
        }
        if (node.block) {
          this.visit(node.block);
          this.buf.push('  break;');
        }
      },
    
      /**
       * Visit literal `node`.
       *
       * @param {Literal} node
       * @api public
       */
    
      visitLiteral: function(node){
        this.buffer(node.str);
      },
    
      /**
       * Visit all nodes in `block`.
       *
       * @param {Block} block
       * @api public
       */
    
      visitBlock: function(block){
        var len = block.nodes.length
          , escape = this.escape
          , pp = this.pp
    
        // Pretty print multi-line text
        if (pp && len > 1 && !escape && block.nodes[0].isText && block.nodes[1].isText)
          this.prettyIndent(1, true);
    
        for (var i = 0; i < len; ++i) {
          // Pretty print text
          if (pp && i > 0 && !escape && block.nodes[i].isText && block.nodes[i-1].isText)
            this.prettyIndent(1, false);
    
          this.visit(block.nodes[i]);
          // Multiple text nodes are separated by newlines
          if (block.nodes[i+1] && block.nodes[i].isText && block.nodes[i+1].isText)
            this.buffer('\n');
        }
      },
    
      /**
       * Visit a mixin's `block` keyword.
       *
       * @param {MixinBlock} block
       * @api public
       */
    
      visitMixinBlock: function(block){
        if (this.pp) this.buf.push("jade_indent.push('" + Array(this.indents + 1).join(this.pp) + "');");
        this.buf.push('block && block();');
        if (this.pp) this.buf.push("jade_indent.pop();");
      },
    
      /**
       * Visit `doctype`. Sets terse mode to `true` when html 5
       * is used, causing self-closing tags to end with ">" vs "/>",
       * and boolean attributes are not mirrored.
       *
       * @param {Doctype} doctype
       * @api public
       */
    
      visitDoctype: function(doctype){
        if (doctype && (doctype.val || !this.doctype)) {
          this.setDoctype(doctype.val || 'default');
        }
    
        if (this.doctype) this.buffer(this.doctype);
        this.hasCompiledDoctype = true;
      },
    
      /**
       * Visit `mixin`, generating a function that
       * may be called within the template.
       *
       * @param {Mixin} mixin
       * @api public
       */
    
      visitMixin: function(mixin){
        var name = 'jade_mixins[';
        var args = mixin.args || '';
        var block = mixin.block;
        var attrs = mixin.attrs;
        var attrsBlocks = mixin.attributeBlocks.slice();
        var pp = this.pp;
        var dynamic = mixin.name[0]==='#';
        var key = mixin.name;
        if (dynamic) this.dynamicMixins = true;
        name += (dynamic ? mixin.name.substr(2,mixin.name.length-3):'"'+mixin.name+'"')+']';
    
        this.mixins[key] = this.mixins[key] || {used: false, instances: []};
        if (mixin.call) {
          this.mixins[key].used = true;
          if (pp) this.buf.push("jade_indent.push('" + Array(this.indents + 1).join(pp) + "');")
          if (block || attrs.length || attrsBlocks.length) {
    
            this.buf.push(name + '.call({');
    
            if (block) {
              this.buf.push('block: function(){');
    
              // Render block with no indents, dynamically added when rendered
              this.parentIndents++;
              var _indents = this.indents;
              this.indents = 0;
              this.visit(mixin.block);
              this.indents = _indents;
              this.parentIndents--;
    
              if (attrs.length || attrsBlocks.length) {
                this.buf.push('},');
              } else {
                this.buf.push('}');
              }
            }
    
            if (attrsBlocks.length) {
              if (attrs.length) {
                var val = this.attrs(attrs);
                attrsBlocks.unshift(val);
              }
              this.buf.push('attributes: jade.merge([' + attrsBlocks.join(',') + '])');
            } else if (attrs.length) {
              var val = this.attrs(attrs);
              this.buf.push('attributes: ' + val);
            }
    
            if (args) {
              this.buf.push('}, ' + args + ');');
            } else {
              this.buf.push('});');
            }
    
          } else {
            this.buf.push(name + '(' + args + ');');
          }
          if (pp) this.buf.push("jade_indent.pop();")
        } else {
          var mixin_start = this.buf.length;
          args = args ? args.split(',') : [];
          var rest;
          if (args.length && /^\.\.\./.test(args[args.length - 1].trim())) {
            rest = args.pop().trim().replace(/^\.\.\./, '');
          }
          this.buf.push(name + ' = function(' + args.join(',') + '){');
          this.buf.push('var block = (this && this.block), attributes = (this && this.attributes) || {};');
          if (rest) {
            this.buf.push('var ' + rest + ' = [];');
            this.buf.push('for (jade_interp = ' + args.length + '; jade_interp < arguments.length; jade_interp++) {');
            this.buf.push('  ' + rest + '.push(arguments[jade_interp]);');
            this.buf.push('}');
          }
          this.parentIndents++;
          this.visit(block);
          this.parentIndents--;
          this.buf.push('};');
          var mixin_end = this.buf.length;
          this.mixins[key].instances.push({start: mixin_start, end: mixin_end});
        }
      },
    
      /**
       * Visit `tag` buffering tag markup, generating
       * attributes, visiting the `tag`'s code and block.
       *
       * @param {Tag} tag
       * @api public
       */
    
      visitTag: function(tag){
        this.indents++;
        var name = tag.name
          , pp = this.pp
          , self = this;
    
        function bufferName() {
          if (tag.buffer) self.bufferExpression(name);
          else self.buffer(name);
        }
    
        if ('pre' == tag.name) this.escape = true;
    
        if (!this.hasCompiledTag) {
          if (!this.hasCompiledDoctype && 'html' == name) {
            this.visitDoctype();
          }
          this.hasCompiledTag = true;
        }
    
        // pretty print
        if (pp && !tag.isInline())
          this.prettyIndent(0, true);
    
        if (tag.selfClosing || (!this.xml && selfClosing[tag.name])) {
          this.buffer('<');
          bufferName();
          this.visitAttributes(tag.attrs, tag.attributeBlocks.slice());
          this.terse
            ? this.buffer('>')
            : this.buffer('/>');
          // if it is non-empty throw an error
          if (tag.block &&
              !(tag.block.type === 'Block' && tag.block.nodes.length === 0) &&
              tag.block.nodes.some(function (tag) {
                return tag.type !== 'Text' || !/^\s*$/.test(tag.val)
              })) {
            throw errorAtNode(tag, new Error(name + ' is self closing and should not have content.'));
          }
        } else {
          // Optimize attributes buffering
          this.buffer('<');
          bufferName();
          this.visitAttributes(tag.attrs, tag.attributeBlocks.slice());
          this.buffer('>');
          if (tag.code) this.visitCode(tag.code);
          this.visit(tag.block);
    
          // pretty print
          if (pp && !tag.isInline() && 'pre' != tag.name && !tag.canInline())
            this.prettyIndent(0, true);
    
          this.buffer('</');
          bufferName();
          this.buffer('>');
        }
    
        if ('pre' == tag.name) this.escape = false;
    
        this.indents--;
      },
    
      /**
       * Visit `filter`, throwing when the filter does not exist.
       *
       * @param {Filter} filter
       * @api public
       */
    
      visitFilter: function(filter){
        var text = filter.block.nodes.map(
          function(node){ return node.val; }
        ).join('\n');
        filter.attrs.filename = this.options.filename;
        try {
          this.buffer(filters(filter.name, text, filter.attrs), true);
        } catch (err) {
          throw errorAtNode(filter, err);
        }
      },
    
      /**
       * Visit `text` node.
       *
       * @param {Text} text
       * @api public
       */
    
      visitText: function(text){
        this.buffer(text.val, true);
      },
    
      /**
       * Visit a `comment`, only buffering when the buffer flag is set.
       *
       * @param {Comment} comment
       * @api public
       */
    
      visitComment: function(comment){
        if (!comment.buffer) return;
        if (this.pp) this.prettyIndent(1, true);
        this.buffer('<!--' + comment.val + '-->');
      },
    
      /**
       * Visit a `BlockComment`.
       *
       * @param {Comment} comment
       * @api public
       */
    
      visitBlockComment: function(comment){
        if (!comment.buffer) return;
        if (this.pp) this.prettyIndent(1, true);
        this.buffer('<!--' + comment.val);
        this.visit(comment.block);
        if (this.pp) this.prettyIndent(1, true);
        this.buffer('-->');
      },
    
      /**
       * Visit `code`, respecting buffer / escape flags.
       * If the code is followed by a block, wrap it in
       * a self-calling function.
       *
       * @param {Code} code
       * @api public
       */
    
      visitCode: function(code){
        // Wrap code blocks with {}.
        // we only wrap unbuffered code blocks ATM
        // since they are usually flow control
    
        // Buffer code
        if (code.buffer) {
          var val = code.val.trim();
          val = 'null == (jade_interp = '+val+') ? "" : jade_interp';
          if (code.escape) val = 'jade.escape(' + val + ')';
          this.bufferExpression(val);
        } else {
          this.buf.push(code.val);
        }
    
        // Block support
        if (code.block) {
          if (!code.buffer) this.buf.push('{');
          this.visit(code.block);
          if (!code.buffer) this.buf.push('}');
        }
      },
    
      /**
       * Visit `each` block.
       *
       * @param {Each} each
       * @api public
       */
    
      visitEach: function(each){
        this.buf.push(''
          + '// iterate ' + each.obj + '\n'
          + ';(function(){\n'
          + '  var $$obj = ' + each.obj + ';\n'
          + '  if (\'number\' == typeof $$obj.length) {\n');
    
        if (each.alternative) {
          this.buf.push('  if ($$obj.length) {');
        }
    
        this.buf.push(''
          + '    for (var ' + each.key + ' = 0, $$l = $$obj.length; ' + each.key + ' < $$l; ' + each.key + '++) {\n'
          + '      var ' + each.val + ' = $$obj[' + each.key + '];\n');
    
        this.visit(each.block);
    
        this.buf.push('    }\n');
    
        if (each.alternative) {
          this.buf.push('  } else {');
          this.visit(each.alternative);
          this.buf.push('  }');
        }
    
        this.buf.push(''
          + '  } else {\n'
          + '    var $$l = 0;\n'
          + '    for (var ' + each.key + ' in $$obj) {\n'
          + '      $$l++;'
          + '      var ' + each.val + ' = $$obj[' + each.key + '];\n');
    
        this.visit(each.block);
    
        this.buf.push('    }\n');
        if (each.alternative) {
          this.buf.push('    if ($$l === 0) {');
          this.visit(each.alternative);
          this.buf.push('    }');
        }
        this.buf.push('  }\n}).call(this);\n');
      },
    
      /**
       * Visit `attrs`.
       *
       * @param {Array} attrs
       * @api public
       */
    
      visitAttributes: function(attrs, attributeBlocks){
        if (attributeBlocks.length) {
          if (attrs.length) {
            var val = this.attrs(attrs);
            attributeBlocks.unshift(val);
          }
          this.bufferExpression('jade.attrs(jade.merge([' + attributeBlocks.join(',') + ']), ' + utils.stringify(this.terse) + ')');
        } else if (attrs.length) {
          this.attrs(attrs, true);
        }
      },
    
      /**
       * Compile attributes.
       */
    
      attrs: function(attrs, buffer){
        var buf = [];
        var classes = [];
        var classEscaping = [];
    
        attrs.forEach(function(attr){
          var key = attr.name;
          var escaped = attr.escaped;
    
          if (key === 'class') {
            classes.push(attr.val);
            classEscaping.push(attr.escaped);
          } else if (isConstant(attr.val)) {
            if (buffer) {
              this.buffer(runtime.attr(key, toConstant(attr.val), escaped, this.terse));
            } else {
              var val = toConstant(attr.val);
              if (key === 'style') val = runtime.style(val);
              if (escaped && !(key.indexOf('data') === 0 && typeof val !== 'string')) {
                val = runtime.escape(val);
              }
              buf.push(utils.stringify(key) + ': ' + utils.stringify(val));
            }
          } else {
            if (buffer) {
              this.bufferExpression('jade.attr("' + key + '", ' + attr.val + ', ' + utils.stringify(escaped) + ', ' + utils.stringify(this.terse) + ')');
            } else {
              var val = attr.val;
              if (key === 'style') {
                val = 'jade.style(' + val + ')';
              }
              if (escaped && !(key.indexOf('data') === 0)) {
                val = 'jade.escape(' + val + ')';
              } else if (escaped) {
                val = '(typeof (jade_interp = ' + val + ') == "string" ? jade.escape(jade_interp) : jade_interp)';
              }
              buf.push(utils.stringify(key) + ': ' + val);
            }
          }
        }.bind(this));
        if (buffer) {
          if (classes.every(isConstant)) {
            this.buffer(runtime.cls(classes.map(toConstant), classEscaping));
          } else {
            this.bufferExpression('jade.cls([' + classes.join(',') + '], ' + utils.stringify(classEscaping) + ')');
          }
        } else if (classes.length) {
          if (classes.every(isConstant)) {
            classes = utils.stringify(runtime.joinClasses(classes.map(toConstant).map(runtime.joinClasses).map(function (cls, i) {
              return classEscaping[i] ? runtime.escape(cls) : cls;
            })));
          } else {
            classes = '(jade_interp = ' + utils.stringify(classEscaping) + ',' +
              ' jade.joinClasses([' + classes.join(',') + '].map(jade.joinClasses).map(function (cls, i) {' +
              '   return jade_interp[i] ? jade.escape(cls) : cls' +
              ' }))' +
              ')';
          }
          if (classes.length)
            buf.push('"class": ' + classes);
        }
        return '{' + buf.join(',') + '}';
      }
    };
    
  provide("jade/lib/compiler", module.exports);
}(global));

// pakmanager:jade
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    /*!
     * Jade
     * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
     * MIT Licensed
     */
    
    /**
     * Module dependencies.
     */
    
    var Parser =  require('jade/lib/parser')
      , Lexer =  require('jade/lib/lexer')
      , Compiler =  require('jade/lib/compiler')
      , runtime =  require('jade/lib/runtime')
      , addWith = require('with')
      , fs = require('fs')
      , utils =  require('jade/lib/utils');
    
    /**
     * Expose self closing tags.
     */
    
    // FIXME: either stop exporting selfClosing in v2 or export the new object
    // form
    exports.selfClosing = Object.keys(require('void-elements'));
    
    /**
     * Default supported doctypes.
     */
    
    exports.doctypes =  require('jade/lib/doctypes');
    
    /**
     * Text filters.
     */
    
    exports.filters =  require('jade/lib/filters');
    
    /**
     * Utilities.
     */
    
    exports.utils = utils;
    
    /**
     * Expose `Compiler`.
     */
    
    exports.Compiler = Compiler;
    
    /**
     * Expose `Parser`.
     */
    
    exports.Parser = Parser;
    
    /**
     * Expose `Lexer`.
     */
    
    exports.Lexer = Lexer;
    
    /**
     * Nodes.
     */
    
    exports.nodes =  require('jade/lib/nodes');
    
    /**
     * Jade runtime helpers.
     */
    
    exports.runtime = runtime;
    
    /**
     * Template function cache.
     */
    
    exports.cache = {};
    
    /**
     * Parse the given `str` of jade and return a function body.
     *
     * @param {String} str
     * @param {Object} options
     * @return {Object}
     * @api private
     */
    
    function parse(str, options){
    
      if (options.lexer) {
        console.warn('Using `lexer` as a local in render() is deprecated and '
                   + 'will be interpreted as an option in Jade 2.0.0');
      }
    
      // Parse
      var parser = new (options.parser || Parser)(str, options.filename, options);
      var tokens;
      try {
        // Parse
        tokens = parser.parse();
      } catch (err) {
        parser = parser.context();
        runtime.rethrow(err, parser.filename, parser.lexer.lineno, parser.input);
      }
    
      // Compile
      var compiler = new (options.compiler || Compiler)(tokens, options);
      var js;
      try {
        js = compiler.compile();
      } catch (err) {
        if (err.line && (err.filename || !options.filename)) {
          runtime.rethrow(err, err.filename, err.line, parser.input);
        } else {
          if (err instanceof Error) {
            err.message += '\n\nPlease report this entire error and stack trace to https://github.com/jadejs/jade/issues';
          }
          throw err;
        }
      }
    
      // Debug compiler
      if (options.debug) {
        console.error('\nCompiled Function:\n\n\u001b[90m%s\u001b[0m', js.replace(/^/gm, '  '));
      }
    
      var globals = [];
    
      if (options.globals) {
        globals = options.globals.slice();
      }
    
      globals.push('jade');
      globals.push('jade_mixins');
      globals.push('jade_interp');
      globals.push('jade_debug');
      globals.push('buf');
    
      var body = ''
        + 'var buf = [];\n'
        + 'var jade_mixins = {};\n'
        + 'var jade_interp;\n'
        + (options.self
          ? 'var self = locals || {};\n' + js
          : addWith('locals || {}', '\n' + js, globals)) + ';'
        + 'return buf.join("");';
      return {body: body, dependencies: parser.dependencies};
    }
    
    /**
     * Get the template from a string or a file, either compiled on-the-fly or
     * read from cache (if enabled), and cache the template if needed.
     *
     * If `str` is not set, the file specified in `options.filename` will be read.
     *
     * If `options.cache` is true, this function reads the file from
     * `options.filename` so it must be set prior to calling this function.
     *
     * @param {Object} options
     * @param {String=} str
     * @return {Function}
     * @api private
     */
    function handleTemplateCache (options, str) {
      var key = options.filename;
      if (options.cache && exports.cache[key]) {
        return exports.cache[key];
      } else {
        if (str === undefined) str = fs.readFileSync(options.filename, 'utf8');
        var templ = exports.compile(str, options);
        if (options.cache) exports.cache[key] = templ;
        return templ;
      }
    }
    
    /**
     * Compile a `Function` representation of the given jade `str`.
     *
     * Options:
     *
     *   - `compileDebug` when `false` debugging code is stripped from the compiled
           template, when it is explicitly `true`, the source code is included in
           the compiled template for better accuracy.
     *   - `filename` used to improve errors when `compileDebug` is not `false` and to resolve imports/extends
     *
     * @param {String} str
     * @param {Options} options
     * @return {Function}
     * @api public
     */
    
    exports.compile = function(str, options){
      var options = options || {}
        , filename = options.filename
          ? utils.stringify(options.filename)
          : 'undefined'
        , fn;
    
      str = String(str);
    
      var parsed = parse(str, options);
      if (options.compileDebug !== false) {
        fn = [
            'var jade_debug = [{ lineno: 1, filename: ' + filename + ' }];'
          , 'try {'
          , parsed.body
          , '} catch (err) {'
          , '  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno' + (options.compileDebug === true ? ',' + utils.stringify(str) : '') + ');'
          , '}'
        ].join('\n');
      } else {
        fn = parsed.body;
      }
      fn = new Function('locals, jade', fn)
      var res = function(locals){ return fn(locals, Object.create(runtime)) };
      if (options.client) {
        res.toString = function () {
          var err = new Error('The `client` option is deprecated, use the `jade.compileClient` method instead');
          err.name = 'Warning';
          console.error(err.stack || /* istanbul ignore next */ err.message);
          return exports.compileClient(str, options);
        };
      }
      res.dependencies = parsed.dependencies;
      return res;
    };
    
    /**
     * Compile a JavaScript source representation of the given jade `str`.
     *
     * Options:
     *
     *   - `compileDebug` When it is `true`, the source code is included in
     *     the compiled template for better error messages.
     *   - `filename` used to improve errors when `compileDebug` is not `true` and to resolve imports/extends
     *   - `name` the name of the resulting function (defaults to "template")
     *
     * @param {String} str
     * @param {Options} options
     * @return {Object}
     * @api public
     */
    
    exports.compileClientWithDependenciesTracked = function(str, options){
      var options = options || {};
      var name = options.name || 'template';
      var filename = options.filename ? utils.stringify(options.filename) : 'undefined';
      var fn;
    
      str = String(str);
      options.compileDebug = options.compileDebug ? true : false;
      var parsed = parse(str, options);
      if (options.compileDebug) {
        fn = [
            'var jade_debug = [{ lineno: 1, filename: ' + filename + ' }];'
          , 'try {'
          , parsed.body
          , '} catch (err) {'
          , '  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno, ' + utils.stringify(str) + ');'
          , '}'
        ].join('\n');
      } else {
        fn = parsed.body;
      }
    
      return {body: 'function ' + name + '(locals) {\n' + fn + '\n}', dependencies: parsed.dependencies};
    };
    
    /**
     * Compile a JavaScript source representation of the given jade `str`.
     *
     * Options:
     *
     *   - `compileDebug` When it is `true`, the source code is included in
     *     the compiled template for better error messages.
     *   - `filename` used to improve errors when `compileDebug` is not `true` and to resolve imports/extends
     *   - `name` the name of the resulting function (defaults to "template")
     *
     * @param {String} str
     * @param {Options} options
     * @return {String}
     * @api public
     */
    exports.compileClient = function (str, options) {
      return exports.compileClientWithDependenciesTracked(str, options).body;
    };
    
    /**
     * Compile a `Function` representation of the given jade file.
     *
     * Options:
     *
     *   - `compileDebug` when `false` debugging code is stripped from the compiled
           template, when it is explicitly `true`, the source code is included in
           the compiled template for better accuracy.
     *
     * @param {String} path
     * @param {Options} options
     * @return {Function}
     * @api public
     */
    exports.compileFile = function (path, options) {
      options = options || {};
      options.filename = path;
      return handleTemplateCache(options);
    };
    
    /**
     * Render the given `str` of jade.
     *
     * Options:
     *
     *   - `cache` enable template caching
     *   - `filename` filename required for `include` / `extends` and caching
     *
     * @param {String} str
     * @param {Object|Function} options or fn
     * @param {Function|undefined} fn
     * @returns {String}
     * @api public
     */
    
    exports.render = function(str, options, fn){
      // support callback API
      if ('function' == typeof options) {
        fn = options, options = undefined;
      }
      if (typeof fn === 'function') {
        var res
        try {
          res = exports.render(str, options);
        } catch (ex) {
          return fn(ex);
        }
        return fn(null, res);
      }
    
      options = options || {};
    
      // cache requires .filename
      if (options.cache && !options.filename) {
        throw new Error('the "filename" option is required for caching');
      }
    
      return handleTemplateCache(options, str)(options);
    };
    
    /**
     * Render a Jade file at the given `path`.
     *
     * @param {String} path
     * @param {Object|Function} options or callback
     * @param {Function|undefined} fn
     * @returns {String}
     * @api public
     */
    
    exports.renderFile = function(path, options, fn){
      // support callback API
      if ('function' == typeof options) {
        fn = options, options = undefined;
      }
      if (typeof fn === 'function') {
        var res
        try {
          res = exports.renderFile(path, options);
        } catch (ex) {
          return fn(ex);
        }
        return fn(null, res);
      }
    
      options = options || {};
    
      options.filename = path;
      return handleTemplateCache(options)(options);
    };
    
    
    /**
     * Compile a Jade file at the given `path` for use on the client.
     *
     * @param {String} path
     * @param {Object} options
     * @returns {String}
     * @api public
     */
    
    exports.compileFileClient = function(path, options){
      var key = path + ':client';
      options = options || {};
    
      options.filename = path;
    
      if (options.cache && exports.cache[key]) {
          return exports.cache[key];
      }
    
      var str = fs.readFileSync(options.filename, 'utf8');
      var out = exports.compileClient(str, options);
      if (options.cache) exports.cache[key] = out;
      return out;
    };
    
    /**
     * Express support.
     */
    
    exports.__express = exports.renderFile;
    
  provide("jade", module.exports);
}(global));

// pakmanager:supports-color
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var argv = process.argv;
    
    module.exports = (function () {
    	if ('FORCE_COLOR' in process.env) {
    		return true;
    	}
    
    	if (argv.indexOf('--no-color') !== -1 ||
    		argv.indexOf('--no-colors') !== -1 ||
    		argv.indexOf('--color=false') !== -1) {
    		return false;
    	}
    
    	if (argv.indexOf('--color') !== -1 ||
    		argv.indexOf('--colors') !== -1 ||
    		argv.indexOf('--color=true') !== -1 ||
    		argv.indexOf('--color=always') !== -1) {
    		return true;
    	}
    
    	if (process.stdout && !process.stdout.isTTY) {
    		return false;
    	}
    
    	if (process.platform === 'win32') {
    		return true;
    	}
    
    	if ('COLORTERM' in process.env) {
    		return true;
    	}
    
    	if (process.env.TERM === 'dumb') {
    		return false;
    	}
    
    	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
    		return true;
    	}
    
    	return false;
    })();
    
  provide("supports-color", module.exports);
}(global));

// pakmanager:optimist
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var path = require('path');
    var minimist = require('minimist');
    var wordwrap = require('wordwrap');
    
    /*  Hack an instance of Argv with process.argv into Argv
        so people can do
             require('optimist')(['--beeble=1','-z','zizzle']).argv
        to parse a list of args and
             require('optimist').argv
        to get a parsed version of process.argv.
    */
    
    var inst = Argv(process.argv.slice(2));
    Object.keys(inst).forEach(function (key) {
        Argv[key] = typeof inst[key] == 'function'
            ? inst[key].bind(inst)
            : inst[key];
    });
    
    var exports = module.exports = Argv;
    function Argv (processArgs, cwd) {
        var self = {};
        if (!cwd) cwd = process.cwd();
        
        self.$0 = process.argv
            .slice(0,2)
            .map(function (x) {
                var b = rebase(cwd, x);
                return x.match(/^\//) && b.length < x.length
                    ? b : x
            })
            .join(' ')
        ;
        
        if (process.env._ != undefined && process.argv[1] == process.env._) {
            self.$0 = process.env._.replace(
                path.dirname(process.execPath) + '/', ''
            );
        }
        
        var options = {
            boolean: [],
            string: [],
            alias: {},
            default: []
        };
        
        self.boolean = function (bools) {
            options.boolean.push.apply(options.boolean, [].concat(bools));
            return self;
        };
        
        self.string = function (strings) {
            options.string.push.apply(options.string, [].concat(strings));
            return self;
        };
        
        self.default = function (key, value) {
            if (typeof key === 'object') {
                Object.keys(key).forEach(function (k) {
                    self.default(k, key[k]);
                });
            }
            else {
                options.default[key] = value;
            }
            return self;
        };
        
        self.alias = function (x, y) {
            if (typeof x === 'object') {
                Object.keys(x).forEach(function (key) {
                    self.alias(key, x[key]);
                });
            }
            else {
                options.alias[x] = (options.alias[x] || []).concat(y);
            }
            return self;
        };
        
        var demanded = {};
        self.demand = function (keys) {
            if (typeof keys == 'number') {
                if (!demanded._) demanded._ = 0;
                demanded._ += keys;
            }
            else if (Array.isArray(keys)) {
                keys.forEach(function (key) {
                    self.demand(key);
                });
            }
            else {
                demanded[keys] = true;
            }
            
            return self;
        };
        
        var usage;
        self.usage = function (msg, opts) {
            if (!opts && typeof msg === 'object') {
                opts = msg;
                msg = null;
            }
            
            usage = msg;
            
            if (opts) self.options(opts);
            
            return self;
        };
        
        function fail (msg) {
            self.showHelp();
            if (msg) console.error(msg);
            process.exit(1);
        }
        
        var checks = [];
        self.check = function (f) {
            checks.push(f);
            return self;
        };
        
        var descriptions = {};
        self.describe = function (key, desc) {
            if (typeof key === 'object') {
                Object.keys(key).forEach(function (k) {
                    self.describe(k, key[k]);
                });
            }
            else {
                descriptions[key] = desc;
            }
            return self;
        };
        
        self.parse = function (args) {
            return parseArgs(args);
        };
        
        self.option = self.options = function (key, opt) {
            if (typeof key === 'object') {
                Object.keys(key).forEach(function (k) {
                    self.options(k, key[k]);
                });
            }
            else {
                if (opt.alias) self.alias(key, opt.alias);
                if (opt.demand) self.demand(key);
                if (typeof opt.default !== 'undefined') {
                    self.default(key, opt.default);
                }
                
                if (opt.boolean || opt.type === 'boolean') {
                    self.boolean(key);
                }
                if (opt.string || opt.type === 'string') {
                    self.string(key);
                }
                
                var desc = opt.describe || opt.description || opt.desc;
                if (desc) {
                    self.describe(key, desc);
                }
            }
            
            return self;
        };
        
        var wrap = null;
        self.wrap = function (cols) {
            wrap = cols;
            return self;
        };
        
        self.showHelp = function (fn) {
            if (!fn) fn = console.error;
            fn(self.help());
        };
        
        self.help = function () {
            var keys = Object.keys(
                Object.keys(descriptions)
                .concat(Object.keys(demanded))
                .concat(Object.keys(options.default))
                .reduce(function (acc, key) {
                    if (key !== '_') acc[key] = true;
                    return acc;
                }, {})
            );
            
            var help = keys.length ? [ 'Options:' ] : [];
            
            if (usage) {
                help.unshift(usage.replace(/\$0/g, self.$0), '');
            }
            
            var switches = keys.reduce(function (acc, key) {
                acc[key] = [ key ].concat(options.alias[key] || [])
                    .map(function (sw) {
                        return (sw.length > 1 ? '--' : '-') + sw
                    })
                    .join(', ')
                ;
                return acc;
            }, {});
            
            var switchlen = longest(Object.keys(switches).map(function (s) {
                return switches[s] || '';
            }));
            
            var desclen = longest(Object.keys(descriptions).map(function (d) { 
                return descriptions[d] || '';
            }));
            
            keys.forEach(function (key) {
                var kswitch = switches[key];
                var desc = descriptions[key] || '';
                
                if (wrap) {
                    desc = wordwrap(switchlen + 4, wrap)(desc)
                        .slice(switchlen + 4)
                    ;
                }
                
                var spadding = new Array(
                    Math.max(switchlen - kswitch.length + 3, 0)
                ).join(' ');
                
                var dpadding = new Array(
                    Math.max(desclen - desc.length + 1, 0)
                ).join(' ');
                
                var type = null;
                
                if (options.boolean[key]) type = '[boolean]';
                if (options.string[key]) type = '[string]';
                
                if (!wrap && dpadding.length > 0) {
                    desc += dpadding;
                }
                
                var prelude = '  ' + kswitch + spadding;
                var extra = [
                    type,
                    demanded[key]
                        ? '[required]'
                        : null
                    ,
                    options.default[key] !== undefined
                        ? '[default: ' + JSON.stringify(options.default[key]) + ']'
                        : null
                    ,
                ].filter(Boolean).join('  ');
                
                var body = [ desc, extra ].filter(Boolean).join('  ');
                
                if (wrap) {
                    var dlines = desc.split('\n');
                    var dlen = dlines.slice(-1)[0].length
                        + (dlines.length === 1 ? prelude.length : 0)
                    
                    body = desc + (dlen + extra.length > wrap - 2
                        ? '\n'
                            + new Array(wrap - extra.length + 1).join(' ')
                            + extra
                        : new Array(wrap - extra.length - dlen + 1).join(' ')
                            + extra
                    );
                }
                
                help.push(prelude + body);
            });
            
            help.push('');
            return help.join('\n');
        };
        
        Object.defineProperty(self, 'argv', {
            get : function () { return parseArgs(processArgs) },
            enumerable : true,
        });
        
        function parseArgs (args) {
            var argv = minimist(args, options);
            argv.$0 = self.$0;
            
            if (demanded._ && argv._.length < demanded._) {
                fail('Not enough non-option arguments: got '
                    + argv._.length + ', need at least ' + demanded._
                );
            }
            
            var missing = [];
            Object.keys(demanded).forEach(function (key) {
                if (!argv[key]) missing.push(key);
            });
            
            if (missing.length) {
                fail('Missing required arguments: ' + missing.join(', '));
            }
            
            checks.forEach(function (f) {
                try {
                    if (f(argv) === false) {
                        fail('Argument check failed: ' + f.toString());
                    }
                }
                catch (err) {
                    fail(err)
                }
            });
            
            return argv;
        }
        
        function longest (xs) {
            return Math.max.apply(
                null,
                xs.map(function (x) { return x.length })
            );
        }
        
        return self;
    };
    
    // rebase an absolute path to a relative one with respect to a base directory
    // exported for tests
    exports.rebase = rebase;
    function rebase (base, dir) {
        var ds = path.normalize(dir).split('/').slice(1);
        var bs = path.normalize(base).split('/').slice(1);
        
        for (var i = 0; ds[i] && ds[i] == bs[i]; i++);
        ds.splice(0, i); bs.splice(0, i);
        
        var p = path.normalize(
            bs.map(function () { return '..' }).concat(ds).join('/')
        ).replace(/\/$/,'').replace(/^$/, '.');
        return p.match(/^[.\/]/) ? p : './' + p;
    };
    
  provide("optimist", module.exports);
}(global));

// pakmanager:chokidar/lib/nodefs-handler
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var fs = require('fs');
    var sysPath = require('path');
    var readdirp = require('readdirp');
    var isBinaryPath = require('is-binary-path');
    
    // fs.watch helpers
    
    // object to hold per-process fs.watch instances
    // (may be shared across chokidar FSWatcher instances)
    var FsWatchInstances = Object.create(null);
    
    // Private function: Instantiates the fs.watch interface
    
    // * path       - string, path to be watched
    // * options    - object, options to be passed to fs.watch
    // * listener   - function, main event handler
    // * errHandler - function, handler which emits info about errors
    // * emitRaw    - function, handler which emits raw event data
    
    // Returns new fsevents instance
    function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {
      var handleEvent = function(rawEvent, evPath) {
        listener(path);
        emitRaw(rawEvent, evPath, {watchedPath: path});
    
        // emit based on events occuring for files from a directory's watcher in
        // case the file's watcher misses it (and rely on throttling to de-dupe)
        if (evPath && path !== evPath) {
          fsWatchBroadcast(
            sysPath.resolve(path, evPath), 'listeners', sysPath.join(path, evPath)
          );
        }
      };
      try {
        return fs.watch(path, options, handleEvent);
      } catch (error) {
        errHandler(error);
      }
    }
    
    // Private function: Helper for passing fs.watch event data to a
    // collection of listeners
    
    // * fullPath   - string, absolute path bound to the fs.watch instance
    // * type       - string, listener type
    // * val[1..3]  - arguments to be passed to listeners
    
    // Returns nothing
    function fsWatchBroadcast(fullPath, type, val1, val2, val3) {
      if (!FsWatchInstances[fullPath]) return;
      FsWatchInstances[fullPath][type].forEach(function(listener) {
        listener(val1, val2, val3);
      });
    }
    
    // Private function: Instantiates the fs.watch interface or binds listeners
    // to an existing one covering the same file system entry
    
    // * path       - string, path to be watched
    // * fullPath   - string, absolute path
    // * options    - object, options to be passed to fs.watch
    // * handlers   - object, container for event listener functions
    
    // Returns close function
    function setFsWatchListener(path, fullPath, options, handlers) {
      var listener = handlers.listener;
      var errHandler = handlers.errHandler;
      var rawEmitter = handlers.rawEmitter;
      var container = FsWatchInstances[fullPath];
      var watcher;
      if (!options.persistent) {
        watcher = createFsWatchInstance(
          path, options, listener, errHandler, rawEmitter
        );
        return watcher.close.bind(watcher);
      }
      if (!container) {
        var watcher = createFsWatchInstance(
          path,
          options,
          fsWatchBroadcast.bind(null, fullPath, 'listeners'),
          errHandler, // no need to use broadcast here
          fsWatchBroadcast.bind(null, fullPath, 'rawEmitters')
        );
        if (!watcher) return;
        var broadcastErr = fsWatchBroadcast.bind(null, fullPath, 'errHandlers');
        watcher.on('error', function(error) {
          // Workaround for https://github.com/joyent/node/issues/4337
          if (process.platform === 'win32' && error.code === 'EPERM') {
            fs.open(path, 'r', function(err, fd) {
              if (fd) fs.close(fd);
              if (!err) broadcastErr(error);
            });
          } else {
            broadcastErr(error);
          }
        });
        container = FsWatchInstances[fullPath] = {
          listeners: [listener],
          errHandlers: [errHandler],
          rawEmitters: [rawEmitter],
          watcher: watcher
        };
      } else {
        container.listeners.push(listener);
        container.errHandlers.push(errHandler);
        container.rawEmitters.push(rawEmitter);
      }
      var listenerIndex = container.listeners.length - 1;
    
      // removes this instance's listeners and closes the underlying fs.watch
      // instance if there are no more listeners left
      return function close() {
        delete container.listeners[listenerIndex];
        delete container.errHandlers[listenerIndex];
        delete container.rawEmitters[listenerIndex];
        if (!Object.keys(container.listeners).length) {
          container.watcher.close();
          delete FsWatchInstances[fullPath];
        }
      };
    }
    
    // fs.watchFile helpers
    
    // object to hold per-process fs.watchFile instances
    // (may be shared across chokidar FSWatcher instances)
    var FsWatchFileInstances = Object.create(null);
    
    // Private function: Instantiates the fs.watchFile interface or binds listeners
    // to an existing one covering the same file system entry
    
    // * path       - string, path to be watched
    // * fullPath   - string, absolute path
    // * options    - object, options to be passed to fs.watchFile
    // * handlers   - object, container for event listener functions
    
    // Returns close function
    function setFsWatchFileListener(path, fullPath, options, handlers) {
      var listener = handlers.listener;
      var rawEmitter = handlers.rawEmitter;
      var container = FsWatchFileInstances[fullPath];
      var listeners = [];
      var rawEmitters = [];
      if (
        container && (
          container.options.persistent < options.persistent ||
          container.options.interval > options.interval
        )
      ) {
        // "Upgrade" the watcher to persistence or a quicker interval.
        // This creates some unlikely edge case issues if the user mixes
        // settings in a very weird way, but solving for those cases
        // doesn't seem worthwhile for the added complexity.
        listeners = container.listeners;
        rawEmitters = container.rawEmitters;
        fs.unwatchFile(fullPath);
        container = false;
      }
      if (!container) {
        listeners.push(listener);
        rawEmitters.push(rawEmitter);
        container = FsWatchFileInstances[fullPath] = {
          listeners: listeners,
          rawEmitters: rawEmitters,
          options: options,
          watcher: fs.watchFile(fullPath, options, function(curr, prev) {
            container.rawEmitters.forEach(function(rawEmitter) {
              rawEmitter('change', fullPath, {curr: curr, prev: prev});
            });
            var currmtime = curr.mtime.getTime();
            if (curr.size !== prev.size || currmtime > prev.mtime.getTime() || currmtime === 0) {
              container.listeners.forEach(function(listener) {
                listener(path, curr);
              });
            }
          })
        };
      } else {
        container.listeners.push(listener);
        container.rawEmitters.push(rawEmitter);
      }
      var listenerIndex = container.listeners.length - 1;
    
      // removes this instance's listeners and closes the underlying fs.watchFile
      // instance if there are no more listeners left
      return function close() {
        delete container.listeners[listenerIndex];
        delete container.rawEmitters[listenerIndex];
        if (!Object.keys(container.listeners).length) {
          fs.unwatchFile(fullPath);
          delete FsWatchFileInstances[fullPath];
        }
      }
    }
    
    // fake constructor for attaching nodefs-specific prototype methods that
    // will be copied to FSWatcher's prototype
    function NodeFsHandler() {}
    
    // Private method: Watch file for changes with fs.watchFile or fs.watch.
    
    // * path     - string, path to file or directory.
    // * listener - function, to be executed on fs change.
    
    // Returns close function for the watcher instance
    NodeFsHandler.prototype._watchWithNodeFs =
    function(path, listener) {
      var directory = sysPath.dirname(path);
      var basename = sysPath.basename(path);
      var parent = this._getWatchedDir(directory);
      parent.add(basename);
      var absolutePath = sysPath.resolve(path);
      var options = {persistent: this.options.persistent};
      if (!listener) listener = Function.prototype; // empty function
    
      var closer;
      if (this.options.usePolling) {
        options.interval = this.enableBinaryInterval && isBinaryPath(basename) ?
          this.options.binaryInterval : this.options.interval;
        closer = setFsWatchFileListener(path, absolutePath, options, {
          listener: listener,
          rawEmitter: this.emit.bind(this, 'raw')
        });
      } else {
        closer = setFsWatchListener(path, absolutePath, options, {
          listener: listener,
          errHandler: this._handleError.bind(this),
          rawEmitter: this.emit.bind(this, 'raw')
        });
      }
      return closer;
    };
    
    // Private method: Watch a file and emit add event if warranted
    
    // * file       - string, the file's path
    // * stats      - object, result of fs.stat
    // * initialAdd - boolean, was the file added at watch instantiation?
    // * callback   - function, called when done processing as a newly seen file
    
    // Returns close function for the watcher instance
    NodeFsHandler.prototype._handleFile =
    function(file, stats, initialAdd, callback) {
      var dirname = sysPath.dirname(file);
      var basename = sysPath.basename(file);
      var parent = this._getWatchedDir(dirname);
    
      // if the file is already being watched, do nothing
      if (parent.has(basename)) return callback();
    
      // kick off the watcher
      var closer = this._watchWithNodeFs(file, function(path, newStats) {
        if (!this._throttle('watch', file, 5)) return;
        if (!newStats || newStats && newStats.mtime.getTime() === 0) {
          fs.stat(file, function(error, newStats) {
            // Fix issues where mtime is null but file is still present
            if (error) {
              this._remove(dirname, basename);
            } else {
              this._emit('change', file, newStats);
            }
          }.bind(this));
        // add is about to be emitted if file not already tracked in parent
        } else if (parent.has(basename)) {
          this._emit('change', file, newStats);
        }
      }.bind(this));
    
      // emit an add event if we're supposed to
      if (!(initialAdd && this.options.ignoreInitial)) {
        if (!this._throttle('add', file, 0)) return;
        this._emit('add', file, stats);
      }
    
      if (callback) callback();
      return closer;
    };
    
    // Private method: Handle symlinks encountered while reading a dir
    
    // * entry      - object, entry object returned by readdirp
    // * directory  - string, path of the directory being read
    // * path       - string, path of this item
    // * item       - string, basename of this item
    
    // Returns true if no more processing is needed for this entry.
    NodeFsHandler.prototype._handleSymlink =
    function(entry, directory, path, item) {
      var full = entry.fullPath;
      var dir = this._getWatchedDir(directory);
    
      if (!this.options.followSymlinks) {
        // watch symlink directly (don't follow) and detect changes
        this._readyCount++;
        fs.realpath(path, function(error, linkPath) {
          if (dir.has(item)) {
            if (this._symlinkPaths[full] !== linkPath) {
              this._symlinkPaths[full] = linkPath;
              this._emit('change', path, entry.stat);
            }
          } else {
            dir.add(item);
            this._symlinkPaths[full] = linkPath;
            this._emit('add', path, entry.stat);
          }
          this._emitReady();
        }.bind(this));
        return true;
      }
    
      // don't follow the same symlink more than once
      if (this._symlinkPaths[full]) return true;
      else this._symlinkPaths[full] = true;
    }
    
    // Private method: Read directory to add / remove files from `@watched` list
    // and re-read it on change.
    
    // * dir        - string, fs path.
    // * stats      - object, result of fs.stat
    // * initialAdd - boolean, was the file added at watch instantiation?
    // * depth      - int, depth relative to user-supplied path
    // * target     - string, child path actually targeted for watch
    // * wh         - object, common watch helpers for this path
    // * callback   - function, called when dir scan is complete
    
    // Returns close function for the watcher instance
    NodeFsHandler.prototype._handleDir =
    function(dir, stats, initialAdd, depth, target, wh, callback) {
      if (!(initialAdd && this.options.ignoreInitial) && !target && !wh.hasGlob) {
        this._emit('addDir', dir, stats);
      }
    
      // ensure dir is tracked
      this._getWatchedDir(sysPath.dirname(dir)).add(sysPath.basename(dir));
      this._getWatchedDir(dir);
    
      var read = function(directory, initialAdd, done) {
        // Normalize the directory name on Windows
        directory = sysPath.join(directory, '');
    
        if (!wh.hasGlob) {
          var throttler = this._throttle('readdir', directory, 1000);
          if (!throttler) return;
        }
    
        var previous = this._getWatchedDir(wh.path);
        var current = [];
    
        readdirp({
          root: directory,
          entryType: 'all',
          fileFilter: wh.filterPath,
          directoryFilter: wh.filterDir,
          depth: 0,
          lstat: true
        }).on('data', function(entry) {
          var item = entry.path;
          var path = sysPath.join(directory, item);
          current.push(item);
    
          if (entry.stat.isSymbolicLink() &&
            this._handleSymlink(entry, directory, path, item)) return;
    
          // Files that present in current directory snapshot
          // but absent in previous are added to watch list and
          // emit `add` event.
          if (item === target || !target && !previous.has(item)) {
            this._readyCount++;
    
            // ensure relativeness of path is preserved in case of watcher reuse
            path = sysPath.join(dir, sysPath.relative(dir, path));
    
            this._addToNodeFs(path, initialAdd, wh, depth + 1);
          }
        }.bind(this)).on('end', function() {
          if (throttler) throttler.clear();
          if (done) done();
    
          // Files that absent in current directory snapshot
          // but present in previous emit `remove` event
          // and are removed from @watched[directory].
          previous.children().filter(function(item) {
            return item !== directory &&
              current.indexOf(item) === -1 &&
              // in case of intersecting globs;
              // a path may have been filtered out of this readdir, but
              // shouldn't be removed because it matches a different glob
              (!wh.hasGlob || wh.filterPath({
                fullPath: sysPath.resolve(directory, item)
              }));
          }).forEach(function(item) {
            this._remove(directory, item);
          }, this);
        }.bind(this)).on('error', this._handleError.bind(this));
      }.bind(this);
    
      if (this.options.depth == null || depth <= this.options.depth) {
        if (!target) read(dir, initialAdd, callback);
        var closer = this._watchWithNodeFs(dir, function(dirPath, stats) {
          // if current directory is removed, do nothing
          if (stats && stats.mtime.getTime() === 0) return;
    
          read(dirPath, false);
        });
      } else {
        callback();
      }
      return closer;
    };
    
    // Private method: Handle added file, directory, or glob pattern.
    // Delegates call to _handleFile / _handleDir after checks.
    
    // * path       - string, path to file or directory.
    // * initialAdd - boolean, was the file added at watch instantiation?
    // * depth      - int, depth relative to user-supplied path
    // * target     - string, child path actually targeted for watch
    // * callback   - function, indicates whether the path was found or not
    
    // Returns nothing
    NodeFsHandler.prototype._addToNodeFs =
    function(path, initialAdd, priorWh, depth, target, callback) {
      if (!callback) callback = Function.prototype;
      var ready = this._emitReady;
      if (this._isIgnored(path) || this.closed) {
        ready();
        return callback(null, false);
      }
    
      var wh = this._getWatchHelpers(path, depth);
      if (!wh.hasGlob && priorWh) {
        wh.hasGlob = priorWh.hasGlob;
        wh.filterPath = priorWh.filterPath;
        wh.filterDir = priorWh.filterDir;
      }
    
      // evaluate what is at the path we're being asked to watch
      fs[wh.statMethod](wh.watchPath, function(error, stats) {
        if (this._handleError(error)) return callback(null, path);
        if (this._isIgnored(wh.watchPath, stats)) {
          ready();
          return callback(null, false);
        }
    
        var initDir = function(dir, target) {
          return this._handleDir(dir, stats, initialAdd, depth, target, wh, ready);
        }.bind(this);
    
        var closer;
        if (stats.isDirectory()) {
          closer = initDir(wh.watchPath, target);
        } else if (stats.isSymbolicLink()) {
          var parent = sysPath.dirname(wh.watchPath);
          this._getWatchedDir(parent).add(wh.watchPath);
          this._emit('add', wh.watchPath, stats);
          closer = initDir(parent, path);
    
          // preserve this symlink's target path
          fs.realpath(path, function(error, targetPath) {
            this._symlinkPaths[sysPath.resolve(path)] = targetPath;
            ready();
          }.bind(this));
        } else {
          closer = this._handleFile(wh.watchPath, stats, initialAdd, ready);
        }
    
        if (closer) this._closers[path] = closer;
        callback(null, false);
      }.bind(this));
    };
    
    module.exports = NodeFsHandler;
    
  provide("chokidar/lib/nodefs-handler", module.exports);
}(global));

// pakmanager:chokidar/lib/fsevents-handler
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var fs = require('fs');
    var sysPath = require('path');
    var readdirp = require('readdirp');
    var fsevents;
    try { fsevents = require('fsevents'); } catch (error) {}
    
    // fsevents instance helper functions
    
    // object to hold per-process fsevents instances
    // (may be shared across chokidar FSWatcher instances)
    var FSEventsWatchers = Object.create(null);
    
    // Private function: Instantiates the fsevents interface
    
    // * path       - string, path to be watched
    // * callback   - function, called when fsevents is bound and ready
    
    // Returns new fsevents instance
    function createFSEventsInstance(path, callback) {
      return (new fsevents(path)).on('fsevent', callback).start();
    }
    
    // Private function: Instantiates the fsevents interface or binds listeners
    // to an existing one covering the same file tree
    
    // * path       - string, path to be watched
    // * realPath   - string, real path (in case of symlinks)
    // * listener   - function, called when fsevents emits events
    // * rawEmitter - function, passes data to listeners of the 'raw' event
    
    // Returns close function
    function setFSEventsListener(path, realPath, listener, rawEmitter) {
      var watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;
      var watchContainer;
    
      var resolvedPath = sysPath.resolve(path);
      var hasSymlink = resolvedPath !== realPath;
      function filteredListener(fullPath, flags, info) {
        if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);
        if (
          fullPath === resolvedPath ||
          !fullPath.indexOf(resolvedPath + sysPath.sep)
        ) listener(fullPath, flags, info);
      }
    
      // check if there is already a watcher on a parent path
      // modifies `watchPath` to the parent path when it finds a match
      function watchedParent() {
        return Object.keys(FSEventsWatchers).some(function(watchedPath) {
          // condition is met when indexOf returns 0
          if (!realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep)) {
            watchPath = watchedPath;
            return true;
          }
        });
      }
    
      if (watchPath in FSEventsWatchers || watchedParent()) {
        watchContainer = FSEventsWatchers[watchPath];
        watchContainer.listeners.push(filteredListener);
      } else {
        watchContainer = FSEventsWatchers[watchPath] = {
          listeners: [filteredListener],
          rawEmitters: [rawEmitter],
          watcher: createFSEventsInstance(watchPath, function(fullPath, flags) {
            var info = fsevents.getInfo(fullPath, flags);
            watchContainer.listeners.forEach(function(listener) {
              listener(fullPath, flags, info);
            });
            watchContainer.rawEmitters.forEach(function(emitter) {
              emitter(info.event, fullPath, info);
            });
          })
        };
      }
      var listenerIndex = watchContainer.listeners.length - 1;
    
      // removes this instance's listeners and closes the underlying fsevents
      // instance if there are no more listeners left
      return function close() {
        delete watchContainer.listeners[listenerIndex];
        delete watchContainer.rawEmitters[listenerIndex];
        if (!Object.keys(watchContainer.listeners).length) {
          watchContainer.watcher.stop();
          delete FSEventsWatchers[watchPath];
        }
      }
    }
    
    // returns boolean indicating whether fsevents can be used
    function canUse() {
      return fsevents && Object.keys(FSEventsWatchers).length < 128;
    }
    
    // determines subdirectory traversal levels from root to path
    function depth(path, root) {
      var i = 0;
      while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;
      return i;
    }
    
    // fake constructor for attaching fsevents-specific prototype methods that
    // will be copied to FSWatcher's prototype
    function FsEventsHandler() {}
    
    // Private method: Handle symlinks encountered during directory scan
    
    // * wathPath   - string, file/dir path to be watched with fsevents
    // * realPath   - string, real path (in case of symlinks)
    // * transform  - function, path transformer
    // * globFilter - function, path filter in case a glob pattern was provided
    
    // Returns close function for the watcher instance
    FsEventsHandler.prototype._watchWithFsEvents =
    function(watchPath, realPath, transform, globFilter) {
      if (this._isIgnored(watchPath)) return;
      var watchCallback = function(fullPath, flags, info) {
        if (
          this.options.depth !== undefined &&
          depth(fullPath, realPath) > this.options.depth
        ) return;
        var path = transform(sysPath.join(
          watchPath, sysPath.relative(watchPath, fullPath)
        ));
        if (globFilter && !globFilter(path)) return;
        // ensure directories are tracked
        var parent = sysPath.dirname(path);
        var item = sysPath.basename(path);
        var watchedDir = this._getWatchedDir(
          info.type === 'directory' ? path : parent
        );
        var checkIgnored = function(stats) {
          if (this._isIgnored(path, stats)) {
            this._ignoredPaths[path] = true;
            if (stats && stats.isDirectory()) {
              this._ignoredPaths[path + '/**/*'] = true;
            }
            return true;
          } else {
            delete this._ignoredPaths[path];
            delete this._ignoredPaths[path + '/**/*'];
          }
        }.bind(this);
    
        var handleEvent = function(event) {
          if (checkIgnored()) return;
    
          if (event === 'unlink') {
            // suppress unlink events on never before seen files
            if (info.type === 'directory' || watchedDir.has(item)) {
              this._remove(parent, item);
            }
          } else {
            if (event === 'add') {
              // track new directories
              if (info.type === 'directory') this._getWatchedDir(path);
    
              if (info.type === 'symlink' && this.options.followSymlinks) {
                // push symlinks back to the top of the stack to get handled
                var curDepth = this.options.depth === undefined ?
                  undefined : depth(fullPath, realPath) + 1;
                return this._addToFsEvents(path, false, true, curDepth);
              } else {
                // track new paths
                // (other than symlinks being followed, which will be tracked soon)
                this._getWatchedDir(parent).add(item);
              }
            }
            var eventName = info.type === 'directory' ? event + 'Dir' : event;
            this._emit(eventName, path);
          }
        }.bind(this);
    
        function addOrChange() {
          handleEvent(watchedDir.has(item) ? 'change' : 'add');
        }
        function checkFd() {
          fs.open(path, 'r', function(error, fd) {
            if (fd) fs.close(fd);
            error && error.code !== 'EACCES' ?
              handleEvent('unlink') : addOrChange();
          });
        }
        // correct for wrong events emitted
        var wrongEventFlags = [
          69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912
        ];
        if (wrongEventFlags.indexOf(flags) !== -1 || info.event === 'unknown') {
          if (typeof this.options.ignored === 'function') {
            fs.stat(path, function(error, stats) {
              if (checkIgnored(stats)) return;
              stats ? addOrChange() : handleEvent('unlink');
            });
          } else {
            checkFd();
          }
        } else {
          switch (info.event) {
          case 'created':
          case 'modified':
            return addOrChange();
          case 'deleted':
          case 'moved':
            return checkFd();
          }
        }
      }.bind(this);
    
      var closer = setFSEventsListener(
        watchPath,
        realPath,
        watchCallback,
        this.emit.bind(this, 'raw')
      );
    
      this._emitReady();
      return closer;
    };
    
    // Private method: Handle symlinks encountered during directory scan
    
    // * linkPath   - string, path to symlink
    // * fullPath   - string, absolute path to the symlink
    // * transform  - function, pre-existing path transformer
    // * curDepth   - int, level of subdirectories traversed to where symlink is
    
    // Returns nothing
    FsEventsHandler.prototype._fsEventsSymlink =
    function(linkPath, fullPath, transform, curDepth) {
      // don't follow the same symlink more than once
      if (this._symlinkPaths[fullPath]) return;
      else this._symlinkPaths[fullPath] = true;
    
      this._readyCount++;
    
      fs.realpath(linkPath, function(error, linkTarget) {
        if (this._handleError(error) || this._isIgnored(linkTarget)) {
          return this._emitReady();
        }
    
        this._readyCount++;
    
        // add the linkTarget for watching with a wrapper for transform
        // that causes emitted paths to incorporate the link's path
        this._addToFsEvents(linkTarget || linkPath, function(path) {
          var dotSlash = '.' + sysPath.sep;
          var aliasedPath = linkPath;
          if (linkTarget && linkTarget !== dotSlash) {
            aliasedPath = path.replace(linkTarget, linkPath);
          } else if (path !== dotSlash) {
            aliasedPath = sysPath.join(linkPath, path);
          }
          return transform(aliasedPath);
        }, false, curDepth);
      }.bind(this));
    };
    
    // Private method: Handle added path with fsevents
    
    // * path       - string, file/directory path or glob pattern
    // * transform  - function, converts working path to what the user expects
    // * forceAdd   - boolean, ensure add is emitted
    // * priorDepth - int, level of subdirectories already traversed
    
    // Returns nothing
    FsEventsHandler.prototype._addToFsEvents =
    function(path, transform, forceAdd, priorDepth) {
    
      // applies transform if provided, otherwise returns same value
      var processPath = typeof transform === 'function' ?
        transform : function(val) { return val; };
    
      var emitAdd = function(newPath, stats) {
        var pp = processPath(newPath);
        var isDir = stats.isDirectory();
        var dirObj = this._getWatchedDir(sysPath.dirname(pp));
        var base = sysPath.basename(pp);
    
        // ensure empty dirs get tracked
        if (isDir) this._getWatchedDir(pp);
    
        if (dirObj.has(base)) return;
        dirObj.add(base);
    
        if (!this.options.ignoreInitial || forceAdd === true) {
          this._emit(isDir ? 'addDir' : 'add', pp, stats);
        }
      }.bind(this);
    
      var wh = this._getWatchHelpers(path);
    
      // evaluate what is at the path we're being asked to watch
      fs[wh.statMethod](wh.watchPath, function(error, stats) {
        if (this._handleError(error) || this._isIgnored(wh.watchPath, stats)) {
          this._emitReady();
          return this._emitReady();
        }
    
        if (stats.isDirectory()) {
          // emit addDir unless this is a glob parent
          if (!wh.globFilter) emitAdd(processPath(path), stats);
    
          // don't recurse further if it would exceed depth setting
          if (priorDepth && priorDepth > this.options.depth) return;
    
          // scan the contents of the dir
          readdirp({
            root: wh.watchPath,
            entryType: 'all',
            fileFilter: wh.filterPath,
            directoryFilter: wh.filterDir,
            lstat: true,
            depth: this.options.depth - (priorDepth || 0)
          }).on('data', function(entry) {
            // need to check filterPath on dirs b/c filterDir is less restrictive
            if (entry.stat.isDirectory() && !wh.filterPath(entry)) return;
    
            var joinedPath = sysPath.join(wh.watchPath, entry.path);
            var fullPath = entry.fullPath;
    
            if (wh.followSymlinks && entry.stat.isSymbolicLink()) {
              // preserve the current depth here since it can't be derived from
              // real paths past the symlink
              var curDepth = this.options.depth === undefined ?
                undefined : depth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;
    
              this._fsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
            } else {
              emitAdd(joinedPath, entry.stat);
            }
          }.bind(this)).on('end', this._emitReady);
        } else {
          emitAdd(wh.watchPath, stats);
          this._emitReady();
        }
      }.bind(this));
    
      if (this.options.persistent) {
        var initWatch = function(error, realPath) {
          var closer = this._watchWithFsEvents(
            wh.watchPath,
            sysPath.resolve(realPath || wh.watchPath),
            processPath,
            wh.globFilter
          );
          if (closer) this._closers[path] = closer;
        }.bind(this);
    
        if (typeof transform === 'function') {
          // realpath has already been resolved
          initWatch();
        } else {
          fs.realpath(wh.watchPath, initWatch);
        }
      }
    };
    
    module.exports = FsEventsHandler;
    module.exports.canUse = canUse;
    
  provide("chokidar/lib/fsevents-handler", module.exports);
}(global));

// pakmanager:chokidar
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var EventEmitter = require('events').EventEmitter;
    var fs = require('fs');
    var sysPath = require('path');
    var each = require('async-each');
    var anymatch = require('anymatch');
    var globparent = require('glob-parent');
    var isglob = require('is-glob');
    var arrify = require('arrify');
    
    var NodeFsHandler =  require('chokidar/lib/nodefs-handler');
    var FsEventsHandler =  require('chokidar/lib/fsevents-handler');
    
    // Public: Main class.
    // Watches files & directories for changes.
    //
    // * _opts - object, chokidar options hash
    //
    // Emitted events:
    // `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`
    //
    // Examples
    //
    //  var watcher = new FSWatcher()
    //    .add(directories)
    //    .on('add', function(path) {console.log('File', path, 'was added');})
    //    .on('change', function(path) {console.log('File', path, 'was changed');})
    //    .on('unlink', function(path) {console.log('File', path, 'was removed');})
    //    .on('all', function(event, path) {console.log(path, ' emitted ', event);})
    //
    function FSWatcher(_opts) {
      var opts = {};
      // in case _opts that is passed in is a frozen object
      if (_opts) for (var opt in _opts) opts[opt] = _opts[opt];
      this._watched = Object.create(null);
      this._closers = Object.create(null);
      this._ignoredPaths = Object.create(null);
      Object.defineProperty(this, '_globIgnored', {
        get: function() { return Object.keys(this._ignoredPaths); }
      });
      this.closed = false;
      this._throttled = Object.create(null);
      this._symlinkPaths = Object.create(null);
    
      function undef(key) {
        return opts[key] === undefined;
      }
    
      // Set up default options.
      if (undef('persistent')) opts.persistent = true;
      if (undef('ignoreInitial')) opts.ignoreInitial = false;
      if (undef('ignorePermissionErrors')) opts.ignorePermissionErrors = false;
      if (undef('interval')) opts.interval = 100;
      if (undef('binaryInterval')) opts.binaryInterval = 300;
      this.enableBinaryInterval = opts.binaryInterval !== opts.interval;
    
      // Enable fsevents on OS X when polling isn't explicitly enabled.
      if (undef('useFsEvents')) opts.useFsEvents = !opts.usePolling;
    
      // If we can't use fsevents, ensure the options reflect it's disabled.
      if (!FsEventsHandler.canUse()) opts.useFsEvents = false;
    
      // Use polling on Mac if not using fsevents.
      // Other platforms use non-polling fs.watch.
      if (undef('usePolling') && !opts.useFsEvents) {
        opts.usePolling = process.platform === 'darwin';
      }
    
      // Editor atomic write normalization enabled by default with fs.watch
      if (undef('atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;
      if (opts.atomic) this._pendingUnlinks = Object.create(null);
    
      if (undef('followSymlinks')) opts.followSymlinks = true;
    
      this._isntIgnored = function(path, stat) {
        return !this._isIgnored(path, stat);
      }.bind(this);
    
      var readyCalls = 0;
      this._emitReady = function() {
        if (++readyCalls >= this._readyCount) {
          this._emitReady = Function.prototype;
          // use process.nextTick to allow time for listener to be bound
          process.nextTick(this.emit.bind(this, 'ready'));
        }
      }.bind(this);
    
      this.options = opts;
    
      // You’re frozen when your heart’s not open.
      Object.freeze(opts);
    }
    
    FSWatcher.prototype = Object.create(EventEmitter.prototype);
    
    // Common helpers
    // --------------
    
    // Private method: Normalize and emit events
    //
    // * event     - string, type of event
    // * path      - string, file or directory path
    // * val[1..3] - arguments to be passed with event
    //
    // Returns the error if defined, otherwise the value of the
    // FSWatcher instance's `closed` flag
    FSWatcher.prototype._emit = function(event, path, val1, val2, val3) {
      if (this.options.cwd) path = sysPath.relative(this.options.cwd, path);
      var args = [event, path];
      if (val3 !== undefined) args.push(val1, val2, val3);
      else if (val2 !== undefined) args.push(val1, val2);
      else if (val1 !== undefined) args.push(val1);
      if (this.options.atomic) {
        if (event === 'unlink') {
          this._pendingUnlinks[path] = args;
          setTimeout(function() {
            Object.keys(this._pendingUnlinks).forEach(function(path) {
              this.emit.apply(this, this._pendingUnlinks[path]);
              this.emit.apply(this, ['all'].concat(this._pendingUnlinks[path]));
              delete this._pendingUnlinks[path];
            }.bind(this));
          }.bind(this), 100);
          return this;
        } else if (event === 'add' && this._pendingUnlinks[path]) {
          event = args[0] = 'change';
          delete this._pendingUnlinks[path];
        }
      }
    
      if (event === 'change') {
        if (!this._throttle('change', path, 50)) return this;
      }
    
      var emitEvent = function() {
        this.emit.apply(this, args);
        if (event !== 'error') this.emit.apply(this, ['all'].concat(args));
      }.bind(this);
    
      if (
        this.options.alwaysStat && val1 === undefined &&
        (event === 'add' || event === 'addDir' || event === 'change')
      ) {
        fs.stat(path, function(error, stats) {
          args.push(stats);
          emitEvent();
        });
      } else {
        emitEvent();
      }
    
      return this;
    };
    
    // Private method: Common handler for errors
    //
    // * error  - object, Error instance
    //
    // Returns the error if defined, otherwise the value of the
    // FSWatcher instance's `closed` flag
    FSWatcher.prototype._handleError = function(error) {
      var code = error && error.code;
      var ipe = this.options.ignorePermissionErrors;
      if (error &&
        code !== 'ENOENT' &&
        code !== 'ENOTDIR' &&
        (!ipe || (code !== 'EPERM' && code !== 'EACCES'))
      ) this.emit('error', error);
      return error || this.closed;
    };
    
    // Private method: Helper utility for throttling
    //
    // * action  - string, type of action being throttled
    // * path    - string, path being acted upon
    // * timeout - int, duration of time to suppress duplicate actions
    //
    // Returns throttle tracking object or false if action should be suppressed
    FSWatcher.prototype._throttle = function(action, path, timeout) {
      if (!(action in this._throttled)) {
        this._throttled[action] = Object.create(null);
      }
      var throttled = this._throttled[action];
      if (path in throttled) return false;
      function clear() {
        delete throttled[path];
        clearTimeout(timeoutObject);
      }
      var timeoutObject = setTimeout(clear, timeout);
      throttled[path] = {timeoutObject: timeoutObject, clear: clear};
      return throttled[path];
    };
    
    // Private method: Determines whether user has asked to ignore this path
    //
    // * path  - string, path to file or directory
    // * stats - object, result of fs.stat
    //
    // Returns boolean
    FSWatcher.prototype._isIgnored = function(path, stats) {
      if (
        this.options.atomic &&
        /\..*\.(sw[px])$|\~$|\.subl.*\.tmp/.test(path)
      ) return true;
    
      // create the anymatch fn if it doesn't already exist
      this._userIgnored = this._userIgnored || anymatch(this._globIgnored
        .concat(this.options.ignored)
        .concat(arrify(this.options.ignored)
          .filter(function(path) {
            return typeof path === 'string' && !isglob(path);
          }).map(function(path) {
            return path + '/**/*';
          })
        )
      );
    
      return this._userIgnored([path, stats]);
    };
    
    // Private method: Provides a set of common helpers and properties relating to
    // symlink and glob handling
    //
    // * path - string, file, directory, or glob pattern being watched
    // * depth - int, at any depth > 0, this isn't a glob
    //
    // Returns object containing helpers for this path
    FSWatcher.prototype._getWatchHelpers = function(path, depth) {
      path = path.replace(/^\.[\/\\]/, '');
      var watchPath = depth ? path : globparent(path);
      var hasGlob = watchPath !== path;
      var globFilter = hasGlob ? anymatch(path) : false;
    
      var entryPath = function(entry) {
        return sysPath.join(watchPath, sysPath.relative(watchPath, entry.fullPath));
      }
    
      var filterPath = function(entry) {
        return (!hasGlob || globFilter(entryPath(entry))) &&
          this._isntIgnored(entryPath(entry), entry.stat) &&
          (this.options.ignorePermissionErrors ||
            this._hasReadPermissions(entry.stat));
      }.bind(this);
    
      var getDirParts = function(path) {
        if (!hasGlob) return false;
        var parts = sysPath.relative(watchPath, path).split(/[\/\\]/);
        return parts;
      }
      var dirParts = getDirParts(path);
      if (dirParts && dirParts.length > 1) dirParts.pop();
    
      var filterDir = function(entry) {
        if (hasGlob) {
          var entryParts = getDirParts(entry.fullPath);
          var globstar = false;
          var unmatchedGlob = !dirParts.every(function(part, i) {
            if (part === '**') globstar = true;
            return globstar || !entryParts[i] || anymatch(part, entryParts[i]);
          });
        }
        return !unmatchedGlob && this._isntIgnored(entryPath(entry), entry.stat);
      }.bind(this);
    
      return {
        followSymlinks: this.options.followSymlinks,
        statMethod: this.options.followSymlinks ? 'stat' : 'lstat',
        path: path,
        watchPath: watchPath,
        entryPath: entryPath,
        hasGlob: hasGlob,
        globFilter: globFilter,
        filterPath: filterPath,
        filterDir: filterDir
      };
    }
    
    // Directory helpers
    // -----------------
    
    // Private method: Provides directory tracking objects
    //
    // * directory - string, path of the directory
    //
    // Returns the directory's tracking object
    FSWatcher.prototype._getWatchedDir = function(directory) {
      var dir = sysPath.resolve(directory);
      var watcherRemove = this._remove.bind(this);
      if (!(dir in this._watched)) this._watched[dir] = {
        _items: Object.create(null),
        add: function(item) {this._items[item] = true;},
        remove: function(item) {
          delete this._items[item];
          if (!this.children().length) {
            fs.readdir(dir, function(err) {
              if (err) watcherRemove(sysPath.dirname(dir), sysPath.basename(dir));
            });
          }
        },
        has: function(item) {return item in this._items;},
        children: function() {return Object.keys(this._items);}
      };
      return this._watched[dir];
    };
    
    // File helpers
    // ------------
    
    // Private method: Check for read permissions
    // Based on this answer on SO: http://stackoverflow.com/a/11781404/1358405
    //
    // * stats - object, result of fs.stat
    //
    // Returns boolean
    FSWatcher.prototype._hasReadPermissions = function(stats) {
      return Boolean(4 & parseInt(((stats && stats.mode) & 0x1ff).toString(8)[0], 10));
    };
    
    // Private method: Handles emitting unlink events for
    // files and directories, and via recursion, for
    // files and directories within directories that are unlinked
    //
    // * directory - string, directory within which the following item is located
    // * item      - string, base path of item/directory
    //
    // Returns nothing
    FSWatcher.prototype._remove = function(directory, item) {
      // if what is being deleted is a directory, get that directory's paths
      // for recursive deleting and cleaning of watched object
      // if it is not a directory, nestedDirectoryChildren will be empty array
      var path = sysPath.join(directory, item);
      var fullPath = sysPath.resolve(path);
      var isDirectory = this._watched[path] || this._watched[fullPath];
    
      // prevent duplicate handling in case of arriving here nearly simultaneously
      // via multiple paths (such as _handleFile and _handleDir)
      if (!this._throttle('remove', path, 100)) return;
    
      // if the only watched file is removed, watch for its return
      var watchedDirs = Object.keys(this._watched);
      if (!isDirectory && !this.options.useFsEvents && watchedDirs.length === 1) {
        this.add(directory, item, true);
      }
    
      // This will create a new entry in the watched object in either case
      // so we got to do the directory check beforehand
      var nestedDirectoryChildren = this._getWatchedDir(path).children();
    
      // Recursively remove children directories / files.
      nestedDirectoryChildren.forEach(function(nestedItem) {
        this._remove(path, nestedItem);
      }, this);
    
      // Check if item was on the watched list and remove it
      var parent = this._getWatchedDir(directory);
      var wasTracked = parent.has(item);
      parent.remove(item);
    
      // The Entry will either be a directory that just got removed
      // or a bogus entry to a file, in either case we have to remove it
      delete this._watched[path];
      delete this._watched[fullPath];
      var eventName = isDirectory ? 'unlinkDir' : 'unlink';
      if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);
    };
    
    // Public method: Adds paths to be watched on an existing FSWatcher instance
    
    // * paths     - string or array of strings, file/directory paths and/or globs
    // * _origAdd  - private boolean, for handling non-existent paths to be watched
    // * _internal - private boolean, indicates a non-user add
    
    // Returns an instance of FSWatcher for chaining.
    FSWatcher.prototype.add = function(paths, _origAdd, _internal) {
      this.closed = false;
      paths = arrify(paths);
    
      if (this.options.cwd) paths = paths.map(function(path) {
        return sysPath.join(this.options.cwd, path);
      }, this);
    
      // set aside negated glob strings
      paths = paths.filter(function(path) {
        if (path[0] === '!') this._ignoredPaths[path.substring(1)] = true;
        else {
          // if a path is being added that was previously ignored, stop ignoring it
          delete this._ignoredPaths[path];
          delete this._ignoredPaths[path + '/**/*'];
    
          // reset the cached userIgnored anymatch fn
          // to make ignoredPaths changes effective
          this._userIgnored = null;
    
          return true;
        }
      }, this);
    
      if (this.options.useFsEvents && FsEventsHandler.canUse()) {
        if (!this._readyCount) this._readyCount = paths.length;
        if (this.options.persistent) this._readyCount *= 2;
        paths.forEach(this._addToFsEvents, this);
      } else {
        if (!this._readyCount) this._readyCount = 0;
        this._readyCount += paths.length;
        each(paths, function(path, next) {
          this._addToNodeFs(path, !_internal, 0, 0, _origAdd, function(err, res) {
            if (res) this._emitReady();
            next(err, res);
          }.bind(this));
        }.bind(this), function(error, results) {
          results.forEach(function(item){
            if (!item) return;
            this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
          }, this);
        }.bind(this));
      }
    
      return this;
    };
    
    // Public method: Close watchers or start ignoring events from specified paths.
    
    // * paths     - string or array of strings, file/directory paths and/or globs
    
    // Returns instance of FSWatcher for chaining.
    FSWatcher.prototype.unwatch = function(paths) {
      if (this.closed) return this;
      paths = arrify(paths);
    
      paths.forEach(function(path) {
        if (this._closers[path]) {
          this._closers[path]();
        } else {
          this._ignoredPaths[path] = true;
          if (path in this._watched) this._ignoredPaths[path + '/**/*'] = true;
    
          // reset the cached userIgnored anymatch fn
          // to make ignoredPaths changes effective
          this._userIgnored = null;
        }
      }, this);
    
      return this;
    };
    
    // Public method: Close watchers and remove all listeners from watched paths.
    
    // Returns instance of FSWatcher for chaining.
    FSWatcher.prototype.close = function() {
      if (this.closed) return this;
    
      this.closed = true;
      Object.keys(this._closers).forEach(function(watchPath) {
        this._closers[watchPath]();
        delete this._closers[watchPath];
      }, this);
      this._watched = Object.create(null);
    
      this.removeAllListeners();
      return this;
    };
    
    // Attach watch handler prototype methods
    function importHandler(handler) {
      Object.keys(handler.prototype).forEach(function(method) {
        FSWatcher.prototype[method] = handler.prototype[method];
      });
    }
    importHandler(NodeFsHandler);
    if (FsEventsHandler.canUse()) importHandler(FsEventsHandler);
    
    // Export FSWatcher class
    exports.FSWatcher = FSWatcher;
    
    // Public function: Instantiates watcher with paths to be tracked.
    
    // * paths     - string or array of strings, file/directory paths and/or globs
    // * options   - object, chokidar options
    
    // Returns an instance of FSWatcher for chaining.
    exports.watch = function(paths, options) {
      return new FSWatcher(options).add(paths);
    };
    
  provide("chokidar", module.exports);
}(global));

// pakmanager:app-root-path/lib/resolve.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    module.exports = function resolve(dirname) {
    	var path = require('path');
    
    	// Check for environmental variable
    	if (process.env.APP_ROOT_PATH) {
    		return path.resolve(process.env.APP_ROOT_PATH);
    	}
    
    	var globalPaths = require('module').globalPaths;
    	var resolved = path.resolve(dirname);
    	var alternateMethod = false;
    	var appRootPath = null;
    
    	// Make sure that we're not loaded from a global include path
    	// Eg. $HOME/.node_modules
    	//     $HOME/.node_libraries
    	//     $PREFIX/lib/node
    	globalPaths.forEach(function(globalPath) {
    		if (!alternateMethod && 0 === resolved.indexOf(globalPath)) {
    			alternateMethod = true;
    		}
    	});
    
    	// If the app-root-path library isn't loaded globally, 
    	// and node_modules exists in the path, just split __dirname
    	var nodeModulesDir = path.sep + 'node_modules';
    	if (!alternateMethod && -1 !== resolved.indexOf(nodeModulesDir)) {
    		var parts = resolved.split(nodeModulesDir);
    		if (parts.length) {
    			appRootPath = parts[0];
    			parts = null;
    		}
    	}
    
    	// If the above didn't work, or this module is loaded globally, then
    	// resort to require.main.filename (See http://nodejs.org/api/modules.html)
    	if (alternateMethod || null == appRootPath) {
    		appRootPath = path.dirname(require.main.filename);
    	}
    
    	// Return
    	return appRootPath;
    };
  provide("app-root-path/lib/resolve.js", module.exports);
}(global));

// pakmanager:app-root-path/lib/app-root-path.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    module.exports = function(dirname) {
    	var path = require('path');
    	var resolve =  require('app-root-path/lib/resolve.js');
    	var appRootPath = resolve(dirname);
    
    	var publicInterface = {
    		resolve: function(pathToModule) {
    			return path.join(appRootPath, pathToModule);
    		},
    
    		require: function(pathToModule) {
    			// Backwards compatibility check
    			if ('function' === typeof pathToModule) {
    				console.warn('Just use appRootPath.require() -- no need to pass in your ' +
    							 'modules\'s require() function any more.');
    				return function(pathToModule) {
    					return publicInterface.require(pathToModule);
    				}
    			}
    
    			return require(publicInterface.resolve(pathToModule));
    		},
    
    		toString: function() {
    			return appRootPath;
    		},
    
    		setPath: function(explicitlySetPath) {
    			appRootPath = path.resolve(explicitlySetPath);
    		},
    
    		path: appRootPath
    	};
    
    	return publicInterface;
    };
  provide("app-root-path/lib/app-root-path.js", module.exports);
}(global));

// pakmanager:app-root-path
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var lib =  require('app-root-path/lib/app-root-path.js');
    module.exports = lib(__dirname);
  provide("app-root-path", module.exports);
}(global));

// pakmanager:body-parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * body-parser
     * Copyright(c) 2014 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    /**
     * Module dependencies.
     */
    
    var deprecate = require('depd')('body-parser')
    var fs = require('fs')
    var path = require('path')
    
    /**
     * @typedef Parsers
     * @type {function}
     * @property {function} json
     * @property {function} raw
     * @property {function} text
     * @property {function} urlencoded
     */
    
    /**
     * Module exports.
     * @type {Parsers}
     */
    
    exports = module.exports = deprecate.function(bodyParser,
      'bodyParser: use individual json/urlencoded middlewares')
    
    /**
     * Path to the parser modules.
     */
    
    var parsersDir = path.join(__dirname, 'lib', 'types')
    
    /**
     * Auto-load bundled parsers with getters.
     */
    
    fs.readdirSync(parsersDir).forEach(function onfilename(filename) {
      if (!/\.js$/.test(filename)) return
    
      var loc = path.resolve(parsersDir, filename)
      var mod
      var name = path.basename(filename, '.js')
    
      function load() {
        if (mod) {
          return mod
        }
    
        return mod = require(loc)
      }
    
      Object.defineProperty(exports, name, {
        configurable: true,
        enumerable: true,
        get: load
      })
    })
    
    /**
     * Create a middleware to parse json and urlencoded bodies.
     *
     * @param {object} [options]
     * @return {function}
     * @deprecated
     * @api public
     */
    
    function bodyParser(options){
      var opts = {}
    
      options = options || {}
    
      // exclude type option
      for (var prop in options) {
        if ('type' !== prop) {
          opts[prop] = options[prop]
        }
      }
    
      var _urlencoded = exports.urlencoded(opts)
      var _json = exports.json(opts)
    
      return function bodyParser(req, res, next) {
        _json(req, res, function(err){
          if (err) return next(err);
          _urlencoded(req, res, next);
        });
      }
    }
    
  provide("body-parser", module.exports);
}(global));

// pakmanager:cookie-parser/lib/parse
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var signature = require('cookie-signature');
    
    /**
     * Parse signed cookies, returning an object
     * containing the decoded key/value pairs,
     * while removing the signed key from `obj`.
     *
     * @param {Object} obj
     * @return {Object}
     * @api private
     */
    
    exports.signedCookies = function(obj, secret){
      var cookies = Object.keys(obj);
      var dec;
      var key;
      var ret = Object.create(null);
      var val;
    
      for (var i = 0; i < cookies.length; i++) {
        key = cookies[i];
        val = obj[key];
        dec = exports.signedCookie(val, secret);
    
        if (val !== dec) {
          ret[key] = dec;
          delete obj[key];
        }
      }
    
      return ret;
    };
    
    /**
     * Parse a signed cookie string, return the decoded value
     *
     * @param {String} str signed cookie string
     * @param {String} secret
     * @return {String} decoded value
     * @api private
     */
    
    exports.signedCookie = function(str, secret){
      return str.substr(0, 2) === 's:'
        ? signature.unsign(str.slice(2), secret)
        : str;
    };
    
    /**
     * Parse JSON cookies.
     *
     * @param {Object} obj
     * @return {Object}
     * @api private
     */
    
    exports.JSONCookies = function(obj){
      var cookies = Object.keys(obj);
      var key;
      var val;
    
      for (var i = 0; i < cookies.length; i++) {
        key = cookies[i];
        val = exports.JSONCookie(obj[key]);
    
        if (val) {
          obj[key] = val;
        }
      }
    
      return obj;
    };
    
    /**
     * Parse JSON cookie string
     *
     * @param {String} str
     * @return {Object} Parsed object or null if not json cookie
     * @api private
     */
    
    exports.JSONCookie = function(str) {
      if (!str || str.substr(0, 2) !== 'j:') return;
    
      try {
        return JSON.parse(str.slice(2));
      } catch (err) {
        // no op
      }
    };
    
  provide("cookie-parser/lib/parse", module.exports);
}(global));

// pakmanager:cookie-parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * cookie-parser
     * MIT Licensed
     */
    
    /**
     * Module dependencies.
     */
    
    var cookie = require('cookie');
    var parse =  require('cookie-parser/lib/parse');
    
    /**
     * Parse Cookie header and populate `req.cookies`
     * with an object keyed by the cookie names.
     *
     * @param {String} [secret]
     * @param {Object} [options]
     * @return {Function}
     * @api public
     */
    
    exports = module.exports = function cookieParser(secret, options){
      return function cookieParser(req, res, next) {
        if (req.cookies) return next();
        var cookies = req.headers.cookie;
    
        req.secret = secret;
        req.cookies = Object.create(null);
        req.signedCookies = Object.create(null);
    
        // no cookies
        if (!cookies) {
          return next();
        }
    
        req.cookies = cookie.parse(cookies, options);
    
        // parse signed cookies
        if (secret) {
          req.signedCookies = parse.signedCookies(req.cookies, secret);
          req.signedCookies = parse.JSONCookies(req.signedCookies);
        }
    
        // parse JSON cookies
        req.cookies = parse.JSONCookies(req.cookies);
    
        next();
      };
    };
    
    /**
     * Export parsing functions.
     */
    
    exports.JSONCookie = parse.JSONCookie;
    exports.JSONCookies = parse.JSONCookies;
    exports.signedCookie = parse.signedCookie;
    exports.signedCookies = parse.signedCookies;
    
  provide("cookie-parser", module.exports);
}(global));

// pakmanager:express/lib/router/layer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var pathRegexp = require('path-to-regexp');
    var debug = require('debug')('express:router:layer');
    
    /**
     * Module variables.
     */
    
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    
    /**
     * Expose `Layer`.
     */
    
    module.exports = Layer;
    
    function Layer(path, options, fn) {
      if (!(this instanceof Layer)) {
        return new Layer(path, options, fn);
      }
    
      debug('new %s', path);
      options = options || {};
    
      this.handle = fn;
      this.name = fn.name || '<anonymous>';
      this.params = undefined;
      this.path = undefined;
      this.regexp = pathRegexp(path, this.keys = [], options);
    
      if (path === '/' && options.end === false) {
        this.regexp.fast_slash = true;
      }
    }
    
    /**
     * Handle the error for the layer.
     *
     * @param {Error} error
     * @param {Request} req
     * @param {Response} res
     * @param {function} next
     * @api private
     */
    
    Layer.prototype.handle_error = function handle_error(error, req, res, next) {
      var fn = this.handle;
    
      if (fn.length !== 4) {
        // not a standard error handler
        return next(error);
      }
    
      try {
        fn(error, req, res, next);
      } catch (err) {
        next(err);
      }
    };
    
    /**
     * Handle the request for the layer.
     *
     * @param {Request} req
     * @param {Response} res
     * @param {function} next
     * @api private
     */
    
    Layer.prototype.handle_request = function handle(req, res, next) {
      var fn = this.handle;
    
      if (fn.length > 3) {
        // not a standard request handler
        return next();
      }
    
      try {
        fn(req, res, next);
      } catch (err) {
        next(err);
      }
    };
    
    /**
     * Check if this route matches `path`, if so
     * populate `.params`.
     *
     * @param {String} path
     * @return {Boolean}
     * @api private
     */
    
    Layer.prototype.match = function match(path) {
      if (path == null) {
        // no path, nothing matches
        this.params = undefined;
        this.path = undefined;
        return false;
      }
    
      if (this.regexp.fast_slash) {
        // fast path non-ending match for / (everything matches)
        this.params = {};
        this.path = '';
        return true;
      }
    
      var m = this.regexp.exec(path);
    
      if (!m) {
        this.params = undefined;
        this.path = undefined;
        return false;
      }
    
      // store values
      this.params = {};
      this.path = m[0];
    
      var keys = this.keys;
      var params = this.params;
      var prop;
      var n = 0;
      var key;
      var val;
    
      for (var i = 1, len = m.length; i < len; ++i) {
        key = keys[i - 1];
        prop = key
          ? key.name
          : n++;
        val = decode_param(m[i]);
    
        if (val !== undefined || !(hasOwnProperty.call(params, prop))) {
          params[prop] = val;
        }
      }
    
      return true;
    };
    
    /**
     * Decode param value.
     *
     * @param {string} val
     * @return {string}
     * @api private
     */
    
    function decode_param(val){
      if (typeof val !== 'string') {
        return val;
      }
    
      try {
        return decodeURIComponent(val);
      } catch (e) {
        var err = new TypeError("Failed to decode param '" + val + "'");
        err.status = 400;
        throw err;
      }
    }
    
  provide("express/lib/router/layer", module.exports);
}(global));

// pakmanager:express/lib/utils
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * express
     * Copyright(c) 2009-2013 TJ Holowaychuk
     * Copyright(c) 2014-2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    /**
     * Module dependencies.
     * @api private
     */
    
    var contentDisposition = require('content-disposition');
    var contentType = require('content-type');
    var deprecate = require('depd')('express');
    var mime = require('send').mime;
    var basename = require('path').basename;
    var etag = require('etag');
    var proxyaddr = require('proxy-addr');
    var qs = require('qs');
    var querystring = require('querystring');
    
    /**
     * Return strong ETag for `body`.
     *
     * @param {String|Buffer} body
     * @param {String} [encoding]
     * @return {String}
     * @api private
     */
    
    exports.etag = function (body, encoding) {
      var buf = !Buffer.isBuffer(body)
        ? new Buffer(body, encoding)
        : body;
    
      return etag(buf, {weak: false});
    };
    
    /**
     * Return weak ETag for `body`.
     *
     * @param {String|Buffer} body
     * @param {String} [encoding]
     * @return {String}
     * @api private
     */
    
    exports.wetag = function wetag(body, encoding){
      var buf = !Buffer.isBuffer(body)
        ? new Buffer(body, encoding)
        : body;
    
      return etag(buf, {weak: true});
    };
    
    /**
     * Check if `path` looks absolute.
     *
     * @param {String} path
     * @return {Boolean}
     * @api private
     */
    
    exports.isAbsolute = function(path){
      if ('/' == path[0]) return true;
      if (':' == path[1] && '\\' == path[2]) return true;
      if ('\\\\' == path.substring(0, 2)) return true; // Microsoft Azure absolute path
    };
    
    /**
     * Flatten the given `arr`.
     *
     * @param {Array} arr
     * @return {Array}
     * @api private
     */
    
    exports.flatten = function(arr, ret){
      ret = ret || [];
      var len = arr.length;
      for (var i = 0; i < len; ++i) {
        if (Array.isArray(arr[i])) {
          exports.flatten(arr[i], ret);
        } else {
          ret.push(arr[i]);
        }
      }
      return ret;
    };
    
    /**
     * Normalize the given `type`, for example "html" becomes "text/html".
     *
     * @param {String} type
     * @return {Object}
     * @api private
     */
    
    exports.normalizeType = function(type){
      return ~type.indexOf('/')
        ? acceptParams(type)
        : { value: mime.lookup(type), params: {} };
    };
    
    /**
     * Normalize `types`, for example "html" becomes "text/html".
     *
     * @param {Array} types
     * @return {Array}
     * @api private
     */
    
    exports.normalizeTypes = function(types){
      var ret = [];
    
      for (var i = 0; i < types.length; ++i) {
        ret.push(exports.normalizeType(types[i]));
      }
    
      return ret;
    };
    
    /**
     * Generate Content-Disposition header appropriate for the filename.
     * non-ascii filenames are urlencoded and a filename* parameter is added
     *
     * @param {String} filename
     * @return {String}
     * @api private
     */
    
    exports.contentDisposition = deprecate.function(contentDisposition,
      'utils.contentDisposition: use content-disposition npm module instead');
    
    /**
     * Parse accept params `str` returning an
     * object with `.value`, `.quality` and `.params`.
     * also includes `.originalIndex` for stable sorting
     *
     * @param {String} str
     * @return {Object}
     * @api private
     */
    
    function acceptParams(str, index) {
      var parts = str.split(/ *; */);
      var ret = { value: parts[0], quality: 1, params: {}, originalIndex: index };
    
      for (var i = 1; i < parts.length; ++i) {
        var pms = parts[i].split(/ *= */);
        if ('q' == pms[0]) {
          ret.quality = parseFloat(pms[1]);
        } else {
          ret.params[pms[0]] = pms[1];
        }
      }
    
      return ret;
    }
    
    /**
     * Compile "etag" value to function.
     *
     * @param  {Boolean|String|Function} val
     * @return {Function}
     * @api private
     */
    
    exports.compileETag = function(val) {
      var fn;
    
      if (typeof val === 'function') {
        return val;
      }
    
      switch (val) {
        case true:
          fn = exports.wetag;
          break;
        case false:
          break;
        case 'strong':
          fn = exports.etag;
          break;
        case 'weak':
          fn = exports.wetag;
          break;
        default:
          throw new TypeError('unknown value for etag function: ' + val);
      }
    
      return fn;
    }
    
    /**
     * Compile "query parser" value to function.
     *
     * @param  {String|Function} val
     * @return {Function}
     * @api private
     */
    
    exports.compileQueryParser = function compileQueryParser(val) {
      var fn;
    
      if (typeof val === 'function') {
        return val;
      }
    
      switch (val) {
        case true:
          fn = querystring.parse;
          break;
        case false:
          fn = newObject;
          break;
        case 'extended':
          fn = qs.parse;
          break;
        case 'simple':
          fn = querystring.parse;
          break;
        default:
          throw new TypeError('unknown value for query parser function: ' + val);
      }
    
      return fn;
    }
    
    /**
     * Compile "proxy trust" value to function.
     *
     * @param  {Boolean|String|Number|Array|Function} val
     * @return {Function}
     * @api private
     */
    
    exports.compileTrust = function(val) {
      if (typeof val === 'function') return val;
    
      if (val === true) {
        // Support plain true/false
        return function(){ return true };
      }
    
      if (typeof val === 'number') {
        // Support trusting hop count
        return function(a, i){ return i < val };
      }
    
      if (typeof val === 'string') {
        // Support comma-separated values
        val = val.split(/ *, */);
      }
    
      return proxyaddr.compile(val || []);
    }
    
    /**
     * Set the charset in a given Content-Type string.
     *
     * @param {String} type
     * @param {String} charset
     * @return {String}
     * @api private
     */
    
    exports.setCharset = function setCharset(type, charset) {
      if (!type || !charset) {
        return type;
      }
    
      // parse type
      var parsed = contentType.parse(type);
    
      // set charset
      parsed.parameters.charset = charset;
    
      // format type
      return contentType.format(parsed);
    };
    
    /**
     * Return new empty object.
     *
     * @return {Object}
     * @api private
     */
    
    function newObject() {
      return {};
    }
    
  provide("express/lib/utils", module.exports);
}(global));

// pakmanager:express/lib/router/route
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var debug = require('debug')('express:router:route');
    var Layer =  require('express/lib/router/layer');
    var methods = require('methods');
    var utils =  require('express/lib/utils');
    
    /**
     * Expose `Route`.
     */
    
    module.exports = Route;
    
    /**
     * Initialize `Route` with the given `path`,
     *
     * @param {String} path
     * @api private
     */
    
    function Route(path) {
      debug('new %s', path);
      this.path = path;
      this.stack = [];
    
      // route handlers for various http methods
      this.methods = {};
    }
    
    /**
     * @api private
     */
    
    Route.prototype._handles_method = function _handles_method(method) {
      if (this.methods._all) {
        return true;
      }
    
      method = method.toLowerCase();
    
      if (method === 'head' && !this.methods['head']) {
        method = 'get';
      }
    
      return Boolean(this.methods[method]);
    };
    
    /**
     * @return {Array} supported HTTP methods
     * @api private
     */
    
    Route.prototype._options = function _options() {
      var methods = Object.keys(this.methods);
    
      // append automatic head
      if (this.methods.get && !this.methods.head) {
        methods.push('head');
      }
    
      for (var i = 0; i < methods.length; i++) {
        // make upper case
        methods[i] = methods[i].toUpperCase();
      }
    
      return methods;
    };
    
    /**
     * dispatch req, res into this route
     *
     * @api private
     */
    
    Route.prototype.dispatch = function(req, res, done){
      var idx = 0;
      var stack = this.stack;
      if (stack.length === 0) {
        return done();
      }
    
      var method = req.method.toLowerCase();
      if (method === 'head' && !this.methods['head']) {
        method = 'get';
      }
    
      req.route = this;
    
      next();
    
      function next(err) {
        if (err && err === 'route') {
          return done();
        }
    
        var layer = stack[idx++];
        if (!layer) {
          return done(err);
        }
    
        if (layer.method && layer.method !== method) {
          return next(err);
        }
    
        if (err) {
          layer.handle_error(err, req, res, next);
        } else {
          layer.handle_request(req, res, next);
        }
      }
    };
    
    /**
     * Add a handler for all HTTP verbs to this route.
     *
     * Behaves just like middleware and can respond or call `next`
     * to continue processing.
     *
     * You can use multiple `.all` call to add multiple handlers.
     *
     *   function check_something(req, res, next){
     *     next();
     *   };
     *
     *   function validate_user(req, res, next){
     *     next();
     *   };
     *
     *   route
     *   .all(validate_user)
     *   .all(check_something)
     *   .get(function(req, res, next){
     *     res.send('hello world');
     *   });
     *
     * @param {function} handler
     * @return {Route} for chaining
     * @api public
     */
    
    Route.prototype.all = function(){
      var callbacks = utils.flatten([].slice.call(arguments));
      callbacks.forEach(function(fn) {
        if (typeof fn !== 'function') {
          var type = {}.toString.call(fn);
          var msg = 'Route.all() requires callback functions but got a ' + type;
          throw new Error(msg);
        }
    
        var layer = Layer('/', {}, fn);
        layer.method = undefined;
    
        this.methods._all = true;
        this.stack.push(layer);
      }, this);
    
      return this;
    };
    
    methods.forEach(function(method){
      Route.prototype[method] = function(){
        var callbacks = utils.flatten([].slice.call(arguments));
    
        callbacks.forEach(function(fn) {
          if (typeof fn !== 'function') {
            var type = {}.toString.call(fn);
            var msg = 'Route.' + method + '() requires callback functions but got a ' + type;
            throw new Error(msg);
          }
    
          debug('%s %s', method, this.path);
    
          var layer = Layer('/', {}, fn);
          layer.method = method;
    
          this.methods[method] = true;
          this.stack.push(layer);
        }, this);
        return this;
      };
    });
    
  provide("express/lib/router/route", module.exports);
}(global));

// pakmanager:express/lib/router
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Route =  require('express/lib/router/route');
    var Layer =  require('express/lib/router/layer');
    var methods = require('methods');
    var mixin = require('utils-merge');
    var debug = require('debug')('express:router');
    var deprecate = require('depd')('express');
    var parseUrl = require('parseurl');
    var utils =  require('express/lib/utils');
    
    /**
     * Module variables.
     */
    
    var objectRegExp = /^\[object (\S+)\]$/;
    var slice = Array.prototype.slice;
    var toString = Object.prototype.toString;
    
    /**
     * Initialize a new `Router` with the given `options`.
     *
     * @param {Object} options
     * @return {Router} which is an callable function
     * @api public
     */
    
    var proto = module.exports = function(options) {
      options = options || {};
    
      function router(req, res, next) {
        router.handle(req, res, next);
      }
    
      // mixin Router class functions
      router.__proto__ = proto;
    
      router.params = {};
      router._params = [];
      router.caseSensitive = options.caseSensitive;
      router.mergeParams = options.mergeParams;
      router.strict = options.strict;
      router.stack = [];
    
      return router;
    };
    
    /**
     * Map the given param placeholder `name`(s) to the given callback.
     *
     * Parameter mapping is used to provide pre-conditions to routes
     * which use normalized placeholders. For example a _:user_id_ parameter
     * could automatically load a user's information from the database without
     * any additional code,
     *
     * The callback uses the same signature as middleware, the only difference
     * being that the value of the placeholder is passed, in this case the _id_
     * of the user. Once the `next()` function is invoked, just like middleware
     * it will continue on to execute the route, or subsequent parameter functions.
     *
     * Just like in middleware, you must either respond to the request or call next
     * to avoid stalling the request.
     *
     *  app.param('user_id', function(req, res, next, id){
     *    User.find(id, function(err, user){
     *      if (err) {
     *        return next(err);
     *      } else if (!user) {
     *        return next(new Error('failed to load user'));
     *      }
     *      req.user = user;
     *      next();
     *    });
     *  });
     *
     * @param {String} name
     * @param {Function} fn
     * @return {app} for chaining
     * @api public
     */
    
    proto.param = function param(name, fn) {
      // param logic
      if (typeof name === 'function') {
        deprecate('router.param(fn): Refactor to use path params');
        this._params.push(name);
        return;
      }
    
      // apply param functions
      var params = this._params;
      var len = params.length;
      var ret;
    
      if (name[0] === ':') {
        deprecate('router.param(' + JSON.stringify(name) + ', fn): Use router.param(' + JSON.stringify(name.substr(1)) + ', fn) instead');
        name = name.substr(1);
      }
    
      for (var i = 0; i < len; ++i) {
        if (ret = params[i](name, fn)) {
          fn = ret;
        }
      }
    
      // ensure we end up with a
      // middleware function
      if ('function' != typeof fn) {
        throw new Error('invalid param() call for ' + name + ', got ' + fn);
      }
    
      (this.params[name] = this.params[name] || []).push(fn);
      return this;
    };
    
    /**
     * Dispatch a req, res into the router.
     *
     * @api private
     */
    
    proto.handle = function(req, res, done) {
      var self = this;
    
      debug('dispatching %s %s', req.method, req.url);
    
      var search = 1 + req.url.indexOf('?');
      var pathlength = search ? search - 1 : req.url.length;
      var fqdn = req.url[0] !== '/' && 1 + req.url.substr(0, pathlength).indexOf('://');
      var protohost = fqdn ? req.url.substr(0, req.url.indexOf('/', 2 + fqdn)) : '';
      var idx = 0;
      var removed = '';
      var slashAdded = false;
      var paramcalled = {};
    
      // store options for OPTIONS request
      // only used if OPTIONS request
      var options = [];
    
      // middleware and routes
      var stack = self.stack;
    
      // manage inter-router variables
      var parentParams = req.params;
      var parentUrl = req.baseUrl || '';
      done = restore(done, req, 'baseUrl', 'next', 'params');
    
      // setup next layer
      req.next = next;
    
      // for options requests, respond with a default if nothing else responds
      if (req.method === 'OPTIONS') {
        done = wrap(done, function(old, err) {
          if (err || options.length === 0) return old(err);
          sendOptionsResponse(res, options, old);
        });
      }
    
      // setup basic req values
      req.baseUrl = parentUrl;
      req.originalUrl = req.originalUrl || req.url;
    
      next();
    
      function next(err) {
        var layerError = err === 'route'
          ? null
          : err;
    
        // remove added slash
        if (slashAdded) {
          req.url = req.url.substr(1);
          slashAdded = false;
        }
    
        // restore altered req.url
        if (removed.length !== 0) {
          req.baseUrl = parentUrl;
          req.url = protohost + removed + req.url.substr(protohost.length);
          removed = '';
        }
    
        // no more matching layers
        if (idx >= stack.length) {
          setImmediate(done, layerError);
          return;
        }
    
        // get pathname of request
        var path = getPathname(req);
    
        if (path == null) {
          return done(layerError);
        }
    
        // find next matching layer
        var layer;
        var match;
        var route;
    
        while (match !== true && idx < stack.length) {
          layer = stack[idx++];
          match = matchLayer(layer, path);
          route = layer.route;
    
          if (typeof match !== 'boolean') {
            // hold on to layerError
            layerError = layerError || match;
          }
    
          if (match !== true) {
            continue;
          }
    
          if (!route) {
            // process non-route handlers normally
            continue;
          }
    
          if (layerError) {
            // routes do not match with a pending error
            match = false;
            continue;
          }
    
          var method = req.method;
          var has_method = route._handles_method(method);
    
          // build up automatic options response
          if (!has_method && method === 'OPTIONS') {
            appendMethods(options, route._options());
          }
    
          // don't even bother matching route
          if (!has_method && method !== 'HEAD') {
            match = false;
            continue;
          }
        }
    
        // no match
        if (match !== true) {
          return done(layerError);
        }
    
        // store route for dispatch on change
        if (route) {
          req.route = route;
        }
    
        // Capture one-time layer values
        req.params = self.mergeParams
          ? mergeParams(layer.params, parentParams)
          : layer.params;
        var layerPath = layer.path;
    
        // this should be done for the layer
        self.process_params(layer, paramcalled, req, res, function (err) {
          if (err) {
            return next(layerError || err);
          }
    
          if (route) {
            return layer.handle_request(req, res, next);
          }
    
          trim_prefix(layer, layerError, layerPath, path);
        });
      }
    
      function trim_prefix(layer, layerError, layerPath, path) {
        var c = path[layerPath.length];
        if (c && '/' !== c && '.' !== c) return next(layerError);
    
         // Trim off the part of the url that matches the route
         // middleware (.use stuff) needs to have the path stripped
        if (layerPath.length !== 0) {
          debug('trim prefix (%s) from url %s', layerPath, req.url);
          removed = layerPath;
          req.url = protohost + req.url.substr(protohost.length + removed.length);
    
          // Ensure leading slash
          if (!fqdn && req.url[0] !== '/') {
            req.url = '/' + req.url;
            slashAdded = true;
          }
    
          // Setup base URL (no trailing slash)
          req.baseUrl = parentUrl + (removed[removed.length - 1] === '/'
            ? removed.substring(0, removed.length - 1)
            : removed);
        }
    
        debug('%s %s : %s', layer.name, layerPath, req.originalUrl);
    
        if (layerError) {
          layer.handle_error(layerError, req, res, next);
        } else {
          layer.handle_request(req, res, next);
        }
      }
    };
    
    /**
     * Process any parameters for the layer.
     *
     * @api private
     */
    
    proto.process_params = function(layer, called, req, res, done) {
      var params = this.params;
    
      // captured parameters from the layer, keys and values
      var keys = layer.keys;
    
      // fast track
      if (!keys || keys.length === 0) {
        return done();
      }
    
      var i = 0;
      var name;
      var paramIndex = 0;
      var key;
      var paramVal;
      var paramCallbacks;
      var paramCalled;
    
      // process params in order
      // param callbacks can be async
      function param(err) {
        if (err) {
          return done(err);
        }
    
        if (i >= keys.length ) {
          return done();
        }
    
        paramIndex = 0;
        key = keys[i++];
    
        if (!key) {
          return done();
        }
    
        name = key.name;
        paramVal = req.params[name];
        paramCallbacks = params[name];
        paramCalled = called[name];
    
        if (paramVal === undefined || !paramCallbacks) {
          return param();
        }
    
        // param previously called with same value or error occurred
        if (paramCalled && (paramCalled.error || paramCalled.match === paramVal)) {
          // restore value
          req.params[name] = paramCalled.value;
    
          // next param
          return param(paramCalled.error);
        }
    
        called[name] = paramCalled = {
          error: null,
          match: paramVal,
          value: paramVal
        };
    
        paramCallback();
      }
    
      // single param callbacks
      function paramCallback(err) {
        var fn = paramCallbacks[paramIndex++];
    
        // store updated value
        paramCalled.value = req.params[key.name];
    
        if (err) {
          // store error
          paramCalled.error = err;
          param(err);
          return;
        }
    
        if (!fn) return param();
    
        try {
          fn(req, res, paramCallback, paramVal, key.name);
        } catch (e) {
          paramCallback(e);
        }
      }
    
      param();
    };
    
    /**
     * Use the given middleware function, with optional path, defaulting to "/".
     *
     * Use (like `.all`) will run for any http METHOD, but it will not add
     * handlers for those methods so OPTIONS requests will not consider `.use`
     * functions even if they could respond.
     *
     * The other difference is that _route_ path is stripped and not visible
     * to the handler function. The main effect of this feature is that mounted
     * handlers can operate without any code changes regardless of the "prefix"
     * pathname.
     *
     * @api public
     */
    
    proto.use = function use(fn) {
      var offset = 0;
      var path = '/';
    
      // default path to '/'
      // disambiguate router.use([fn])
      if (typeof fn !== 'function') {
        var arg = fn;
    
        while (Array.isArray(arg) && arg.length !== 0) {
          arg = arg[0];
        }
    
        // first arg is the path
        if (typeof arg !== 'function') {
          offset = 1;
          path = fn;
        }
      }
    
      var callbacks = utils.flatten(slice.call(arguments, offset));
    
      if (callbacks.length === 0) {
        throw new TypeError('Router.use() requires middleware functions');
      }
    
      callbacks.forEach(function (fn) {
        if (typeof fn !== 'function') {
          throw new TypeError('Router.use() requires middleware function but got a ' + gettype(fn));
        }
    
        // add the middleware
        debug('use %s %s', path, fn.name || '<anonymous>');
    
        var layer = new Layer(path, {
          sensitive: this.caseSensitive,
          strict: false,
          end: false
        }, fn);
    
        layer.route = undefined;
    
        this.stack.push(layer);
      }, this);
    
      return this;
    };
    
    /**
     * Create a new Route for the given path.
     *
     * Each route contains a separate middleware stack and VERB handlers.
     *
     * See the Route api documentation for details on adding handlers
     * and middleware to routes.
     *
     * @param {String} path
     * @return {Route}
     * @api public
     */
    
    proto.route = function(path){
      var route = new Route(path);
    
      var layer = new Layer(path, {
        sensitive: this.caseSensitive,
        strict: this.strict,
        end: true
      }, route.dispatch.bind(route));
    
      layer.route = route;
    
      this.stack.push(layer);
      return route;
    };
    
    // create Router#VERB functions
    methods.concat('all').forEach(function(method){
      proto[method] = function(path){
        var route = this.route(path)
        route[method].apply(route, slice.call(arguments, 1));
        return this;
      };
    });
    
    // append methods to a list of methods
    function appendMethods(list, addition) {
      for (var i = 0; i < addition.length; i++) {
        var method = addition[i];
        if (list.indexOf(method) === -1) {
          list.push(method);
        }
      }
    }
    
    // get pathname of request
    function getPathname(req) {
      try {
        return parseUrl(req).pathname;
      } catch (err) {
        return undefined;
      }
    }
    
    // get type for error message
    function gettype(obj) {
      var type = typeof obj;
    
      if (type !== 'object') {
        return type;
      }
    
      // inspect [[Class]] for objects
      return toString.call(obj)
        .replace(objectRegExp, '$1');
    }
    
    /**
     * Match path to a layer.
     *
     * @param {Layer} layer
     * @param {string} path
     * @private
     */
    
    function matchLayer(layer, path) {
      try {
        return layer.match(path);
      } catch (err) {
        return err;
      }
    }
    
    // merge params with parent params
    function mergeParams(params, parent) {
      if (typeof parent !== 'object' || !parent) {
        return params;
      }
    
      // make copy of parent for base
      var obj = mixin({}, parent);
    
      // simple non-numeric merging
      if (!(0 in params) || !(0 in parent)) {
        return mixin(obj, params);
      }
    
      var i = 0;
      var o = 0;
    
      // determine numeric gaps
      while (i === o || o in parent) {
        if (i in params) i++;
        if (o in parent) o++;
      }
    
      // offset numeric indices in params before merge
      for (i--; i >= 0; i--) {
        params[i + o] = params[i];
    
        // create holes for the merge when necessary
        if (i < o) {
          delete params[i];
        }
      }
    
      return mixin(parent, params);
    }
    
    // restore obj props after function
    function restore(fn, obj) {
      var props = new Array(arguments.length - 2);
      var vals = new Array(arguments.length - 2);
    
      for (var i = 0; i < props.length; i++) {
        props[i] = arguments[i + 2];
        vals[i] = obj[props[i]];
      }
    
      return function(err){
        // restore vals
        for (var i = 0; i < props.length; i++) {
          obj[props[i]] = vals[i];
        }
    
        return fn.apply(this, arguments);
      };
    }
    
    // send an OPTIONS response
    function sendOptionsResponse(res, options, next) {
      try {
        var body = options.join(',');
        res.set('Allow', body);
        res.send(body);
      } catch (err) {
        next(err);
      }
    }
    
    // wrap a function
    function wrap(old, fn) {
      return function proxy() {
        var args = new Array(arguments.length + 1);
    
        args[0] = old;
        for (var i = 0, len = arguments.length; i < len; i++) {
          args[i + 1] = arguments[i];
        }
    
        fn.apply(this, args);
      };
    }
    
  provide("express/lib/router", module.exports);
}(global));

// pakmanager:express/lib/middleware/init
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Initialization middleware, exposing the
     * request and response to each other, as well
     * as defaulting the X-Powered-By header field.
     *
     * @param {Function} app
     * @return {Function}
     * @api private
     */
    
    exports.init = function(app){
      return function expressInit(req, res, next){
        if (app.enabled('x-powered-by')) res.setHeader('X-Powered-By', 'Express');
        req.res = res;
        res.req = req;
        req.next = next;
    
        req.__proto__ = app.request;
        res.__proto__ = app.response;
    
        res.locals = res.locals || Object.create(null);
    
        next();
      };
    };
    
    
  provide("express/lib/middleware/init", module.exports);
}(global));

// pakmanager:express/lib/middleware/query
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var parseUrl = require('parseurl');
    var qs = require('qs');
    
    /**
     * @param {Object} options
     * @return {Function}
     * @api public
     */
    
    module.exports = function query(options) {
      var queryparse = qs.parse;
    
      if (typeof options === 'function') {
        queryparse = options;
        options = undefined;
      }
    
      return function query(req, res, next){
        if (!req.query) {
          var val = parseUrl(req).query;
          req.query = queryparse(val, options);
        }
    
        next();
      };
    };
    
  provide("express/lib/middleware/query", module.exports);
}(global));

// pakmanager:express/lib/view
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var debug = require('debug')('express:view');
    var path = require('path');
    var fs = require('fs');
    var utils =  require('express/lib/utils');
    
    /**
     * Module variables.
     * @private
     */
    
    var dirname = path.dirname;
    var basename = path.basename;
    var extname = path.extname;
    var join = path.join;
    var resolve = path.resolve;
    
    /**
     * Expose `View`.
     */
    
    module.exports = View;
    
    /**
     * Initialize a new `View` with the given `name`.
     *
     * Options:
     *
     *   - `defaultEngine` the default template engine name
     *   - `engines` template engine require() cache
     *   - `root` root path for view lookup
     *
     * @param {String} name
     * @param {Object} options
     * @api private
     */
    
    function View(name, options) {
      options = options || {};
      this.name = name;
      this.root = options.root;
      var engines = options.engines;
      this.defaultEngine = options.defaultEngine;
      var ext = this.ext = extname(name);
      if (!ext && !this.defaultEngine) throw new Error('No default engine was specified and no extension was provided.');
      if (!ext) name += (ext = this.ext = ('.' != this.defaultEngine[0] ? '.' : '') + this.defaultEngine);
      this.engine = engines[ext] || (engines[ext] = require(ext.slice(1)).__express);
      this.path = this.lookup(name);
    }
    
    /**
     * Lookup view by the given `name`
     *
     * @param {String} name
     * @return {String}
     * @api private
     */
    
    View.prototype.lookup = function lookup(name) {
      var path;
      var roots = [].concat(this.root);
    
      debug('lookup "%s"', name);
    
      for (var i = 0; i < roots.length && !path; i++) {
        var root = roots[i];
    
        // resolve the path
        var loc = resolve(root, name);
        var dir = dirname(loc);
        var file = basename(loc);
    
        // resolve the file
        path = this.resolve(dir, file);
      }
    
      return path;
    };
    
    /**
     * Render with the given `options` and callback `fn(err, str)`.
     *
     * @param {Object} options
     * @param {Function} fn
     * @api private
     */
    
    View.prototype.render = function render(options, fn) {
      debug('render "%s"', this.path);
      this.engine(this.path, options, fn);
    };
    
    /**
     * Resolve the file within the given directory.
     *
     * @param {string} dir
     * @param {string} file
     * @private
     */
    
    View.prototype.resolve = function resolve(dir, file) {
      var ext = this.ext;
      var path;
      var stat;
    
      // <path>.<ext>
      path = join(dir, file);
      stat = tryStat(path);
    
      if (stat && stat.isFile()) {
        return path;
      }
    
      // <path>/index.<ext>
      path = join(dir, basename(file, ext), 'index' + ext);
      stat = tryStat(path);
    
      if (stat && stat.isFile()) {
        return path;
      }
    };
    
    /**
     * Return a stat, maybe.
     *
     * @param {string} path
     * @return {fs.Stats}
     * @private
     */
    
    function tryStat(path) {
      debug('stat "%s"', path);
    
      try {
        return fs.statSync(path);
      } catch (e) {
        return undefined;
      }
    }
    
  provide("express/lib/view", module.exports);
}(global));

// pakmanager:express/lib/application
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * express
     * Copyright(c) 2009-2013 TJ Holowaychuk
     * Copyright(c) 2013 Roman Shtylman
     * Copyright(c) 2014-2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    /**
     * Module dependencies.
     * @api private
     */
    
    var finalhandler = require('finalhandler');
    var flatten =  require('express/lib/utils').flatten;
    var Router =  require('express/lib/router');
    var methods = require('methods');
    var middleware =  require('express/lib/middleware/init');
    var query =  require('express/lib/middleware/query');
    var debug = require('debug')('express:application');
    var View =  require('express/lib/view');
    var http = require('http');
    var compileETag =  require('express/lib/utils').compileETag;
    var compileQueryParser =  require('express/lib/utils').compileQueryParser;
    var compileTrust =  require('express/lib/utils').compileTrust;
    var deprecate = require('depd')('express');
    var merge = require('utils-merge');
    var resolve = require('path').resolve;
    var slice = Array.prototype.slice;
    
    /**
     * Application prototype.
     */
    
    var app = exports = module.exports = {};
    
    /**
     * Variable for trust proxy inheritance back-compat
     * @api private
     */
    
    var trustProxyDefaultSymbol = '@@symbol:trust_proxy_default';
    
    /**
     * Initialize the server.
     *
     *   - setup default configuration
     *   - setup default middleware
     *   - setup route reflection methods
     *
     * @api private
     */
    
    app.init = function(){
      this.cache = {};
      this.settings = {};
      this.engines = {};
      this.defaultConfiguration();
    };
    
    /**
     * Initialize application configuration.
     *
     * @api private
     */
    
    app.defaultConfiguration = function(){
      // default settings
      this.enable('x-powered-by');
      this.set('etag', 'weak');
      var env = process.env.NODE_ENV || 'development';
      this.set('env', env);
      this.set('query parser', 'extended');
      this.set('subdomain offset', 2);
      this.set('trust proxy', false);
    
      // trust proxy inherit back-compat
      Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
        configurable: true,
        value: true
      });
    
      debug('booting in %s mode', env);
    
      this.on('mount', function onmount(parent) {
        // inherit trust proxy
        if (this.settings[trustProxyDefaultSymbol] === true
          && typeof parent.settings['trust proxy fn'] === 'function') {
          delete this.settings['trust proxy'];
          delete this.settings['trust proxy fn'];
        }
    
        // inherit protos
        this.request.__proto__ = parent.request;
        this.response.__proto__ = parent.response;
        this.engines.__proto__ = parent.engines;
        this.settings.__proto__ = parent.settings;
      });
    
      // setup locals
      this.locals = Object.create(null);
    
      // top-most app is mounted at /
      this.mountpath = '/';
    
      // default locals
      this.locals.settings = this.settings;
    
      // default configuration
      this.set('view', View);
      this.set('views', resolve('views'));
      this.set('jsonp callback name', 'callback');
    
      if (env === 'production') {
        this.enable('view cache');
      }
    
      Object.defineProperty(this, 'router', {
        get: function() {
          throw new Error('\'app.router\' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.');
        }
      });
    };
    
    /**
     * lazily adds the base router if it has not yet been added.
     *
     * We cannot add the base router in the defaultConfiguration because
     * it reads app settings which might be set after that has run.
     *
     * @api private
     */
    app.lazyrouter = function() {
      if (!this._router) {
        this._router = new Router({
          caseSensitive: this.enabled('case sensitive routing'),
          strict: this.enabled('strict routing')
        });
    
        this._router.use(query(this.get('query parser fn')));
        this._router.use(middleware.init(this));
      }
    };
    
    /**
     * Dispatch a req, res pair into the application. Starts pipeline processing.
     *
     * If no _done_ callback is provided, then default error handlers will respond
     * in the event of an error bubbling through the stack.
     *
     * @api private
     */
    
    app.handle = function(req, res, done) {
      var router = this._router;
    
      // final handler
      done = done || finalhandler(req, res, {
        env: this.get('env'),
        onerror: logerror.bind(this)
      });
    
      // no routes
      if (!router) {
        debug('no routes defined on app');
        done();
        return;
      }
    
      router.handle(req, res, done);
    };
    
    /**
     * Proxy `Router#use()` to add middleware to the app router.
     * See Router#use() documentation for details.
     *
     * If the _fn_ parameter is an express app, then it will be
     * mounted at the _route_ specified.
     *
     * @api public
     */
    
    app.use = function use(fn) {
      var offset = 0;
      var path = '/';
    
      // default path to '/'
      // disambiguate app.use([fn])
      if (typeof fn !== 'function') {
        var arg = fn;
    
        while (Array.isArray(arg) && arg.length !== 0) {
          arg = arg[0];
        }
    
        // first arg is the path
        if (typeof arg !== 'function') {
          offset = 1;
          path = fn;
        }
      }
    
      var fns = flatten(slice.call(arguments, offset));
    
      if (fns.length === 0) {
        throw new TypeError('app.use() requires middleware functions');
      }
    
      // setup router
      this.lazyrouter();
      var router = this._router;
    
      fns.forEach(function (fn) {
        // non-express app
        if (!fn || !fn.handle || !fn.set) {
          return router.use(path, fn);
        }
    
        debug('.use app under %s', path);
        fn.mountpath = path;
        fn.parent = this;
    
        // restore .app property on req and res
        router.use(path, function mounted_app(req, res, next) {
          var orig = req.app;
          fn.handle(req, res, function (err) {
            req.__proto__ = orig.request;
            res.__proto__ = orig.response;
            next(err);
          });
        });
    
        // mounted an app
        fn.emit('mount', this);
      }, this);
    
      return this;
    };
    
    /**
     * Proxy to the app `Router#route()`
     * Returns a new `Route` instance for the _path_.
     *
     * Routes are isolated middleware stacks for specific paths.
     * See the Route api docs for details.
     *
     * @api public
     */
    
    app.route = function(path){
      this.lazyrouter();
      return this._router.route(path);
    };
    
    /**
     * Register the given template engine callback `fn`
     * as `ext`.
     *
     * By default will `require()` the engine based on the
     * file extension. For example if you try to render
     * a "foo.jade" file Express will invoke the following internally:
     *
     *     app.engine('jade', require('jade').__express);
     *
     * For engines that do not provide `.__express` out of the box,
     * or if you wish to "map" a different extension to the template engine
     * you may use this method. For example mapping the EJS template engine to
     * ".html" files:
     *
     *     app.engine('html', require('ejs').renderFile);
     *
     * In this case EJS provides a `.renderFile()` method with
     * the same signature that Express expects: `(path, options, callback)`,
     * though note that it aliases this method as `ejs.__express` internally
     * so if you're using ".ejs" extensions you dont need to do anything.
     *
     * Some template engines do not follow this convention, the
     * [Consolidate.js](https://github.com/tj/consolidate.js)
     * library was created to map all of node's popular template
     * engines to follow this convention, thus allowing them to
     * work seamlessly within Express.
     *
     * @param {String} ext
     * @param {Function} fn
     * @return {app} for chaining
     * @api public
     */
    
    app.engine = function(ext, fn){
      if ('function' != typeof fn) throw new Error('callback function required');
      if ('.' != ext[0]) ext = '.' + ext;
      this.engines[ext] = fn;
      return this;
    };
    
    /**
     * Proxy to `Router#param()` with one added api feature. The _name_ parameter
     * can be an array of names.
     *
     * See the Router#param() docs for more details.
     *
     * @param {String|Array} name
     * @param {Function} fn
     * @return {app} for chaining
     * @api public
     */
    
    app.param = function(name, fn){
      this.lazyrouter();
    
      if (Array.isArray(name)) {
        name.forEach(function(key) {
          this.param(key, fn);
        }, this);
        return this;
      }
    
      this._router.param(name, fn);
      return this;
    };
    
    /**
     * Assign `setting` to `val`, or return `setting`'s value.
     *
     *    app.set('foo', 'bar');
     *    app.get('foo');
     *    // => "bar"
     *
     * Mounted servers inherit their parent server's settings.
     *
     * @param {String} setting
     * @param {*} [val]
     * @return {Server} for chaining
     * @api public
     */
    
    app.set = function(setting, val){
      if (arguments.length === 1) {
        // app.get(setting)
        return this.settings[setting];
      }
    
      // set value
      this.settings[setting] = val;
    
      // trigger matched settings
      switch (setting) {
        case 'etag':
          debug('compile etag %s', val);
          this.set('etag fn', compileETag(val));
          break;
        case 'query parser':
          debug('compile query parser %s', val);
          this.set('query parser fn', compileQueryParser(val));
          break;
        case 'trust proxy':
          debug('compile trust proxy %s', val);
          this.set('trust proxy fn', compileTrust(val));
    
          // trust proxy inherit back-compat
          Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
            configurable: true,
            value: false
          });
    
          break;
      }
    
      return this;
    };
    
    /**
     * Return the app's absolute pathname
     * based on the parent(s) that have
     * mounted it.
     *
     * For example if the application was
     * mounted as "/admin", which itself
     * was mounted as "/blog" then the
     * return value would be "/blog/admin".
     *
     * @return {String}
     * @api private
     */
    
    app.path = function(){
      return this.parent
        ? this.parent.path() + this.mountpath
        : '';
    };
    
    /**
     * Check if `setting` is enabled (truthy).
     *
     *    app.enabled('foo')
     *    // => false
     *
     *    app.enable('foo')
     *    app.enabled('foo')
     *    // => true
     *
     * @param {String} setting
     * @return {Boolean}
     * @api public
     */
    
    app.enabled = function(setting){
      return !!this.set(setting);
    };
    
    /**
     * Check if `setting` is disabled.
     *
     *    app.disabled('foo')
     *    // => true
     *
     *    app.enable('foo')
     *    app.disabled('foo')
     *    // => false
     *
     * @param {String} setting
     * @return {Boolean}
     * @api public
     */
    
    app.disabled = function(setting){
      return !this.set(setting);
    };
    
    /**
     * Enable `setting`.
     *
     * @param {String} setting
     * @return {app} for chaining
     * @api public
     */
    
    app.enable = function(setting){
      return this.set(setting, true);
    };
    
    /**
     * Disable `setting`.
     *
     * @param {String} setting
     * @return {app} for chaining
     * @api public
     */
    
    app.disable = function(setting){
      return this.set(setting, false);
    };
    
    /**
     * Delegate `.VERB(...)` calls to `router.VERB(...)`.
     */
    
    methods.forEach(function(method){
      app[method] = function(path){
        if ('get' == method && 1 == arguments.length) return this.set(path);
    
        this.lazyrouter();
    
        var route = this._router.route(path);
        route[method].apply(route, slice.call(arguments, 1));
        return this;
      };
    });
    
    /**
     * Special-cased "all" method, applying the given route `path`,
     * middleware, and callback to _every_ HTTP method.
     *
     * @param {String} path
     * @param {Function} ...
     * @return {app} for chaining
     * @api public
     */
    
    app.all = function(path){
      this.lazyrouter();
    
      var route = this._router.route(path);
      var args = slice.call(arguments, 1);
      methods.forEach(function(method){
        route[method].apply(route, args);
      });
    
      return this;
    };
    
    // del -> delete alias
    
    app.del = deprecate.function(app.delete, 'app.del: Use app.delete instead');
    
    /**
     * Render the given view `name` name with `options`
     * and a callback accepting an error and the
     * rendered template string.
     *
     * Example:
     *
     *    app.render('email', { name: 'Tobi' }, function(err, html){
     *      // ...
     *    })
     *
     * @param {String} name
     * @param {String|Function} options or fn
     * @param {Function} fn
     * @api public
     */
    
    app.render = function(name, options, fn){
      var opts = {};
      var cache = this.cache;
      var engines = this.engines;
      var view;
    
      // support callback function as second arg
      if ('function' == typeof options) {
        fn = options, options = {};
      }
    
      // merge app.locals
      merge(opts, this.locals);
    
      // merge options._locals
      if (options._locals) {
        merge(opts, options._locals);
      }
    
      // merge options
      merge(opts, options);
    
      // set .cache unless explicitly provided
      opts.cache = null == opts.cache
        ? this.enabled('view cache')
        : opts.cache;
    
      // primed cache
      if (opts.cache) view = cache[name];
    
      // view
      if (!view) {
        view = new (this.get('view'))(name, {
          defaultEngine: this.get('view engine'),
          root: this.get('views'),
          engines: engines
        });
    
        if (!view.path) {
          var dirs = Array.isArray(view.root) && view.root.length > 1
            ? 'directories "' + view.root.slice(0, -1).join('", "') + '" or "' + view.root[view.root.length - 1] + '"'
            : 'directory "' + view.root + '"'
          var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
          err.view = view;
          return fn(err);
        }
    
        // prime the cache
        if (opts.cache) cache[name] = view;
      }
    
      // render
      try {
        view.render(opts, fn);
      } catch (err) {
        fn(err);
      }
    };
    
    /**
     * Listen for connections.
     *
     * A node `http.Server` is returned, with this
     * application (which is a `Function`) as its
     * callback. If you wish to create both an HTTP
     * and HTTPS server you may do so with the "http"
     * and "https" modules as shown here:
     *
     *    var http = require('http')
     *      , https = require('https')
     *      , express =  require('express')
     *      , app = express();
     *
     *    http.createServer(app).listen(80);
     *    https.createServer({ ... }, app).listen(443);
     *
     * @return {http.Server}
     * @api public
     */
    
    app.listen = function(){
      var server = http.createServer(this);
      return server.listen.apply(server, arguments);
    };
    
    /**
    * Log error using console.error.
    *
    * @param {Error} err
    * @api private
    */
    
    function logerror(err){
      if (this.get('env') !== 'test') console.error(err.stack || err.toString());
    }
    
  provide("express/lib/application", module.exports);
}(global));

// pakmanager:express/lib/request
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var accepts = require('accepts');
    var deprecate = require('depd')('express');
    var isIP = require('net').isIP;
    var typeis = require('type-is');
    var http = require('http');
    var fresh = require('fresh');
    var parseRange = require('range-parser');
    var parse = require('parseurl');
    var proxyaddr = require('proxy-addr');
    
    /**
     * Request prototype.
     */
    
    var req = exports = module.exports = {
      __proto__: http.IncomingMessage.prototype
    };
    
    /**
     * Return request header.
     *
     * The `Referrer` header field is special-cased,
     * both `Referrer` and `Referer` are interchangeable.
     *
     * Examples:
     *
     *     req.get('Content-Type');
     *     // => "text/plain"
     *
     *     req.get('content-type');
     *     // => "text/plain"
     *
     *     req.get('Something');
     *     // => undefined
     *
     * Aliased as `req.header()`.
     *
     * @param {String} name
     * @return {String}
     * @api public
     */
    
    req.get =
    req.header = function(name){
      switch (name = name.toLowerCase()) {
        case 'referer':
        case 'referrer':
          return this.headers.referrer
            || this.headers.referer;
        default:
          return this.headers[name];
      }
    };
    
    /**
     * To do: update docs.
     *
     * Check if the given `type(s)` is acceptable, returning
     * the best match when true, otherwise `undefined`, in which
     * case you should respond with 406 "Not Acceptable".
     *
     * The `type` value may be a single MIME type string
     * such as "application/json", an extension name
     * such as "json", a comma-delimited list such as "json, html, text/plain",
     * an argument list such as `"json", "html", "text/plain"`,
     * or an array `["json", "html", "text/plain"]`. When a list
     * or array is given, the _best_ match, if any is returned.
     *
     * Examples:
     *
     *     // Accept: text/html
     *     req.accepts('html');
     *     // => "html"
     *
     *     // Accept: text/*, application/json
     *     req.accepts('html');
     *     // => "html"
     *     req.accepts('text/html');
     *     // => "text/html"
     *     req.accepts('json, text');
     *     // => "json"
     *     req.accepts('application/json');
     *     // => "application/json"
     *
     *     // Accept: text/*, application/json
     *     req.accepts('image/png');
     *     req.accepts('png');
     *     // => undefined
     *
     *     // Accept: text/*;q=.5, application/json
     *     req.accepts(['html', 'json']);
     *     req.accepts('html', 'json');
     *     req.accepts('html, json');
     *     // => "json"
     *
     * @param {String|Array} type(s)
     * @return {String}
     * @api public
     */
    
    req.accepts = function(){
      var accept = accepts(this);
      return accept.types.apply(accept, arguments);
    };
    
    /**
     * Check if the given `encoding`s are accepted.
     *
     * @param {String} ...encoding
     * @return {Boolean}
     * @api public
     */
    
    req.acceptsEncodings = function(){
      var accept = accepts(this);
      return accept.encodings.apply(accept, arguments);
    };
    
    req.acceptsEncoding = deprecate.function(req.acceptsEncodings,
      'req.acceptsEncoding: Use acceptsEncodings instead');
    
    /**
     * Check if the given `charset`s are acceptable,
     * otherwise you should respond with 406 "Not Acceptable".
     *
     * @param {String} ...charset
     * @return {Boolean}
     * @api public
     */
    
    req.acceptsCharsets = function(){
      var accept = accepts(this);
      return accept.charsets.apply(accept, arguments);
    };
    
    req.acceptsCharset = deprecate.function(req.acceptsCharsets,
      'req.acceptsCharset: Use acceptsCharsets instead');
    
    /**
     * Check if the given `lang`s are acceptable,
     * otherwise you should respond with 406 "Not Acceptable".
     *
     * @param {String} ...lang
     * @return {Boolean}
     * @api public
     */
    
    req.acceptsLanguages = function(){
      var accept = accepts(this);
      return accept.languages.apply(accept, arguments);
    };
    
    req.acceptsLanguage = deprecate.function(req.acceptsLanguages,
      'req.acceptsLanguage: Use acceptsLanguages instead');
    
    /**
     * Parse Range header field,
     * capping to the given `size`.
     *
     * Unspecified ranges such as "0-" require
     * knowledge of your resource length. In
     * the case of a byte range this is of course
     * the total number of bytes. If the Range
     * header field is not given `null` is returned,
     * `-1` when unsatisfiable, `-2` when syntactically invalid.
     *
     * NOTE: remember that ranges are inclusive, so
     * for example "Range: users=0-3" should respond
     * with 4 users when available, not 3.
     *
     * @param {Number} size
     * @return {Array}
     * @api public
     */
    
    req.range = function(size){
      var range = this.get('Range');
      if (!range) return;
      return parseRange(size, range);
    };
    
    /**
     * Return the value of param `name` when present or `defaultValue`.
     *
     *  - Checks route placeholders, ex: _/user/:id_
     *  - Checks body params, ex: id=12, {"id":12}
     *  - Checks query string params, ex: ?id=12
     *
     * To utilize request bodies, `req.body`
     * should be an object. This can be done by using
     * the `bodyParser()` middleware.
     *
     * @param {String} name
     * @param {Mixed} [defaultValue]
     * @return {String}
     * @api public
     */
    
    req.param = function param(name, defaultValue) {
      var params = this.params || {};
      var body = this.body || {};
      var query = this.query || {};
    
      var args = arguments.length === 1
        ? 'name'
        : 'name, default';
      deprecate('req.param(' + args + '): Use req.params, req.body, or req.query instead');
    
      if (null != params[name] && params.hasOwnProperty(name)) return params[name];
      if (null != body[name]) return body[name];
      if (null != query[name]) return query[name];
    
      return defaultValue;
    };
    
    /**
     * Check if the incoming request contains the "Content-Type"
     * header field, and it contains the give mime `type`.
     *
     * Examples:
     *
     *      // With Content-Type: text/html; charset=utf-8
     *      req.is('html');
     *      req.is('text/html');
     *      req.is('text/*');
     *      // => true
     *
     *      // When Content-Type is application/json
     *      req.is('json');
     *      req.is('application/json');
     *      req.is('application/*');
     *      // => true
     *
     *      req.is('html');
     *      // => false
     *
     * @param {String} type
     * @return {Boolean}
     * @api public
     */
    
    req.is = function(types){
      if (!Array.isArray(types)) types = [].slice.call(arguments);
      return typeis(this, types);
    };
    
    /**
     * Return the protocol string "http" or "https"
     * when requested with TLS. When the "trust proxy"
     * setting trusts the socket address, the
     * "X-Forwarded-Proto" header field will be trusted
     * and used if present.
     *
     * If you're running behind a reverse proxy that
     * supplies https for you this may be enabled.
     *
     * @return {String}
     * @api public
     */
    
    defineGetter(req, 'protocol', function protocol(){
      var proto = this.connection.encrypted
        ? 'https'
        : 'http';
      var trust = this.app.get('trust proxy fn');
    
      if (!trust(this.connection.remoteAddress, 0)) {
        return proto;
      }
    
      // Note: X-Forwarded-Proto is normally only ever a
      //       single value, but this is to be safe.
      proto = this.get('X-Forwarded-Proto') || proto;
      return proto.split(/\s*,\s*/)[0];
    });
    
    /**
     * Short-hand for:
     *
     *    req.protocol == 'https'
     *
     * @return {Boolean}
     * @api public
     */
    
    defineGetter(req, 'secure', function secure(){
      return 'https' == this.protocol;
    });
    
    /**
     * Return the remote address from the trusted proxy.
     *
     * The is the remote address on the socket unless
     * "trust proxy" is set.
     *
     * @return {String}
     * @api public
     */
    
    defineGetter(req, 'ip', function ip(){
      var trust = this.app.get('trust proxy fn');
      return proxyaddr(this, trust);
    });
    
    /**
     * When "trust proxy" is set, trusted proxy addresses + client.
     *
     * For example if the value were "client, proxy1, proxy2"
     * you would receive the array `["client", "proxy1", "proxy2"]`
     * where "proxy2" is the furthest down-stream and "proxy1" and
     * "proxy2" were trusted.
     *
     * @return {Array}
     * @api public
     */
    
    defineGetter(req, 'ips', function ips() {
      var trust = this.app.get('trust proxy fn');
      var addrs = proxyaddr.all(this, trust);
      return addrs.slice(1).reverse();
    });
    
    /**
     * Return subdomains as an array.
     *
     * Subdomains are the dot-separated parts of the host before the main domain of
     * the app. By default, the domain of the app is assumed to be the last two
     * parts of the host. This can be changed by setting "subdomain offset".
     *
     * For example, if the domain is "tobi.ferrets.example.com":
     * If "subdomain offset" is not set, req.subdomains is `["ferrets", "tobi"]`.
     * If "subdomain offset" is 3, req.subdomains is `["tobi"]`.
     *
     * @return {Array}
     * @api public
     */
    
    defineGetter(req, 'subdomains', function subdomains() {
      var hostname = this.hostname;
    
      if (!hostname) return [];
    
      var offset = this.app.get('subdomain offset');
      var subdomains = !isIP(hostname)
        ? hostname.split('.').reverse()
        : [hostname];
    
      return subdomains.slice(offset);
    });
    
    /**
     * Short-hand for `url.parse(req.url).pathname`.
     *
     * @return {String}
     * @api public
     */
    
    defineGetter(req, 'path', function path() {
      return parse(this).pathname;
    });
    
    /**
     * Parse the "Host" header field to a hostname.
     *
     * When the "trust proxy" setting trusts the socket
     * address, the "X-Forwarded-Host" header field will
     * be trusted.
     *
     * @return {String}
     * @api public
     */
    
    defineGetter(req, 'hostname', function hostname(){
      var trust = this.app.get('trust proxy fn');
      var host = this.get('X-Forwarded-Host');
    
      if (!host || !trust(this.connection.remoteAddress, 0)) {
        host = this.get('Host');
      }
    
      if (!host) return;
    
      // IPv6 literal support
      var offset = host[0] === '['
        ? host.indexOf(']') + 1
        : 0;
      var index = host.indexOf(':', offset);
    
      return ~index
        ? host.substring(0, index)
        : host;
    });
    
    // TODO: change req.host to return host in next major
    
    defineGetter(req, 'host', deprecate.function(function host(){
      return this.hostname;
    }, 'req.host: Use req.hostname instead'));
    
    /**
     * Check if the request is fresh, aka
     * Last-Modified and/or the ETag
     * still match.
     *
     * @return {Boolean}
     * @api public
     */
    
    defineGetter(req, 'fresh', function(){
      var method = this.method;
      var s = this.res.statusCode;
    
      // GET or HEAD for weak freshness validation only
      if ('GET' != method && 'HEAD' != method) return false;
    
      // 2xx or 304 as per rfc2616 14.26
      if ((s >= 200 && s < 300) || 304 == s) {
        return fresh(this.headers, (this.res._headers || {}));
      }
    
      return false;
    });
    
    /**
     * Check if the request is stale, aka
     * "Last-Modified" and / or the "ETag" for the
     * resource has changed.
     *
     * @return {Boolean}
     * @api public
     */
    
    defineGetter(req, 'stale', function stale(){
      return !this.fresh;
    });
    
    /**
     * Check if the request was an _XMLHttpRequest_.
     *
     * @return {Boolean}
     * @api public
     */
    
    defineGetter(req, 'xhr', function xhr(){
      var val = this.get('X-Requested-With') || '';
      return 'xmlhttprequest' == val.toLowerCase();
    });
    
    /**
     * Helper function for creating a getter on an object.
     *
     * @param {Object} obj
     * @param {String} name
     * @param {Function} getter
     * @api private
     */
    function defineGetter(obj, name, getter) {
      Object.defineProperty(obj, name, {
        configurable: true,
        enumerable: true,
        get: getter
      });
    };
    
  provide("express/lib/request", module.exports);
}(global));

// pakmanager:express/lib/response
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * express
     * Copyright(c) 2009-2013 TJ Holowaychuk
     * Copyright(c) 2014-2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    /**
     * Module dependencies.
     * @api private
     */
    
    var contentDisposition = require('content-disposition');
    var deprecate = require('depd')('express');
    var escapeHtml = require('escape-html');
    var http = require('http');
    var isAbsolute =  require('express/lib/utils').isAbsolute;
    var onFinished = require('on-finished');
    var path = require('path');
    var merge = require('utils-merge');
    var sign = require('cookie-signature').sign;
    var normalizeType =  require('express/lib/utils').normalizeType;
    var normalizeTypes =  require('express/lib/utils').normalizeTypes;
    var setCharset =  require('express/lib/utils').setCharset;
    var statusCodes = http.STATUS_CODES;
    var cookie = require('cookie');
    var send = require('send');
    var extname = path.extname;
    var mime = send.mime;
    var resolve = path.resolve;
    var vary = require('vary');
    
    /**
     * Response prototype.
     */
    
    var res = module.exports = {
      __proto__: http.ServerResponse.prototype
    };
    
    /**
     * Set status `code`.
     *
     * @param {Number} code
     * @return {ServerResponse}
     * @api public
     */
    
    res.status = function(code){
      this.statusCode = code;
      return this;
    };
    
    /**
     * Set Link header field with the given `links`.
     *
     * Examples:
     *
     *    res.links({
     *      next: 'http://api.example.com/users?page=2',
     *      last: 'http://api.example.com/users?page=5'
     *    });
     *
     * @param {Object} links
     * @return {ServerResponse}
     * @api public
     */
    
    res.links = function(links){
      var link = this.get('Link') || '';
      if (link) link += ', ';
      return this.set('Link', link + Object.keys(links).map(function(rel){
        return '<' + links[rel] + '>; rel="' + rel + '"';
      }).join(', '));
    };
    
    /**
     * Send a response.
     *
     * Examples:
     *
     *     res.send(new Buffer('wahoo'));
     *     res.send({ some: 'json' });
     *     res.send('<p>some html</p>');
     *
     * @param {string|number|boolean|object|Buffer} body
     * @api public
     */
    
    res.send = function send(body) {
      var chunk = body;
      var encoding;
      var len;
      var req = this.req;
      var type;
    
      // settings
      var app = this.app;
    
      // allow status / body
      if (arguments.length === 2) {
        // res.send(body, status) backwards compat
        if (typeof arguments[0] !== 'number' && typeof arguments[1] === 'number') {
          deprecate('res.send(body, status): Use res.status(status).send(body) instead');
          this.statusCode = arguments[1];
        } else {
          deprecate('res.send(status, body): Use res.status(status).send(body) instead');
          this.statusCode = arguments[0];
          chunk = arguments[1];
        }
      }
    
      // disambiguate res.send(status) and res.send(status, num)
      if (typeof chunk === 'number' && arguments.length === 1) {
        // res.send(status) will set status message as text string
        if (!this.get('Content-Type')) {
          this.type('txt');
        }
    
        deprecate('res.send(status): Use res.sendStatus(status) instead');
        this.statusCode = chunk;
        chunk = http.STATUS_CODES[chunk];
      }
    
      switch (typeof chunk) {
        // string defaulting to html
        case 'string':
          if (!this.get('Content-Type')) {
            this.type('html');
          }
          break;
        case 'boolean':
        case 'number':
        case 'object':
          if (chunk === null) {
            chunk = '';
          } else if (Buffer.isBuffer(chunk)) {
            if (!this.get('Content-Type')) {
              this.type('bin');
            }
          } else {
            return this.json(chunk);
          }
          break;
      }
    
      // write strings in utf-8
      if (typeof chunk === 'string') {
        encoding = 'utf8';
        type = this.get('Content-Type');
    
        // reflect this in content-type
        if (typeof type === 'string') {
          this.set('Content-Type', setCharset(type, 'utf-8'));
        }
      }
    
      // populate Content-Length
      if (chunk !== undefined) {
        if (!Buffer.isBuffer(chunk)) {
          // convert chunk to Buffer; saves later double conversions
          chunk = new Buffer(chunk, encoding);
          encoding = undefined;
        }
    
        len = chunk.length;
        this.set('Content-Length', len);
      }
    
      // populate ETag
      var etag;
      var generateETag = len !== undefined && app.get('etag fn');
      if (typeof generateETag === 'function' && !this.get('ETag')) {
        if ((etag = generateETag(chunk, encoding))) {
          this.set('ETag', etag);
        }
      }
    
      // freshness
      if (req.fresh) this.statusCode = 304;
    
      // strip irrelevant headers
      if (204 == this.statusCode || 304 == this.statusCode) {
        this.removeHeader('Content-Type');
        this.removeHeader('Content-Length');
        this.removeHeader('Transfer-Encoding');
        chunk = '';
      }
    
      if (req.method === 'HEAD') {
        // skip body for HEAD
        this.end();
      } else {
        // respond
        this.end(chunk, encoding);
      }
    
      return this;
    };
    
    /**
     * Send JSON response.
     *
     * Examples:
     *
     *     res.json(null);
     *     res.json({ user: 'tj' });
     *
     * @param {string|number|boolean|object} obj
     * @api public
     */
    
    res.json = function json(obj) {
      var val = obj;
    
      // allow status / body
      if (arguments.length === 2) {
        // res.json(body, status) backwards compat
        if (typeof arguments[1] === 'number') {
          deprecate('res.json(obj, status): Use res.status(status).json(obj) instead');
          this.statusCode = arguments[1];
        } else {
          deprecate('res.json(status, obj): Use res.status(status).json(obj) instead');
          this.statusCode = arguments[0];
          val = arguments[1];
        }
      }
    
      // settings
      var app = this.app;
      var replacer = app.get('json replacer');
      var spaces = app.get('json spaces');
      var body = JSON.stringify(val, replacer, spaces);
    
      // content-type
      if (!this.get('Content-Type')) {
        this.set('Content-Type', 'application/json');
      }
    
      return this.send(body);
    };
    
    /**
     * Send JSON response with JSONP callback support.
     *
     * Examples:
     *
     *     res.jsonp(null);
     *     res.jsonp({ user: 'tj' });
     *
     * @param {string|number|boolean|object} obj
     * @api public
     */
    
    res.jsonp = function jsonp(obj) {
      var val = obj;
    
      // allow status / body
      if (arguments.length === 2) {
        // res.json(body, status) backwards compat
        if (typeof arguments[1] === 'number') {
          deprecate('res.jsonp(obj, status): Use res.status(status).json(obj) instead');
          this.statusCode = arguments[1];
        } else {
          deprecate('res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead');
          this.statusCode = arguments[0];
          val = arguments[1];
        }
      }
    
      // settings
      var app = this.app;
      var replacer = app.get('json replacer');
      var spaces = app.get('json spaces');
      var body = JSON.stringify(val, replacer, spaces);
      var callback = this.req.query[app.get('jsonp callback name')];
    
      // content-type
      if (!this.get('Content-Type')) {
        this.set('X-Content-Type-Options', 'nosniff');
        this.set('Content-Type', 'application/json');
      }
    
      // fixup callback
      if (Array.isArray(callback)) {
        callback = callback[0];
      }
    
      // jsonp
      if (typeof callback === 'string' && callback.length !== 0) {
        this.charset = 'utf-8';
        this.set('X-Content-Type-Options', 'nosniff');
        this.set('Content-Type', 'text/javascript');
    
        // restrict callback charset
        callback = callback.replace(/[^\[\]\w$.]/g, '');
    
        // replace chars not allowed in JavaScript that are in JSON
        body = body
          .replace(/\u2028/g, '\\u2028')
          .replace(/\u2029/g, '\\u2029');
    
        // the /**/ is a specific security mitigation for "Rosetta Flash JSONP abuse"
        // the typeof check is just to reduce client error noise
        body = '/**/ typeof ' + callback + ' === \'function\' && ' + callback + '(' + body + ');';
      }
    
      return this.send(body);
    };
    
    /**
     * Send given HTTP status code.
     *
     * Sets the response status to `statusCode` and the body of the
     * response to the standard description from node's http.STATUS_CODES
     * or the statusCode number if no description.
     *
     * Examples:
     *
     *     res.sendStatus(200);
     *
     * @param {number} statusCode
     * @api public
     */
    
    res.sendStatus = function sendStatus(statusCode) {
      var body = http.STATUS_CODES[statusCode] || String(statusCode);
    
      this.statusCode = statusCode;
      this.type('txt');
    
      return this.send(body);
    };
    
    /**
     * Transfer the file at the given `path`.
     *
     * Automatically sets the _Content-Type_ response header field.
     * The callback `fn(err)` is invoked when the transfer is complete
     * or when an error occurs. Be sure to check `res.sentHeader`
     * if you wish to attempt responding, as the header and some data
     * may have already been transferred.
     *
     * Options:
     *
     *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
     *   - `root`     root directory for relative filenames
     *   - `headers`  object of headers to serve with file
     *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
     *
     * Other options are passed along to `send`.
     *
     * Examples:
     *
     *  The following example illustrates how `res.sendFile()` may
     *  be used as an alternative for the `static()` middleware for
     *  dynamic situations. The code backing `res.sendFile()` is actually
     *  the same code, so HTTP cache support etc is identical.
     *
     *     app.get('/user/:uid/photos/:file', function(req, res){
     *       var uid = req.params.uid
     *         , file = req.params.file;
     *
     *       req.user.mayViewFilesFrom(uid, function(yes){
     *         if (yes) {
     *           res.sendFile('/uploads/' + uid + '/' + file);
     *         } else {
     *           res.send(403, 'Sorry! you cant see that.');
     *         }
     *       });
     *     });
     *
     * @api public
     */
    
    res.sendFile = function sendFile(path, options, fn) {
      var req = this.req;
      var res = this;
      var next = req.next;
    
      if (!path) {
        throw new TypeError('path argument is required to res.sendFile');
      }
    
      // support function as second arg
      if (typeof options === 'function') {
        fn = options;
        options = {};
      }
    
      options = options || {};
    
      if (!options.root && !isAbsolute(path)) {
        throw new TypeError('path must be absolute or specify root to res.sendFile');
      }
    
      // create file stream
      var pathname = encodeURI(path);
      var file = send(req, pathname, options);
    
      // transfer
      sendfile(res, file, options, function (err) {
        if (fn) return fn(err);
        if (err && err.code === 'EISDIR') return next();
    
        // next() all but write errors
        if (err && err.code !== 'ECONNABORTED' && err.syscall !== 'write') {
          next(err);
        }
      });
    };
    
    /**
     * Transfer the file at the given `path`.
     *
     * Automatically sets the _Content-Type_ response header field.
     * The callback `fn(err)` is invoked when the transfer is complete
     * or when an error occurs. Be sure to check `res.sentHeader`
     * if you wish to attempt responding, as the header and some data
     * may have already been transferred.
     *
     * Options:
     *
     *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
     *   - `root`     root directory for relative filenames
     *   - `headers`  object of headers to serve with file
     *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
     *
     * Other options are passed along to `send`.
     *
     * Examples:
     *
     *  The following example illustrates how `res.sendfile()` may
     *  be used as an alternative for the `static()` middleware for
     *  dynamic situations. The code backing `res.sendfile()` is actually
     *  the same code, so HTTP cache support etc is identical.
     *
     *     app.get('/user/:uid/photos/:file', function(req, res){
     *       var uid = req.params.uid
     *         , file = req.params.file;
     *
     *       req.user.mayViewFilesFrom(uid, function(yes){
     *         if (yes) {
     *           res.sendfile('/uploads/' + uid + '/' + file);
     *         } else {
     *           res.send(403, 'Sorry! you cant see that.');
     *         }
     *       });
     *     });
     *
     * @api public
     */
    
    res.sendfile = function(path, options, fn){
      var req = this.req;
      var res = this;
      var next = req.next;
    
      // support function as second arg
      if (typeof options === 'function') {
        fn = options;
        options = {};
      }
    
      options = options || {};
    
      // create file stream
      var file = send(req, path, options);
    
      // transfer
      sendfile(res, file, options, function (err) {
        if (fn) return fn(err);
        if (err && err.code === 'EISDIR') return next();
    
        // next() all but write errors
        if (err && err.code !== 'ECONNABORT' && err.syscall !== 'write') {
          next(err);
        }
      });
    };
    
    res.sendfile = deprecate.function(res.sendfile,
      'res.sendfile: Use res.sendFile instead');
    
    /**
     * Transfer the file at the given `path` as an attachment.
     *
     * Optionally providing an alternate attachment `filename`,
     * and optional callback `fn(err)`. The callback is invoked
     * when the data transfer is complete, or when an error has
     * ocurred. Be sure to check `res.headersSent` if you plan to respond.
     *
     * This method uses `res.sendfile()`.
     *
     * @api public
     */
    
    res.download = function download(path, filename, fn) {
      // support function as second arg
      if (typeof filename === 'function') {
        fn = filename;
        filename = null;
      }
    
      filename = filename || path;
    
      // set Content-Disposition when file is sent
      var headers = {
        'Content-Disposition': contentDisposition(filename)
      };
    
      // Resolve the full path for sendFile
      var fullPath = resolve(path);
    
      return this.sendFile(fullPath, { headers: headers }, fn);
    };
    
    /**
     * Set _Content-Type_ response header with `type` through `mime.lookup()`
     * when it does not contain "/", or set the Content-Type to `type` otherwise.
     *
     * Examples:
     *
     *     res.type('.html');
     *     res.type('html');
     *     res.type('json');
     *     res.type('application/json');
     *     res.type('png');
     *
     * @param {String} type
     * @return {ServerResponse} for chaining
     * @api public
     */
    
    res.contentType =
    res.type = function(type){
      return this.set('Content-Type', ~type.indexOf('/')
        ? type
        : mime.lookup(type));
    };
    
    /**
     * Respond to the Acceptable formats using an `obj`
     * of mime-type callbacks.
     *
     * This method uses `req.accepted`, an array of
     * acceptable types ordered by their quality values.
     * When "Accept" is not present the _first_ callback
     * is invoked, otherwise the first match is used. When
     * no match is performed the server responds with
     * 406 "Not Acceptable".
     *
     * Content-Type is set for you, however if you choose
     * you may alter this within the callback using `res.type()`
     * or `res.set('Content-Type', ...)`.
     *
     *    res.format({
     *      'text/plain': function(){
     *        res.send('hey');
     *      },
     *
     *      'text/html': function(){
     *        res.send('<p>hey</p>');
     *      },
     *
     *      'appliation/json': function(){
     *        res.send({ message: 'hey' });
     *      }
     *    });
     *
     * In addition to canonicalized MIME types you may
     * also use extnames mapped to these types:
     *
     *    res.format({
     *      text: function(){
     *        res.send('hey');
     *      },
     *
     *      html: function(){
     *        res.send('<p>hey</p>');
     *      },
     *
     *      json: function(){
     *        res.send({ message: 'hey' });
     *      }
     *    });
     *
     * By default Express passes an `Error`
     * with a `.status` of 406 to `next(err)`
     * if a match is not made. If you provide
     * a `.default` callback it will be invoked
     * instead.
     *
     * @param {Object} obj
     * @return {ServerResponse} for chaining
     * @api public
     */
    
    res.format = function(obj){
      var req = this.req;
      var next = req.next;
    
      var fn = obj.default;
      if (fn) delete obj.default;
      var keys = Object.keys(obj);
    
      var key = req.accepts(keys);
    
      this.vary("Accept");
    
      if (key) {
        this.set('Content-Type', normalizeType(key).value);
        obj[key](req, this, next);
      } else if (fn) {
        fn();
      } else {
        var err = new Error('Not Acceptable');
        err.status = 406;
        err.types = normalizeTypes(keys).map(function(o){ return o.value });
        next(err);
      }
    
      return this;
    };
    
    /**
     * Set _Content-Disposition_ header to _attachment_ with optional `filename`.
     *
     * @param {String} filename
     * @return {ServerResponse}
     * @api public
     */
    
    res.attachment = function attachment(filename) {
      if (filename) {
        this.type(extname(filename));
      }
    
      this.set('Content-Disposition', contentDisposition(filename));
    
      return this;
    };
    
    /**
     * Append additional header `field` with value `val`.
     *
     * Example:
     *
     *    res.append('Link', ['<http://localhost/>', '<http://localhost:3000/>']);
     *    res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly');
     *    res.append('Warning', '199 Miscellaneous warning');
     *
     * @param {String} field
     * @param {String|Array} val
     * @return {ServerResponse} for chaining
     * @api public
     */
    
    res.append = function append(field, val) {
      var prev = this.get(field);
      var value = val;
    
      if (prev) {
        // concat the new and prev vals
        value = Array.isArray(prev) ? prev.concat(val)
          : Array.isArray(val) ? [prev].concat(val)
          : [prev, val];
      }
    
      return this.set(field, value);
    };
    
    /**
     * Set header `field` to `val`, or pass
     * an object of header fields.
     *
     * Examples:
     *
     *    res.set('Foo', ['bar', 'baz']);
     *    res.set('Accept', 'application/json');
     *    res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });
     *
     * Aliased as `res.header()`.
     *
     * @param {String|Object|Array} field
     * @param {String} val
     * @return {ServerResponse} for chaining
     * @api public
     */
    
    res.set =
    res.header = function header(field, val) {
      if (arguments.length === 2) {
        if (Array.isArray(val)) val = val.map(String);
        else val = String(val);
        if ('content-type' == field.toLowerCase() && !/;\s*charset\s*=/.test(val)) {
          var charset = mime.charsets.lookup(val.split(';')[0]);
          if (charset) val += '; charset=' + charset.toLowerCase();
        }
        this.setHeader(field, val);
      } else {
        for (var key in field) {
          this.set(key, field[key]);
        }
      }
      return this;
    };
    
    /**
     * Get value for header `field`.
     *
     * @param {String} field
     * @return {String}
     * @api public
     */
    
    res.get = function(field){
      return this.getHeader(field);
    };
    
    /**
     * Clear cookie `name`.
     *
     * @param {String} name
     * @param {Object} options
     * @return {ServerResponse} for chaining
     * @api public
     */
    
    res.clearCookie = function(name, options){
      var opts = { expires: new Date(1), path: '/' };
      return this.cookie(name, '', options
        ? merge(opts, options)
        : opts);
    };
    
    /**
     * Set cookie `name` to `val`, with the given `options`.
     *
     * Options:
     *
     *    - `maxAge`   max-age in milliseconds, converted to `expires`
     *    - `signed`   sign the cookie
     *    - `path`     defaults to "/"
     *
     * Examples:
     *
     *    // "Remember Me" for 15 minutes
     *    res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
     *
     *    // save as above
     *    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
     *
     * @param {String} name
     * @param {String|Object} val
     * @param {Options} options
     * @return {ServerResponse} for chaining
     * @api public
     */
    
    res.cookie = function(name, val, options){
      options = merge({}, options);
      var secret = this.req.secret;
      var signed = options.signed;
      if (signed && !secret) throw new Error('cookieParser("secret") required for signed cookies');
      if ('number' == typeof val) val = val.toString();
      if ('object' == typeof val) val = 'j:' + JSON.stringify(val);
      if (signed) val = 's:' + sign(val, secret);
      if ('maxAge' in options) {
        options.expires = new Date(Date.now() + options.maxAge);
        options.maxAge /= 1000;
      }
      if (null == options.path) options.path = '/';
      var headerVal = cookie.serialize(name, String(val), options);
    
      // supports multiple 'res.cookie' calls by getting previous value
      var prev = this.get('Set-Cookie');
      if (prev) {
        if (Array.isArray(prev)) {
          headerVal = prev.concat(headerVal);
        } else {
          headerVal = [prev, headerVal];
        }
      }
      this.set('Set-Cookie', headerVal);
      return this;
    };
    
    
    /**
     * Set the location header to `url`.
     *
     * The given `url` can also be "back", which redirects
     * to the _Referrer_ or _Referer_ headers or "/".
     *
     * Examples:
     *
     *    res.location('/foo/bar').;
     *    res.location('http://example.com');
     *    res.location('../login');
     *
     * @param {String} url
     * @return {ServerResponse} for chaining
     * @api public
     */
    
    res.location = function(url){
      var req = this.req;
    
      // "back" is an alias for the referrer
      if ('back' == url) url = req.get('Referrer') || '/';
    
      // Respond
      this.set('Location', url);
      return this;
    };
    
    /**
     * Redirect to the given `url` with optional response `status`
     * defaulting to 302.
     *
     * The resulting `url` is determined by `res.location()`, so
     * it will play nicely with mounted apps, relative paths,
     * `"back"` etc.
     *
     * Examples:
     *
     *    res.redirect('/foo/bar');
     *    res.redirect('http://example.com');
     *    res.redirect(301, 'http://example.com');
     *    res.redirect('../login'); // /blog/post/1 -> /blog/login
     *
     * @api public
     */
    
    res.redirect = function redirect(url) {
      var address = url;
      var body;
      var status = 302;
    
      // allow status / url
      if (arguments.length === 2) {
        if (typeof arguments[0] === 'number') {
          status = arguments[0];
          address = arguments[1];
        } else {
          deprecate('res.redirect(url, status): Use res.redirect(status, url) instead');
          status = arguments[1];
        }
      }
    
      // Set location header
      this.location(address);
      address = this.get('Location');
    
      // Support text/{plain,html} by default
      this.format({
        text: function(){
          body = statusCodes[status] + '. Redirecting to ' + encodeURI(address);
        },
    
        html: function(){
          var u = escapeHtml(address);
          body = '<p>' + statusCodes[status] + '. Redirecting to <a href="' + u + '">' + u + '</a></p>';
        },
    
        default: function(){
          body = '';
        }
      });
    
      // Respond
      this.statusCode = status;
      this.set('Content-Length', Buffer.byteLength(body));
    
      if (this.req.method === 'HEAD') {
        this.end();
      } else {
        this.end(body);
      }
    };
    
    /**
     * Add `field` to Vary. If already present in the Vary set, then
     * this call is simply ignored.
     *
     * @param {Array|String} field
     * @return {ServerResponse} for chaining
     * @api public
     */
    
    res.vary = function(field){
      // checks for back-compat
      if (!field || (Array.isArray(field) && !field.length)) {
        deprecate('res.vary(): Provide a field name');
        return this;
      }
    
      vary(this, field);
    
      return this;
    };
    
    /**
     * Render `view` with the given `options` and optional callback `fn`.
     * When a callback function is given a response will _not_ be made
     * automatically, otherwise a response of _200_ and _text/html_ is given.
     *
     * Options:
     *
     *  - `cache`     boolean hinting to the engine it should cache
     *  - `filename`  filename of the view being rendered
     *
     * @api public
     */
    
    res.render = function(view, options, fn){
      options = options || {};
      var self = this;
      var req = this.req;
      var app = req.app;
    
      // support callback function as second arg
      if ('function' == typeof options) {
        fn = options, options = {};
      }
    
      // merge res.locals
      options._locals = self.locals;
    
      // default callback to respond
      fn = fn || function(err, str){
        if (err) return req.next(err);
        self.send(str);
      };
    
      // render
      app.render(view, options, fn);
    };
    
    // pipe the send file stream
    function sendfile(res, file, options, callback) {
      var done = false;
      var streaming;
    
      // request aborted
      function onaborted() {
        if (done) return;
        done = true;
    
        var err = new Error('Request aborted');
        err.code = 'ECONNABORTED';
        callback(err);
      }
    
      // directory
      function ondirectory() {
        if (done) return;
        done = true;
    
        var err = new Error('EISDIR, read');
        err.code = 'EISDIR';
        callback(err);
      }
    
      // errors
      function onerror(err) {
        if (done) return;
        done = true;
        callback(err);
      }
    
      // ended
      function onend() {
        if (done) return;
        done = true;
        callback();
      }
    
      // file
      function onfile() {
        streaming = false;
      }
    
      // finished
      function onfinish(err) {
        if (err && err.code === 'ECONNRESET') return onaborted();
        if (err) return onerror(err);
        if (done) return;
    
        setImmediate(function () {
          if (streaming !== false && !done) {
            onaborted();
            return;
          }
    
          if (done) return;
          done = true;
          callback();
        });
      }
    
      // streaming
      function onstream() {
        streaming = true;
      }
    
      file.on('directory', ondirectory);
      file.on('end', onend);
      file.on('error', onerror);
      file.on('file', onfile);
      file.on('stream', onstream);
      onFinished(res, onfinish);
    
      if (options.headers) {
        // set headers on successful transfer
        file.on('headers', function headers(res) {
          var obj = options.headers;
          var keys = Object.keys(obj);
    
          for (var i = 0; i < keys.length; i++) {
            var k = keys[i];
            res.setHeader(k, obj[k]);
          }
        });
      }
    
      // pipe
      file.pipe(res);
    }
    
  provide("express/lib/response", module.exports);
}(global));

// pakmanager:express/lib/express
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var EventEmitter = require('events').EventEmitter;
    var mixin = require('merge-descriptors');
    var proto =  require('express/lib/application');
    var Route =  require('express/lib/router/route');
    var Router =  require('express/lib/router');
    var req =  require('express/lib/request');
    var res =  require('express/lib/response');
    
    /**
     * Expose `createApplication()`.
     */
    
    exports = module.exports = createApplication;
    
    /**
     * Create an express application.
     *
     * @return {Function}
     * @api public
     */
    
    function createApplication() {
      var app = function(req, res, next) {
        app.handle(req, res, next);
      };
    
      mixin(app, EventEmitter.prototype, false);
      mixin(app, proto, false);
    
      app.request = { __proto__: req, app: app };
      app.response = { __proto__: res, app: app };
      app.init();
      return app;
    }
    
    /**
     * Expose the prototypes.
     */
    
    exports.application = proto;
    exports.request = req;
    exports.response = res;
    
    /**
     * Expose constructors.
     */
    
    exports.Route = Route;
    exports.Router = Router;
    
    /**
     * Expose middleware
     */
    
    exports.query =  require('express/lib/middleware/query');
    exports.static = require('serve-static');
    
    /**
     * Replace removed middleware with an appropriate error message.
     */
    
    [
      'json',
      'urlencoded',
      'bodyParser',
      'compress',
      'cookieSession',
      'session',
      'logger',
      'cookieParser',
      'favicon',
      'responseTime',
      'errorHandler',
      'timeout',
      'methodOverride',
      'vhost',
      'csrf',
      'directory',
      'limit',
      'multipart',
      'staticCache',
    ].forEach(function (name) {
      Object.defineProperty(exports, name, {
        get: function () {
          throw new Error('Most middleware (like ' + name + ') is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.');
        },
        configurable: true
      });
    });
    
  provide("express/lib/express", module.exports);
}(global));

// pakmanager:express
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    module.exports =  require('express/lib/express');
    
  provide("express", module.exports);
}(global));

// pakmanager:mocha/lib/pending
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Expose `Pending`.
     */
    
    module.exports = Pending;
    
    /**
     * Initialize a new `Pending` error with the given message.
     *
     * @param {String} message
     */
    
    function Pending(message) {
        this.message = message;
    }
    
  provide("mocha/lib/pending", module.exports);
}(global));

// pakmanager:mocha/lib/ms
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Helpers.
     */
    
    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    
    /**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} options
     * @return {String|Number}
     * @api public
     */
    
    module.exports = function(val, options){
      options = options || {};
      if ('string' == typeof val) return parse(val);
      return options['long'] ? longFormat(val) : shortFormat(val);
    };
    
    /**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */
    
    function parse(str) {
      var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
      if (!match) return;
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'y':
          return n * y;
        case 'days':
        case 'day':
        case 'd':
          return n * d;
        case 'hours':
        case 'hour':
        case 'h':
          return n * h;
        case 'minutes':
        case 'minute':
        case 'm':
          return n * m;
        case 'seconds':
        case 'second':
        case 's':
          return n * s;
        case 'ms':
          return n;
      }
    }
    
    /**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */
    
    function shortFormat(ms) {
      if (ms >= d) return Math.round(ms / d) + 'd';
      if (ms >= h) return Math.round(ms / h) + 'h';
      if (ms >= m) return Math.round(ms / m) + 'm';
      if (ms >= s) return Math.round(ms / s) + 's';
      return ms + 'ms';
    }
    
    /**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */
    
    function longFormat(ms) {
      return plural(ms, d, 'day')
        || plural(ms, h, 'hour')
        || plural(ms, m, 'minute')
        || plural(ms, s, 'second')
        || ms + ' ms';
    }
    
    /**
     * Pluralization helper.
     */
    
    function plural(ms, n, name) {
      if (ms < n) return;
      if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
      return Math.ceil(ms / n) + ' ' + name + 's';
    }
    
  provide("mocha/lib/ms", module.exports);
}(global));

// pakmanager:mocha/lib/utils
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var fs = require('fs')
      , path = require('path')
      , basename = path.basename
      , exists = fs.existsSync || path.existsSync
      , glob = require('glob')
      , join = path.join
      , debug = require('debug')('mocha:watch');
    
    /**
     * Ignored directories.
     */
    
    var ignore = ['node_modules', '.git'];
    
    /**
     * Escape special characters in the given string of html.
     *
     * @param  {String} html
     * @return {String}
     * @api private
     */
    
    exports.escape = function(html){
      return String(html)
        .replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    };
    
    /**
     * Array#forEach (<=IE8)
     *
     * @param {Array} array
     * @param {Function} fn
     * @param {Object} scope
     * @api private
     */
    
    exports.forEach = function(arr, fn, scope){
      for (var i = 0, l = arr.length; i < l; i++)
        fn.call(scope, arr[i], i);
    };
    
    /**
     * Test if the given obj is type of string
     *
     * @param {Object} obj
     * @returns Boolean
     */
    
    exports.isString = function(obj) {
      return 'string' === typeof obj;
    };
    
    /**
     * Array#map (<=IE8)
     *
     * @param {Array} array
     * @param {Function} fn
     * @param {Object} scope
     * @api private
     */
    
    exports.map = function(arr, fn, scope){
      var result = [];
      for (var i = 0, l = arr.length; i < l; i++)
        result.push(fn.call(scope, arr[i], i, arr));
      return result;
    };
    
    /**
     * Array#indexOf (<=IE8)
     *
     * @parma {Array} arr
     * @param {Object} obj to find index of
     * @param {Number} start
     * @api private
     */
    
    exports.indexOf = function(arr, obj, start){
      for (var i = start || 0, l = arr.length; i < l; i++) {
        if (arr[i] === obj)
          return i;
      }
      return -1;
    };
    
    /**
     * Array#reduce (<=IE8)
     *
     * @param {Array} array
     * @param {Function} fn
     * @param {Object} initial value
     * @api private
     */
    
    exports.reduce = function(arr, fn, val){
      var rval = val;
    
      for (var i = 0, l = arr.length; i < l; i++) {
        rval = fn(rval, arr[i], i, arr);
      }
    
      return rval;
    };
    
    /**
     * Array#filter (<=IE8)
     *
     * @param {Array} array
     * @param {Function} fn
     * @api private
     */
    
    exports.filter = function(arr, fn){
      var ret = [];
    
      for (var i = 0, l = arr.length; i < l; i++) {
        var val = arr[i];
        if (fn(val, i, arr)) ret.push(val);
      }
    
      return ret;
    };
    
    /**
     * Object.keys (<=IE8)
     *
     * @param {Object} obj
     * @return {Array} keys
     * @api private
     */
    
    exports.keys = Object.keys || function(obj) {
      var keys = []
        , has = Object.prototype.hasOwnProperty; // for `window` on <=IE8
    
      for (var key in obj) {
        if (has.call(obj, key)) {
          keys.push(key);
        }
      }
    
      return keys;
    };
    
    /**
     * Watch the given `files` for changes
     * and invoke `fn(file)` on modification.
     *
     * @param {Array} files
     * @param {Function} fn
     * @api private
     */
    
    exports.watch = function(files, fn){
      var options = { interval: 100 };
      files.forEach(function(file){
        debug('file %s', file);
        fs.watchFile(file, options, function(curr, prev){
          if (prev.mtime < curr.mtime) fn(file);
        });
      });
    };
    
    /**
     * Array.isArray (<=IE8)
     *
     * @param {Object} obj
     * @return {Boolean}
     * @api private
     */
    var isArray = Array.isArray || function (obj) {
      return '[object Array]' == {}.toString.call(obj);
    };
    
    /**
     * @description
     * Buffer.prototype.toJSON polyfill
     * @type {Function}
     */
    if(typeof Buffer !== 'undefined' && Buffer.prototype) {
      Buffer.prototype.toJSON = Buffer.prototype.toJSON || function () {
        return Array.prototype.slice.call(this, 0);
      };
    }
    
    /**
     * Ignored files.
     */
    
    function ignored(path){
      return !~ignore.indexOf(path);
    }
    
    /**
     * Lookup files in the given `dir`.
     *
     * @return {Array}
     * @api private
     */
    
    exports.files = function(dir, ext, ret){
      ret = ret || [];
      ext = ext || ['js'];
    
      var re = new RegExp('\\.(' + ext.join('|') + ')$');
    
      fs.readdirSync(dir)
        .filter(ignored)
        .forEach(function(path){
          path = join(dir, path);
          if (fs.statSync(path).isDirectory()) {
            exports.files(path, ext, ret);
          } else if (path.match(re)) {
            ret.push(path);
          }
        });
    
      return ret;
    };
    
    /**
     * Compute a slug from the given `str`.
     *
     * @param {String} str
     * @return {String}
     * @api private
     */
    
    exports.slug = function(str){
      return str
        .toLowerCase()
        .replace(/ +/g, '-')
        .replace(/[^-\w]/g, '');
    };
    
    /**
     * Strip the function definition from `str`,
     * and re-indent for pre whitespace.
     */
    
    exports.clean = function(str) {
      str = str
        .replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/^\uFEFF/, '')
        .replace(/^function *\(.*\)\s*{|\(.*\) *=> *{?/, '')
        .replace(/\s+\}$/, '');
    
      var spaces = str.match(/^\n?( *)/)[1].length
        , tabs = str.match(/^\n?(\t*)/)[1].length
        , re = new RegExp('^\n?' + (tabs ? '\t' : ' ') + '{' + (tabs ? tabs : spaces) + '}', 'gm');
    
      str = str.replace(re, '');
    
      return exports.trim(str);
    };
    
    /**
     * Trim the given `str`.
     *
     * @param {String} str
     * @return {String}
     * @api private
     */
    
    exports.trim = function(str){
      return str.replace(/^\s+|\s+$/g, '');
    };
    
    /**
     * Parse the given `qs`.
     *
     * @param {String} qs
     * @return {Object}
     * @api private
     */
    
    exports.parseQuery = function(qs){
      return exports.reduce(qs.replace('?', '').split('&'), function(obj, pair){
        var i = pair.indexOf('=')
          , key = pair.slice(0, i)
          , val = pair.slice(++i);
    
        obj[key] = decodeURIComponent(val);
        return obj;
      }, {});
    };
    
    /**
     * Highlight the given string of `js`.
     *
     * @param {String} js
     * @return {String}
     * @api private
     */
    
    function highlight(js) {
      return js
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/\/\/(.*)/gm, '<span class="comment">//$1</span>')
        .replace(/('.*?')/gm, '<span class="string">$1</span>')
        .replace(/(\d+\.\d+)/gm, '<span class="number">$1</span>')
        .replace(/(\d+)/gm, '<span class="number">$1</span>')
        .replace(/\bnew[ \t]+(\w+)/gm, '<span class="keyword">new</span> <span class="init">$1</span>')
        .replace(/\b(function|new|throw|return|var|if|else)\b/gm, '<span class="keyword">$1</span>')
    }
    
    /**
     * Highlight the contents of tag `name`.
     *
     * @param {String} name
     * @api private
     */
    
    exports.highlightTags = function(name) {
      var code = document.getElementById('mocha').getElementsByTagName(name);
      for (var i = 0, len = code.length; i < len; ++i) {
        code[i].innerHTML = highlight(code[i].innerHTML);
      }
    };
    
    /**
     * If a value could have properties, and has none, this function is called, which returns
     * a string representation of the empty value.
     *
     * Functions w/ no properties return `'[Function]'`
     * Arrays w/ length === 0 return `'[]'`
     * Objects w/ no properties return `'{}'`
     * All else: return result of `value.toString()`
     *
     * @param {*} value Value to inspect
     * @param {string} [type] The type of the value, if known.
     * @returns {string}
     */
    var emptyRepresentation = function emptyRepresentation(value, type) {
      type = type || exports.type(value);
    
      switch(type) {
        case 'function':
          return '[Function]';
        case 'object':
          return '{}';
        case 'array':
          return '[]';
        default:
          return value.toString();
      }
    };
    
    /**
     * Takes some variable and asks `{}.toString()` what it thinks it is.
     * @param {*} value Anything
     * @example
     * type({}) // 'object'
     * type([]) // 'array'
     * type(1) // 'number'
     * type(false) // 'boolean'
     * type(Infinity) // 'number'
     * type(null) // 'null'
     * type(new Date()) // 'date'
     * type(/foo/) // 'regexp'
     * type('type') // 'string'
     * type(global) // 'global'
     * @api private
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString
     * @returns {string}
     */
    exports.type = function type(value) {
      if (typeof Buffer !== 'undefined' && Buffer.isBuffer(value)) {
        return 'buffer';
      }
      return Object.prototype.toString.call(value)
        .replace(/^\[.+\s(.+?)\]$/, '$1')
        .toLowerCase();
    };
    
    /**
     * @summary Stringify `value`.
     * @description Different behavior depending on type of value.
     * - If `value` is undefined or null, return `'[undefined]'` or `'[null]'`, respectively.
     * - If `value` is not an object, function or array, return result of `value.toString()` wrapped in double-quotes.
     * - If `value` is an *empty* object, function, or array, return result of function
     *   {@link emptyRepresentation}.
     * - If `value` has properties, call {@link exports.canonicalize} on it, then return result of
     *   JSON.stringify().
     *
     * @see exports.type
     * @param {*} value
     * @return {string}
     * @api private
     */
    
    exports.stringify = function(value) {
      var type = exports.type(value);
    
      if (!~exports.indexOf(['object', 'array', 'function'], type)) {
        if(type != 'buffer') {
          return jsonStringify(value);
        }
        var json = value.toJSON();
        // Based on the toJSON result
        return jsonStringify(json.data && json.type ? json.data : json, 2)
          .replace(/,(\n|$)/g, '$1');
      }
    
      for (var prop in value) {
        if (Object.prototype.hasOwnProperty.call(value, prop)) {
          return jsonStringify(exports.canonicalize(value), 2).replace(/,(\n|$)/g, '$1');
        }
      }
    
      return emptyRepresentation(value, type);
    };
    
    /**
     * @description
     * like JSON.stringify but more sense.
     * @param {Object}  object
     * @param {Number=} spaces
     * @param {number=} depth
     * @returns {*}
     * @private
     */
    function jsonStringify(object, spaces, depth) {
      if(typeof spaces == 'undefined') return _stringify(object);  // primitive types
    
      depth = depth || 1;
      var space = spaces * depth
        , str = isArray(object) ? '[' : '{'
        , end = isArray(object) ? ']' : '}'
        , length = object.length || exports.keys(object).length
        , repeat = function(s, n) { return new Array(n).join(s); }; // `.repeat()` polyfill
    
      function _stringify(val) {
        switch (exports.type(val)) {
          case 'null':
          case 'undefined':
            val = '[' + val + ']';
            break;
          case 'array':
          case 'object':
            val = jsonStringify(val, spaces, depth + 1);
            break;
          case 'boolean':
          case 'regexp':
          case 'number':
            val = val === 0 && (1/val) === -Infinity // `-0`
              ? '-0'
              : val.toString();
            break;
          case 'date':
            var sDate = isNaN(val.getTime())        // Invalid date
              ? val.toString()
              : val.toISOString();
            val = '[Date: ' + sDate + ']';
            break;
          case 'buffer':
            var json = val.toJSON();
            // Based on the toJSON result
            json = json.data && json.type ? json.data : json;
            val = '[Buffer: ' + jsonStringify(json, 2, depth + 1) + ']';
            break;
          default:
            val = (val == '[Function]' || val == '[Circular]')
              ? val
              : JSON.stringify(val); //string
        }
        return val;
      }
    
      for(var i in object) {
        if(!object.hasOwnProperty(i)) continue;        // not my business
        --length;
        str += '\n ' + repeat(' ', space)
          + (isArray(object) ? '' : '"' + i + '": ') // key
          +  _stringify(object[i])                   // value
          + (length ? ',' : '');                     // comma
      }
    
      return str + (str.length != 1                    // [], {}
        ? '\n' + repeat(' ', --space) + end
        : end);
    }
    
    /**
     * Return if obj is a Buffer
     * @param {Object} arg
     * @return {Boolean}
     * @api private
     */
    exports.isBuffer = function (arg) {
      return typeof Buffer !== 'undefined' && Buffer.isBuffer(arg);
    };
    
    /**
     * @summary Return a new Thing that has the keys in sorted order.  Recursive.
     * @description If the Thing...
     * - has already been seen, return string `'[Circular]'`
     * - is `undefined`, return string `'[undefined]'`
     * - is `null`, return value `null`
     * - is some other primitive, return the value
     * - is not a primitive or an `Array`, `Object`, or `Function`, return the value of the Thing's `toString()` method
     * - is a non-empty `Array`, `Object`, or `Function`, return the result of calling this function again.
     * - is an empty `Array`, `Object`, or `Function`, return the result of calling `emptyRepresentation()`
     *
     * @param {*} value Thing to inspect.  May or may not have properties.
     * @param {Array} [stack=[]] Stack of seen values
     * @return {(Object|Array|Function|string|undefined)}
     * @see {@link exports.stringify}
     * @api private
     */
    
    exports.canonicalize = function(value, stack) {
      var canonicalizedObj,
        type = exports.type(value),
        prop,
        withStack = function withStack(value, fn) {
          stack.push(value);
          fn();
          stack.pop();
        };
    
      stack = stack || [];
    
      if (exports.indexOf(stack, value) !== -1) {
        return '[Circular]';
      }
    
      switch(type) {
        case 'undefined':
        case 'buffer':
        case 'null':
          canonicalizedObj = value;
          break;
        case 'array':
          withStack(value, function () {
            canonicalizedObj = exports.map(value, function (item) {
              return exports.canonicalize(item, stack);
            });
          });
          break;
        case 'function':
          for (prop in value) {
            canonicalizedObj = {};
            break;
          }
          if (!canonicalizedObj) {
            canonicalizedObj = emptyRepresentation(value, type);
            break;
          }
        /* falls through */
        case 'object':
          canonicalizedObj = canonicalizedObj || {};
          withStack(value, function () {
            exports.forEach(exports.keys(value).sort(), function (key) {
              canonicalizedObj[key] = exports.canonicalize(value[key], stack);
            });
          });
          break;
        case 'date':
        case 'number':
        case 'regexp':
        case 'boolean':
          canonicalizedObj = value;
          break;
        default:
          canonicalizedObj = value.toString();
      }
    
      return canonicalizedObj;
    };
    
    /**
     * Lookup file names at the given `path`.
     */
    exports.lookupFiles = function lookupFiles(path, extensions, recursive) {
      var files = [];
      var re = new RegExp('\\.(' + extensions.join('|') + ')$');
    
      if (!exists(path)) {
        if (exists(path + '.js')) {
          path += '.js';
        } else {
          files = glob.sync(path);
          if (!files.length) throw new Error("cannot resolve path (or pattern) '" + path + "'");
          return files;
        }
      }
    
      try {
        var stat = fs.statSync(path);
        if (stat.isFile()) return path;
      }
      catch (ignored) {
        return;
      }
    
      fs.readdirSync(path).forEach(function(file) {
        file = join(path, file);
        try {
          var stat = fs.statSync(file);
          if (stat.isDirectory()) {
            if (recursive) {
              files = files.concat(lookupFiles(file, extensions, recursive));
            }
            return;
          }
        }
        catch (ignored) {
          return;
        }
        if (!stat.isFile() || !re.test(file) || basename(file)[0] === '.') return;
        files.push(file);
      });
    
      return files;
    };
    
    /**
     * Generate an undefined error with a message warning the user.
     *
     * @return {Error}
     */
    
    exports.undefinedError = function() {
      return new Error('Caught undefined error, did you throw without specifying what?');
    };
    
    /**
     * Generate an undefined error if `err` is not defined.
     *
     * @param {Error} err
     * @return {Error}
     */
    
    exports.getError = function(err) {
      return err || exports.undefinedError();
    };
    
    
    /**
     * @summary
     * This Filter based on `mocha-clean` module.(see: `github.com/rstacruz/mocha-clean`)
     * @description
     * When invoking this function you get a filter function that get the Error.stack as an input,
     * and return a prettify output.
     * (i.e: strip Mocha, node_modules, bower and componentJS from stack trace).
     * @returns {Function}
     */
    
    exports.stackTraceFilter = function() {
      var slash = '/'
        , is = typeof document === 'undefined'
          ? { node: true }
          : { browser: true }
        , cwd = is.node
          ? process.cwd() + slash
          : location.href.replace(/\/[^\/]*$/, '/');
    
      function isNodeModule (line) {
        return (~line.indexOf('node_modules'));
      }
    
      function isMochaInternal (line) {
        return (~line.indexOf('node_modules' + slash + 'mocha'))  ||
          (~line.indexOf('components' + slash + 'mochajs'))       ||
          (~line.indexOf('components' + slash + 'mocha'));
      }
    
      // node_modules, bower, componentJS
      function isBrowserModule(line) {
        return (~line.indexOf('node_modules')) ||
          (~line.indexOf('components'));
      }
    
      function isNodeInternal (line) {
        return (~line.indexOf('(timers.js:')) ||
          (~line.indexOf('(events.js:'))      ||
          (~line.indexOf('(node.js:'))        ||
          (~line.indexOf('(module.js:'))      ||
          (~line.indexOf('GeneratorFunctionPrototype.next (native)')) ||
          false
      }
    
      return function(stack) {
        stack = stack.split('\n');
    
        stack = exports.reduce(stack, function(list, line) {
          if (is.node && (isNodeModule(line) ||
            isMochaInternal(line) ||
            isNodeInternal(line)))
            return list;
    
          if (is.browser && (isBrowserModule(line)))
            return list;
    
          // Clean up cwd(absolute)
          list.push(line.replace(cwd, ''));
          return list;
        }, []);
    
        return stack.join('\n');
      }
    };
  provide("mocha/lib/utils", module.exports);
}(global));

// pakmanager:mocha/lib/runnable
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var EventEmitter = require('events').EventEmitter
      , debug = require('debug')('mocha:runnable')
      , Pending =  require('mocha/lib/pending')
      , milliseconds =  require('mocha/lib/ms')
      , utils =  require('mocha/lib/utils');
    
    /**
     * Save timer references to avoid Sinon interfering (see GH-237).
     */
    
    var Date = global.Date
      , setTimeout = global.setTimeout
      , setInterval = global.setInterval
      , clearTimeout = global.clearTimeout
      , clearInterval = global.clearInterval;
    
    /**
     * Object#toString().
     */
    
    var toString = Object.prototype.toString;
    
    /**
     * Expose `Runnable`.
     */
    
    module.exports = Runnable;
    
    /**
     * Initialize a new `Runnable` with the given `title` and callback `fn`.
     *
     * @param {String} title
     * @param {Function} fn
     * @api private
     */
    
    function Runnable(title, fn) {
      this.title = title;
      this.fn = fn;
      this.async = fn && fn.length;
      this.sync = ! this.async;
      this._timeout = 2000;
      this._slow = 75;
      this._enableTimeouts = true;
      this.timedOut = false;
      this._trace = new Error('done() called multiple times')
    }
    
    /**
     * Inherit from `EventEmitter.prototype`.
     */
    
    Runnable.prototype.__proto__ = EventEmitter.prototype;
    
    /**
     * Set & get timeout `ms`.
     *
     * @param {Number|String} ms
     * @return {Runnable|Number} ms or self
     * @api private
     */
    
    Runnable.prototype.timeout = function(ms){
      if (0 == arguments.length) return this._timeout;
      if (ms === 0) this._enableTimeouts = false;
      if ('string' == typeof ms) ms = milliseconds(ms);
      debug('timeout %d', ms);
      this._timeout = ms;
      if (this.timer) this.resetTimeout();
      return this;
    };
    
    /**
     * Set & get slow `ms`.
     *
     * @param {Number|String} ms
     * @return {Runnable|Number} ms or self
     * @api private
     */
    
    Runnable.prototype.slow = function(ms){
      if (0 === arguments.length) return this._slow;
      if ('string' == typeof ms) ms = milliseconds(ms);
      debug('timeout %d', ms);
      this._slow = ms;
      return this;
    };
    
    /**
     * Set and & get timeout `enabled`.
     *
     * @param {Boolean} enabled
     * @return {Runnable|Boolean} enabled or self
     * @api private
     */
    
    Runnable.prototype.enableTimeouts = function(enabled){
      if (arguments.length === 0) return this._enableTimeouts;
      debug('enableTimeouts %s', enabled);
      this._enableTimeouts = enabled;
      return this;
    };
    
    /**
     * Halt and mark as pending.
     *
     * @api private
     */
    
    Runnable.prototype.skip = function(){
        throw new Pending();
    };
    
    /**
     * Return the full title generated by recursively
     * concatenating the parent's full title.
     *
     * @return {String}
     * @api public
     */
    
    Runnable.prototype.fullTitle = function(){
      return this.parent.fullTitle() + ' ' + this.title;
    };
    
    /**
     * Clear the timeout.
     *
     * @api private
     */
    
    Runnable.prototype.clearTimeout = function(){
      clearTimeout(this.timer);
    };
    
    /**
     * Inspect the runnable void of private properties.
     *
     * @return {String}
     * @api private
     */
    
    Runnable.prototype.inspect = function(){
      return JSON.stringify(this, function(key, val){
        if ('_' == key[0]) return;
        if ('parent' == key) return '#<Suite>';
        if ('ctx' == key) return '#<Context>';
        return val;
      }, 2);
    };
    
    /**
     * Reset the timeout.
     *
     * @api private
     */
    
    Runnable.prototype.resetTimeout = function(){
      var self = this;
      var ms = this.timeout() || 1e9;
    
      if (!this._enableTimeouts) return;
      this.clearTimeout();
      this.timer = setTimeout(function(){
        if (!self._enableTimeouts) return;
        self.callback(new Error('timeout of ' + ms + 'ms exceeded. Ensure the done() callback is being called in this test.'));
        self.timedOut = true;
      }, ms);
    };
    
    /**
     * Whitelist these globals for this test run
     *
     * @api private
     */
    Runnable.prototype.globals = function(arr){
      var self = this;
      this._allowedGlobals = arr;
    };
    
    /**
     * Run the test and invoke `fn(err)`.
     *
     * @param {Function} fn
     * @api private
     */
    
    Runnable.prototype.run = function(fn){
      var self = this
        , start = new Date
        , ctx = this.ctx
        , finished
        , emitted;
    
      // Some times the ctx exists but it is not runnable
      if (ctx && ctx.runnable) ctx.runnable(this);
    
      // called multiple times
      function multiple(err) {
        if (emitted) return;
        emitted = true;
        self.emit('error', err || new Error('done() called multiple times; stacktrace may be inaccurate'));
      }
    
      // finished
      function done(err) {
        var ms = self.timeout();
        if (self.timedOut) return;
        if (finished) return multiple(err || self._trace);
    
        // Discard the resolution if this test has already failed asynchronously
        if (self.state) return;
    
        self.clearTimeout();
        self.duration = new Date - start;
        finished = true;
        if (!err && self.duration > ms && self._enableTimeouts) err = new Error('timeout of ' + ms + 'ms exceeded. Ensure the done() callback is being called in this test.');
        fn(err);
      }
    
      // for .resetTimeout()
      this.callback = done;
    
      // explicit async with `done` argument
      if (this.async) {
        this.resetTimeout();
    
        try {
          this.fn.call(ctx, function(err){
            if (err instanceof Error || toString.call(err) === "[object Error]") return done(err);
            if (null != err) {
              if (Object.prototype.toString.call(err) === '[object Object]') {
                return done(new Error('done() invoked with non-Error: ' + JSON.stringify(err)));
              } else {
                return done(new Error('done() invoked with non-Error: ' + err));
              }
            }
            done();
          });
        } catch (err) {
          done(utils.getError(err));
        }
        return;
      }
    
      if (this.asyncOnly) {
        return done(new Error('--async-only option in use without declaring `done()`'));
      }
    
      // sync or promise-returning
      try {
        if (this.pending) {
          done();
        } else {
          callFn(this.fn);
        }
      } catch (err) {
        done(utils.getError(err));
      }
    
      function callFn(fn) {
        var result = fn.call(ctx);
        if (result && typeof result.then === 'function') {
          self.resetTimeout();
          result
            .then(function() {
              done()
            },
            function(reason) {
              done(reason || new Error('Promise rejected with no or falsy reason'))
            });
        } else {
          done();
        }
      }
    };
    
  provide("mocha/lib/runnable", module.exports);
}(global));

// pakmanager:mocha/lib/hook
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var Runnable =  require('mocha/lib/runnable');
    
    /**
     * Expose `Hook`.
     */
    
    module.exports = Hook;
    
    /**
     * Initialize a new `Hook` with the given `title` and callback `fn`.
     *
     * @param {String} title
     * @param {Function} fn
     * @api private
     */
    
    function Hook(title, fn) {
      Runnable.call(this, title, fn);
      this.type = 'hook';
    }
    
    /**
     * Inherit from `Runnable.prototype`.
     */
    
    Hook.prototype.__proto__ = Runnable.prototype;
    
    /**
     * Get or set the test `err`.
     *
     * @param {Error} err
     * @return {Error}
     * @api public
     */
    
    Hook.prototype.error = function(err){
      if (0 == arguments.length) {
        var err = this._error;
        this._error = null;
        return err;
      }
    
      this._error = err;
    };
    
  provide("mocha/lib/hook", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/base
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var tty = require('tty')
      , diff = require('diff')
      , ms =  require('mocha/lib/ms')
      , utils =  require('mocha/lib/utils')
      , supportsColor = process.env ? require('supports-color') : null;
    
    /**
     * Save timer references to avoid Sinon interfering (see GH-237).
     */
    
    var Date = global.Date
      , setTimeout = global.setTimeout
      , setInterval = global.setInterval
      , clearTimeout = global.clearTimeout
      , clearInterval = global.clearInterval;
    
    /**
     * Check if both stdio streams are associated with a tty.
     */
    
    var isatty = tty.isatty(1) && tty.isatty(2);
    
    /**
     * Expose `Base`.
     */
    
    exports = module.exports = Base;
    
    /**
     * Enable coloring by default, except in the browser interface.
     */
    
    exports.useColors = process.env
      ? (supportsColor || (process.env.MOCHA_COLORS !== undefined))
      : false;
    
    /**
     * Inline diffs instead of +/-
     */
    
    exports.inlineDiffs = false;
    
    /**
     * Default color map.
     */
    
    exports.colors = {
        'pass': 90
      , 'fail': 31
      , 'bright pass': 92
      , 'bright fail': 91
      , 'bright yellow': 93
      , 'pending': 36
      , 'suite': 0
      , 'error title': 0
      , 'error message': 31
      , 'error stack': 90
      , 'checkmark': 32
      , 'fast': 90
      , 'medium': 33
      , 'slow': 31
      , 'green': 32
      , 'light': 90
      , 'diff gutter': 90
      , 'diff added': 32
      , 'diff removed': 31
    };
    
    /**
     * Default symbol map.
     */
    
    exports.symbols = {
      ok: '✓',
      err: '✖',
      dot: '․'
    };
    
    // With node.js on Windows: use symbols available in terminal default fonts
    if ('win32' == process.platform) {
      exports.symbols.ok = '\u221A';
      exports.symbols.err = '\u00D7';
      exports.symbols.dot = '.';
    }
    
    /**
     * Color `str` with the given `type`,
     * allowing colors to be disabled,
     * as well as user-defined color
     * schemes.
     *
     * @param {String} type
     * @param {String} str
     * @return {String}
     * @api private
     */
    
    var color = exports.color = function(type, str) {
      if (!exports.useColors) return String(str);
      return '\u001b[' + exports.colors[type] + 'm' + str + '\u001b[0m';
    };
    
    /**
     * Expose term window size, with some
     * defaults for when stderr is not a tty.
     */
    
    exports.window = {
      width: isatty
        ? process.stdout.getWindowSize
          ? process.stdout.getWindowSize(1)[0]
          : tty.getWindowSize()[1]
        : 75
    };
    
    /**
     * Expose some basic cursor interactions
     * that are common among reporters.
     */
    
    exports.cursor = {
      hide: function(){
        isatty && process.stdout.write('\u001b[?25l');
      },
    
      show: function(){
        isatty && process.stdout.write('\u001b[?25h');
      },
    
      deleteLine: function(){
        isatty && process.stdout.write('\u001b[2K');
      },
    
      beginningOfLine: function(){
        isatty && process.stdout.write('\u001b[0G');
      },
    
      CR: function(){
        if (isatty) {
          exports.cursor.deleteLine();
          exports.cursor.beginningOfLine();
        } else {
          process.stdout.write('\r');
        }
      }
    };
    
    /**
     * Outut the given `failures` as a list.
     *
     * @param {Array} failures
     * @api public
     */
    
    exports.list = function(failures){
      console.log();
      failures.forEach(function(test, i){
        // format
        var fmt = color('error title', '  %s) %s:\n')
          + color('error message', '     %s')
          + color('error stack', '\n%s\n');
    
        // msg
        var err = test.err
          , message = err.message || ''
          , stack = err.stack || message
          , index = stack.indexOf(message)
          , actual = err.actual
          , expected = err.expected
          , escape = true;
        if (index === -1) {
          msg = message;
        } else {
          index += message.length;
          msg = stack.slice(0, index);
          // remove msg from stack
          stack = stack.slice(index + 1);
        }
    
        // uncaught
        if (err.uncaught) {
          msg = 'Uncaught ' + msg;
        }
        // explicitly show diff
        if (err.showDiff !== false && sameType(actual, expected)
            && expected !== undefined) {
    
          escape = false;
          if (!(utils.isString(actual) && utils.isString(expected))) {
            err.actual = actual = utils.stringify(actual);
            err.expected = expected = utils.stringify(expected);
          }
    
          fmt = color('error title', '  %s) %s:\n%s') + color('error stack', '\n%s\n');
          var match = message.match(/^([^:]+): expected/);
          msg = '\n      ' + color('error message', match ? match[1] : msg);
    
          if (exports.inlineDiffs) {
            msg += inlineDiff(err, escape);
          } else {
            msg += unifiedDiff(err, escape);
          }
        }
    
        // indent stack trace
        stack = stack.replace(/^/gm, '  ');
    
        console.log(fmt, (i + 1), test.fullTitle(), msg, stack);
      });
    };
    
    /**
     * Initialize a new `Base` reporter.
     *
     * All other reporters generally
     * inherit from this reporter, providing
     * stats such as test duration, number
     * of tests passed / failed etc.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function Base(runner) {
      var self = this
        , stats = this.stats = { suites: 0, tests: 0, passes: 0, pending: 0, failures: 0 }
        , failures = this.failures = [];
    
      if (!runner) return;
      this.runner = runner;
    
      runner.stats = stats;
    
      runner.on('start', function(){
        stats.start = new Date;
      });
    
      runner.on('suite', function(suite){
        stats.suites = stats.suites || 0;
        suite.root || stats.suites++;
      });
    
      runner.on('test end', function(test){
        stats.tests = stats.tests || 0;
        stats.tests++;
      });
    
      runner.on('pass', function(test){
        stats.passes = stats.passes || 0;
    
        var medium = test.slow() / 2;
        test.speed = test.duration > test.slow()
          ? 'slow'
          : test.duration > medium
            ? 'medium'
            : 'fast';
    
        stats.passes++;
      });
    
      runner.on('fail', function(test, err){
        stats.failures = stats.failures || 0;
        stats.failures++;
        test.err = err;
        failures.push(test);
      });
    
      runner.on('end', function(){
        stats.end = new Date;
        stats.duration = new Date - stats.start;
      });
    
      runner.on('pending', function(){
        stats.pending++;
      });
    }
    
    /**
     * Output common epilogue used by many of
     * the bundled reporters.
     *
     * @api public
     */
    
    Base.prototype.epilogue = function(){
      var stats = this.stats;
      var tests;
      var fmt;
    
      console.log();
    
      // passes
      fmt = color('bright pass', ' ')
        + color('green', ' %d passing')
        + color('light', ' (%s)');
    
      console.log(fmt,
        stats.passes || 0,
        ms(stats.duration));
    
      // pending
      if (stats.pending) {
        fmt = color('pending', ' ')
          + color('pending', ' %d pending');
    
        console.log(fmt, stats.pending);
      }
    
      // failures
      if (stats.failures) {
        fmt = color('fail', '  %d failing');
    
        console.log(fmt, stats.failures);
    
        Base.list(this.failures);
        console.log();
      }
    
      console.log();
    };
    
    /**
     * Pad the given `str` to `len`.
     *
     * @param {String} str
     * @param {String} len
     * @return {String}
     * @api private
     */
    
    function pad(str, len) {
      str = String(str);
      return Array(len - str.length + 1).join(' ') + str;
    }
    
    
    /**
     * Returns an inline diff between 2 strings with coloured ANSI output
     *
     * @param {Error} Error with actual/expected
     * @return {String} Diff
     * @api private
     */
    
    function inlineDiff(err, escape) {
      var msg = errorDiff(err, 'WordsWithSpace', escape);
    
      // linenos
      var lines = msg.split('\n');
      if (lines.length > 4) {
        var width = String(lines.length).length;
        msg = lines.map(function(str, i){
          return pad(++i, width) + ' |' + ' ' + str;
        }).join('\n');
      }
    
      // legend
      msg = '\n'
        + color('diff removed', 'actual')
        + ' '
        + color('diff added', 'expected')
        + '\n\n'
        + msg
        + '\n';
    
      // indent
      msg = msg.replace(/^/gm, '      ');
      return msg;
    }
    
    /**
     * Returns a unified diff between 2 strings
     *
     * @param {Error} Error with actual/expected
     * @return {String} Diff
     * @api private
     */
    
    function unifiedDiff(err, escape) {
      var indent = '      ';
      function cleanUp(line) {
        if (escape) {
          line = escapeInvisibles(line);
        }
        if (line[0] === '+') return indent + colorLines('diff added', line);
        if (line[0] === '-') return indent + colorLines('diff removed', line);
        if (line.match(/\@\@/)) return null;
        if (line.match(/\\ No newline/)) return null;
        else return indent + line;
      }
      function notBlank(line) {
        return line != null;
      }
      var msg = diff.createPatch('string', err.actual, err.expected);
      var lines = msg.split('\n').splice(4);
      return '\n      '
             + colorLines('diff added',   '+ expected') + ' '
             + colorLines('diff removed', '- actual')
             + '\n\n'
             + lines.map(cleanUp).filter(notBlank).join('\n');
    }
    
    /**
     * Return a character diff for `err`.
     *
     * @param {Error} err
     * @return {String}
     * @api private
     */
    
    function errorDiff(err, type, escape) {
      var actual   = escape ? escapeInvisibles(err.actual)   : err.actual;
      var expected = escape ? escapeInvisibles(err.expected) : err.expected;
      return diff['diff' + type](actual, expected).map(function(str){
        if (str.added) return colorLines('diff added', str.value);
        if (str.removed) return colorLines('diff removed', str.value);
        return str.value;
      }).join('');
    }
    
    /**
     * Returns a string with all invisible characters in plain text
     *
     * @param {String} line
     * @return {String}
     * @api private
     */
    function escapeInvisibles(line) {
        return line.replace(/\t/g, '<tab>')
                   .replace(/\r/g, '<CR>')
                   .replace(/\n/g, '<LF>\n');
    }
    
    /**
     * Color lines for `str`, using the color `name`.
     *
     * @param {String} name
     * @param {String} str
     * @return {String}
     * @api private
     */
    
    function colorLines(name, str) {
      return str.split('\n').map(function(str){
        return color(name, str);
      }).join('\n');
    }
    
    /**
     * Check that a / b have the same type.
     *
     * @param {Object} a
     * @param {Object} b
     * @return {Boolean}
     * @api private
     */
    
    function sameType(a, b) {
      a = Object.prototype.toString.call(a);
      b = Object.prototype.toString.call(b);
      return a == b;
    }
    
  provide("mocha/lib/reporters/base", module.exports);
}(global));

// pakmanager:mocha/lib/suite
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var EventEmitter = require('events').EventEmitter
      , debug = require('debug')('mocha:suite')
      , milliseconds =  require('mocha/lib/ms')
      , utils =  require('mocha/lib/utils')
      , Hook =  require('mocha/lib/hook');
    
    /**
     * Expose `Suite`.
     */
    
    exports = module.exports = Suite;
    
    /**
     * Create a new `Suite` with the given `title`
     * and parent `Suite`. When a suite with the
     * same title is already present, that suite
     * is returned to provide nicer reporter
     * and more flexible meta-testing.
     *
     * @param {Suite} parent
     * @param {String} title
     * @return {Suite}
     * @api public
     */
    
    exports.create = function(parent, title){
      var suite = new Suite(title, parent.ctx);
      suite.parent = parent;
      if (parent.pending) suite.pending = true;
      title = suite.fullTitle();
      parent.addSuite(suite);
      return suite;
    };
    
    /**
     * Initialize a new `Suite` with the given
     * `title` and `ctx`.
     *
     * @param {String} title
     * @param {Context} ctx
     * @api private
     */
    
    function Suite(title, parentContext) {
      this.title = title;
      var context = function() {};
      context.prototype = parentContext;
      this.ctx = new context();
      this.suites = [];
      this.tests = [];
      this.pending = false;
      this._beforeEach = [];
      this._beforeAll = [];
      this._afterEach = [];
      this._afterAll = [];
      this.root = !title;
      this._timeout = 2000;
      this._enableTimeouts = true;
      this._slow = 75;
      this._bail = false;
      this.delayed = false;
    }
    
    /**
     * Inherit from `EventEmitter.prototype`.
     */
    
    Suite.prototype.__proto__ = EventEmitter.prototype;
    
    /**
     * Return a clone of this `Suite`.
     *
     * @return {Suite}
     * @api private
     */
    
    Suite.prototype.clone = function(){
      var suite = new Suite(this.title);
      debug('clone');
      suite.ctx = this.ctx;
      suite.timeout(this.timeout());
      suite.enableTimeouts(this.enableTimeouts());
      suite.slow(this.slow());
      suite.bail(this.bail());
      return suite;
    };
    
    /**
     * Set timeout `ms` or short-hand such as "2s".
     *
     * @param {Number|String} ms
     * @return {Suite|Number} for chaining
     * @api private
     */
    
    Suite.prototype.timeout = function(ms){
      if (0 == arguments.length) return this._timeout;
      if (ms.toString() === '0') this._enableTimeouts = false;
      if ('string' == typeof ms) ms = milliseconds(ms);
      debug('timeout %d', ms);
      this._timeout = parseInt(ms, 10);
      return this;
    };
    
    /**
      * Set timeout `enabled`.
      *
      * @param {Boolean} enabled
      * @return {Suite|Boolean} self or enabled
      * @api private
      */
    
    Suite.prototype.enableTimeouts = function(enabled){
      if (arguments.length === 0) return this._enableTimeouts;
      debug('enableTimeouts %s', enabled);
      this._enableTimeouts = enabled;
      return this;
    };
    
    /**
     * Set slow `ms` or short-hand such as "2s".
     *
     * @param {Number|String} ms
     * @return {Suite|Number} for chaining
     * @api private
     */
    
    Suite.prototype.slow = function(ms){
      if (0 === arguments.length) return this._slow;
      if ('string' == typeof ms) ms = milliseconds(ms);
      debug('slow %d', ms);
      this._slow = ms;
      return this;
    };
    
    /**
     * Sets whether to bail after first error.
     *
     * @param {Boolean} bail
     * @return {Suite|Number} for chaining
     * @api private
     */
    
    Suite.prototype.bail = function(bail){
      if (0 == arguments.length) return this._bail;
      debug('bail %s', bail);
      this._bail = bail;
      return this;
    };
    
    /**
     * Run `fn(test[, done])` before running tests.
     *
     * @param {Function} fn
     * @return {Suite} for chaining
     * @api private
     */
    
    Suite.prototype.beforeAll = function(title, fn){
      if (this.pending) return this;
      if ('function' === typeof title) {
        fn = title;
        title = fn.name;
      }
      title = '"before all" hook' + (title ? ': ' + title : '');
    
      var hook = new Hook(title, fn);
      hook.parent = this;
      hook.timeout(this.timeout());
      hook.enableTimeouts(this.enableTimeouts());
      hook.slow(this.slow());
      hook.ctx = this.ctx;
      this._beforeAll.push(hook);
      this.emit('beforeAll', hook);
      return this;
    };
    
    /**
     * Run `fn(test[, done])` after running tests.
     *
     * @param {Function} fn
     * @return {Suite} for chaining
     * @api private
     */
    
    Suite.prototype.afterAll = function(title, fn){
      if (this.pending) return this;
      if ('function' === typeof title) {
        fn = title;
        title = fn.name;
      }
      title = '"after all" hook' + (title ? ': ' + title : '');
    
      var hook = new Hook(title, fn);
      hook.parent = this;
      hook.timeout(this.timeout());
      hook.enableTimeouts(this.enableTimeouts());
      hook.slow(this.slow());
      hook.ctx = this.ctx;
      this._afterAll.push(hook);
      this.emit('afterAll', hook);
      return this;
    };
    
    /**
     * Run `fn(test[, done])` before each test case.
     *
     * @param {Function} fn
     * @return {Suite} for chaining
     * @api private
     */
    
    Suite.prototype.beforeEach = function(title, fn){
      if (this.pending) return this;
      if ('function' === typeof title) {
        fn = title;
        title = fn.name;
      }
      title = '"before each" hook' + (title ? ': ' + title : '');
    
      var hook = new Hook(title, fn);
      hook.parent = this;
      hook.timeout(this.timeout());
      hook.enableTimeouts(this.enableTimeouts());
      hook.slow(this.slow());
      hook.ctx = this.ctx;
      this._beforeEach.push(hook);
      this.emit('beforeEach', hook);
      return this;
    };
    
    /**
     * Run `fn(test[, done])` after each test case.
     *
     * @param {Function} fn
     * @return {Suite} for chaining
     * @api private
     */
    
    Suite.prototype.afterEach = function(title, fn){
      if (this.pending) return this;
      if ('function' === typeof title) {
        fn = title;
        title = fn.name;
      }
      title = '"after each" hook' + (title ? ': ' + title : '');
    
      var hook = new Hook(title, fn);
      hook.parent = this;
      hook.timeout(this.timeout());
      hook.enableTimeouts(this.enableTimeouts());
      hook.slow(this.slow());
      hook.ctx = this.ctx;
      this._afterEach.push(hook);
      this.emit('afterEach', hook);
      return this;
    };
    
    /**
     * Add a test `suite`.
     *
     * @param {Suite} suite
     * @return {Suite} for chaining
     * @api private
     */
    
    Suite.prototype.addSuite = function(suite){
      suite.parent = this;
      suite.timeout(this.timeout());
      suite.enableTimeouts(this.enableTimeouts());
      suite.slow(this.slow());
      suite.bail(this.bail());
      this.suites.push(suite);
      this.emit('suite', suite);
      return this;
    };
    
    /**
     * Add a `test` to this suite.
     *
     * @param {Test} test
     * @return {Suite} for chaining
     * @api private
     */
    
    Suite.prototype.addTest = function(test){
      test.parent = this;
      test.timeout(this.timeout());
      test.enableTimeouts(this.enableTimeouts());
      test.slow(this.slow());
      test.ctx = this.ctx;
      this.tests.push(test);
      this.emit('test', test);
      return this;
    };
    
    /**
     * Return the full title generated by recursively
     * concatenating the parent's full title.
     *
     * @return {String}
     * @api public
     */
    
    Suite.prototype.fullTitle = function(){
      if (this.parent) {
        var full = this.parent.fullTitle();
        if (full) return full + ' ' + this.title;
      }
      return this.title;
    };
    
    /**
     * Return the total number of tests.
     *
     * @return {Number}
     * @api public
     */
    
    Suite.prototype.total = function(){
      return utils.reduce(this.suites, function(sum, suite){
        return sum + suite.total();
      }, 0) + this.tests.length;
    };
    
    /**
     * Iterates through each suite recursively to find
     * all tests. Applies a function in the format
     * `fn(test)`.
     *
     * @param {Function} fn
     * @return {Suite}
     * @api private
     */
    
    Suite.prototype.eachTest = function(fn){
      utils.forEach(this.tests, fn);
      utils.forEach(this.suites, function(suite){
        suite.eachTest(fn);
      });
      return this;
    };
    
    /**
     * This will run the root suite if we happen to be running in delayed mode.
     */
    Suite.prototype.run = function run() {
      if (this.root) {
        this.emit('run');
      }
    };
    
  provide("mocha/lib/suite", module.exports);
}(global));

// pakmanager:mocha/lib/test
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var Runnable =  require('mocha/lib/runnable');
    
    /**
     * Expose `Test`.
     */
    
    module.exports = Test;
    
    /**
     * Initialize a new `Test` with the given `title` and callback `fn`.
     *
     * @param {String} title
     * @param {Function} fn
     * @api private
     */
    
    function Test(title, fn) {
      Runnable.call(this, title, fn);
      this.pending = !fn;
      this.type = 'test';
    }
    
    /**
     * Inherit from `Runnable.prototype`.
     */
    
    Test.prototype.__proto__ = Runnable.prototype;
    
  provide("mocha/lib/test", module.exports);
}(global));

// pakmanager:mocha/lib/interfaces/common
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Functions common to more than one interface
     * @module lib/interfaces/common
     */
    
    'use strict';
    
    module.exports = function (suites, context) {
    
      return {
        /**
         * This is only present if flag --delay is passed into Mocha.  It triggers
         * root suite execution.  Returns a function which runs the root suite.
         */
        runWithSuite: function runWithSuite(suite) {
          return function run() {
            suite.run();
          };
        },
    
        /**
         * Execute before running tests.
         */
        before: function (name, fn) {
          suites[0].beforeAll(name, fn);
        },
    
        /**
         * Execute after running tests.
         */
        after: function (name, fn) {
          suites[0].afterAll(name, fn);
        },
    
        /**
         * Execute before each test case.
         */
        beforeEach: function (name, fn) {
          suites[0].beforeEach(name, fn);
        },
    
        /**
         * Execute after each test case.
         */
        afterEach: function (name, fn) {
          suites[0].afterEach(name, fn);
        },
    
        test: {
          /**
           * Pending test case.
           */
          skip: function (title) {
            context.test(title);
          }
        }
      }
    };
    
  provide("mocha/lib/interfaces/common", module.exports);
}(global));

// pakmanager:mocha/lib/browser/progress
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Expose `Progress`.
     */
    
    module.exports = Progress;
    
    /**
     * Initialize a new `Progress` indicator.
     */
    
    function Progress() {
      this.percent = 0;
      this.size(0);
      this.fontSize(11);
      this.font('helvetica, arial, sans-serif');
    }
    
    /**
     * Set progress size to `n`.
     *
     * @param {Number} n
     * @return {Progress} for chaining
     * @api public
     */
    
    Progress.prototype.size = function(n){
      this._size = n;
      return this;
    };
    
    /**
     * Set text to `str`.
     *
     * @param {String} str
     * @return {Progress} for chaining
     * @api public
     */
    
    Progress.prototype.text = function(str){
      this._text = str;
      return this;
    };
    
    /**
     * Set font size to `n`.
     *
     * @param {Number} n
     * @return {Progress} for chaining
     * @api public
     */
    
    Progress.prototype.fontSize = function(n){
      this._fontSize = n;
      return this;
    };
    
    /**
     * Set font `family`.
     *
     * @param {String} family
     * @return {Progress} for chaining
     */
    
    Progress.prototype.font = function(family){
      this._font = family;
      return this;
    };
    
    /**
     * Update percentage to `n`.
     *
     * @param {Number} n
     * @return {Progress} for chaining
     */
    
    Progress.prototype.update = function(n){
      this.percent = n;
      return this;
    };
    
    /**
     * Draw on `ctx`.
     *
     * @param {CanvasRenderingContext2d} ctx
     * @return {Progress} for chaining
     */
    
    Progress.prototype.draw = function(ctx){
      try {
        var percent = Math.min(this.percent, 100)
          , size = this._size
          , half = size / 2
          , x = half
          , y = half
          , rad = half - 1
          , fontSize = this._fontSize;
    
        ctx.font = fontSize + 'px ' + this._font;
    
        var angle = Math.PI * 2 * (percent / 100);
        ctx.clearRect(0, 0, size, size);
    
        // outer circle
        ctx.strokeStyle = '#9f9f9f';
        ctx.beginPath();
        ctx.arc(x, y, rad, 0, angle, false);
        ctx.stroke();
    
        // inner circle
        ctx.strokeStyle = '#eee';
        ctx.beginPath();
        ctx.arc(x, y, rad - 1, 0, angle, true);
        ctx.stroke();
    
        // text
        var text = this._text || (percent | 0) + '%'
          , w = ctx.measureText(text).width;
    
        ctx.fillText(
            text
          , x - w / 2 + 1
          , y + fontSize / 2 - 1);
      } catch (ex) {} //don't fail if we can't render progress
      return this;
    };
    
  provide("mocha/lib/browser/progress", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/json-cov
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base');
    
    /**
     * Expose `JSONCov`.
     */
    
    exports = module.exports = JSONCov;
    
    /**
     * Initialize a new `JsCoverage` reporter.
     *
     * @param {Runner} runner
     * @param {Boolean} output
     * @api public
     */
    
    function JSONCov(runner, output) {
      var self = this
        , output = 1 == arguments.length ? true : output;
    
      Base.call(this, runner);
    
      var tests = []
        , failures = []
        , passes = [];
    
      runner.on('test end', function(test){
        tests.push(test);
      });
    
      runner.on('pass', function(test){
        passes.push(test);
      });
    
      runner.on('fail', function(test){
        failures.push(test);
      });
    
      runner.on('end', function(){
        var cov = global._$jscoverage || {};
        var result = self.cov = map(cov);
        result.stats = self.stats;
        result.tests = tests.map(clean);
        result.failures = failures.map(clean);
        result.passes = passes.map(clean);
        if (!output) return;
        process.stdout.write(JSON.stringify(result, null, 2 ));
      });
    }
    
    /**
     * Map jscoverage data to a JSON structure
     * suitable for reporting.
     *
     * @param {Object} cov
     * @return {Object}
     * @api private
     */
    
    function map(cov) {
      var ret = {
          instrumentation: 'node-jscoverage'
        , sloc: 0
        , hits: 0
        , misses: 0
        , coverage: 0
        , files: []
      };
    
      for (var filename in cov) {
        var data = coverage(filename, cov[filename]);
        ret.files.push(data);
        ret.hits += data.hits;
        ret.misses += data.misses;
        ret.sloc += data.sloc;
      }
    
      ret.files.sort(function(a, b) {
        return a.filename.localeCompare(b.filename);
      });
    
      if (ret.sloc > 0) {
        ret.coverage = (ret.hits / ret.sloc) * 100;
      }
    
      return ret;
    }
    
    /**
     * Map jscoverage data for a single source file
     * to a JSON structure suitable for reporting.
     *
     * @param {String} filename name of the source file
     * @param {Object} data jscoverage coverage data
     * @return {Object}
     * @api private
     */
    
    function coverage(filename, data) {
      var ret = {
        filename: filename,
        coverage: 0,
        hits: 0,
        misses: 0,
        sloc: 0,
        source: {}
      };
    
      data.source.forEach(function(line, num){
        num++;
    
        if (data[num] === 0) {
          ret.misses++;
          ret.sloc++;
        } else if (data[num] !== undefined) {
          ret.hits++;
          ret.sloc++;
        }
    
        ret.source[num] = {
            source: line
          , coverage: data[num] === undefined
            ? ''
            : data[num]
        };
      });
    
      ret.coverage = ret.hits / ret.sloc * 100;
    
      return ret;
    }
    
    /**
     * Return a plain-object representation of `test`
     * free of cyclic properties etc.
     *
     * @param {Object} test
     * @return {Object}
     * @api private
     */
    
    function clean(test) {
      return {
          title: test.title
        , fullTitle: test.fullTitle()
        , duration: test.duration
      }
    }
    
  provide("mocha/lib/reporters/json-cov", module.exports);
}(global));

// pakmanager:mocha/lib/interfaces/bdd
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var Suite =  require('mocha/lib/suite')
      , Test =  require('mocha/lib/test')
      , utils =  require('mocha/lib/utils')
      , escapeRe = require('escape-string-regexp');
    
    /**
     * BDD-style interface:
     *
     *      describe('Array', function(){
     *        describe('#indexOf()', function(){
     *          it('should return -1 when not present', function(){
     *
     *          });
     *
     *          it('should return the index when present', function(){
     *
     *          });
     *        });
     *      });
     *
     */
    
    module.exports = function(suite){
      var suites = [suite];
    
      suite.on('pre-require', function(context, file, mocha){
    
        var common =  require('mocha/lib/interfaces/common')(suites, context);
    
        context.before = common.before;
        context.after = common.after;
        context.beforeEach = common.beforeEach;
        context.afterEach = common.afterEach;
        context.run = mocha.options.delay && common.runWithSuite(suite);
        /**
         * Describe a "suite" with the given `title`
         * and callback `fn` containing nested suites
         * and/or tests.
         */
    
        context.describe = context.context = function(title, fn){
          var suite = Suite.create(suites[0], title);
          suite.file = file;
          suites.unshift(suite);
          fn.call(suite);
          suites.shift();
          return suite;
        };
    
        /**
         * Pending describe.
         */
    
        context.xdescribe =
        context.xcontext =
        context.describe.skip = function(title, fn){
          var suite = Suite.create(suites[0], title);
          suite.pending = true;
          suites.unshift(suite);
          fn.call(suite);
          suites.shift();
        };
    
        /**
         * Exclusive suite.
         */
    
        context.describe.only = function(title, fn){
          var suite = context.describe(title, fn);
          mocha.grep(suite.fullTitle());
          return suite;
        };
    
        /**
         * Describe a specification or test-case
         * with the given `title` and callback `fn`
         * acting as a thunk.
         */
    
        context.it = context.specify = function(title, fn){
          var suite = suites[0];
          if (suite.pending) fn = null;
          var test = new Test(title, fn);
          test.file = file;
          suite.addTest(test);
          return test;
        };
    
        /**
         * Exclusive test-case.
         */
    
        context.it.only = function(title, fn){
          var test = context.it(title, fn);
          var reString = '^' + escapeRe(test.fullTitle()) + '$';
          mocha.grep(new RegExp(reString));
          return test;
        };
    
        /**
         * Pending test case.
         */
    
        context.xit =
        context.xspecify =
        context.it.skip = function(title){
          context.it(title);
        };
    
      });
    };
    
  provide("mocha/lib/interfaces/bdd", module.exports);
}(global));

// pakmanager:mocha/lib/interfaces/tdd
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var Suite =  require('mocha/lib/suite')
      , Test =  require('mocha/lib/test')
      , escapeRe = require('escape-string-regexp')
      , utils =  require('mocha/lib/utils');
    
    /**
     * TDD-style interface:
     *
     *      suite('Array', function(){
     *        suite('#indexOf()', function(){
     *          suiteSetup(function(){
     *
     *          });
     *
     *          test('should return -1 when not present', function(){
     *
     *          });
     *
     *          test('should return the index when present', function(){
     *
     *          });
     *
     *          suiteTeardown(function(){
     *
     *          });
     *        });
     *      });
     *
     */
    
    module.exports = function(suite){
      var suites = [suite];
    
      suite.on('pre-require', function(context, file, mocha){
    
        var common =  require('mocha/lib/interfaces/common')(suites, context);
    
        context.setup = common.beforeEach;
        context.teardown = common.afterEach;
        context.suiteSetup = common.before;
        context.suiteTeardown = common.after;
        context.run = mocha.options.delay && common.runWithSuite(suite);
        /**
         * Describe a "suite" with the given `title`
         * and callback `fn` containing nested suites
         * and/or tests.
         */
    
        context.suite = function(title, fn){
          var suite = Suite.create(suites[0], title);
          suite.file = file;
          suites.unshift(suite);
          fn.call(suite);
          suites.shift();
          return suite;
        };
    
        /**
         * Pending suite.
         */
        context.suite.skip = function(title, fn) {
          var suite = Suite.create(suites[0], title);
          suite.pending = true;
          suites.unshift(suite);
          fn.call(suite);
          suites.shift();
        };
    
        /**
         * Exclusive test-case.
         */
    
        context.suite.only = function(title, fn){
          var suite = context.suite(title, fn);
          mocha.grep(suite.fullTitle());
        };
    
        /**
         * Describe a specification or test-case
         * with the given `title` and callback `fn`
         * acting as a thunk.
         */
    
        context.test = function(title, fn){
          var suite = suites[0];
          if (suite.pending) fn = null;
          var test = new Test(title, fn);
          test.file = file;
          suite.addTest(test);
          return test;
        };
    
        /**
         * Exclusive test-case.
         */
    
        context.test.only = function(title, fn){
          var test = context.test(title, fn);
          var reString = '^' + escapeRe(test.fullTitle()) + '$';
          mocha.grep(new RegExp(reString));
        };
    
        context.test.skip = common.test.skip;
      });
    };
    
  provide("mocha/lib/interfaces/tdd", module.exports);
}(global));

// pakmanager:mocha/lib/interfaces/qunit
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var Suite =  require('mocha/lib/suite')
      , Test =  require('mocha/lib/test')
      , escapeRe = require('escape-string-regexp')
      , utils =  require('mocha/lib/utils');
    
    /**
     * QUnit-style interface:
     *
     *     suite('Array');
     *
     *     test('#length', function(){
     *       var arr = [1,2,3];
     *       ok(arr.length == 3);
     *     });
     *
     *     test('#indexOf()', function(){
     *       var arr = [1,2,3];
     *       ok(arr.indexOf(1) == 0);
     *       ok(arr.indexOf(2) == 1);
     *       ok(arr.indexOf(3) == 2);
     *     });
     *
     *     suite('String');
     *
     *     test('#length', function(){
     *       ok('foo'.length == 3);
     *     });
     *
     */
    
    module.exports = function(suite){
      var suites = [suite];
    
      suite.on('pre-require', function(context, file, mocha){
    
        var common =  require('mocha/lib/interfaces/common')(suites, context);
    
        context.before = common.before;
        context.after = common.after;
        context.beforeEach = common.beforeEach;
        context.afterEach = common.afterEach;
        context.run = mocha.options.delay && common.runWithSuite(suite);
        /**
         * Describe a "suite" with the given `title`.
         */
    
        context.suite = function(title){
          if (suites.length > 1) suites.shift();
          var suite = Suite.create(suites[0], title);
          suite.file = file;
          suites.unshift(suite);
          return suite;
        };
    
        /**
         * Exclusive test-case.
         */
    
        context.suite.only = function(title, fn){
          var suite = context.suite(title, fn);
          mocha.grep(suite.fullTitle());
        };
    
        /**
         * Describe a specification or test-case
         * with the given `title` and callback `fn`
         * acting as a thunk.
         */
    
        context.test = function(title, fn){
          var test = new Test(title, fn);
          test.file = file;
          suites[0].addTest(test);
          return test;
        };
    
        /**
         * Exclusive test-case.
         */
    
        context.test.only = function(title, fn){
          var test = context.test(title, fn);
          var reString = '^' + escapeRe(test.fullTitle()) + '$';
          mocha.grep(new RegExp(reString));
        };
    
        context.test.skip = common.test.skip;
    
      });
    };
    
  provide("mocha/lib/interfaces/qunit", module.exports);
}(global));

// pakmanager:mocha/lib/interfaces/exports
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var Suite =  require('mocha/lib/suite')
      , Test =  require('mocha/lib/test');
    
    /**
     * TDD-style interface:
     *
     *     exports.Array = {
     *       '#indexOf()': {
     *         'should return -1 when the value is not present': function(){
     *
     *         },
     *
     *         'should return the correct index when the value is present': function(){
     *
     *         }
     *       }
     *     };
     *
     */
    
    module.exports = function(suite){
      var suites = [suite];
    
      suite.on('require', visit);
    
      function visit(obj, file) {
        var suite;
        for (var key in obj) {
          if ('function' == typeof obj[key]) {
            var fn = obj[key];
            switch (key) {
              case 'before':
                suites[0].beforeAll(fn);
                break;
              case 'after':
                suites[0].afterAll(fn);
                break;
              case 'beforeEach':
                suites[0].beforeEach(fn);
                break;
              case 'afterEach':
                suites[0].afterEach(fn);
                break;
              default:
                var test = new Test(key, fn);
                test.file = file;
                suites[0].addTest(test);
            }
          } else {
            suite = Suite.create(suites[0], key);
            suites.unshift(suite);
            visit(obj[key]);
            suites.shift();
          }
        }
      }
    };
    
  provide("mocha/lib/interfaces/exports", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/dot
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base')
      , color = Base.color;
    
    /**
     * Expose `Dot`.
     */
    
    exports = module.exports = Dot;
    
    /**
     * Initialize a new `Dot` matrix test reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function Dot(runner) {
      Base.call(this, runner);
    
      var self = this
        , stats = this.stats
        , width = Base.window.width * .75 | 0
        , n = -1;
    
      runner.on('start', function(){
        process.stdout.write('\n');
      });
    
      runner.on('pending', function(test){
        if (++n % width == 0) process.stdout.write('\n  ');
        process.stdout.write(color('pending', Base.symbols.dot));
      });
    
      runner.on('pass', function(test){
        if (++n % width == 0) process.stdout.write('\n  ');
        if ('slow' == test.speed) {
          process.stdout.write(color('bright yellow', Base.symbols.dot));
        } else {
          process.stdout.write(color(test.speed, Base.symbols.dot));
        }
      });
    
      runner.on('fail', function(test, err){
        if (++n % width == 0) process.stdout.write('\n  ');
        process.stdout.write(color('fail', Base.symbols.dot));
      });
    
      runner.on('end', function(){
        console.log();
        self.epilogue();
      });
    }
    
    /**
     * Inherit from `Base.prototype`.
     */
    
    Dot.prototype.__proto__ = Base.prototype;
    
  provide("mocha/lib/reporters/dot", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/doc
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base')
      , utils =  require('mocha/lib/utils');
    
    /**
     * Expose `Doc`.
     */
    
    exports = module.exports = Doc;
    
    /**
     * Initialize a new `Doc` reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function Doc(runner) {
      Base.call(this, runner);
    
      var self = this
        , stats = this.stats
        , total = runner.total
        , indents = 2;
    
      function indent() {
        return Array(indents).join('  ');
      }
    
      runner.on('suite', function(suite){
        if (suite.root) return;
        ++indents;
        console.log('%s<section class="suite">', indent());
        ++indents;
        console.log('%s<h1>%s</h1>', indent(), utils.escape(suite.title));
        console.log('%s<dl>', indent());
      });
    
      runner.on('suite end', function(suite){
        if (suite.root) return;
        console.log('%s</dl>', indent());
        --indents;
        console.log('%s</section>', indent());
        --indents;
      });
    
      runner.on('pass', function(test){
        console.log('%s  <dt>%s</dt>', indent(), utils.escape(test.title));
        var code = utils.escape(utils.clean(test.fn.toString()));
        console.log('%s  <dd><pre><code>%s</code></pre></dd>', indent(), code);
      });
    
      runner.on('fail', function(test, err){
        console.log('%s  <dt class="error">%s</dt>', indent(), utils.escape(test.title));
        var code = utils.escape(utils.clean(test.fn.toString()));
        console.log('%s  <dd class="error"><pre><code>%s</code></pre></dd>', indent(), code);
        console.log('%s  <dd class="error">%s</dd>', indent(), utils.escape(err));
      });
    }
    
  provide("mocha/lib/reporters/doc", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/tap
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base')
      , cursor = Base.cursor
      , color = Base.color;
    
    /**
     * Expose `TAP`.
     */
    
    exports = module.exports = TAP;
    
    /**
     * Initialize a new `TAP` reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function TAP(runner) {
      Base.call(this, runner);
    
      var self = this
        , stats = this.stats
        , n = 1
        , passes = 0
        , failures = 0;
    
      runner.on('start', function(){
        var total = runner.grepTotal(runner.suite);
        console.log('%d..%d', 1, total);
      });
    
      runner.on('test end', function(){
        ++n;
      });
    
      runner.on('pending', function(test){
        console.log('ok %d %s # SKIP -', n, title(test));
      });
    
      runner.on('pass', function(test){
        passes++;
        console.log('ok %d %s', n, title(test));
      });
    
      runner.on('fail', function(test, err){
        failures++;
        console.log('not ok %d %s', n, title(test));
        if (err.stack) console.log(err.stack.replace(/^/gm, '  '));
      });
    
      runner.on('end', function(){
        console.log('# tests ' + (passes + failures));
        console.log('# pass ' + passes);
        console.log('# fail ' + failures);
      });
    }
    
    /**
     * Return a TAP-safe title of `test`
     *
     * @param {Object} test
     * @return {String}
     * @api private
     */
    
    function title(test) {
      return test.fullTitle().replace(/#/g, '');
    }
    
  provide("mocha/lib/reporters/tap", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/json
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base')
      , cursor = Base.cursor
      , color = Base.color;
    
    /**
     * Expose `JSON`.
     */
    
    exports = module.exports = JSONReporter;
    
    /**
     * Initialize a new `JSON` reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function JSONReporter(runner) {
      var self = this;
      Base.call(this, runner);
    
      var tests = []
        , pending = []
        , failures = []
        , passes = [];
    
      runner.on('test end', function(test){
        tests.push(test);
      });
    
      runner.on('pass', function(test){
        passes.push(test);
      });
    
      runner.on('fail', function(test){
        failures.push(test);
      });
    
      runner.on('pending', function(test){
        pending.push(test);
      });
    
      runner.on('end', function(){
        var obj = {
          stats: self.stats,
          tests: tests.map(clean),
          pending: pending.map(clean),
          failures: failures.map(clean),
          passes: passes.map(clean)
        };
    
        runner.testResults = obj;
    
        process.stdout.write(JSON.stringify(obj, null, 2));
      });
    }
    
    /**
     * Return a plain-object representation of `test`
     * free of cyclic properties etc.
     *
     * @param {Object} test
     * @return {Object}
     * @api private
     */
    
    function clean(test) {
      return {
        title: test.title,
        fullTitle: test.fullTitle(),
        duration: test.duration,
        err: errorJSON(test.err || {})
      }
    }
    
    /**
     * Transform `error` into a JSON object.
     * @param {Error} err
     * @return {Object}
     */
    
    function errorJSON(err) {
      var res = {};
      Object.getOwnPropertyNames(err).forEach(function(key) {
        res[key] = err[key];
      }, err);
      return res;
    }
    
  provide("mocha/lib/reporters/json", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/html
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base')
      , utils =  require('mocha/lib/utils')
      , Progress =  require('mocha/lib/browser/progress')
      , escape = utils.escape;
    
    /**
     * Save timer references to avoid Sinon interfering (see GH-237).
     */
    
    var Date = global.Date
      , setTimeout = global.setTimeout
      , setInterval = global.setInterval
      , clearTimeout = global.clearTimeout
      , clearInterval = global.clearInterval;
    
    /**
     * Expose `HTML`.
     */
    
    exports = module.exports = HTML;
    
    /**
     * Stats template.
     */
    
    var statsTemplate = '<ul id="mocha-stats">'
      + '<li class="progress"><canvas width="40" height="40"></canvas></li>'
      + '<li class="passes"><a href="#">passes:</a> <em>0</em></li>'
      + '<li class="failures"><a href="#">failures:</a> <em>0</em></li>'
      + '<li class="duration">duration: <em>0</em>s</li>'
      + '</ul>';
    
    /**
     * Initialize a new `HTML` reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function HTML(runner) {
      Base.call(this, runner);
    
      var self = this
        , stats = this.stats
        , total = runner.total
        , stat = fragment(statsTemplate)
        , items = stat.getElementsByTagName('li')
        , passes = items[1].getElementsByTagName('em')[0]
        , passesLink = items[1].getElementsByTagName('a')[0]
        , failures = items[2].getElementsByTagName('em')[0]
        , failuresLink = items[2].getElementsByTagName('a')[0]
        , duration = items[3].getElementsByTagName('em')[0]
        , canvas = stat.getElementsByTagName('canvas')[0]
        , report = fragment('<ul id="mocha-report"></ul>')
        , stack = [report]
        , progress
        , ctx
        , root = document.getElementById('mocha');
    
      if (canvas.getContext) {
        var ratio = window.devicePixelRatio || 1;
        canvas.style.width = canvas.width;
        canvas.style.height = canvas.height;
        canvas.width *= ratio;
        canvas.height *= ratio;
        ctx = canvas.getContext('2d');
        ctx.scale(ratio, ratio);
        progress = new Progress;
      }
    
      if (!root) return error('#mocha div missing, add it to your document');
    
      // pass toggle
      on(passesLink, 'click', function(){
        unhide();
        var name = /pass/.test(report.className) ? '' : ' pass';
        report.className = report.className.replace(/fail|pass/g, '') + name;
        if (report.className.trim()) hideSuitesWithout('test pass');
      });
    
      // failure toggle
      on(failuresLink, 'click', function(){
        unhide();
        var name = /fail/.test(report.className) ? '' : ' fail';
        report.className = report.className.replace(/fail|pass/g, '') + name;
        if (report.className.trim()) hideSuitesWithout('test fail');
      });
    
      root.appendChild(stat);
      root.appendChild(report);
    
      if (progress) progress.size(40);
    
      runner.on('suite', function(suite){
        if (suite.root) return;
    
        // suite
        var url = self.suiteURL(suite);
        var el = fragment('<li class="suite"><h1><a href="%s">%s</a></h1></li>', url, escape(suite.title));
    
        // container
        stack[0].appendChild(el);
        stack.unshift(document.createElement('ul'));
        el.appendChild(stack[0]);
      });
    
      runner.on('suite end', function(suite){
        if (suite.root) return;
        stack.shift();
      });
    
      runner.on('fail', function(test, err){
        if ('hook' == test.type) runner.emit('test end', test);
      });
    
      runner.on('test end', function(test){
        // TODO: add to stats
        var percent = stats.tests / this.total * 100 | 0;
        if (progress) progress.update(percent).draw(ctx);
    
        // update stats
        var ms = new Date - stats.start;
        text(passes, stats.passes);
        text(failures, stats.failures);
        text(duration, (ms / 1000).toFixed(2));
    
        // test
        if ('passed' == test.state) {
          var url = self.testURL(test);
          var el = fragment('<li class="test pass %e"><h2>%e<span class="duration">%ems</span> <a href="%s" class="replay">‣</a></h2></li>', test.speed, test.title, test.duration, url);
        } else if (test.pending) {
          var el = fragment('<li class="test pass pending"><h2>%e</h2></li>', test.title);
        } else {
          var el = fragment('<li class="test fail"><h2>%e <a href="%e" class="replay">‣</a></h2></li>', test.title, self.testURL(test));
          var str = test.err.stack || test.err.toString();
    
          // FF / Opera do not add the message
          if (!~str.indexOf(test.err.message)) {
            str = test.err.message + '\n' + str;
          }
    
          // <=IE7 stringifies to [Object Error]. Since it can be overloaded, we
          // check for the result of the stringifying.
          if ('[object Error]' == str) str = test.err.message;
    
          // Safari doesn't give you a stack. Let's at least provide a source line.
          if (!test.err.stack && test.err.sourceURL && test.err.line !== undefined) {
            str += "\n(" + test.err.sourceURL + ":" + test.err.line + ")";
          }
    
          el.appendChild(fragment('<pre class="error">%e</pre>', str));
        }
    
        // toggle code
        // TODO: defer
        if (!test.pending) {
          var h2 = el.getElementsByTagName('h2')[0];
    
          on(h2, 'click', function(){
            pre.style.display = 'none' == pre.style.display
              ? 'block'
              : 'none';
          });
    
          var pre = fragment('<pre><code>%e</code></pre>', utils.clean(test.fn.toString()));
          el.appendChild(pre);
          pre.style.display = 'none';
        }
    
        // Don't call .appendChild if #mocha-report was already .shift()'ed off the stack.
        if (stack[0]) stack[0].appendChild(el);
      });
    }
    
    /**
     * Makes a URL, preserving querystring ("search") parameters.
     * @param {string} s
     * @returns {string} your new URL
     */
    var makeUrl = function makeUrl(s) {
      var search = window.location.search;
    
      // Remove previous grep query parameter if present
      if (search) {
        search = search.replace(/[?&]grep=[^&\s]*/g, '').replace(/^&/, '?');
      }
    
      return window.location.pathname + (search ? search + '&' : '?' ) + 'grep=' + encodeURIComponent(s);
    };
    
    /**
     * Provide suite URL
     *
     * @param {Object} [suite]
     */
    HTML.prototype.suiteURL = function(suite){
      return makeUrl(suite.fullTitle());
    };
    
    /**
     * Provide test URL
     *
     * @param {Object} [test]
     */
    
    HTML.prototype.testURL = function(test){
      return makeUrl(test.fullTitle());
    };
    
    /**
     * Display error `msg`.
     */
    
    function error(msg) {
      document.body.appendChild(fragment('<div id="mocha-error">%s</div>', msg));
    }
    
    /**
     * Return a DOM fragment from `html`.
     */
    
    function fragment(html) {
      var args = arguments
        , div = document.createElement('div')
        , i = 1;
    
      div.innerHTML = html.replace(/%([se])/g, function(_, type){
        switch (type) {
          case 's': return String(args[i++]);
          case 'e': return escape(args[i++]);
        }
      });
    
      return div.firstChild;
    }
    
    /**
     * Check for suites that do not have elements
     * with `classname`, and hide them.
     */
    
    function hideSuitesWithout(classname) {
      var suites = document.getElementsByClassName('suite');
      for (var i = 0; i < suites.length; i++) {
        var els = suites[i].getElementsByClassName(classname);
        if (0 == els.length) suites[i].className += ' hidden';
      }
    }
    
    /**
     * Unhide .hidden suites.
     */
    
    function unhide() {
      var els = document.getElementsByClassName('suite hidden');
      for (var i = 0; i < els.length; ++i) {
        els[i].className = els[i].className.replace('suite hidden', 'suite');
      }
    }
    
    /**
     * Set `el` text to `str`.
     */
    
    function text(el, str) {
      if (el.textContent) {
        el.textContent = str;
      } else {
        el.innerText = str;
      }
    }
    
    /**
     * Listen on `event` with callback `fn`.
     */
    
    function on(el, event, fn) {
      if (el.addEventListener) {
        el.addEventListener(event, fn, false);
      } else {
        el.attachEvent('on' + event, fn);
      }
    }
    
  provide("mocha/lib/reporters/html", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/list
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base')
      , cursor = Base.cursor
      , color = Base.color;
    
    /**
     * Expose `List`.
     */
    
    exports = module.exports = List;
    
    /**
     * Initialize a new `List` test reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function List(runner) {
      Base.call(this, runner);
    
      var self = this
        , stats = this.stats
        , n = 0;
    
      runner.on('start', function(){
        console.log();
      });
    
      runner.on('test', function(test){
        process.stdout.write(color('pass', '    ' + test.fullTitle() + ': '));
      });
    
      runner.on('pending', function(test){
        var fmt = color('checkmark', '  -')
          + color('pending', ' %s');
        console.log(fmt, test.fullTitle());
      });
    
      runner.on('pass', function(test){
        var fmt = color('checkmark', '  '+Base.symbols.dot)
          + color('pass', ' %s: ')
          + color(test.speed, '%dms');
        cursor.CR();
        console.log(fmt, test.fullTitle(), test.duration);
      });
    
      runner.on('fail', function(test, err){
        cursor.CR();
        console.log(color('fail', '  %d) %s'), ++n, test.fullTitle());
      });
    
      runner.on('end', self.epilogue.bind(self));
    }
    
    /**
     * Inherit from `Base.prototype`.
     */
    
    List.prototype.__proto__ = Base.prototype;
    
  provide("mocha/lib/reporters/list", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/min
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base');
    
    /**
     * Expose `Min`.
     */
    
    exports = module.exports = Min;
    
    /**
     * Initialize a new `Min` minimal test reporter (best used with --watch).
     *
     * @param {Runner} runner
     * @api public
     */
    
    function Min(runner) {
      Base.call(this, runner);
    
      runner.on('start', function(){
        // clear screen
        process.stdout.write('\u001b[2J');
        // set cursor position
        process.stdout.write('\u001b[1;3H');
      });
    
      runner.on('end', this.epilogue.bind(this));
    }
    
    /**
     * Inherit from `Base.prototype`.
     */
    
    Min.prototype.__proto__ = Base.prototype;
    
  provide("mocha/lib/reporters/min", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/spec
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base')
      , cursor = Base.cursor
      , color = Base.color;
    
    /**
     * Expose `Spec`.
     */
    
    exports = module.exports = Spec;
    
    /**
     * Initialize a new `Spec` test reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function Spec(runner) {
      Base.call(this, runner);
    
      var self = this
        , stats = this.stats
        , indents = 0
        , n = 0;
    
      function indent() {
        return Array(indents).join('  ')
      }
    
      runner.on('start', function(){
        console.log();
      });
    
      runner.on('suite', function(suite){
        ++indents;
        console.log(color('suite', '%s%s'), indent(), suite.title);
      });
    
      runner.on('suite end', function(suite){
        --indents;
        if (1 == indents) console.log();
      });
    
      runner.on('pending', function(test){
        var fmt = indent() + color('pending', '  - %s');
        console.log(fmt, test.title);
      });
    
      runner.on('pass', function(test){
        if ('fast' == test.speed) {
          var fmt = indent()
            + color('checkmark', '  ' + Base.symbols.ok)
            + color('pass', ' %s');
          cursor.CR();
          console.log(fmt, test.title);
        } else {
          var fmt = indent()
            + color('checkmark', '  ' + Base.symbols.ok)
            + color('pass', ' %s')
            + color(test.speed, ' (%dms)');
          cursor.CR();
          console.log(fmt, test.title, test.duration);
        }
      });
    
      runner.on('fail', function(test, err){
        cursor.CR();
        console.log(indent() + color('fail', '  %d) %s'), ++n, test.title);
      });
    
      runner.on('end', self.epilogue.bind(self));
    }
    
    /**
     * Inherit from `Base.prototype`.
     */
    
    Spec.prototype.__proto__ = Base.prototype;
    
  provide("mocha/lib/reporters/spec", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/nyan
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base');
    
    /**
     * Expose `Dot`.
     */
    
    exports = module.exports = NyanCat;
    
    /**
     * Initialize a new `Dot` matrix test reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function NyanCat(runner) {
      Base.call(this, runner);
      var self = this
        , stats = this.stats
        , width = Base.window.width * .75 | 0
        , rainbowColors = this.rainbowColors = self.generateColors()
        , colorIndex = this.colorIndex = 0
        , numerOfLines = this.numberOfLines = 4
        , trajectories = this.trajectories = [[], [], [], []]
        , nyanCatWidth = this.nyanCatWidth = 11
        , trajectoryWidthMax = this.trajectoryWidthMax = (width - nyanCatWidth)
        , scoreboardWidth = this.scoreboardWidth = 5
        , tick = this.tick = 0
        , n = 0;
    
      runner.on('start', function(){
        Base.cursor.hide();
        self.draw();
      });
    
      runner.on('pending', function(test){
        self.draw();
      });
    
      runner.on('pass', function(test){
        self.draw();
      });
    
      runner.on('fail', function(test, err){
        self.draw();
      });
    
      runner.on('end', function(){
        Base.cursor.show();
        for (var i = 0; i < self.numberOfLines; i++) write('\n');
        self.epilogue();
      });
    }
    
    /**
     * Draw the nyan cat
     *
     * @api private
     */
    
    NyanCat.prototype.draw = function(){
      this.appendRainbow();
      this.drawScoreboard();
      this.drawRainbow();
      this.drawNyanCat();
      this.tick = !this.tick;
    };
    
    /**
     * Draw the "scoreboard" showing the number
     * of passes, failures and pending tests.
     *
     * @api private
     */
    
    NyanCat.prototype.drawScoreboard = function(){
      var stats = this.stats;
    
      function draw(type, n) {
        write(' ');
        write(Base.color(type, n));
        write('\n');
      }
    
      draw('green', stats.passes);
      draw('fail', stats.failures);
      draw('pending', stats.pending);
      write('\n');
    
      this.cursorUp(this.numberOfLines);
    };
    
    /**
     * Append the rainbow.
     *
     * @api private
     */
    
    NyanCat.prototype.appendRainbow = function(){
      var segment = this.tick ? '_' : '-';
      var rainbowified = this.rainbowify(segment);
    
      for (var index = 0; index < this.numberOfLines; index++) {
        var trajectory = this.trajectories[index];
        if (trajectory.length >= this.trajectoryWidthMax) trajectory.shift();
        trajectory.push(rainbowified);
      }
    };
    
    /**
     * Draw the rainbow.
     *
     * @api private
     */
    
    NyanCat.prototype.drawRainbow = function(){
      var self = this;
    
      this.trajectories.forEach(function(line, index) {
        write('\u001b[' + self.scoreboardWidth + 'C');
        write(line.join(''));
        write('\n');
      });
    
      this.cursorUp(this.numberOfLines);
    };
    
    /**
     * Draw the nyan cat
     *
     * @api private
     */
    
    NyanCat.prototype.drawNyanCat = function() {
      var self = this;
      var startWidth = this.scoreboardWidth + this.trajectories[0].length;
      var dist = '\u001b[' + startWidth + 'C';
      var padding = '';
    
      write(dist);
      write('_,------,');
      write('\n');
    
      write(dist);
      padding = self.tick ? '  ' : '   ';
      write('_|' + padding + '/\\_/\\ ');
      write('\n');
    
      write(dist);
      padding = self.tick ? '_' : '__';
      var tail = self.tick ? '~' : '^';
      var face;
      write(tail + '|' + padding + this.face() + ' ');
      write('\n');
    
      write(dist);
      padding = self.tick ? ' ' : '  ';
      write(padding + '""  "" ');
      write('\n');
    
      this.cursorUp(this.numberOfLines);
    };
    
    /**
     * Draw nyan cat face.
     *
     * @return {String}
     * @api private
     */
    
    NyanCat.prototype.face = function() {
      var stats = this.stats;
      if (stats.failures) {
        return '( x .x)';
      } else if (stats.pending) {
        return '( o .o)';
      } else if(stats.passes) {
        return '( ^ .^)';
      } else {
        return '( - .-)';
      }
    };
    
    /**
     * Move cursor up `n`.
     *
     * @param {Number} n
     * @api private
     */
    
    NyanCat.prototype.cursorUp = function(n) {
      write('\u001b[' + n + 'A');
    };
    
    /**
     * Move cursor down `n`.
     *
     * @param {Number} n
     * @api private
     */
    
    NyanCat.prototype.cursorDown = function(n) {
      write('\u001b[' + n + 'B');
    };
    
    /**
     * Generate rainbow colors.
     *
     * @return {Array}
     * @api private
     */
    
    NyanCat.prototype.generateColors = function(){
      var colors = [];
    
      for (var i = 0; i < (6 * 7); i++) {
        var pi3 = Math.floor(Math.PI / 3);
        var n = (i * (1.0 / 6));
        var r = Math.floor(3 * Math.sin(n) + 3);
        var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);
        var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);
        colors.push(36 * r + 6 * g + b + 16);
      }
    
      return colors;
    };
    
    /**
     * Apply rainbow to the given `str`.
     *
     * @param {String} str
     * @return {String}
     * @api private
     */
    
    NyanCat.prototype.rainbowify = function(str){
      if (!Base.useColors)
        return str;
      var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];
      this.colorIndex += 1;
      return '\u001b[38;5;' + color + 'm' + str + '\u001b[0m';
    };
    
    /**
     * Stdout helper.
     */
    
    function write(string) {
      process.stdout.write(string);
    }
    
    /**
     * Inherit from `Base.prototype`.
     */
    
    NyanCat.prototype.__proto__ = Base.prototype;
    
  provide("mocha/lib/reporters/nyan", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/xunit
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base')
      , utils =  require('mocha/lib/utils')
      , fs = require('fs')
      , escape = utils.escape;
    
    /**
     * Save timer references to avoid Sinon interfering (see GH-237).
     */
    
    var Date = global.Date
      , setTimeout = global.setTimeout
      , setInterval = global.setInterval
      , clearTimeout = global.clearTimeout
      , clearInterval = global.clearInterval;
    
    /**
     * Expose `XUnit`.
     */
    
    exports = module.exports = XUnit;
    
    /**
     * Initialize a new `XUnit` reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function XUnit(runner, options) {
      Base.call(this, runner);
      var stats = this.stats
        , tests = []
        , self = this;
    
      if (options.reporterOptions && options.reporterOptions.output) {
          if (! fs.createWriteStream) {
              throw new Error('file output not supported in browser');
          }
          self.fileStream = fs.createWriteStream(options.reporterOptions.output);
      }
    
      runner.on('pending', function(test){
        tests.push(test);
      });
    
      runner.on('pass', function(test){
        tests.push(test);
      });
    
      runner.on('fail', function(test){
        tests.push(test);
      });
    
      runner.on('end', function(){
        self.write(tag('testsuite', {
            name: 'Mocha Tests'
          , tests: stats.tests
          , failures: stats.failures
          , errors: stats.failures
          , skipped: stats.tests - stats.failures - stats.passes
          , timestamp: (new Date).toUTCString()
          , time: (stats.duration / 1000) || 0
        }, false));
    
        tests.forEach(function(t) { self.test(t); });
        self.write('</testsuite>');
      });
    }
    
    /**
     * Override done to close the stream (if it's a file).
     */
    XUnit.prototype.done = function(failures, fn) {
        if (this.fileStream) {
            this.fileStream.end(function() {
                fn(failures);
            });
        } else {
            fn(failures);
        }
    };
    
    /**
     * Inherit from `Base.prototype`.
     */
    
    XUnit.prototype.__proto__ = Base.prototype;
    
    /**
     * Write out the given line
     */
    XUnit.prototype.write = function(line) {
        if (this.fileStream) {
            this.fileStream.write(line + '\n');
        } else {
            console.log(line);
        }
    };
    
    /**
     * Output tag for the given `test.`
     */
    
    XUnit.prototype.test = function(test, ostream) {
      var attrs = {
          classname: test.parent.fullTitle()
        , name: test.title
        , time: (test.duration / 1000) || 0
      };
    
      if ('failed' == test.state) {
        var err = test.err;
        this.write(tag('testcase', attrs, false, tag('failure', {}, false, cdata(escape(err.message) + "\n" + err.stack))));
      } else if (test.pending) {
        this.write(tag('testcase', attrs, false, tag('skipped', {}, true)));
      } else {
        this.write(tag('testcase', attrs, true) );
      }
    };
    
    /**
     * HTML tag helper.
     */
    
    function tag(name, attrs, close, content) {
      var end = close ? '/>' : '>'
        , pairs = []
        , tag;
    
      for (var key in attrs) {
        pairs.push(key + '="' + escape(attrs[key]) + '"');
      }
    
      tag = '<' + name + (pairs.length ? ' ' + pairs.join(' ') : '') + end;
      if (content) tag += content + '</' + name + end;
      return tag;
    }
    
    /**
     * Return cdata escaped CDATA `str`.
     */
    
    function cdata(str) {
      return '<![CDATA[' + escape(str) + ']]>';
    }
    
  provide("mocha/lib/reporters/xunit", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/markdown
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base')
      , utils =  require('mocha/lib/utils');
    
    /**
     * Constants
     */
    
    var SUITE_PREFIX = '$';
    
    /**
     * Expose `Markdown`.
     */
    
    exports = module.exports = Markdown;
    
    /**
     * Initialize a new `Markdown` reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function Markdown(runner) {
      Base.call(this, runner);
    
      var self = this
        , stats = this.stats
        , level = 0
        , buf = '';
    
      function title(str) {
        return Array(level).join('#') + ' ' + str;
      }
    
      function indent() {
        return Array(level).join('  ');
      }
    
      function mapTOC(suite, obj) {
        var ret = obj,
            key = SUITE_PREFIX + suite.title;
        obj = obj[key] = obj[key] || { suite: suite };
        suite.suites.forEach(function(suite){
          mapTOC(suite, obj);
        });
        return ret;
      }
    
      function stringifyTOC(obj, level) {
        ++level;
        var buf = '';
        var link;
        for (var key in obj) {
          if ('suite' == key) continue;
          if (key !== SUITE_PREFIX) {
            link = ' - [' + key.substring(1) + ']';
            link += '(#' + utils.slug(obj[key].suite.fullTitle()) + ')\n';
            buf += Array(level).join('  ') + link;
          }
          buf += stringifyTOC(obj[key], level);
        }
        return buf;
      }
    
      function generateTOC(suite) {
        var obj = mapTOC(suite, {});
        return stringifyTOC(obj, 0);
      }
    
      generateTOC(runner.suite);
    
      runner.on('suite', function(suite){
        ++level;
        var slug = utils.slug(suite.fullTitle());
        buf += '<a name="' + slug + '"></a>' + '\n';
        buf += title(suite.title) + '\n';
      });
    
      runner.on('suite end', function(suite){
        --level;
      });
    
      runner.on('pass', function(test){
        var code = utils.clean(test.fn.toString());
        buf += test.title + '.\n';
        buf += '\n```js\n';
        buf += code + '\n';
        buf += '```\n\n';
      });
    
      runner.on('end', function(){
        process.stdout.write('# TOC\n');
        process.stdout.write(generateTOC(runner.suite));
        process.stdout.write(buf);
      });
    }
    
  provide("mocha/lib/reporters/markdown", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/progress
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base')
      , cursor = Base.cursor
      , color = Base.color;
    
    /**
     * Expose `Progress`.
     */
    
    exports = module.exports = Progress;
    
    /**
     * General progress bar color.
     */
    
    Base.colors.progress = 90;
    
    /**
     * Initialize a new `Progress` bar test reporter.
     *
     * @param {Runner} runner
     * @param {Object} options
     * @api public
     */
    
    function Progress(runner, options) {
      Base.call(this, runner);
    
      var self = this
        , options = options || {}
        , stats = this.stats
        , width = Base.window.width * .50 | 0
        , total = runner.total
        , complete = 0
        , max = Math.max
        , lastN = -1;
    
      // default chars
      options.open = options.open || '[';
      options.complete = options.complete || '▬';
      options.incomplete = options.incomplete || Base.symbols.dot;
      options.close = options.close || ']';
      options.verbose = false;
    
      // tests started
      runner.on('start', function(){
        console.log();
        cursor.hide();
      });
    
      // tests complete
      runner.on('test end', function(){
        complete++;
        var incomplete = total - complete
          , percent = complete / total
          , n = width * percent | 0
          , i = width - n;
    
        if (lastN === n && !options.verbose) {
          // Don't re-render the line if it hasn't changed
          return;
        }
        lastN = n;
    
        cursor.CR();
        process.stdout.write('\u001b[J');
        process.stdout.write(color('progress', '  ' + options.open));
        process.stdout.write(Array(n).join(options.complete));
        process.stdout.write(Array(i).join(options.incomplete));
        process.stdout.write(color('progress', options.close));
        if (options.verbose) {
          process.stdout.write(color('progress', ' ' + complete + ' of ' + total));
        }
      });
    
      // tests are complete, output some stats
      // and the failures if any
      runner.on('end', function(){
        cursor.show();
        console.log();
        self.epilogue();
      });
    }
    
    /**
     * Inherit from `Base.prototype`.
     */
    
    Progress.prototype.__proto__ = Base.prototype;
    
  provide("mocha/lib/reporters/progress", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/landing
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base')
      , cursor = Base.cursor
      , color = Base.color;
    
    /**
     * Expose `Landing`.
     */
    
    exports = module.exports = Landing;
    
    /**
     * Airplane color.
     */
    
    Base.colors.plane = 0;
    
    /**
     * Airplane crash color.
     */
    
    Base.colors['plane crash'] = 31;
    
    /**
     * Runway color.
     */
    
    Base.colors.runway = 90;
    
    /**
     * Initialize a new `Landing` reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function Landing(runner) {
      Base.call(this, runner);
    
      var self = this
        , stats = this.stats
        , width = Base.window.width * .75 | 0
        , total = runner.total
        , stream = process.stdout
        , plane = color('plane', '✈')
        , crashed = -1
        , n = 0;
    
      function runway() {
        var buf = Array(width).join('-');
        return '  ' + color('runway', buf);
      }
    
      runner.on('start', function(){
        stream.write('\n\n\n  ');
        cursor.hide();
      });
    
      runner.on('test end', function(test){
        // check if the plane crashed
        var col = -1 == crashed
          ? width * ++n / total | 0
          : crashed;
    
        // show the crash
        if ('failed' == test.state) {
          plane = color('plane crash', '✈');
          crashed = col;
        }
    
        // render landing strip
        stream.write('\u001b['+(width+1)+'D\u001b[2A');
        stream.write(runway());
        stream.write('\n  ');
        stream.write(color('runway', Array(col).join('⋅')));
        stream.write(plane)
        stream.write(color('runway', Array(width - col).join('⋅') + '\n'));
        stream.write(runway());
        stream.write('\u001b[0m');
      });
    
      runner.on('end', function(){
        cursor.show();
        console.log();
        self.epilogue();
      });
    }
    
    /**
     * Inherit from `Base.prototype`.
     */
    
    Landing.prototype.__proto__ = Base.prototype;
    
  provide("mocha/lib/reporters/landing", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/html-cov
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var JSONCov =  require('mocha/lib/reporters/json-cov')
      , fs = require('fs');
    
    /**
     * Expose `HTMLCov`.
     */
    
    exports = module.exports = HTMLCov;
    
    /**
     * Initialize a new `JsCoverage` reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function HTMLCov(runner) {
      var jade = require('jade')
        , file = __dirname + '/templates/coverage.jade'
        , str = fs.readFileSync(file, 'utf8')
        , fn = jade.compile(str, { filename: file })
        , self = this;
    
      JSONCov.call(this, runner, false);
    
      runner.on('end', function(){
        process.stdout.write(fn({
            cov: self.cov
          , coverageClass: coverageClass
        }));
      });
    }
    
    /**
     * Return coverage class for `n`.
     *
     * @return {String}
     * @api private
     */
    
    function coverageClass(n) {
      if (n >= 75) return 'high';
      if (n >= 50) return 'medium';
      if (n >= 25) return 'low';
      return 'terrible';
    }
    
  provide("mocha/lib/reporters/html-cov", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/json-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base')
      , color = Base.color;
    
    /**
     * Expose `List`.
     */
    
    exports = module.exports = List;
    
    /**
     * Initialize a new `List` test reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function List(runner) {
      Base.call(this, runner);
    
      var self = this
        , stats = this.stats
        , total = runner.total;
    
      runner.on('start', function(){
        console.log(JSON.stringify(['start', { total: total }]));
      });
    
      runner.on('pass', function(test){
        console.log(JSON.stringify(['pass', clean(test)]));
      });
    
      runner.on('fail', function(test, err){
        test = clean(test);
        test.err = err.message;
        console.log(JSON.stringify(['fail', test]));
      });
    
      runner.on('end', function(){
        process.stdout.write(JSON.stringify(['end', self.stats]));
      });
    }
    
    /**
     * Return a plain-object representation of `test`
     * free of cyclic properties etc.
     *
     * @param {Object} test
     * @return {Object}
     * @api private
     */
    
    function clean(test) {
      return {
          title: test.title
        , fullTitle: test.fullTitle()
        , duration: test.duration
      }
    }
    
  provide("mocha/lib/reporters/json-stream", module.exports);
}(global));

// pakmanager:mocha/lib/interfaces
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports.bdd =  require('mocha/lib/interfaces/bdd');
    exports.tdd =  require('mocha/lib/interfaces/tdd');
    exports.qunit =  require('mocha/lib/interfaces/qunit');
    exports.exports =  require('mocha/lib/interfaces/exports');
    
  provide("mocha/lib/interfaces", module.exports);
}(global));

// pakmanager:mocha/lib/reporters
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports.Base =  require('mocha/lib/reporters/base');
    exports.Dot =  require('mocha/lib/reporters/dot');
    exports.Doc =  require('mocha/lib/reporters/doc');
    exports.TAP =  require('mocha/lib/reporters/tap');
    exports.JSON =  require('mocha/lib/reporters/json');
    exports.HTML =  require('mocha/lib/reporters/html');
    exports.List =  require('mocha/lib/reporters/list');
    exports.Min =  require('mocha/lib/reporters/min');
    exports.Spec =  require('mocha/lib/reporters/spec');
    exports.Nyan =  require('mocha/lib/reporters/nyan');
    exports.XUnit =  require('mocha/lib/reporters/xunit');
    exports.Markdown =  require('mocha/lib/reporters/markdown');
    exports.Progress =  require('mocha/lib/reporters/progress');
    exports.Landing =  require('mocha/lib/reporters/landing');
    exports.JSONCov =  require('mocha/lib/reporters/json-cov');
    exports.HTMLCov =  require('mocha/lib/reporters/html-cov');
    exports.JSONStream =  require('mocha/lib/reporters/json-stream');
    
  provide("mocha/lib/reporters", module.exports);
}(global));

// pakmanager:mocha/lib/context
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Expose `Context`.
     */
    
    module.exports = Context;
    
    /**
     * Initialize a new `Context`.
     *
     * @api private
     */
    
    function Context(){}
    
    /**
     * Set or get the context `Runnable` to `runnable`.
     *
     * @param {Runnable} runnable
     * @return {Context}
     * @api private
     */
    
    Context.prototype.runnable = function(runnable){
      if (0 == arguments.length) return this._runnable;
      this.test = this._runnable = runnable;
      return this;
    };
    
    /**
     * Set test timeout `ms`.
     *
     * @param {Number} ms
     * @return {Context} self
     * @api private
     */
    
    Context.prototype.timeout = function(ms){
      if (arguments.length === 0) return this.runnable().timeout();
      this.runnable().timeout(ms);
      return this;
    };
    
    /**
     * Set test timeout `enabled`.
     *
     * @param {Boolean} enabled
     * @return {Context} self
     * @api private
     */
    
    Context.prototype.enableTimeouts = function (enabled) {
      this.runnable().enableTimeouts(enabled);
      return this;
    };
    
    
    /**
     * Set test slowness threshold `ms`.
     *
     * @param {Number} ms
     * @return {Context} self
     * @api private
     */
    
    Context.prototype.slow = function(ms){
      this.runnable().slow(ms);
      return this;
    };
    
    /**
     * Mark a test as skipped.
     *
     * @return {Context} self
     * @api private
     */
    
    Context.prototype.skip = function(){
        this.runnable().skip();
        return this;
    };
    
    /**
     * Inspect the context void of `._runnable`.
     *
     * @return {String}
     * @api private
     */
    
    Context.prototype.inspect = function(){
      return JSON.stringify(this, function(key, val){
        if ('_runnable' == key) return;
        if ('test' == key) return;
        return val;
      }, 2);
    };
    
  provide("mocha/lib/context", module.exports);
}(global));

// pakmanager:mocha/lib/runner
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var EventEmitter = require('events').EventEmitter
      , debug = require('debug')('mocha:runner')
      , Pending =  require('mocha/lib/pending')
      , Test =  require('mocha/lib/test')
      , utils =  require('mocha/lib/utils')
      , filter = utils.filter
      , keys = utils.keys
      , type = utils.type
      , stringify = utils.stringify
      , stackFilter = utils.stackTraceFilter();
    
    /**
     * Non-enumerable globals.
     */
    
    var globals = [
      'setTimeout',
      'clearTimeout',
      'setInterval',
      'clearInterval',
      'XMLHttpRequest',
      'Date',
      'setImmediate',
      'clearImmediate'
    ];
    
    /**
     * Expose `Runner`.
     */
    
    module.exports = Runner;
    
    /**
     * Initialize a `Runner` for the given `suite`.
     *
     * Events:
     *
     *   - `start`  execution started
     *   - `end`  execution complete
     *   - `suite`  (suite) test suite execution started
     *   - `suite end`  (suite) all tests (and sub-suites) have finished
     *   - `test`  (test) test execution started
     *   - `test end`  (test) test completed
     *   - `hook`  (hook) hook execution started
     *   - `hook end`  (hook) hook complete
     *   - `pass`  (test) test passed
     *   - `fail`  (test, err) test failed
     *   - `pending`  (test) test pending
     *
     * @param {Suite} suite Root suite
     * @param {boolean} [delay] Whether or not to delay execution of root suite
     *   until ready.
     * @api public
     */
    
    function Runner(suite, delay) {
      var self = this;
      this._globals = [];
      this._abort = false;
      this._delay = delay;
      this.suite = suite;
      this.total = suite.total();
      this.failures = 0;
      this.on('test end', function(test){ self.checkGlobals(test); });
      this.on('hook end', function(hook){ self.checkGlobals(hook); });
      this.grep(/.*/);
      this.globals(this.globalProps().concat(extraGlobals()));
    }
    
    /**
     * Wrapper for setImmediate, process.nextTick, or browser polyfill.
     *
     * @param {Function} fn
     * @api private
     */
    
    Runner.immediately = global.setImmediate || process.nextTick;
    
    /**
     * Inherit from `EventEmitter.prototype`.
     */
    
    Runner.prototype.__proto__ = EventEmitter.prototype;
    
    /**
     * Run tests with full titles matching `re`. Updates runner.total
     * with number of tests matched.
     *
     * @param {RegExp} re
     * @param {Boolean} invert
     * @return {Runner} for chaining
     * @api public
     */
    
    Runner.prototype.grep = function(re, invert){
      debug('grep %s', re);
      this._grep = re;
      this._invert = invert;
      this.total = this.grepTotal(this.suite);
      return this;
    };
    
    /**
     * Returns the number of tests matching the grep search for the
     * given suite.
     *
     * @param {Suite} suite
     * @return {Number}
     * @api public
     */
    
    Runner.prototype.grepTotal = function(suite) {
      var self = this;
      var total = 0;
    
      suite.eachTest(function(test){
        var match = self._grep.test(test.fullTitle());
        if (self._invert) match = !match;
        if (match) total++;
      });
    
      return total;
    };
    
    /**
     * Return a list of global properties.
     *
     * @return {Array}
     * @api private
     */
    
    Runner.prototype.globalProps = function() {
      var props = utils.keys(global);
    
      // non-enumerables
      for (var i = 0; i < globals.length; ++i) {
        if (~utils.indexOf(props, globals[i])) continue;
        props.push(globals[i]);
      }
    
      return props;
    };
    
    /**
     * Allow the given `arr` of globals.
     *
     * @param {Array} arr
     * @return {Runner} for chaining
     * @api public
     */
    
    Runner.prototype.globals = function(arr){
      if (0 == arguments.length) return this._globals;
      debug('globals %j', arr);
      this._globals = this._globals.concat(arr);
      return this;
    };
    
    /**
     * Check for global variable leaks.
     *
     * @api private
     */
    
    Runner.prototype.checkGlobals = function(test){
      if (this.ignoreLeaks) return;
      var ok = this._globals;
    
      var globals = this.globalProps();
      var leaks;
    
      if (test) {
        ok = ok.concat(test._allowedGlobals || []);
      }
    
      if(this.prevGlobalsLength == globals.length) return;
      this.prevGlobalsLength = globals.length;
    
      leaks = filterLeaks(ok, globals);
      this._globals = this._globals.concat(leaks);
    
      if (leaks.length > 1) {
        this.fail(test, new Error('global leaks detected: ' + leaks.join(', ') + ''));
      } else if (leaks.length) {
        this.fail(test, new Error('global leak detected: ' + leaks[0]));
      }
    };
    
    /**
     * Fail the given `test`.
     *
     * @param {Test} test
     * @param {Error} err
     * @api private
     */
    
    Runner.prototype.fail = function(test, err) {
      ++this.failures;
      test.state = 'failed';
    
      if (!(err instanceof Error)) {
        err = new Error('the ' + type(err) + ' ' + stringify(err) + ' was thrown, throw an Error :)');
      }
    
      err.stack = (this.fullStackTrace || !err.stack)
        ? err.stack
        : stackFilter(err.stack);
    
      this.emit('fail', test, err);
    };
    
    /**
     * Fail the given `hook` with `err`.
     *
     * Hook failures work in the following pattern:
     * - If bail, then exit
     * - Failed `before` hook skips all tests in a suite and subsuites,
     *   but jumps to corresponding `after` hook
     * - Failed `before each` hook skips remaining tests in a
     *   suite and jumps to corresponding `after each` hook,
     *   which is run only once
     * - Failed `after` hook does not alter
     *   execution order
     * - Failed `after each` hook skips remaining tests in a
     *   suite and subsuites, but executes other `after each`
     *   hooks
     *
     * @param {Hook} hook
     * @param {Error} err
     * @api private
     */
    
    Runner.prototype.failHook = function(hook, err){
      this.fail(hook, err);
      if (this.suite.bail()) {
        this.emit('end');
      }
    };
    
    /**
     * Run hook `name` callbacks and then invoke `fn()`.
     *
     * @param {String} name
     * @param {Function} function
     * @api private
     */
    
    Runner.prototype.hook = function(name, fn){
      var suite = this.suite
        , hooks = suite['_' + name]
        , self = this
        , timer;
    
      function next(i) {
        var hook = hooks[i];
        if (!hook) return fn();
        self.currentRunnable = hook;
    
        hook.ctx.currentTest = self.test;
    
        self.emit('hook', hook);
    
        hook.on('error', function(err){
          self.failHook(hook, err);
        });
    
        hook.run(function(err){
          hook.removeAllListeners('error');
          var testError = hook.error();
          if (testError) self.fail(self.test, testError);
          if (err) {
            if (err instanceof Pending) {
              suite.pending = true;
            } else {
              self.failHook(hook, err);
    
              // stop executing hooks, notify callee of hook err
              return fn(err);
            }
          }
          self.emit('hook end', hook);
          delete hook.ctx.currentTest;
          next(++i);
        });
      }
    
      Runner.immediately(function(){
        next(0);
      });
    };
    
    /**
     * Run hook `name` for the given array of `suites`
     * in order, and callback `fn(err, errSuite)`.
     *
     * @param {String} name
     * @param {Array} suites
     * @param {Function} fn
     * @api private
     */
    
    Runner.prototype.hooks = function(name, suites, fn){
      var self = this
        , orig = this.suite;
    
      function next(suite) {
        self.suite = suite;
    
        if (!suite) {
          self.suite = orig;
          return fn();
        }
    
        self.hook(name, function(err){
          if (err) {
            var errSuite = self.suite;
            self.suite = orig;
            return fn(err, errSuite);
          }
    
          next(suites.pop());
        });
      }
    
      next(suites.pop());
    };
    
    /**
     * Run hooks from the top level down.
     *
     * @param {String} name
     * @param {Function} fn
     * @api private
     */
    
    Runner.prototype.hookUp = function(name, fn){
      var suites = [this.suite].concat(this.parents()).reverse();
      this.hooks(name, suites, fn);
    };
    
    /**
     * Run hooks from the bottom up.
     *
     * @param {String} name
     * @param {Function} fn
     * @api private
     */
    
    Runner.prototype.hookDown = function(name, fn){
      var suites = [this.suite].concat(this.parents());
      this.hooks(name, suites, fn);
    };
    
    /**
     * Return an array of parent Suites from
     * closest to furthest.
     *
     * @return {Array}
     * @api private
     */
    
    Runner.prototype.parents = function(){
      var suite = this.suite
        , suites = [];
      while (suite = suite.parent) suites.push(suite);
      return suites;
    };
    
    /**
     * Run the current test and callback `fn(err)`.
     *
     * @param {Function} fn
     * @api private
     */
    
    Runner.prototype.runTest = function(fn){
      var test = this.test
        , self = this;
    
      if (this.asyncOnly) test.asyncOnly = true;
    
      try {
        test.on('error', function(err){
          self.fail(test, err);
        });
        test.run(fn);
      } catch (err) {
        fn(err);
      }
    };
    
    /**
     * Run tests in the given `suite` and invoke
     * the callback `fn()` when complete.
     *
     * @param {Suite} suite
     * @param {Function} fn
     * @api private
     */
    
    Runner.prototype.runTests = function(suite, fn){
      var self = this
        , tests = suite.tests.slice()
        , test;
    
    
      function hookErr(err, errSuite, after) {
        // before/after Each hook for errSuite failed:
        var orig = self.suite;
    
        // for failed 'after each' hook start from errSuite parent,
        // otherwise start from errSuite itself
        self.suite = after ? errSuite.parent : errSuite;
    
        if (self.suite) {
          // call hookUp afterEach
          self.hookUp('afterEach', function(err2, errSuite2) {
            self.suite = orig;
            // some hooks may fail even now
            if (err2) return hookErr(err2, errSuite2, true);
            // report error suite
            fn(errSuite);
          });
        } else {
          // there is no need calling other 'after each' hooks
          self.suite = orig;
          fn(errSuite);
        }
      }
    
      function next(err, errSuite) {
        // if we bail after first err
        if (self.failures && suite._bail) return fn();
    
        if (self._abort) return fn();
    
        if (err) return hookErr(err, errSuite, true);
    
        // next test
        test = tests.shift();
    
        // all done
        if (!test) return fn();
    
        // grep
        var match = self._grep.test(test.fullTitle());
        if (self._invert) match = !match;
        if (!match) return next();
    
        // pending
        if (test.pending) {
          self.emit('pending', test);
          self.emit('test end', test);
          return next();
        }
    
        // execute test and hook(s)
        self.emit('test', self.test = test);
        self.hookDown('beforeEach', function(err, errSuite){
    
          if (suite.pending) {
            self.emit('pending', test);
            self.emit('test end', test);
            return next();
          }
          if (err) return hookErr(err, errSuite, false);
    
          self.currentRunnable = self.test;
          self.runTest(function(err){
            test = self.test;
    
            if (err) {
              if (err instanceof Pending) {
                self.emit('pending', test);
              } else {
                self.fail(test, err);
              }
              self.emit('test end', test);
    
              if (err instanceof Pending) {
                return next();
              }
    
              return self.hookUp('afterEach', next);
            }
    
            test.state = 'passed';
            self.emit('pass', test);
            self.emit('test end', test);
            self.hookUp('afterEach', next);
          });
        });
      }
    
      this.next = next;
      next();
    };
    
    /**
     * Run the given `suite` and invoke the
     * callback `fn()` when complete.
     *
     * @param {Suite} suite
     * @param {Function} fn
     * @api private
     */
    
    Runner.prototype.runSuite = function(suite, fn){
      var total = this.grepTotal(suite)
        , self = this
        , i = 0;
    
      debug('run suite %s', suite.fullTitle());
    
      if (!total) return fn();
    
      this.emit('suite', this.suite = suite);
    
      function next(errSuite) {
        if (errSuite) {
          // current suite failed on a hook from errSuite
          if (errSuite == suite) {
            // if errSuite is current suite
            // continue to the next sibling suite
            return done();
          } else {
            // errSuite is among the parents of current suite
            // stop execution of errSuite and all sub-suites
            return done(errSuite);
          }
        }
    
        if (self._abort) return done();
    
        var curr = suite.suites[i++];
        if (!curr) return done();
        self.runSuite(curr, next);
      }
    
      function done(errSuite) {
        self.suite = suite;
        self.hook('afterAll', function(){
          self.emit('suite end', suite);
          fn(errSuite);
        });
      }
    
      this.hook('beforeAll', function(err){
        if (err) return done();
        self.runTests(suite, next);
      });
    };
    
    /**
     * Handle uncaught exceptions.
     *
     * @param {Error} err
     * @api private
     */
    
    Runner.prototype.uncaught = function(err){
      if (err) {
        debug('uncaught exception %s', err !== function () {
          return this;
        }.call(err) ? err : ( err.message || err ));
      } else {
        debug('uncaught undefined exception');
        err = utils.undefinedError();
      }
      err.uncaught = true;
    
      var runnable = this.currentRunnable;
      if (!runnable) return;
    
      runnable.clearTimeout();
    
      // Ignore errors if complete
      if (runnable.state) return;
      this.fail(runnable, err);
    
      // recover from test
      if ('test' == runnable.type) {
        this.emit('test end', runnable);
        this.hookUp('afterEach', this.next);
        return;
      }
    
      // bail on hooks
      this.emit('end');
    };
    
    /**
     * Run the root suite and invoke `fn(failures)`
     * on completion.
     *
     * @param {Function} fn
     * @return {Runner} for chaining
     * @api public
     */
    
    Runner.prototype.run = function(fn){
      var self = this,
        rootSuite = this.suite;
    
      fn = fn || function(){};
    
      function uncaught(err){
        self.uncaught(err);
      }
    
      function start() {
        self.emit('start');
        self.runSuite(rootSuite, function(){
          debug('finished running');
          self.emit('end');
        });
      }
    
      debug('start');
    
      // callback
      this.on('end', function(){
        debug('end');
        process.removeListener('uncaughtException', uncaught);
        fn(self.failures);
      });
    
      // uncaught exception
      process.on('uncaughtException', uncaught);
    
      if (this._delay) {
        // for reporters, I guess.
        // might be nice to debounce some dots while we wait.
        this.emit('waiting', rootSuite);
        rootSuite.once('run', start);
      }
      else {
        start();
      }
    
      return this;
    };
    
    /**
     * Cleanly abort execution
     *
     * @return {Runner} for chaining
     * @api public
     */
    Runner.prototype.abort = function(){
      debug('aborting');
      this._abort = true;
    };
    
    /**
     * Filter leaks with the given globals flagged as `ok`.
     *
     * @param {Array} ok
     * @param {Array} globals
     * @return {Array}
     * @api private
     */
    
    function filterLeaks(ok, globals) {
      return filter(globals, function(key){
        // Firefox and Chrome exposes iframes as index inside the window object
        if (/^d+/.test(key)) return false;
    
        // in firefox
        // if runner runs in an iframe, this iframe's window.getInterface method not init at first
        // it is assigned in some seconds
        if (global.navigator && /^getInterface/.test(key)) return false;
    
        // an iframe could be approached by window[iframeIndex]
        // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak
        if (global.navigator && /^\d+/.test(key)) return false;
    
        // Opera and IE expose global variables for HTML element IDs (issue #243)
        if (/^mocha-/.test(key)) return false;
    
        var matched = filter(ok, function(ok){
          if (~ok.indexOf('*')) return 0 == key.indexOf(ok.split('*')[0]);
          return key == ok;
        });
        return matched.length == 0 && (!global.navigator || 'onerror' !== key);
      });
    }
    
    /**
     * Array of globals dependent on the environment.
     *
     * @return {Array}
     * @api private
     */
    
    function extraGlobals() {
     if (typeof(process) === 'object' &&
         typeof(process.version) === 'string') {
    
       var nodeVersion = process.version.split('.').reduce(function(a, v) {
         return a << 8 | v;
       });
    
       // 'errno' was renamed to process._errno in v0.9.11.
    
       if (nodeVersion < 0x00090B) {
         return ['errno'];
       }
     }
    
     return [];
    }
    
  provide("mocha/lib/runner", module.exports);
}(global));

// pakmanager:mocha/lib/mocha
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * mocha
     * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
     * MIT Licensed
     */
    
    /**
     * Module dependencies.
     */
    
    var path = require('path')
      , escapeRe = require('escape-string-regexp')
      , utils =  require('mocha/lib/utils');
    
    /**
     * Expose `Mocha`.
     */
    
    exports = module.exports = Mocha;
    
    /**
     * To require local UIs and reporters when running in node.
     */
    
    if (typeof process !== 'undefined' && typeof process.cwd === 'function') {
      var join = path.join
        , cwd = process.cwd();
      module.paths.push(cwd, join(cwd, 'node_modules'));
    }
    
    /**
     * Expose internals.
     */
    
    exports.utils = utils;
    exports.interfaces =  require('mocha/lib/interfaces');
    exports.reporters =  require('mocha/lib/reporters');
    exports.Runnable =  require('mocha/lib/runnable');
    exports.Context =  require('mocha/lib/context');
    exports.Runner =  require('mocha/lib/runner');
    exports.Suite =  require('mocha/lib/suite');
    exports.Hook =  require('mocha/lib/hook');
    exports.Test =  require('mocha/lib/test');
    
    /**
     * Return image `name` path.
     *
     * @param {String} name
     * @return {String}
     * @api private
     */
    
    function image(name) {
      return __dirname + '/../images/' + name + '.png';
    }
    
    /**
     * Setup mocha with `options`.
     *
     * Options:
     *
     *   - `ui` name "bdd", "tdd", "exports" etc
     *   - `reporter` reporter instance, defaults to `mocha.reporters.spec`
     *   - `globals` array of accepted globals
     *   - `timeout` timeout in milliseconds
     *   - `bail` bail on the first test failure
     *   - `slow` milliseconds to wait before considering a test slow
     *   - `ignoreLeaks` ignore global leaks
     *   - `fullTrace` display the full stack-trace on failing
     *   - `grep` string or regexp to filter tests with
     *
     * @param {Object} options
     * @api public
     */
    
    function Mocha(options) {
      options = options || {};
      this.files = [];
      this.options = options;
      if (options.grep) this.grep(new RegExp(options.grep));
      if (options.fgrep) this.grep(options.fgrep);
      this.suite = new exports.Suite('', new exports.Context);
      this.ui(options.ui);
      this.bail(options.bail);
      this.reporter(options.reporter, options.reporterOptions);
      if (null != options.timeout) this.timeout(options.timeout);
      this.useColors(options.useColors);
      if (options.enableTimeouts !== null) this.enableTimeouts(options.enableTimeouts);
      if (options.slow) this.slow(options.slow);
    
      this.suite.on('pre-require', function (context) {
        exports.afterEach = context.afterEach || context.teardown;
        exports.after = context.after || context.suiteTeardown;
        exports.beforeEach = context.beforeEach || context.setup;
        exports.before = context.before || context.suiteSetup;
        exports.describe = context.describe || context.suite;
        exports.it = context.it || context.test;
        exports.setup = context.setup || context.beforeEach;
        exports.suiteSetup = context.suiteSetup || context.before;
        exports.suiteTeardown = context.suiteTeardown || context.after;
        exports.suite = context.suite || context.describe;
        exports.teardown = context.teardown || context.afterEach;
        exports.test = context.test || context.it;
        exports.run = context.run;
      });
    }
    
    /**
     * Enable or disable bailing on the first failure.
     *
     * @param {Boolean} [bail]
     * @api public
     */
    
    Mocha.prototype.bail = function(bail){
      if (0 == arguments.length) bail = true;
      this.suite.bail(bail);
      return this;
    };
    
    /**
     * Add test `file`.
     *
     * @param {String} file
     * @api public
     */
    
    Mocha.prototype.addFile = function(file){
      this.files.push(file);
      return this;
    };
    
    /**
     * Set reporter to `reporter`, defaults to "spec".
     *
     * @param {String|Function} reporter name or constructor
     * @param {Object} reporterOptions optional options
     * @api public
     */
    Mocha.prototype.reporter = function(reporter, reporterOptions){
      if ('function' == typeof reporter) {
        this._reporter = reporter;
      } else {
        reporter = reporter || 'spec';
        var _reporter;
        try { _reporter = require('./reporters/' + reporter); } catch (err) {}
        if (!_reporter) try { _reporter = require(reporter); } catch (err) {
          err.message.indexOf('Cannot find module') !== -1
            ? console.warn('"' + reporter + '" reporter not found')
            : console.warn('"' + reporter + '" reporter blew up with error:\n' + err.stack);
        }
        if (!_reporter && reporter === 'teamcity')
          console.warn('The Teamcity reporter was moved to a package named ' +
            'mocha-teamcity-reporter ' +
            '(https://npmjs.org/package/mocha-teamcity-reporter).');
        if (!_reporter) throw new Error('invalid reporter "' + reporter + '"');
        this._reporter = _reporter;
      }
      this.options.reporterOptions = reporterOptions;
      return this;
    };
    
    /**
     * Set test UI `name`, defaults to "bdd".
     *
     * @param {String} bdd
     * @api public
     */
    
    Mocha.prototype.ui = function(name){
      name = name || 'bdd';
      this._ui = exports.interfaces[name];
      if (!this._ui) try { this._ui = require(name); } catch (err) {}
      if (!this._ui) throw new Error('invalid interface "' + name + '"');
      this._ui = this._ui(this.suite);
      return this;
    };
    
    /**
     * Load registered files.
     *
     * @api private
     */
    
    Mocha.prototype.loadFiles = function(fn){
      var self = this;
      var suite = this.suite;
      var pending = this.files.length;
      this.files.forEach(function(file){
        file = path.resolve(file);
        suite.emit('pre-require', global, file, self);
        suite.emit('require', require(file), file, self);
        suite.emit('post-require', global, file, self);
        --pending || (fn && fn());
      });
    };
    
    /**
     * Enable growl support.
     *
     * @api private
     */
    
    Mocha.prototype._growl = function(runner, reporter) {
      var notify = require('growl');
    
      runner.on('end', function(){
        var stats = reporter.stats;
        if (stats.failures) {
          var msg = stats.failures + ' of ' + runner.total + ' tests failed';
          notify(msg, { name: 'mocha', title: 'Failed', image: image('error') });
        } else {
          notify(stats.passes + ' tests passed in ' + stats.duration + 'ms', {
              name: 'mocha'
            , title: 'Passed'
            , image: image('ok')
          });
        }
      });
    };
    
    /**
     * Add regexp to grep, if `re` is a string it is escaped.
     *
     * @param {RegExp|String} re
     * @return {Mocha}
     * @api public
     */
    
    Mocha.prototype.grep = function(re){
      this.options.grep = 'string' == typeof re
        ? new RegExp(escapeRe(re))
        : re;
      return this;
    };
    
    /**
     * Invert `.grep()` matches.
     *
     * @return {Mocha}
     * @api public
     */
    
    Mocha.prototype.invert = function(){
      this.options.invert = true;
      return this;
    };
    
    /**
     * Ignore global leaks.
     *
     * @param {Boolean} ignore
     * @return {Mocha}
     * @api public
     */
    
    Mocha.prototype.ignoreLeaks = function(ignore){
      this.options.ignoreLeaks = !!ignore;
      return this;
    };
    
    /**
     * Enable global leak checking.
     *
     * @return {Mocha}
     * @api public
     */
    
    Mocha.prototype.checkLeaks = function(){
      this.options.ignoreLeaks = false;
      return this;
    };
    
    /**
     * Display long stack-trace on failing
     *
     * @return {Mocha}
     * @api public
     */
    
    Mocha.prototype.fullTrace = function() {
      this.options.fullStackTrace = true;
      return this;
    };
    
    /**
     * Enable growl support.
     *
     * @return {Mocha}
     * @api public
     */
    
    Mocha.prototype.growl = function(){
      this.options.growl = true;
      return this;
    };
    
    /**
     * Ignore `globals` array or string.
     *
     * @param {Array|String} globals
     * @return {Mocha}
     * @api public
     */
    
    Mocha.prototype.globals = function(globals){
      this.options.globals = (this.options.globals || []).concat(globals);
      return this;
    };
    
    /**
     * Emit color output.
     *
     * @param {Boolean} colors
     * @return {Mocha}
     * @api public
     */
    
    Mocha.prototype.useColors = function(colors){
      if (colors !== undefined) {
        this.options.useColors = colors;
      }
      return this;
    };
    
    /**
     * Use inline diffs rather than +/-.
     *
     * @param {Boolean} inlineDiffs
     * @return {Mocha}
     * @api public
     */
    
    Mocha.prototype.useInlineDiffs = function(inlineDiffs) {
      this.options.useInlineDiffs = arguments.length && inlineDiffs != undefined
      ? inlineDiffs
      : false;
      return this;
    };
    
    /**
     * Set the timeout in milliseconds.
     *
     * @param {Number} timeout
     * @return {Mocha}
     * @api public
     */
    
    Mocha.prototype.timeout = function(timeout){
      this.suite.timeout(timeout);
      return this;
    };
    
    /**
     * Set slowness threshold in milliseconds.
     *
     * @param {Number} slow
     * @return {Mocha}
     * @api public
     */
    
    Mocha.prototype.slow = function(slow){
      this.suite.slow(slow);
      return this;
    };
    
    /**
     * Enable timeouts.
     *
     * @param {Boolean} enabled
     * @return {Mocha}
     * @api public
     */
    
    Mocha.prototype.enableTimeouts = function(enabled) {
      this.suite.enableTimeouts(arguments.length && enabled !== undefined
        ? enabled
        : true);
      return this
    };
    
    /**
     * Makes all tests async (accepting a callback)
     *
     * @return {Mocha}
     * @api public
     */
    
    Mocha.prototype.asyncOnly = function(){
      this.options.asyncOnly = true;
      return this;
    };
    
    /**
     * Disable syntax highlighting (in browser).
     * @returns {Mocha}
     * @api public
     */
    Mocha.prototype.noHighlighting = function() {
      this.options.noHighlighting = true;
      return this;
    };
    
    /**
     * Delay root suite execution.
     * @returns {Mocha}
     * @api public
     */
    Mocha.prototype.delay = function delay() {
      this.options.delay = true;
      return this;
    };
    
    /**
     * Run tests and invoke `fn()` when complete.
     *
     * @param {Function} fn
     * @return {Runner}
     * @api public
     */
    Mocha.prototype.run = function(fn){
      if (this.files.length) this.loadFiles();
      var suite = this.suite;
      var options = this.options;
      options.files = this.files;
      var runner = new exports.Runner(suite, options.delay);
      var reporter = new this._reporter(runner, options);
      runner.ignoreLeaks = false !== options.ignoreLeaks;
      runner.fullStackTrace = options.fullStackTrace;
      runner.asyncOnly = options.asyncOnly;
      if (options.grep) runner.grep(options.grep, options.invert);
      if (options.globals) runner.globals(options.globals);
      if (options.growl) this._growl(runner, reporter);
      if (options.useColors !== undefined) {
        exports.reporters.Base.useColors = options.useColors;
      }
      exports.reporters.Base.inlineDiffs = options.useInlineDiffs;
    
      function done(failures) {
          if (reporter.done) {
              reporter.done(failures, fn);
          } else fn && fn(failures);
      }
    
      return runner.run(done);
    };
    
  provide("mocha/lib/mocha", module.exports);
}(global));

// pakmanager:mocha
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = process.env.COV
      ? require('./lib-cov/mocha')
      :  require('mocha/lib/mocha');
    
  provide("mocha", module.exports);
}(global));

// pakmanager:nunjucks/src/lib
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var ArrayProto = Array.prototype;
    var ObjProto = Object.prototype;
    
    var escapeMap = {
        '&': '&amp;',
        '"': '&quot;',
        '\'': '&#39;',
        '<': '&lt;',
        '>': '&gt;'
    };
    
    var escapeRegex = /[&"'<>]/g;
    
    var lookupEscape = function(ch) {
        return escapeMap[ch];
    };
    
    var exports = module.exports = {};
    
    exports.withPrettyErrors = function(path, withInternals, func) {
        try {
            return func();
        } catch (e) {
            if (!e.Update) {
                // not one of ours, cast it
                e = new exports.TemplateError(e);
            }
            e.Update(path);
    
            // Unless they marked the dev flag, show them a trace from here
            if (!withInternals) {
                var old = e;
                e = new Error(old.message);
                e.name = old.name;
            }
    
            throw e;
        }
    };
    
    exports.TemplateError = function(message, lineno, colno) {
        var err = this;
    
        if (message instanceof Error) { // for casting regular js errors
            err = message;
            message = message.name + ': ' + message.message;
        } else {
            if(Error.captureStackTrace) {
                Error.captureStackTrace(err);
            }
        }
    
        err.name = 'Template render error';
        err.message = message;
        err.lineno = lineno;
        err.colno = colno;
        err.firstUpdate = true;
    
        err.Update = function(path) {
            var message = '(' + (path || 'unknown path') + ')';
    
            // only show lineno + colno next to path of template
            // where error occurred
            if (this.firstUpdate) {
                if(this.lineno && this.colno) {
                    message += ' [Line ' + this.lineno + ', Column ' + this.colno + ']';
                }
                else if(this.lineno) {
                    message += ' [Line ' + this.lineno + ']';
                }
            }
    
            message += '\n ';
            if (this.firstUpdate) {
                message += ' ';
            }
    
            this.message = message + (this.message || '');
            this.firstUpdate = false;
            return this;
        };
    
        return err;
    };
    
    exports.TemplateError.prototype = Error.prototype;
    
    exports.escape = function(val) {
      return val.replace(escapeRegex, lookupEscape);
    };
    
    exports.isFunction = function(obj) {
        return ObjProto.toString.call(obj) === '[object Function]';
    };
    
    exports.isArray = Array.isArray || function(obj) {
        return ObjProto.toString.call(obj) === '[object Array]';
    };
    
    exports.isString = function(obj) {
        return ObjProto.toString.call(obj) === '[object String]';
    };
    
    exports.isObject = function(obj) {
        return ObjProto.toString.call(obj) === '[object Object]';
    };
    
    exports.groupBy = function(obj, val) {
        var result = {};
        var iterator = exports.isFunction(val) ? val : function(obj) { return obj[val]; };
        for(var i=0; i<obj.length; i++) {
            var value = obj[i];
            var key = iterator(value, i);
            (result[key] || (result[key] = [])).push(value);
        }
        return result;
    };
    
    exports.toArray = function(obj) {
        return Array.prototype.slice.call(obj);
    };
    
    exports.without = function(array) {
        var result = [];
        if (!array) {
            return result;
        }
        var index = -1,
        length = array.length,
        contains = exports.toArray(arguments).slice(1);
    
        while(++index < length) {
            if(exports.indexOf(contains, array[index]) === -1) {
                result.push(array[index]);
            }
        }
        return result;
    };
    
    exports.extend = function(obj, obj2) {
        for(var k in obj2) {
            obj[k] = obj2[k];
        }
        return obj;
    };
    
    exports.repeat = function(char_, n) {
        var str = '';
        for(var i=0; i<n; i++) {
            str += char_;
        }
        return str;
    };
    
    exports.each = function(obj, func, context) {
        if(obj == null) {
            return;
        }
    
        if(ArrayProto.each && obj.each === ArrayProto.each) {
            obj.forEach(func, context);
        }
        else if(obj.length === +obj.length) {
            for(var i=0, l=obj.length; i<l; i++) {
                func.call(context, obj[i], i, obj);
            }
        }
    };
    
    exports.map = function(obj, func) {
        var results = [];
        if(obj == null) {
            return results;
        }
    
        if(ArrayProto.map && obj.map === ArrayProto.map) {
            return obj.map(func);
        }
    
        for(var i=0; i<obj.length; i++) {
            results[results.length] = func(obj[i], i);
        }
    
        if(obj.length === +obj.length) {
            results.length = obj.length;
        }
    
        return results;
    };
    
    exports.asyncIter = function(arr, iter, cb) {
        var i = -1;
    
        function next() {
            i++;
    
            if(i < arr.length) {
                iter(arr[i], i, next, cb);
            }
            else {
                cb();
            }
        }
    
        next();
    };
    
    exports.asyncFor = function(obj, iter, cb) {
        var keys = exports.keys(obj);
        var len = keys.length;
        var i = -1;
    
        function next() {
            i++;
            var k = keys[i];
    
            if(i < len) {
                iter(k, obj[k], i, len, next);
            }
            else {
                cb();
            }
        }
    
        next();
    };
    
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Polyfill
    exports.indexOf = Array.prototype.indexOf ?
        function (arr, searchElement, fromIndex) {
            return Array.prototype.indexOf.call(arr, searchElement, fromIndex);
        } :
        function (arr, searchElement, fromIndex) {
            var length = this.length >>> 0; // Hack to convert object.length to a UInt32
    
            fromIndex = +fromIndex || 0;
    
            if(Math.abs(fromIndex) === Infinity) {
                fromIndex = 0;
            }
    
            if(fromIndex < 0) {
                fromIndex += length;
                if (fromIndex < 0) {
                    fromIndex = 0;
                }
            }
    
            for(;fromIndex < length; fromIndex++) {
                if (arr[fromIndex] === searchElement) {
                    return fromIndex;
                }
            }
    
            return -1;
        };
    
    if(!Array.prototype.map) {
        Array.prototype.map = function() {
            throw new Error('map is unimplemented for this js engine');
        };
    }
    
    exports.keys = function(obj) {
        if(Object.prototype.keys) {
            return obj.keys();
        }
        else {
            var keys = [];
            for(var k in obj) {
                if(obj.hasOwnProperty(k)) {
                    keys.push(k);
                }
            }
            return keys;
        }
    }
    
  provide("nunjucks/src/lib", module.exports);
}(global));

// pakmanager:nunjucks/src/object
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    // A simple class system, more documentation to come
    
    function extend(cls, name, props) {
        // This does that same thing as Object.create, but with support for IE8
        var F = function() {};
        F.prototype = cls.prototype;
        var prototype = new F();
    
        var fnTest = /xyz/.test(function(){ xyz; }) ? /\bparent\b/ : /.*/;
        props = props || {};
    
        for(var k in props) {
            var src = props[k];
            var parent = prototype[k];
    
            if(typeof parent === 'function' &&
               typeof src === 'function' &&
               fnTest.test(src)) {
                prototype[k] = (function (src, parent) {
                    return function() {
                        // Save the current parent method
                        var tmp = this.parent;
    
                        // Set parent to the previous method, call, and restore
                        this.parent = parent;
                        var res = src.apply(this, arguments);
                        this.parent = tmp;
    
                        return res;
                    };
                })(src, parent);
            }
            else {
                prototype[k] = src;
            }
        }
    
        prototype.typename = name;
    
        var new_cls = function() {
            if(prototype.init) {
                prototype.init.apply(this, arguments);
            }
        };
    
        new_cls.prototype = prototype;
        new_cls.prototype.constructor = new_cls;
    
        new_cls.extend = function(name, props) {
            if(typeof name === 'object') {
                props = name;
                name = 'anonymous';
            }
            return extend(new_cls, name, props);
        };
    
        return new_cls;
    }
    
    module.exports = extend(Object, 'Object', {});
    
  provide("nunjucks/src/object", module.exports);
}(global));

// pakmanager:nunjucks/src/lexer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var lib =  require('nunjucks/src/lib');
    
    var whitespaceChars = ' \n\t\r\u00A0';
    var delimChars = '()[]{}%*-+/#,:|.<>=!';
    var intChars = '0123456789';
    
    var BLOCK_START = '{%';
    var BLOCK_END = '%}';
    var VARIABLE_START = '{{';
    var VARIABLE_END = '}}';
    var COMMENT_START = '{#';
    var COMMENT_END = '#}';
    
    var TOKEN_STRING = 'string';
    var TOKEN_WHITESPACE = 'whitespace';
    var TOKEN_DATA = 'data';
    var TOKEN_BLOCK_START = 'block-start';
    var TOKEN_BLOCK_END = 'block-end';
    var TOKEN_VARIABLE_START = 'variable-start';
    var TOKEN_VARIABLE_END = 'variable-end';
    var TOKEN_COMMENT = 'comment';
    var TOKEN_LEFT_PAREN = 'left-paren';
    var TOKEN_RIGHT_PAREN = 'right-paren';
    var TOKEN_LEFT_BRACKET = 'left-bracket';
    var TOKEN_RIGHT_BRACKET = 'right-bracket';
    var TOKEN_LEFT_CURLY = 'left-curly';
    var TOKEN_RIGHT_CURLY = 'right-curly';
    var TOKEN_OPERATOR = 'operator';
    var TOKEN_COMMA = 'comma';
    var TOKEN_COLON = 'colon';
    var TOKEN_PIPE = 'pipe';
    var TOKEN_INT = 'int';
    var TOKEN_FLOAT = 'float';
    var TOKEN_BOOLEAN = 'boolean';
    var TOKEN_SYMBOL = 'symbol';
    var TOKEN_SPECIAL = 'special';
    var TOKEN_REGEX = 'regex';
    
    function token(type, value, lineno, colno) {
        return {
            type: type,
            value: value,
            lineno: lineno,
            colno: colno
        };
    }
    
    function Tokenizer(str, opts) {
        this.str = str;
        this.index = 0;
        this.len = str.length;
        this.lineno = 0;
        this.colno = 0;
    
        this.in_code = false;
    
        opts = opts || {};
    
        var tags = opts.tags || {};
        this.tags = {
            BLOCK_START: tags.blockStart || BLOCK_START,
            BLOCK_END: tags.blockEnd || BLOCK_END,
            VARIABLE_START: tags.variableStart || VARIABLE_START,
            VARIABLE_END: tags.variableEnd || VARIABLE_END,
            COMMENT_START: tags.commentStart || COMMENT_START,
            COMMENT_END: tags.commentEnd || COMMENT_END
        };
    
        this.trimBlocks = !!opts.trimBlocks;
        this.lstripBlocks = !!opts.lstripBlocks;
    }
    
    Tokenizer.prototype.nextToken = function() {
        var lineno = this.lineno;
        var colno = this.colno;
        var tok;
    
        if(this.in_code) {
            // Otherwise, if we are in a block parse it as code
            var cur = this.current();
    
            if(this.is_finished()) {
                // We have nothing else to parse
                return null;
            }
            else if(cur === '"' || cur === '\'') {
                // We've hit a string
                return token(TOKEN_STRING, this.parseString(cur), lineno, colno);
            }
            else if((tok = this._extract(whitespaceChars))) {
                // We hit some whitespace
                return token(TOKEN_WHITESPACE, tok, lineno, colno);
            }
            else if((tok = this._extractString(this.tags.BLOCK_END)) ||
                    (tok = this._extractString('-' + this.tags.BLOCK_END))) {
                // Special check for the block end tag
                //
                // It is a requirement that start and end tags are composed of
                // delimiter characters (%{}[] etc), and our code always
                // breaks on delimiters so we can assume the token parsing
                // doesn't consume these elsewhere
                this.in_code = false;
                if(this.trimBlocks) {
                    cur = this.current();
                    if(cur === '\n') {
                        // Skip newline
                        this.forward();
                    }
                }
                return token(TOKEN_BLOCK_END, tok, lineno, colno);
            }
            else if((tok = this._extractString(this.tags.VARIABLE_END))) {
                // Special check for variable end tag (see above)
                this.in_code = false;
                return token(TOKEN_VARIABLE_END, tok, lineno, colno);
            }
            else if (cur === 'r' && this.str.charAt(this.index + 1) === '/') {
                // Skip past 'r/'.
                this.forwardN(2);
    
                // Extract until the end of the regex -- / ends it, \/ does not.
                var regexBody = '';
                while (!this.is_finished()) {
                    if (this.current() === '/' && this.previous() !== '\\') {
                        this.forward();
                        break;
                    } else {
                        regexBody += this.current();
                        this.forward();
                    }
                }
    
                // Check for flags.
                // The possible flags are according to https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/RegExp)
                var POSSIBLE_FLAGS = ['g', 'i', 'm', 'y'];
                var regexFlags = '';
                while (!this.is_finished()) {
                    var isCurrentAFlag = POSSIBLE_FLAGS.indexOf(this.current()) !== -1;
                    if (isCurrentAFlag) {
                        regexFlags += this.current();
                        this.forward();
                    } else {
                        break;
                    }
                }
    
                return token(TOKEN_REGEX, {body: regexBody, flags: regexFlags}, lineno, colno);
            }
            else if(delimChars.indexOf(cur) !== -1) {
                // We've hit a delimiter (a special char like a bracket)
                this.forward();
                var complexOps = ['==', '!=', '<=', '>=', '//', '**'];
                var curComplex = cur + this.current();
                var type;
    
                if(lib.indexOf(complexOps, curComplex) !== -1) {
                    this.forward();
                    cur = curComplex;
                }
    
                switch(cur) {
                case '(': type = TOKEN_LEFT_PAREN; break;
                case ')': type = TOKEN_RIGHT_PAREN; break;
                case '[': type = TOKEN_LEFT_BRACKET; break;
                case ']': type = TOKEN_RIGHT_BRACKET; break;
                case '{': type = TOKEN_LEFT_CURLY; break;
                case '}': type = TOKEN_RIGHT_CURLY; break;
                case ',': type = TOKEN_COMMA; break;
                case ':': type = TOKEN_COLON; break;
                case '|': type = TOKEN_PIPE; break;
                default: type = TOKEN_OPERATOR;
                }
    
                return token(type, cur, lineno, colno);
            }
            else {
                // We are not at whitespace or a delimiter, so extract the
                // text and parse it
                tok = this._extractUntil(whitespaceChars + delimChars);
    
                if(tok.match(/^[-+]?[0-9]+$/)) {
                    if(this.current() === '.') {
                        this.forward();
                        var dec = this._extract(intChars);
                        return token(TOKEN_FLOAT, tok + '.' + dec, lineno, colno);
                    }
                    else {
                        return token(TOKEN_INT, tok, lineno, colno);
                    }
                }
                else if(tok.match(/^(true|false)$/)) {
                    return token(TOKEN_BOOLEAN, tok, lineno, colno);
                }
                else if(tok) {
                    return token(TOKEN_SYMBOL, tok, lineno, colno);
                }
                else {
                    throw new Error('Unexpected value while parsing: ' + tok);
                }
            }
        }
        else {
            // Parse out the template text, breaking on tag
            // delimiters because we need to look for block/variable start
            // tags (don't use the full delimChars for optimization)
            var beginChars = (this.tags.BLOCK_START.charAt(0) +
                              this.tags.VARIABLE_START.charAt(0) +
                              this.tags.COMMENT_START.charAt(0) +
                              this.tags.COMMENT_END.charAt(0));
    
            if(this.is_finished()) {
                return null;
            }
            else if((tok = this._extractString(this.tags.BLOCK_START + '-')) ||
                    (tok = this._extractString(this.tags.BLOCK_START))) {
                this.in_code = true;
                return token(TOKEN_BLOCK_START, tok, lineno, colno);
            }
            else if((tok = this._extractString(this.tags.VARIABLE_START))) {
                this.in_code = true;
                return token(TOKEN_VARIABLE_START, tok, lineno, colno);
            }
            else {
                tok = '';
                var data;
                var in_comment = false;
    
                if(this._matches(this.tags.COMMENT_START)) {
                    in_comment = true;
                    tok = this._extractString(this.tags.COMMENT_START);
                }
    
                // Continually consume text, breaking on the tag delimiter
                // characters and checking to see if it's a start tag.
                //
                // We could hit the end of the template in the middle of
                // our looping, so check for the null return value from
                // _extractUntil
                while((data = this._extractUntil(beginChars)) !== null) {
                    tok += data;
    
                    if((this._matches(this.tags.BLOCK_START) ||
                        this._matches(this.tags.VARIABLE_START) ||
                        this._matches(this.tags.COMMENT_START)) &&
                      !in_comment) {
                        if(this.lstripBlocks &&
                            this._matches(this.tags.BLOCK_START) &&
                            this.colno > 0 &&
                            this.colno <= tok.length) {
                            var lastLine = tok.slice(-this.colno);
                            if(/^\s+$/.test(lastLine)) {
                                // Remove block leading whitespace from beginning of the string
                                tok = tok.slice(0, -this.colno);
                                if(!tok.length) {
                                    // All data removed, collapse to avoid unnecessary nodes
                                    // by returning next token (block start)
                                    return this.nextToken();
                                }
                            }
                        }
                        // If it is a start tag, stop looping
                        break;
                    }
                    else if(this._matches(this.tags.COMMENT_END)) {
                        if(!in_comment) {
                            throw new Error('unexpected end of comment');
                        }
                        tok += this._extractString(this.tags.COMMENT_END);
                        break;
                    }
                    else {
                        // It does not match any tag, so add the character and
                        // carry on
                        tok += this.current();
                        this.forward();
                    }
                }
    
                if(data === null && in_comment) {
                    throw new Error('expected end of comment, got end of file');
                }
    
                return token(in_comment ? TOKEN_COMMENT : TOKEN_DATA,
                             tok,
                             lineno,
                             colno);
            }
        }
    
        throw new Error('Could not parse text');
    };
    
    Tokenizer.prototype.parseString = function(delimiter) {
        this.forward();
    
        var lineno = this.lineno;
        var colno = this.colno;
        var str = '';
    
        while(!this.is_finished() && this.current() !== delimiter) {
            var cur = this.current();
    
            if(cur === '\\') {
                this.forward();
                switch(this.current()) {
                case 'n': str += '\n'; break;
                case 't': str += '\t'; break;
                case 'r': str += '\r'; break;
                default:
                    str += this.current();
                }
                this.forward();
            }
            else {
                str += cur;
                this.forward();
            }
        }
    
        this.forward();
        return str;
    };
    
    Tokenizer.prototype._matches = function(str) {
        if(this.index + str.length > this.len) {
            return null;
        }
    
        var m = this.str.slice(this.index, this.index + str.length);
        return m === str;
    };
    
    Tokenizer.prototype._extractString = function(str) {
        if(this._matches(str)) {
            this.index += str.length;
            return str;
        }
        return null;
    };
    
    Tokenizer.prototype._extractUntil = function(charString) {
        // Extract all non-matching chars, with the default matching set
        // to everything
        return this._extractMatching(true, charString || '');
    };
    
    Tokenizer.prototype._extract = function(charString) {
        // Extract all matching chars (no default, so charString must be
        // explicit)
        return this._extractMatching(false, charString);
    };
    
    Tokenizer.prototype._extractMatching = function (breakOnMatch, charString) {
        // Pull out characters until a breaking char is hit.
        // If breakOnMatch is false, a non-matching char stops it.
        // If breakOnMatch is true, a matching char stops it.
    
        if(this.is_finished()) {
            return null;
        }
    
        var first = charString.indexOf(this.current());
    
        // Only proceed if the first character doesn't meet our condition
        if((breakOnMatch && first === -1) ||
           (!breakOnMatch && first !== -1)) {
            var t = this.current();
            this.forward();
    
            // And pull out all the chars one at a time until we hit a
            // breaking char
            var idx = charString.indexOf(this.current());
    
            while(((breakOnMatch && idx === -1) ||
                   (!breakOnMatch && idx !== -1)) && !this.is_finished()) {
                t += this.current();
                this.forward();
    
                idx = charString.indexOf(this.current());
            }
    
            return t;
        }
    
        return '';
    };
    
    Tokenizer.prototype.is_finished = function() {
        return this.index >= this.len;
    };
    
    Tokenizer.prototype.forwardN = function(n) {
        for(var i=0; i<n; i++) {
            this.forward();
        }
    };
    
    Tokenizer.prototype.forward = function() {
        this.index++;
    
        if(this.previous() === '\n') {
            this.lineno++;
            this.colno = 0;
        }
        else {
            this.colno++;
        }
    };
    
    Tokenizer.prototype.back = function() {
        this.index--;
    
        if(this.current() === '\n') {
            this.lineno--;
    
            var idx = this.src.lastIndexOf('\n', this.index-1);
            if(idx === -1) {
                this.colno = this.index;
            }
            else {
                this.colno = this.index - idx;
            }
        }
        else {
            this.colno--;
        }
    };
    
    Tokenizer.prototype.current = function() {
        if(!this.is_finished()) {
            return this.str.charAt(this.index);
        }
        return '';
    };
    
    Tokenizer.prototype.previous = function() {
        return this.str.charAt(this.index-1);
    };
    
    module.exports = {
        lex: function(src, opts) {
            return new Tokenizer(src, opts);
        },
    
        TOKEN_STRING: TOKEN_STRING,
        TOKEN_WHITESPACE: TOKEN_WHITESPACE,
        TOKEN_DATA: TOKEN_DATA,
        TOKEN_BLOCK_START: TOKEN_BLOCK_START,
        TOKEN_BLOCK_END: TOKEN_BLOCK_END,
        TOKEN_VARIABLE_START: TOKEN_VARIABLE_START,
        TOKEN_VARIABLE_END: TOKEN_VARIABLE_END,
        TOKEN_COMMENT: TOKEN_COMMENT,
        TOKEN_LEFT_PAREN: TOKEN_LEFT_PAREN,
        TOKEN_RIGHT_PAREN: TOKEN_RIGHT_PAREN,
        TOKEN_LEFT_BRACKET: TOKEN_LEFT_BRACKET,
        TOKEN_RIGHT_BRACKET: TOKEN_RIGHT_BRACKET,
        TOKEN_LEFT_CURLY: TOKEN_LEFT_CURLY,
        TOKEN_RIGHT_CURLY: TOKEN_RIGHT_CURLY,
        TOKEN_OPERATOR: TOKEN_OPERATOR,
        TOKEN_COMMA: TOKEN_COMMA,
        TOKEN_COLON: TOKEN_COLON,
        TOKEN_PIPE: TOKEN_PIPE,
        TOKEN_INT: TOKEN_INT,
        TOKEN_FLOAT: TOKEN_FLOAT,
        TOKEN_BOOLEAN: TOKEN_BOOLEAN,
        TOKEN_SYMBOL: TOKEN_SYMBOL,
        TOKEN_SPECIAL: TOKEN_SPECIAL,
        TOKEN_REGEX: TOKEN_REGEX
    };
    
  provide("nunjucks/src/lexer", module.exports);
}(global));

// pakmanager:nunjucks/src/nodes
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var util = require('util');
    var lib =  require('nunjucks/src/lib');
    var Object =  require('nunjucks/src/object');
    
    function traverseAndCheck(obj, type, results) {
        if(obj instanceof type) {
            results.push(obj);
        }
    
        if(obj instanceof Node) {
            obj.findAll(type, results);
        }
    }
    
    var Node = Object.extend('Node', {
        init: function(lineno, colno) {
            this.lineno = lineno;
            this.colno = colno;
    
            var fields = this.fields;
            for(var i=0, l=fields.length; i<l; i++) {
                var field = fields[i];
    
                // The first two args are line/col numbers, so offset by 2
                var val = arguments[i + 2];
    
                // Fields should never be undefined, but null. It makes
                // testing easier to normalize values.
                if(val === undefined) {
                    val = null;
                }
    
                this[field] = val;
            }
        },
    
        findAll: function(type, results) {
            results = results || [];
    
            if(this instanceof NodeList) {
                var children = this.children;
    
                for(var i=0, l=children.length; i<l; i++) {
                    traverseAndCheck(children[i], type, results);
                }
            }
            else {
                var fields = this.fields;
    
                for(var i=0, l=fields.length; i<l; i++) {
                    traverseAndCheck(this[fields[i]], type, results);
                }
            }
    
            return results;
        },
    
        iterFields: function(func) {
            lib.each(this.fields, function(field) {
                func(this[field], field);
            }, this);
        }
    });
    
    // Abstract nodes
    var Value = Node.extend('Value', { fields: ['value'] });
    
    // Concrete nodes
    var NodeList = Node.extend('NodeList', {
        fields: ['children'],
    
        init: function(lineno, colno, nodes) {
            this.parent(lineno, colno, nodes || []);
        },
    
        addChild: function(node) {
            this.children.push(node);
        }
    });
    
    var Root = NodeList.extend('Root');
    var Literal = Value.extend('Literal');
    var Symbol = Value.extend('Symbol');
    var Group = NodeList.extend('Group');
    var Array = NodeList.extend('Array');
    var Pair = Node.extend('Pair', { fields: ['key', 'value'] });
    var Dict = NodeList.extend('Dict');
    var LookupVal = Node.extend('LookupVal', { fields: ['target', 'val'] });
    var If = Node.extend('If', { fields: ['cond', 'body', 'else_'] });
    var IfAsync = If.extend('IfAsync');
    var InlineIf = Node.extend('InlineIf', { fields: ['cond', 'body', 'else_'] });
    var For = Node.extend('For', { fields: ['arr', 'name', 'body', 'else_'] });
    var AsyncEach = For.extend('AsyncEach');
    var AsyncAll = For.extend('AsyncAll');
    var Macro = Node.extend('Macro', { fields: ['name', 'args', 'body'] });
    var Caller = Macro.extend('Caller');
    var Import = Node.extend('Import', { fields: ['template', 'target', 'withContext'] });
    var FromImport = Node.extend('FromImport', {
        fields: ['template', 'names', 'withContext'],
    
        init: function(lineno, colno, template, names, withContext) {
            this.parent(lineno, colno,
                        template,
                        names || new NodeList(), withContext);
        }
    });
    var FunCall = Node.extend('FunCall', { fields: ['name', 'args'] });
    var Filter = FunCall.extend('Filter');
    var FilterAsync = Filter.extend('FilterAsync', {
        fields: ['name', 'args', 'symbol']
    });
    var KeywordArgs = Dict.extend('KeywordArgs');
    var Block = Node.extend('Block', { fields: ['name', 'body'] });
    var Super = Node.extend('Super', { fields: ['blockName', 'symbol'] });
    var TemplateRef = Node.extend('TemplateRef', { fields: ['template'] });
    var Extends = TemplateRef.extend('Extends');
    var Include = TemplateRef.extend('Include');
    var Set = Node.extend('Set', { fields: ['targets', 'value'] });
    var Output = NodeList.extend('Output');
    var TemplateData = Literal.extend('TemplateData');
    var UnaryOp = Node.extend('UnaryOp', { fields: ['target'] });
    var BinOp = Node.extend('BinOp', { fields: ['left', 'right'] });
    var In = BinOp.extend('In');
    var Or = BinOp.extend('Or');
    var And = BinOp.extend('And');
    var Not = UnaryOp.extend('Not');
    var Add = BinOp.extend('Add');
    var Sub = BinOp.extend('Sub');
    var Mul = BinOp.extend('Mul');
    var Div = BinOp.extend('Div');
    var FloorDiv = BinOp.extend('FloorDiv');
    var Mod = BinOp.extend('Mod');
    var Pow = BinOp.extend('Pow');
    var Neg = UnaryOp.extend('Neg');
    var Pos = UnaryOp.extend('Pos');
    var Compare = Node.extend('Compare', { fields: ['expr', 'ops'] });
    var CompareOperand = Node.extend('CompareOperand', {
        fields: ['expr', 'type']
    });
    
    var CustomTag = Node.extend('CustomTag', {
        init: function(lineno, colno, name) {
            this.lineno = lineno;
            this.colno = colno;
            this.name = name;
        }
    });
    
    var CallExtension = Node.extend('CallExtension', {
        fields: ['extName', 'prop', 'args', 'contentArgs'],
    
        init: function(ext, prop, args, contentArgs) {
            this.extName = ext._name || ext;
            this.prop = prop;
            this.args = args || new NodeList();
            this.contentArgs = contentArgs || [];
            this.autoescape = ext.autoescape;
        }
    });
    
    var CallExtensionAsync = CallExtension.extend('CallExtensionAsync');
    
    // Print the AST in a nicely formatted tree format for debuggin
    function printNodes(node, indent) {
        indent = indent || 0;
    
        // This is hacky, but this is just a debugging function anyway
        function print(str, indent, inline) {
            var lines = str.split('\n');
    
            for(var i=0; i<lines.length; i++) {
                if(lines[i]) {
                    if((inline && i > 0) || !inline) {
                        for(var j=0; j<indent; j++) {
                            util.print(' ');
                        }
                    }
                }
    
                if(i === lines.length-1) {
                    util.print(lines[i]);
                }
                else {
                    util.puts(lines[i]);
                }
            }
        }
    
        print(node.typename + ': ', indent);
    
        if(node instanceof NodeList) {
            print('\n');
            lib.each(node.children, function(n) {
                printNodes(n, indent + 2);
            });
        }
        else if(node instanceof CallExtension) {
            print(node.extName + '.' + node.prop);
            print('\n');
    
            if(node.args) {
                printNodes(node.args, indent + 2);
            }
    
            if(node.contentArgs) {
                lib.each(node.contentArgs, function(n) {
                    printNodes(n, indent + 2);
                });
            }
        }
        else {
            var nodes = null;
            var props = null;
    
            node.iterFields(function(val, field) {
                if(val instanceof Node) {
                    nodes = nodes || {};
                    nodes[field] = val;
                }
                else {
                    props = props || {};
                    props[field] = val;
                }
            });
    
            if(props) {
                print(util.inspect(props, true, null) + '\n', null, true);
            }
            else {
                print('\n');
            }
    
            if(nodes) {
                for(var k in nodes) {
                    printNodes(nodes[k], indent + 2);
                }
            }
    
        }
    }
    
    // var t = new NodeList(0, 0,
    //                      [new Value(0, 0, 3),
    //                       new Value(0, 0, 10),
    //                       new Pair(0, 0,
    //                                new Value(0, 0, 'key'),
    //                                new Value(0, 0, 'value'))]);
    // printNodes(t);
    
    module.exports = {
        Node: Node,
        Root: Root,
        NodeList: NodeList,
        Value: Value,
        Literal: Literal,
        Symbol: Symbol,
        Group: Group,
        Array: Array,
        Pair: Pair,
        Dict: Dict,
        Output: Output,
        TemplateData: TemplateData,
        If: If,
        IfAsync: IfAsync,
        InlineIf: InlineIf,
        For: For,
        AsyncEach: AsyncEach,
        AsyncAll: AsyncAll,
        Macro: Macro,
        Caller: Caller,
        Import: Import,
        FromImport: FromImport,
        FunCall: FunCall,
        Filter: Filter,
        FilterAsync: FilterAsync,
        KeywordArgs: KeywordArgs,
        Block: Block,
        Super: Super,
        Extends: Extends,
        Include: Include,
        Set: Set,
        LookupVal: LookupVal,
        BinOp: BinOp,
        In: In,
        Or: Or,
        And: And,
        Not: Not,
        Add: Add,
        Sub: Sub,
        Mul: Mul,
        Div: Div,
        FloorDiv: FloorDiv,
        Mod: Mod,
        Pow: Pow,
        Neg: Neg,
        Pos: Pos,
        Compare: Compare,
        CompareOperand: CompareOperand,
    
        CallExtension: CallExtension,
        CallExtensionAsync: CallExtensionAsync,
    
        printNodes: printNodes
    };
    
  provide("nunjucks/src/nodes", module.exports);
}(global));

// pakmanager:nunjucks/src/loader
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var path = require('path');
    var Obj =  require('nunjucks/src/object');
    var lib =  require('nunjucks/src/lib');
    
    var Loader = Obj.extend({
        on: function(name, func) {
            this.listeners = this.listeners || {};
            this.listeners[name] = this.listeners[name] || [];
            this.listeners[name].push(func);
        },
    
        emit: function(name /*, arg1, arg2, ...*/) {
            var args = Array.prototype.slice.call(arguments, 1);
    
            if(this.listeners && this.listeners[name]) {
                lib.each(this.listeners[name], function(listener) {
                    listener.apply(null, args);
                });
            }
        },
    
        resolve: function(from, to) {
            return path.resolve(path.dirname(from), to);
        },
    
        isRelative: function(filename) {
            return (filename.indexOf('./') === 0 || filename.indexOf('../') === 0);
        }
    });
    
    module.exports = Loader;
    
  provide("nunjucks/src/loader", module.exports);
}(global));

// pakmanager:nunjucks/src/parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var lexer =  require('nunjucks/src/lexer');
    var nodes =  require('nunjucks/src/nodes');
    var Object =  require('nunjucks/src/object');
    var lib =  require('nunjucks/src/lib');
    
    var Parser = Object.extend({
        init: function (tokens) {
            this.tokens = tokens;
            this.peeked = null;
            this.breakOnBlocks = null;
            this.dropLeadingWhitespace = false;
    
            this.extensions = [];
        },
    
        nextToken: function (withWhitespace) {
            var tok;
    
            if(this.peeked) {
                if(!withWhitespace && this.peeked.type === lexer.TOKEN_WHITESPACE) {
                    this.peeked = null;
                }
                else {
                    tok = this.peeked;
                    this.peeked = null;
                    return tok;
                }
            }
    
            tok = this.tokens.nextToken();
    
            if(!withWhitespace) {
                while(tok && tok.type === lexer.TOKEN_WHITESPACE) {
                    tok = this.tokens.nextToken();
                }
            }
    
            return tok;
        },
    
        peekToken: function () {
            this.peeked = this.peeked || this.nextToken();
            return this.peeked;
        },
    
        pushToken: function(tok) {
            if(this.peeked) {
                throw new Error('pushToken: can only push one token on between reads');
            }
            this.peeked = tok;
        },
    
        fail: function (msg, lineno, colno) {
            if((lineno === undefined || colno === undefined) && this.peekToken()) {
                var tok = this.peekToken();
                lineno = tok.lineno;
                colno = tok.colno;
            }
            if (lineno !== undefined) lineno += 1;
            if (colno !== undefined) colno += 1;
    
            throw new lib.TemplateError(msg, lineno, colno);
        },
    
        skip: function(type) {
            var tok = this.nextToken();
            if(!tok || tok.type !== type) {
                this.pushToken(tok);
                return false;
            }
            return true;
        },
    
        expect: function(type) {
            var tok = this.nextToken();
            if(tok.type !== type) {
                this.fail('expected ' + type + ', got ' + tok.type,
                          tok.lineno,
                          tok.colno);
            }
            return tok;
        },
    
        skipValue: function(type, val) {
            var tok = this.nextToken();
            if(!tok || tok.type !== type || tok.value !== val) {
                this.pushToken(tok);
                return false;
            }
            return true;
        },
    
        skipWhitespace: function () {
            return this.skip(lexer.TOKEN_WHITESPACE);
        },
    
        skipSymbol: function(val) {
            return this.skipValue(lexer.TOKEN_SYMBOL, val);
        },
    
        advanceAfterBlockEnd: function(name) {
            if(!name) {
                var tok = this.peekToken();
    
                if(!tok) {
                    this.fail('unexpected end of file');
                }
    
                if(tok.type !== lexer.TOKEN_SYMBOL) {
                    this.fail('advanceAfterBlockEnd: expected symbol token or ' +
                              'explicit name to be passed');
                }
    
                name = this.nextToken().value;
            }
    
            var tok = this.nextToken();
    
            if(tok && tok.type === lexer.TOKEN_BLOCK_END) {
                if(tok.value.charAt(0) === '-') {
                    this.dropLeadingWhitespace = true;
                }
            }
            else {
                this.fail('expected block end in ' + name + ' statement');
            }
        },
    
        advanceAfterVariableEnd: function() {
            if(!this.skip(lexer.TOKEN_VARIABLE_END)) {
                this.fail('expected variable end');
            }
        },
    
        parseFor: function() {
            var forTok = this.peekToken();
            var node;
            var endBlock;
    
            if(this.skipSymbol('for')) {
                node = new nodes.For(forTok.lineno, forTok.colno);
                endBlock = 'endfor';
            }
            else if(this.skipSymbol('asyncEach')) {
                node = new nodes.AsyncEach(forTok.lineno, forTok.colno);
                endBlock = 'endeach';
            }
            else if(this.skipSymbol('asyncAll')) {
                node = new nodes.AsyncAll(forTok.lineno, forTok.colno);
                endBlock = 'endall';
            }
            else {
                this.fail('parseFor: expected for{Async}', forTok.lineno, forTok.colno);
            }
    
            node.name = this.parsePrimary();
    
            if(!(node.name instanceof nodes.Symbol)) {
                this.fail('parseFor: variable name expected for loop');
            }
    
            var type = this.peekToken().type;
            if(type === lexer.TOKEN_COMMA) {
                // key/value iteration
                var key = node.name;
                node.name = new nodes.Array(key.lineno, key.colno);
                node.name.addChild(key);
    
                while(this.skip(lexer.TOKEN_COMMA)) {
                    var prim = this.parsePrimary();
                    node.name.addChild(prim);
                }
            }
    
            if(!this.skipSymbol('in')) {
                this.fail('parseFor: expected "in" keyword for loop',
                          forTok.lineno,
                          forTok.colno);
            }
    
            node.arr = this.parseExpression();
            this.advanceAfterBlockEnd(forTok.value);
    
            node.body = this.parseUntilBlocks(endBlock, 'else');
    
            if(this.skipSymbol('else')) {
                this.advanceAfterBlockEnd('else');
                node.else_ = this.parseUntilBlocks(endBlock);
            }
    
            this.advanceAfterBlockEnd();
    
            return node;
        },
    
        parseMacro: function() {
            var macroTok = this.peekToken();
            if(!this.skipSymbol('macro')) {
                this.fail('expected macro');
            }
    
            var name = this.parsePrimary(true);
            var args = this.parseSignature();
            var node = new nodes.Macro(macroTok.lineno,
                                       macroTok.colno,
                                       name,
                                       args);
    
            this.advanceAfterBlockEnd(macroTok.value);
            node.body = this.parseUntilBlocks('endmacro');
            this.advanceAfterBlockEnd();
    
            return node;
        },
    
        parseCall: function() {
            // a call block is parsed as a normal FunCall, but with an added
            // 'caller' kwarg which is a Caller node.
            var callTok = this.peekToken();
            if(!this.skipSymbol('call')) {
                this.fail('expected call');
            }
    
            var callerArgs = this.parseSignature(true) || new nodes.NodeList();
            var macroCall = this.parsePrimary();
    
            this.advanceAfterBlockEnd(callTok.value);
            var body = this.parseUntilBlocks('endcall');
            this.advanceAfterBlockEnd();
    
            var callerName = new nodes.Symbol(callTok.lineno,
                                              callTok.colno,
                                              'caller');
            var callerNode = new nodes.Caller(callTok.lineno,
                                              callTok.colno,
                                              callerName,
                                              callerArgs,
                                              body);
    
            // add the additional caller kwarg, adding kwargs if necessary
            var args = macroCall.args.children;
            if (!(args[args.length-1] instanceof nodes.KeywordArgs)) {
              args.push(new nodes.KeywordArgs());
            }
            var kwargs = args[args.length - 1];
            kwargs.addChild(new nodes.Pair(callTok.lineno,
                                           callTok.colno,
                                           callerName,
                                           callerNode));
    
            return new nodes.Output(callTok.lineno,
                                    callTok.colno,
                                    [macroCall]);
        },
    
        parseWithContext: function() {
            var tok = this.peekToken();
    
            var withContext = null;
    
            if(this.skipSymbol('with')) {
                withContext = true;
            }
            else if(this.skipSymbol('without')) {
                withContext = false;
            }
    
            if(withContext !== null) {
                if(!this.skipSymbol('context')) {
                    this.fail('parseFrom: expected context after with/without',
                                tok.lineno,
                                tok.colno);
                }
            }
    
            return withContext;
        },
    
        parseImport: function() {
            var importTok = this.peekToken();
            if(!this.skipSymbol('import')) {
                this.fail('parseImport: expected import',
                          importTok.lineno,
                          importTok.colno);
            }
    
            var template = this.parseExpression();
    
            if(!this.skipSymbol('as')) {
                this.fail('parseImport: expected "as" keyword',
                                importTok.lineno,
                                importTok.colno);
            }
    
            var target = this.parsePrimary();
    
            var withContext = this.parseWithContext();
    
            var node = new nodes.Import(importTok.lineno,
                                        importTok.colno,
                                        template,
                                        target,
                                        withContext);
    
            this.advanceAfterBlockEnd(importTok.value);
    
            return node;
        },
    
        parseFrom: function() {
            var fromTok = this.peekToken();
            if(!this.skipSymbol('from')) {
                this.fail('parseFrom: expected from');
            }
    
            var template = this.parsePrimary();
    
            if(!this.skipSymbol('import')) {
                this.fail('parseFrom: expected import',
                                fromTok.lineno,
                                fromTok.colno);
            }
    
            var names = new nodes.NodeList(),
                withContext;
    
            while(1) {
                var nextTok = this.peekToken();
                if(nextTok.type === lexer.TOKEN_BLOCK_END) {
                    if(!names.children.length) {
                        this.fail('parseFrom: Expected at least one import name',
                                  fromTok.lineno,
                                  fromTok.colno);
                    }
    
                    // Since we are manually advancing past the block end,
                    // need to keep track of whitespace control (normally
                    // this is done in `advanceAfterBlockEnd`
                    if(nextTok.value.charAt(0) === '-') {
                        this.dropLeadingWhitespace = true;
                    }
    
                    this.nextToken();
                    break;
                }
    
                if(names.children.length > 0 && !this.skip(lexer.TOKEN_COMMA)) {
                    this.fail('parseFrom: expected comma',
                                    fromTok.lineno,
                                    fromTok.colno);
                }
    
                var name = this.parsePrimary();
                if(name.value.charAt(0) === '_') {
                    this.fail('parseFrom: names starting with an underscore ' +
                              'cannot be imported',
                              name.lineno,
                              name.colno);
                }
    
                if(this.skipSymbol('as')) {
                    var alias = this.parsePrimary();
                    names.addChild(new nodes.Pair(name.lineno,
                                                  name.colno,
                                                  name,
                                                  alias));
                }
                else {
                    names.addChild(name);
                }
    
                withContext = this.parseWithContext();
            }
    
            return new nodes.FromImport(fromTok.lineno,
                                        fromTok.colno,
                                        template,
                                        names,
                                        withContext);
        },
    
        parseBlock: function() {
            var tag = this.peekToken();
            if(!this.skipSymbol('block')) {
                this.fail('parseBlock: expected block', tag.lineno, tag.colno);
            }
    
            var node = new nodes.Block(tag.lineno, tag.colno);
    
            node.name = this.parsePrimary();
            if(!(node.name instanceof nodes.Symbol)) {
                this.fail('parseBlock: variable name expected',
                          tag.lineno,
                          tag.colno);
            }
    
            this.advanceAfterBlockEnd(tag.value);
    
            node.body = this.parseUntilBlocks('endblock');
    
            if(!this.peekToken()) {
                this.fail('parseBlock: expected endblock, got end of file');
            }
    
            this.advanceAfterBlockEnd();
    
            return node;
        },
    
        parseTemplateRef: function(tagName, nodeType) {
            var tag = this.peekToken();
            if(!this.skipSymbol(tagName)) {
                this.fail('parseTemplateRef: expected '+ tagName);
            }
    
            var node = new nodeType(tag.lineno, tag.colno);
            node.template = this.parseExpression();
    
            this.advanceAfterBlockEnd(tag.value);
            return node;
        },
    
        parseExtends: function() {
            return this.parseTemplateRef('extends', nodes.Extends);
        },
    
        parseInclude: function() {
            return this.parseTemplateRef('include', nodes.Include);
        },
    
        parseIf: function() {
            var tag = this.peekToken();
            var node;
    
            if(this.skipSymbol('if') || this.skipSymbol('elif')) {
                node = new nodes.If(tag.lineno, tag.colno);
            }
            else if(this.skipSymbol('ifAsync')) {
                node = new nodes.IfAsync(tag.lineno, tag.colno);
            }
            else {
                this.fail('parseIf: expected if or elif',
                          tag.lineno,
                          tag.colno);
            }
    
            node.cond = this.parseExpression();
            this.advanceAfterBlockEnd(tag.value);
    
            node.body = this.parseUntilBlocks('elif', 'else', 'endif');
            var tok = this.peekToken();
    
            switch(tok && tok.value) {
            case 'elif':
                node.else_ = this.parseIf();
                break;
            case 'else':
                this.advanceAfterBlockEnd();
                node.else_ = this.parseUntilBlocks('endif');
                this.advanceAfterBlockEnd();
                break;
            case 'endif':
                node.else_ = null;
                this.advanceAfterBlockEnd();
                break;
            default:
                this.fail('parseIf: expected endif, else, or endif, ' +
                          'got end of file');
            }
    
            return node;
        },
    
        parseSet: function() {
            var tag = this.peekToken();
            if(!this.skipSymbol('set')) {
                this.fail('parseSet: expected set', tag.lineno, tag.colno);
            }
    
            var node = new nodes.Set(tag.lineno, tag.colno, []);
    
            var target;
            while((target = this.parsePrimary())) {
                node.targets.push(target);
    
                if(!this.skip(lexer.TOKEN_COMMA)) {
                    break;
                }
            }
    
            if(!this.skipValue(lexer.TOKEN_OPERATOR, '=')) {
                this.fail('parseSet: expected = in set tag',
                          tag.lineno,
                          tag.colno);
            }
    
            node.value = this.parseExpression();
            this.advanceAfterBlockEnd(tag.value);
    
            return node;
        },
    
        parseStatement: function () {
            var tok = this.peekToken();
            var node;
    
            if(tok.type !== lexer.TOKEN_SYMBOL) {
                this.fail('tag name expected', tok.lineno, tok.colno);
            }
    
            if(this.breakOnBlocks &&
               lib.indexOf(this.breakOnBlocks, tok.value) !== -1) {
                return null;
            }
    
            switch(tok.value) {
            case 'raw': return this.parseRaw();
            case 'if':
            case 'ifAsync':
                return this.parseIf();
            case 'for':
            case 'asyncEach':
            case 'asyncAll':
                return this.parseFor();
            case 'block': return this.parseBlock();
            case 'extends': return this.parseExtends();
            case 'include': return this.parseInclude();
            case 'set': return this.parseSet();
            case 'macro': return this.parseMacro();
            case 'call': return this.parseCall();
            case 'import': return this.parseImport();
            case 'from': return this.parseFrom();
            default:
                if (this.extensions.length) {
                    for (var i = 0; i < this.extensions.length; i++) {
                        var ext = this.extensions[i];
                        if (lib.indexOf(ext.tags || [], tok.value) !== -1) {
                            return ext.parse(this, nodes, lexer);
                        }
                    }
                }
                this.fail('unknown block tag: ' + tok.value, tok.lineno, tok.colno);
            }
    
            return node;
        },
    
        parseRaw: function() {
            this.advanceAfterBlockEnd();
            var str = '';
            var begun = this.peekToken();
    
            while(1) {
                // Passing true gives us all the whitespace tokens as
                // well, which are usually ignored.
                var tok = this.nextToken(true);
    
                if(!tok) {
                    this.fail('expected endraw, got end of file');
                }
    
                if(tok.type === lexer.TOKEN_BLOCK_START) {
                    // We need to look for the `endraw` block statement,
                    // which involves a lookahead so carefully keep track
                    // of whitespace
                    var ws = null;
                    var name = this.nextToken(true);
    
                    if(name.type === lexer.TOKEN_WHITESPACE) {
                        ws = name;
                        name = this.nextToken();
                    }
    
                    if(name.type === lexer.TOKEN_SYMBOL &&
                       name.value === 'endraw') {
                        this.advanceAfterBlockEnd(name.value);
                        break;
                    }
                    else {
                        str += tok.value;
                        if(ws) {
                            str += ws.value;
                        }
                        str += name.value;
                    }
                }
                else if(tok.type === lexer.TOKEN_STRING) {
                    str += '"' + tok.value + '"';
                }
                else {
                    str += tok.value;
                }
            }
    
    
            var output = new nodes.Output(
                begun.lineno,
                begun.colno,
                [new nodes.TemplateData(begun.lineno, begun.colno, str)]
            );
    
            return output;
        },
    
        parsePostfix: function(node) {
            var tok = this.peekToken();
    
            while(tok) {
                if(tok.type === lexer.TOKEN_LEFT_PAREN) {
                    // Function call
                    node = new nodes.FunCall(tok.lineno,
                                             tok.colno,
                                             node,
                                             this.parseSignature());
                }
                else if(tok.type === lexer.TOKEN_LEFT_BRACKET) {
                    // Reference
                    var lookup = this.parseAggregate();
                    if(lookup.children.length > 1) {
                        this.fail('invalid index');
                    }
    
                    node =  new nodes.LookupVal(tok.lineno,
                                                tok.colno,
                                                node,
                                                lookup.children[0]);
                }
                else if(tok.type === lexer.TOKEN_OPERATOR && tok.value === '.') {
                    // Reference
                    this.nextToken();
                    var val = this.nextToken();
    
                    if(val.type !== lexer.TOKEN_SYMBOL) {
                        this.fail('expected name as lookup value, got ' + val.value,
                                  val.lineno,
                                  val.colno);
                    }
    
                    // Make a literal string because it's not a variable
                    // reference
                    var lookup = new nodes.Literal(val.lineno,
                                                   val.colno,
                                                   val.value);
    
                    node =  new nodes.LookupVal(tok.lineno,
                                                tok.colno,
                                                node,
                                                lookup);
                }
                else {
                    break;
                }
    
                tok = this.peekToken();
            }
    
            return node;
        },
    
        parseExpression: function() {
            var node = this.parseInlineIf();
            return node;
        },
    
        parseInlineIf: function() {
            var node = this.parseOr();
            if(this.skipSymbol('if')) {
                var cond_node = this.parseOr();
                var body_node = node;
                node = new nodes.InlineIf(node.lineno, node.colno);
                node.body = body_node;
                node.cond = cond_node;
                if(this.skipSymbol('else')) {
                    node.else_ = this.parseOr();
                } else {
                    node.else_ = null;
                }
            }
    
            return node;
        },
    
        parseOr: function() {
            var node = this.parseAnd();
            while(this.skipSymbol('or')) {
                var node2 = this.parseAnd();
                node = new nodes.Or(node.lineno,
                                    node.colno,
                                    node,
                                    node2);
            }
            return node;
        },
    
        parseAnd: function() {
            var node = this.parseNot();
            while(this.skipSymbol('and')) {
                var node2 = this.parseNot();
                node = new nodes.And(node.lineno,
                                     node.colno,
                                     node,
                                     node2);
            }
            return node;
        },
    
        parseNot: function() {
            var tok = this.peekToken();
            if(this.skipSymbol('not')) {
                return new nodes.Not(tok.lineno,
                                     tok.colno,
                                     this.parseNot());
            }
            return this.parseIn();
        },
    
        parseIn: function() {
          var node = this.parseCompare();
          while(1) {
            // check if the next token is 'not'
            var tok = this.nextToken();
            if (!tok) { break; }
            var invert = tok.type === lexer.TOKEN_SYMBOL && tok.value === 'not';
            // if it wasn't 'not', put it back
            if (!invert) { this.pushToken(tok); }
            if (this.skipSymbol('in')) {
              var node2 = this.parseCompare();
              node = new nodes.In(node.lineno,
                                  node.colno,
                                  node,
                                  node2);
              if (invert) {
                node = new nodes.Not(node.lineno,
                                     node.colno,
                                     node);
              }
            }
            else {
              // if we'd found a 'not' but this wasn't an 'in', put back the 'not'
              if (invert) { this.pushToken(tok); }
              break;
            }
          }
          return node;
        },
    
        parseCompare: function() {
            var compareOps = ['==', '!=', '<', '>', '<=', '>='];
            var expr = this.parseAdd();
            var ops = [];
    
            while(1) {
                var tok = this.nextToken();
    
                if(!tok) {
                    break;
                }
                else if(lib.indexOf(compareOps, tok.value) !== -1) {
                    ops.push(new nodes.CompareOperand(tok.lineno,
                                                      tok.colno,
                                                      this.parseAdd(),
                                                      tok.value));
                }
                else {
                    this.pushToken(tok);
                    break;
                }
            }
    
            if(ops.length) {
                return new nodes.Compare(ops[0].lineno,
                                         ops[0].colno,
                                         expr,
                                         ops);
            }
            else {
                return expr;
            }
        },
    
        parseAdd: function() {
            var node = this.parseSub();
            while(this.skipValue(lexer.TOKEN_OPERATOR, '+')) {
                var node2 = this.parseSub();
                node = new nodes.Add(node.lineno,
                                     node.colno,
                                     node,
                                     node2);
            }
            return node;
        },
    
        parseSub: function() {
            var node = this.parseMul();
            while(this.skipValue(lexer.TOKEN_OPERATOR, '-')) {
                var node2 = this.parseMul();
                node = new nodes.Sub(node.lineno,
                                     node.colno,
                                     node,
                                     node2);
            }
            return node;
        },
    
        parseMul: function() {
            var node = this.parseDiv();
            while(this.skipValue(lexer.TOKEN_OPERATOR, '*')) {
                var node2 = this.parseDiv();
                node = new nodes.Mul(node.lineno,
                                     node.colno,
                                     node,
                                     node2);
            }
            return node;
        },
    
        parseDiv: function() {
            var node = this.parseFloorDiv();
            while(this.skipValue(lexer.TOKEN_OPERATOR, '/')) {
                var node2 = this.parseFloorDiv();
                node = new nodes.Div(node.lineno,
                                     node.colno,
                                     node,
                                     node2);
            }
            return node;
        },
    
        parseFloorDiv: function() {
            var node = this.parseMod();
            while(this.skipValue(lexer.TOKEN_OPERATOR, '//')) {
                var node2 = this.parseMod();
                node = new nodes.FloorDiv(node.lineno,
                                          node.colno,
                                          node,
                                          node2);
            }
            return node;
        },
    
        parseMod: function() {
            var node = this.parsePow();
            while(this.skipValue(lexer.TOKEN_OPERATOR, '%')) {
                var node2 = this.parsePow();
                node = new nodes.Mod(node.lineno,
                                     node.colno,
                                     node,
                                     node2);
            }
            return node;
        },
    
        parsePow: function() {
            var node = this.parseUnary();
            while(this.skipValue(lexer.TOKEN_OPERATOR, '**')) {
                var node2 = this.parseUnary();
                node = new nodes.Pow(node.lineno,
                                     node.colno,
                                     node,
                                     node2);
            }
            return node;
        },
    
        parseUnary: function(noFilters) {
            var tok = this.peekToken();
            var node;
    
            if(this.skipValue(lexer.TOKEN_OPERATOR, '-')) {
                node = new nodes.Neg(tok.lineno,
                                     tok.colno,
                                     this.parseUnary(true));
            }
            else if(this.skipValue(lexer.TOKEN_OPERATOR, '+')) {
                node = new nodes.Pos(tok.lineno,
                                     tok.colno,
                                     this.parseUnary(true));
            }
            else {
                node = this.parsePrimary();
            }
    
            if(!noFilters) {
                node = this.parseFilter(node);
            }
    
            return node;
        },
    
        parsePrimary: function (noPostfix) {
            var tok = this.nextToken();
            var val = null;
            var node = null;
    
            if(!tok) {
                this.fail('expected expression, got end of file');
            }
            else if(tok.type === lexer.TOKEN_STRING) {
                val = tok.value;
            }
            else if(tok.type === lexer.TOKEN_INT) {
                val = parseInt(tok.value, 10);
            }
            else if(tok.type === lexer.TOKEN_FLOAT) {
                val = parseFloat(tok.value);
            }
            else if(tok.type === lexer.TOKEN_BOOLEAN) {
                if(tok.value === 'true') {
                    val = true;
                }
                else if(tok.value === 'false') {
                    val = false;
                }
                else {
                    this.fail('invalid boolean: ' + tok.value,
                              tok.lineno,
                              tok.colno);
                }
            }
            else if (tok.type === lexer.TOKEN_REGEX) {
                val = new RegExp(tok.value.body, tok.value.flags);
            }
    
            if(val !== null) {
                node = new nodes.Literal(tok.lineno, tok.colno, val);
            }
            else if(tok.type === lexer.TOKEN_SYMBOL) {
                node = new nodes.Symbol(tok.lineno, tok.colno, tok.value);
    
                if(!noPostfix) {
                    node = this.parsePostfix(node);
                }
            }
            else {
                // See if it's an aggregate type, we need to push the
                // current delimiter token back on
                this.pushToken(tok);
                node = this.parseAggregate();
            }
    
            if(node) {
                return node;
            }
            else {
                this.fail('unexpected token: ' + tok.value,
                          tok.lineno,
                          tok.colno);
            }
        },
    
        parseFilter: function(node) {
            while(this.skip(lexer.TOKEN_PIPE)) {
                var tok = this.expect(lexer.TOKEN_SYMBOL);
                var name = tok.value;
    
                while(this.skipValue(lexer.TOKEN_OPERATOR, '.')) {
                    name += '.' + this.expect(lexer.TOKEN_SYMBOL).value;
                }
    
                node = new nodes.Filter(
                    tok.lineno,
                    tok.colno,
                    new nodes.Symbol(tok.lineno,
                                     tok.colno,
                                     name),
                    new nodes.NodeList(
                        tok.lineno,
                        tok.colno,
                        [node])
                );
    
                if(this.peekToken().type === lexer.TOKEN_LEFT_PAREN) {
                    // Get a FunCall node and add the parameters to the
                    // filter
                    var call = this.parsePostfix(node);
                    node.args.children = node.args.children.concat(call.args.children);
                }
            }
    
            return node;
        },
    
        parseAggregate: function() {
            var tok = this.nextToken();
            var node;
    
            switch(tok.type) {
            case lexer.TOKEN_LEFT_PAREN:
                node = new nodes.Group(tok.lineno, tok.colno); break;
            case lexer.TOKEN_LEFT_BRACKET:
                node = new nodes.Array(tok.lineno, tok.colno); break;
            case lexer.TOKEN_LEFT_CURLY:
                node = new nodes.Dict(tok.lineno, tok.colno); break;
            default:
                return null;
            }
    
            while(1) {
                var type = this.peekToken().type;
                if(type === lexer.TOKEN_RIGHT_PAREN ||
                   type === lexer.TOKEN_RIGHT_BRACKET ||
                   type === lexer.TOKEN_RIGHT_CURLY) {
                    this.nextToken();
                    break;
                }
    
                if(node.children.length > 0) {
                    if(!this.skip(lexer.TOKEN_COMMA)) {
                        this.fail('parseAggregate: expected comma after expression',
                                  tok.lineno,
                                  tok.colno);
                    }
                }
    
                if(node instanceof nodes.Dict) {
                    // TODO: check for errors
                    var key = this.parsePrimary();
    
                    // We expect a key/value pair for dicts, separated by a
                    // colon
                    if(!this.skip(lexer.TOKEN_COLON)) {
                        this.fail('parseAggregate: expected colon after dict key',
                            tok.lineno,
                            tok.colno);
                    }
    
                    // TODO: check for errors
                    var value = this.parseExpression();
                    node.addChild(new nodes.Pair(key.lineno,
                                                 key.colno,
                                                 key,
                                                 value));
                }
                else {
                    // TODO: check for errors
                    var expr = this.parseExpression();
                    node.addChild(expr);
                }
            }
    
            return node;
        },
    
        parseSignature: function(tolerant, noParens) {
            var tok = this.peekToken();
            if(!noParens && tok.type !== lexer.TOKEN_LEFT_PAREN) {
                if(tolerant) {
                    return null;
                }
                else {
                    this.fail('expected arguments', tok.lineno, tok.colno);
                }
            }
    
            if(tok.type === lexer.TOKEN_LEFT_PAREN) {
                tok = this.nextToken();
            }
    
            var args = new nodes.NodeList(tok.lineno, tok.colno);
            var kwargs = new nodes.KeywordArgs(tok.lineno, tok.colno);
            var kwnames = [];
            var checkComma = false;
    
            while(1) {
                tok = this.peekToken();
                if(!noParens && tok.type === lexer.TOKEN_RIGHT_PAREN) {
                    this.nextToken();
                    break;
                }
                else if(noParens && tok.type === lexer.TOKEN_BLOCK_END) {
                    break;
                }
    
                if(checkComma && !this.skip(lexer.TOKEN_COMMA)) {
                    this.fail('parseSignature: expected comma after expression',
                              tok.lineno,
                              tok.colno);
                }
                else {
                    var arg = this.parseExpression();
    
                    if(this.skipValue(lexer.TOKEN_OPERATOR, '=')) {
                        kwargs.addChild(
                            new nodes.Pair(arg.lineno,
                                           arg.colno,
                                           arg,
                                           this.parseExpression())
                        );
                    }
                    else {
                        args.addChild(arg);
                    }
                }
    
                checkComma = true;
            }
    
            if(kwargs.children.length) {
                args.addChild(kwargs);
            }
    
            return args;
        },
    
        parseUntilBlocks: function(/* blockNames */) {
            var prev = this.breakOnBlocks;
            this.breakOnBlocks = lib.toArray(arguments);
    
            var ret = this.parse();
    
            this.breakOnBlocks = prev;
            return ret;
        },
    
        parseNodes: function () {
            var tok;
            var buf = [];
    
            while((tok = this.nextToken())) {
                if(tok.type === lexer.TOKEN_DATA) {
                    var data = tok.value;
                    var nextToken = this.peekToken();
                    var nextVal = nextToken && nextToken.value;
    
                    // If the last token has "-" we need to trim the
                    // leading whitespace of the data. This is marked with
                    // the `dropLeadingWhitespace` variable.
                    if(this.dropLeadingWhitespace) {
                        // TODO: this could be optimized (don't use regex)
                        data = data.replace(/^\s*/, '');
                        this.dropLeadingWhitespace = false;
                    }
    
                    // Same for the succeding block start token
                    if(nextToken &&
                       nextToken.type === lexer.TOKEN_BLOCK_START &&
                       nextVal.charAt(nextVal.length - 1) === '-') {
                        // TODO: this could be optimized (don't use regex)
                        data = data.replace(/\s*$/, '');
                    }
    
                    buf.push(new nodes.Output(tok.lineno,
                                              tok.colno,
                                              [new nodes.TemplateData(tok.lineno,
                                                                      tok.colno,
                                                                      data)]));
                }
                else if(tok.type === lexer.TOKEN_BLOCK_START) {
                    var n = this.parseStatement();
                    if(!n) {
                        break;
                    }
                    buf.push(n);
                }
                else if(tok.type === lexer.TOKEN_VARIABLE_START) {
                    var e = this.parseExpression();
                    this.advanceAfterVariableEnd();
                    buf.push(new nodes.Output(tok.lineno, tok.colno, [e]));
                }
                else if(tok.type !== lexer.TOKEN_COMMENT) {
                    // Ignore comments, otherwise this should be an error
                    this.fail('Unexpected token at top-level: ' +
                                    tok.type, tok.lineno, tok.colno);
                }
            }
    
            return buf;
        },
    
        parse: function() {
            return new nodes.NodeList(0, 0, this.parseNodes());
        },
    
        parseAsRoot: function() {
            return new nodes.Root(0, 0, this.parseNodes());
        }
    });
    
    // var util = require('util');
    
    // var l = lexer.lex('{%- if x -%}\n hello {% endif %}');
    // var t;
    // while((t = l.nextToken())) {
    //     console.log(util.inspect(t));
    // }
    
    // var p = new Parser(lexer.lex('{% if not x %}foo{% endif %}'));
    // var n = p.parseAsRoot();
    // nodes.printNodes(n);
    
    module.exports = {
        parse: function(src, extensions, opts) {
            var p = new Parser(lexer.lex(src, opts));
            if (extensions !== undefined) {
                p.extensions = extensions;
            }
            return p.parseAsRoot();
        }
    };
    
  provide("nunjucks/src/parser", module.exports);
}(global));

// pakmanager:nunjucks/src/transformer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var nodes =  require('nunjucks/src/nodes');
    var lib =  require('nunjucks/src/lib');
    
    var sym = 0;
    function gensym() {
        return 'hole_' + sym++;
    }
    
    // copy-on-write version of map
    function mapCOW(arr, func) {
        var res = null;
    
        for(var i=0; i<arr.length; i++) {
            var item = func(arr[i]);
    
            if(item !== arr[i]) {
                if(!res) {
                    res = arr.slice();
                }
    
                res[i] = item;
            }
        }
    
        return res || arr;
    }
    
    function walk(ast, func, depthFirst) {
        if(!(ast instanceof nodes.Node)) {
            return ast;
        }
    
        if(!depthFirst) {
            var astT = func(ast);
    
            if(astT && astT !== ast) {
                return astT;
            }
        }
    
        if(ast instanceof nodes.NodeList) {
            var children = mapCOW(ast.children, function(node) {
                return walk(node, func, depthFirst);
            });
    
            if(children !== ast.children) {
                ast = new nodes[ast.typename](ast.lineno, ast.colno, children);
            }
        }
        else if(ast instanceof nodes.CallExtension) {
            var args = walk(ast.args, func, depthFirst);
    
            var contentArgs = mapCOW(ast.contentArgs, function(node) {
                return walk(node, func, depthFirst);
            });
    
            if(args !== ast.args || contentArgs !== ast.contentArgs) {
                ast = new nodes[ast.typename](ast.extName,
                                              ast.prop,
                                              args,
                                              contentArgs);
            }
        }
        else {
            var props = ast.fields.map(function(field) {
                return ast[field];
            });
    
            var propsT = mapCOW(props, function(prop) {
                return walk(prop, func, depthFirst);
            });
    
            if(propsT !== props) {
                ast = new nodes[ast.typename](ast.lineno, ast.colno);
    
                propsT.forEach(function(prop, i) {
                    ast[ast.fields[i]] = prop;
                });
            }
        }
    
        return depthFirst ? (func(ast) || ast) : ast;
    }
    
    function depthWalk(ast, func) {
        return walk(ast, func, true);
    }
    
    function _liftFilters(node, asyncFilters, prop) {
        var children = [];
    
        var walked = depthWalk(prop ? node[prop] : node, function(node) {
            if(node instanceof nodes.Block) {
                return node;
            }
            else if((node instanceof nodes.Filter &&
                     lib.indexOf(asyncFilters, node.name.value) !== -1) ||
                    node instanceof nodes.CallExtensionAsync) {
                var symbol = new nodes.Symbol(node.lineno,
                                              node.colno,
                                              gensym());
    
                children.push(new nodes.FilterAsync(node.lineno,
                                                    node.colno,
                                                    node.name,
                                                    node.args,
                                                    symbol));
                return symbol;
            }
        });
    
        if(prop) {
            node[prop] = walked;
        }
        else {
            node = walked;
        }
    
        if(children.length) {
            children.push(node);
    
            return new nodes.NodeList(
                node.lineno,
                node.colno,
                children
            );
        }
        else {
            return node;
        }
    }
    
    function liftFilters(ast, asyncFilters) {
        return depthWalk(ast, function(node) {
            if(node instanceof nodes.Output) {
                return _liftFilters(node, asyncFilters);
            }
            else if(node instanceof nodes.For) {
                return _liftFilters(node, asyncFilters, 'arr');
            }
            else if(node instanceof nodes.If) {
                return _liftFilters(node, asyncFilters, 'cond');
            }
            else if(node instanceof nodes.CallExtension) {
                return _liftFilters(node, asyncFilters, 'args');
            }
        });
    }
    
    function liftSuper(ast) {
        return walk(ast, function(blockNode) {
            if(!(blockNode instanceof nodes.Block)) {
                return;
            }
    
            var hasSuper = false;
            var symbol = gensym();
    
            blockNode.body = walk(blockNode.body, function(node) {
                if(node instanceof nodes.FunCall &&
                   node.name.value === 'super') {
                    hasSuper = true;
                    return new nodes.Symbol(node.lineno, node.colno, symbol);
                }
            });
    
            if(hasSuper) {
                blockNode.body.children.unshift(new nodes.Super(
                    0, 0, blockNode.name, new nodes.Symbol(0, 0, symbol)
                ));
            }
        });
    }
    
    function convertStatements(ast) {
        return depthWalk(ast, function(node) {
            if(!(node instanceof nodes.If) &&
               !(node instanceof nodes.For)) {
                return;
            }
    
            var async = false;
            walk(node, function(node) {
                if(node instanceof nodes.FilterAsync ||
                   node instanceof nodes.IfAsync ||
                   node instanceof nodes.AsyncEach ||
                   node instanceof nodes.AsyncAll ||
                   node instanceof nodes.CallExtensionAsync) {
                    async = true;
                    // Stop iterating by returning the node
                    return node;
                }
            });
    
            if(async) {
    	        if(node instanceof nodes.If) {
                    return new nodes.IfAsync(
                        node.lineno,
                        node.colno,
                        node.cond,
                        node.body,
                        node.else_
                    );
                }
                else if(node instanceof nodes.For) {
                    return new nodes.AsyncEach(
                        node.lineno,
                        node.colno,
                        node.arr,
                        node.name,
                        node.body,
                        node.else_
                    );
                }
            }
        });
    }
    
    function cps(ast, asyncFilters) {
        return convertStatements(liftSuper(liftFilters(ast, asyncFilters)));
    }
    
    function transform(ast, asyncFilters, name) {
        return cps(ast, asyncFilters || []);
    }
    
    // var parser =  require('nunjucks/src/parser');
    // var src = 'hello {% foo %}{% endfoo %} end';
    // var ast = transform(parser.parse(src, [new FooExtension()]), ['bar']);
    // nodes.printNodes(ast);
    
    module.exports = {
        transform: transform
    };
    
  provide("nunjucks/src/transformer", module.exports);
}(global));

// pakmanager:nunjucks/src/runtime
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var lib =  require('nunjucks/src/lib');
    var Obj =  require('nunjucks/src/object');
    
    // Frames keep track of scoping both at compile-time and run-time so
    // we know how to access variables. Block tags can introduce special
    // variables, for example.
    var Frame = Obj.extend({
        init: function(parent) {
            this.variables = {};
            this.parent = parent;
        },
    
        set: function(name, val, resolveUp) {
            // Allow variables with dots by automatically creating the
            // nested structure
            var parts = name.split('.');
            var obj = this.variables;
            var frame = this;
    
            if(resolveUp) {
                if((frame = this.resolve(parts[0]))) {
                    frame.set(name, val);
                    return;
                }
                frame = this;
            }
    
            for(var i=0; i<parts.length - 1; i++) {
                var id = parts[i];
    
                if(!obj[id]) {
                    obj[id] = {};
                }
                obj = obj[id];
            }
    
            obj[parts[parts.length - 1]] = val;
        },
    
        get: function(name) {
            var val = this.variables[name];
            if(val !== undefined && val !== null) {
                return val;
            }
            return null;
        },
    
        lookup: function(name) {
            var p = this.parent;
            var val = this.variables[name];
            if(val !== undefined && val !== null) {
                return val;
            }
            return p && p.lookup(name);
        },
    
        resolve: function(name) {
            var p = this.parent;
            var val = this.variables[name];
            if(val !== undefined && val !== null) {
                return this;
            }
            return p && p.resolve(name);
        },
    
        push: function() {
            return new Frame(this);
        },
    
        pop: function() {
            return this.parent;
        }
    });
    
    function makeMacro(argNames, kwargNames, func) {
        return function() {
            var argCount = numArgs(arguments);
            var args;
            var kwargs = getKeywordArgs(arguments);
    
            if(argCount > argNames.length) {
                args = Array.prototype.slice.call(arguments, 0, argNames.length);
    
                // Positional arguments that should be passed in as
                // keyword arguments (essentially default values)
                var vals = Array.prototype.slice.call(arguments, args.length, argCount);
                for(var i=0; i<vals.length; i++) {
                    if(i < kwargNames.length) {
                        kwargs[kwargNames[i]] = vals[i];
                    }
                }
    
                args.push(kwargs);
            }
            else if(argCount < argNames.length) {
                args = Array.prototype.slice.call(arguments, 0, argCount);
    
                for(var i=argCount; i<argNames.length; i++) {
                    var arg = argNames[i];
    
                    // Keyword arguments that should be passed as
                    // positional arguments, i.e. the caller explicitly
                    // used the name of a positional arg
                    args.push(kwargs[arg]);
                    delete kwargs[arg];
                }
    
                args.push(kwargs);
            }
            else {
                args = arguments;
            }
    
            return func.apply(this, args);
        };
    }
    
    function makeKeywordArgs(obj) {
        obj.__keywords = true;
        return obj;
    }
    
    function getKeywordArgs(args) {
        var len = args.length;
        if(len) {
            var lastArg = args[len - 1];
            if(lastArg && lastArg.hasOwnProperty('__keywords')) {
                return lastArg;
            }
        }
        return {};
    }
    
    function numArgs(args) {
        var len = args.length;
        if(len === 0) {
            return 0;
        }
    
        var lastArg = args[len - 1];
        if(lastArg && lastArg.hasOwnProperty('__keywords')) {
            return len - 1;
        }
        else {
            return len;
        }
    }
    
    // A SafeString object indicates that the string should not be
    // autoescaped. This happens magically because autoescaping only
    // occurs on primitive string objects.
    function SafeString(val) {
        if(typeof val !== 'string') {
            return val;
        }
    
        this.val = val;
    }
    
    SafeString.prototype = Object.create(String.prototype);
    SafeString.prototype.valueOf = function() {
        return this.val;
    };
    SafeString.prototype.toString = function() {
        return this.val;
    };
    
    function copySafeness(dest, target) {
        if(dest instanceof SafeString) {
            return new SafeString(target);
        }
        return target.toString();
    }
    
    function markSafe(val) {
        var type = typeof val;
    
        if(type === 'string') {
            return new SafeString(val);
        }
        else if(type !== 'function') {
            return val;
        }
        else {
            return function() {
                var ret = val.apply(this, arguments);
    
                if(typeof ret === 'string') {
                    return new SafeString(ret);
                }
    
                return ret;
            };
        }
    }
    
    function suppressValue(val, autoescape) {
        val = (val !== undefined && val !== null) ? val : '';
    
        if(autoescape && typeof val === 'string') {
            val = lib.escape(val);
        }
    
        return val;
    }
    
    function memberLookup(obj, val) {
        obj = obj || {};
    
        if(typeof obj[val] === 'function') {
            return function() {
                return obj[val].apply(obj, arguments);
            };
        }
    
        return obj[val];
    }
    
    function callWrap(obj, name, args) {
        if(!obj) {
            throw new Error('Unable to call `' + name + '`, which is undefined or falsey');
        }
        else if(typeof obj !== 'function') {
            throw new Error('Unable to call `' + name + '`, which is not a function');
        }
    
        return obj.apply(this, args);
    }
    
    function contextOrFrameLookup(context, frame, name) {
        var val = frame.lookup(name);
        return (val !== undefined && val !== null) ?
            val :
            context.lookup(name);
    }
    
    function handleError(error, lineno, colno) {
        if(error.lineno) {
            return error;
        }
        else {
            return new lib.TemplateError(error, lineno, colno);
        }
    }
    
    function asyncEach(arr, dimen, iter, cb) {
        if(lib.isArray(arr)) {
            var len = arr.length;
    
            lib.asyncIter(arr, function(item, i, next) {
                switch(dimen) {
                case 1: iter(item, i, len, next); break;
                case 2: iter(item[0], item[1], i, len, next); break;
                case 3: iter(item[0], item[1], item[2], i, len, next); break;
                default:
                    item.push(i, next);
                    iter.apply(this, item);
                }
            }, cb);
        }
        else {
            lib.asyncFor(arr, function(key, val, i, len, next) {
                iter(key, val, i, len, next);
            }, cb);
        }
    }
    
    function asyncAll(arr, dimen, func, cb) {
        var finished = 0;
        var len;
        var outputArr;
    
        function done(i, output) {
            finished++;
            outputArr[i] = output;
    
            if(finished === len) {
                cb(null, outputArr.join(''));
            }
        }
    
        if(lib.isArray(arr)) {
            len = arr.length;
            outputArr = new Array(len);
    
            if(len === 0) {
                cb(null, '');
            }
            else {
                for(var i=0; i<arr.length; i++) {
                    var item = arr[i];
    
                    switch(dimen) {
                    case 1: func(item, i, len, done); break;
                    case 2: func(item[0], item[1], i, len, done); break;
                    case 3: func(item[0], item[1], item[2], i, len, done); break;
                    default:
                        item.push(i, done);
                        func.apply(this, item);
                    }
                }
            }
        }
        else {
            var keys = lib.keys(arr);
            len = keys.length;
            outputArr = new Array(len);
    
            if(len === 0) {
                cb(null, '');
            }
            else {
                for(var i=0; i<keys.length; i++) {
                    var k = keys[i];
                    func(k, arr[k], i, len, done);
                }
            }
        }
    }
    
    module.exports = {
        Frame: Frame,
        makeMacro: makeMacro,
        makeKeywordArgs: makeKeywordArgs,
        numArgs: numArgs,
        suppressValue: suppressValue,
        memberLookup: memberLookup,
        contextOrFrameLookup: contextOrFrameLookup,
        callWrap: callWrap,
        handleError: handleError,
        isArray: lib.isArray,
        keys: lib.keys,
        SafeString: SafeString,
        copySafeness: copySafeness,
        markSafe: markSafe,
        asyncEach: asyncEach,
        asyncAll: asyncAll
    };
    
  provide("nunjucks/src/runtime", module.exports);
}(global));

// pakmanager:nunjucks/src/node-loaders
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var fs = require('fs');
    var path = require('path');
    var lib =  require('nunjucks/src/lib');
    var Loader =  require('nunjucks/src/loader');
    var chokidar = require('chokidar');
    
    // Node <0.7.1 compatibility
    var existsSync = fs.existsSync || path.existsSync;
    
    var FileSystemLoader = Loader.extend({
        init: function(searchPaths, noWatch, noCache) {
            this.pathsToNames = {};
            this.noCache = !!noCache;
    
            if(searchPaths) {
                searchPaths = lib.isArray(searchPaths) ? searchPaths : [searchPaths];
                // For windows, convert to forward slashes
                this.searchPaths = searchPaths.map(path.normalize);
            }
            else {
                this.searchPaths = ['.'];
            }
    
            if(!noWatch) {
                // Watch all the templates in the paths and fire an event when
                // they change
                lib.each(this.searchPaths, function(p) {
                    if(existsSync(p)) {
                        var watcher = chokidar.watch(p);
    
                        watcher.on('all', function(event, fullname) {
                            fullname = path.resolve(fullname);
                            if(event === 'change' && fullname in this.pathsToNames) {
                                this.emit('update', this.pathsToNames[fullname]);
                            }
                        }.bind(this));
                    }
                }.bind(this));
            }
        },
    
        getSource: function(name) {
            var fullpath = null;
            var paths = this.searchPaths;
    
            for(var i=0; i<paths.length; i++) {
                var basePath = path.resolve(paths[i]);
                var p = path.resolve(paths[i], name);
    
                // Only allow the current directory and anything
                // underneath it to be searched
                if(p.indexOf(basePath) === 0 && existsSync(p)) {
                    fullpath = p;
                    break;
                }
            }
    
            if(!fullpath) {
                return null;
            }
    
            this.pathsToNames[fullpath] = name;
    
            return { src: fs.readFileSync(fullpath, 'utf-8'),
                     path: fullpath,
                     noCache: this.noCache };
        }
    });
    
    
    module.exports = {
        FileSystemLoader: FileSystemLoader
    };
    
  provide("nunjucks/src/node-loaders", module.exports);
}(global));

// pakmanager:nunjucks/src/web-loaders
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Loader =  require('nunjucks/src/loader');
    
    var WebLoader = Loader.extend({
        init: function(baseURL, neverUpdate) {
            // It's easy to use precompiled templates: just include them
            // before you configure nunjucks and this will automatically
            // pick it up and use it
            this.precompiled = window.nunjucksPrecompiled || {};
    
            this.baseURL = baseURL || '';
            this.neverUpdate = neverUpdate;
        },
    
        getSource: function(name) {
            if(this.precompiled[name]) {
                return {
                    src: { type: 'code',
                           obj: this.precompiled[name] },
                    path: name
                };
            }
            else {
                var src = this.fetch(this.baseURL + '/' + name);
                if(!src) {
                    return null;
                }
    
                return { src: src,
                         path: name,
                         noCache: !this.neverUpdate };
            }
        },
    
        fetch: function(url, callback) {
            // Only in the browser please
            var ajax;
            var loading = true;
            var src;
    
            if(window.XMLHttpRequest) { // Mozilla, Safari, ...
                ajax = new XMLHttpRequest();
            }
            else if(window.ActiveXObject) { // IE 8 and older
                ajax = new ActiveXObject('Microsoft.XMLHTTP');
            }
    
            ajax.onreadystatechange = function() {
                if(ajax.readyState === 4 && (ajax.status === 0 || ajax.status === 200) && loading) {
                    loading = false;
                    src = ajax.responseText;
                }
            };
    
            url += (url.indexOf('?') === -1 ? '?' : '&') + 's=' +
                   (new Date().getTime());
    
            // Synchronous because this API shouldn't be used in
            // production (pre-load compiled templates instead)
            ajax.open('GET', url, false);
            ajax.send();
    
            return src;
        }
    });
    
    module.exports = {
        WebLoader: WebLoader
    };
    
  provide("nunjucks/src/web-loaders", module.exports);
}(global));

// pakmanager:nunjucks/src/compiler
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var lib =  require('nunjucks/src/lib');
    var parser =  require('nunjucks/src/parser');
    var transformer =  require('nunjucks/src/transformer');
    var nodes =  require('nunjucks/src/nodes');
    var Object =  require('nunjucks/src/object');
    var Frame =  require('nunjucks/src/runtime').Frame;
    
    // These are all the same for now, but shouldn't be passed straight
    // through
    var compareOps = {
        '==': '==',
        '!=': '!=',
        '<': '<',
        '>': '>',
        '<=': '<=',
        '>=': '>='
    };
    
    // A common pattern is to emit binary operators
    function binOpEmitter(str) {
        return function(node, frame) {
            this.compile(node.left, frame);
            this.emit(str);
            this.compile(node.right, frame);
        };
    }
    
    var Compiler = Object.extend({
        init: function(templateName) {
            this.templateName = templateName;
            this.codebuf = [];
            this.lastId = 0;
            this.buffer = null;
            this.bufferStack = [];
            this.isChild = false;
            this.scopeClosers = '';
        },
    
        fail: function (msg, lineno, colno) {
            if (lineno !== undefined) lineno += 1;
            if (colno !== undefined) colno += 1;
    
            throw new lib.TemplateError(msg, lineno, colno);
        },
    
        pushBufferId: function(id) {
            this.bufferStack.push(this.buffer);
            this.buffer = id;
            this.emit('var ' + this.buffer + ' = "";');
        },
    
        popBufferId: function() {
            this.buffer = this.bufferStack.pop();
        },
    
        emit: function(code) {
            this.codebuf.push(code);
        },
    
        emitLine: function(code) {
            this.emit(code + '\n');
        },
    
        emitLines: function() {
            lib.each(lib.toArray(arguments), function(line) {
                this.emitLine(line);
            }, this);
        },
    
        emitFuncBegin: function(name) {
            this.buffer = 'output';
            this.scopeClosers = '';
            this.emitLine('function ' + name + '(env, context, frame, runtime, cb) {');
            this.emitLine('var lineno = null;');
            this.emitLine('var colno = null;');
            this.emitLine('var ' + this.buffer + ' = "";');
            this.emitLine('try {');
        },
    
        emitFuncEnd: function(noReturn) {
            if(!noReturn) {
                this.emitLine('cb(null, ' + this.buffer +');');
            }
    
            this.closeScopeLevels();
            this.emitLine('} catch (e) {');
            this.emitLine('  cb(runtime.handleError(e, lineno, colno));');
            this.emitLine('}');
            this.emitLine('}');
            this.buffer = null;
        },
    
        addScopeLevel: function() {
            this.scopeClosers += '})';
        },
    
        closeScopeLevels: function() {
            this.emitLine(this.scopeClosers + ';');
            this.scopeClosers = '';
        },
    
        withScopedSyntax: function(func) {
            var scopeClosers = this.scopeClosers;
            this.scopeClosers = '';
    
            func.call(this);
    
            this.closeScopeLevels();
            this.scopeClosers = scopeClosers;
        },
    
        makeCallback: function(res) {
            var err = this.tmpid();
    
            return 'function(' + err + (res ? ',' + res : '') + ') {\n' +
                'if(' + err + ') { cb(' + err + '); return; }';
        },
    
        tmpid: function() {
            this.lastId++;
            return 't_' + this.lastId;
        },
    
        _templateName: function() {
            return this.templateName == null? 'undefined' : JSON.stringify(this.templateName);
        },
    
        _bufferAppend: function(func) {
            this.emit(this.buffer + ' += runtime.suppressValue(');
            func.call(this);
            this.emit(', env.opts.autoescape);\n');
        },
    
        _compileChildren: function(node, frame) {
            var children = node.children;
            for(var i=0, l=children.length; i<l; i++) {
                this.compile(children[i], frame);
            }
        },
    
        _compileAggregate: function(node, frame, startChar, endChar) {
            if(startChar) {
                this.emit(startChar);
            }
    
            for(var i=0; i<node.children.length; i++) {
                if(i > 0) {
                    this.emit(',');
                }
    
                this.compile(node.children[i], frame);
            }
    
            if(endChar) {
                this.emit(endChar);
            }
        },
    
        _compileExpression: function(node, frame) {
            // TODO: I'm not really sure if this type check is worth it or
            // not.
            this.assertType(
                node,
                nodes.Literal,
                nodes.Symbol,
                nodes.Group,
                nodes.Array,
                nodes.Dict,
                nodes.FunCall,
                nodes.Caller,
                nodes.Filter,
                nodes.LookupVal,
                nodes.Compare,
                nodes.InlineIf,
                nodes.In,
                nodes.And,
                nodes.Or,
                nodes.Not,
                nodes.Add,
                nodes.Sub,
                nodes.Mul,
                nodes.Div,
                nodes.FloorDiv,
                nodes.Mod,
                nodes.Pow,
                nodes.Neg,
                nodes.Pos,
                nodes.Compare,
                nodes.NodeList
            );
            this.compile(node, frame);
        },
    
        assertType: function(node /*, types */) {
            var types = lib.toArray(arguments).slice(1);
            var success = false;
    
            for(var i=0; i<types.length; i++) {
                if(node instanceof types[i]) {
                    success = true;
                }
            }
    
            if(!success) {
                this.fail('assertType: invalid type: ' + node.typename,
                          node.lineno,
                          node.colno);
            }
        },
    
        compileCallExtension: function(node, frame, async) {
            var name = node.extName;
            var args = node.args;
            var contentArgs = node.contentArgs;
            var autoescape = typeof node.autoescape === 'boolean' ? node.autoescape : true;
            var transformedArgs = [];
    
            if(!async) {
                this.emit(this.buffer + ' += runtime.suppressValue(');
            }
    
            this.emit('env.getExtension("' + node.extName + '")["' + node.prop + '"](');
            this.emit('context');
    
            if(args || contentArgs) {
                this.emit(',');
            }
    
            if(args) {
                if(!(args instanceof nodes.NodeList)) {
                    this.fail('compileCallExtension: arguments must be a NodeList, ' +
                              'use `parser.parseSignature`');
                }
    
                lib.each(args.children, function(arg, i) {
                    // Tag arguments are passed normally to the call. Note
                    // that keyword arguments are turned into a single js
                    // object as the last argument, if they exist.
                    this._compileExpression(arg, frame);
    
                    if(i !== args.children.length - 1 || contentArgs.length) {
                        this.emit(',');
                    }
                }, this);
            }
    
            if(contentArgs.length) {
                lib.each(contentArgs, function(arg, i) {
                    if(i > 0) {
                        this.emit(',');
                    }
    
                    if(arg) {
                        var id = this.tmpid();
    
                        this.emitLine('function(cb) {');
                        this.emitLine('if(!cb) { cb = function(err) { if(err) { throw err; }}}');
                        this.pushBufferId(id);
    
                        this.withScopedSyntax(function() {
                            this.compile(arg, frame);
                            this.emitLine('cb(null, ' + id + ');');
                        });
    
                        this.popBufferId();
                        this.emitLine('return ' + id + ';');
                        this.emitLine('}');
                    }
                    else {
                        this.emit('null');
                    }
                }, this);
            }
    
            if(async) {
                var res = this.tmpid();
                this.emitLine(', ' + this.makeCallback(res));
                this.emitLine(this.buffer + ' += runtime.suppressValue(' + res + ', ' + autoescape + ' && env.opts.autoescape);');
                this.addScopeLevel();
            }
            else {
                this.emit(')');
                this.emit(', ' + autoescape + ' && env.opts.autoescape);\n');
            }
        },
    
        compileCallExtensionAsync: function(node, frame) {
            this.compileCallExtension(node, frame, true);
        },
    
        compileNodeList: function(node, frame) {
            this._compileChildren(node, frame);
        },
    
        compileLiteral: function(node, frame) {
            if(typeof node.value === 'string') {
                var val = node.value.replace(/\\/g, '\\\\');
                val = val.replace(/"/g, '\\"');
                val = val.replace(/\n/g, '\\n');
                val = val.replace(/\r/g, '\\r');
                val = val.replace(/\t/g, '\\t');
                this.emit('"' + val  + '"');
            }
            else {
                this.emit(node.value.toString());
            }
        },
    
        compileSymbol: function(node, frame) {
            var name = node.value;
            var v;
    
            if((v = frame.lookup(name))) {
                this.emit(v);
            }
            else {
                this.emit('runtime.contextOrFrameLookup(' +
                          'context, frame, "' + name + '")');
            }
        },
    
        compileGroup: function(node, frame) {
            this._compileAggregate(node, frame, '(', ')');
        },
    
        compileArray: function(node, frame) {
            this._compileAggregate(node, frame, '[', ']');
        },
    
        compileDict: function(node, frame) {
            this._compileAggregate(node, frame, '{', '}');
        },
    
        compilePair: function(node, frame) {
            var key = node.key;
            var val = node.value;
    
            if(key instanceof nodes.Symbol) {
                key = new nodes.Literal(key.lineno, key.colno, key.value);
            }
            else if(!(key instanceof nodes.Literal &&
                      typeof key.value === 'string')) {
                this.fail('compilePair: Dict keys must be strings or names',
                          key.lineno,
                          key.colno);
            }
    
            this.compile(key, frame);
            this.emit(': ');
            this._compileExpression(val, frame);
        },
    
        compileInlineIf: function(node, frame) {
            this.emit('(');
            this.compile(node.cond, frame);
            this.emit('?');
            this.compile(node.body, frame);
            this.emit(':');
            if(node.else_ !== null)
                this.compile(node.else_, frame);
            else
                this.emit('""');
            this.emit(')');
        },
    
        compileIn: function(node, frame) {
          this.emit('(');
          this.compile(node.right, frame);
          this.emit('.indexOf(');
          this.compile(node.left, frame);
          this.emit(') !== -1)');
        },
    
        compileOr: binOpEmitter(' || '),
        compileAnd: binOpEmitter(' && '),
        compileAdd: binOpEmitter(' + '),
        compileSub: binOpEmitter(' - '),
        compileMul: binOpEmitter(' * '),
        compileDiv: binOpEmitter(' / '),
        compileMod: binOpEmitter(' % '),
    
        compileNot: function(node, frame) {
            this.emit('!');
            this.compile(node.target, frame);
        },
    
        compileFloorDiv: function(node, frame) {
            this.emit('Math.floor(');
            this.compile(node.left, frame);
            this.emit(' / ');
            this.compile(node.right, frame);
            this.emit(')');
        },
    
        compilePow: function(node, frame) {
            this.emit('Math.pow(');
            this.compile(node.left, frame);
            this.emit(', ');
            this.compile(node.right, frame);
            this.emit(')');
        },
    
        compileNeg: function(node, frame) {
            this.emit('-');
            this.compile(node.target, frame);
        },
    
        compilePos: function(node, frame) {
            this.emit('+');
            this.compile(node.target, frame);
        },
    
        compileCompare: function(node, frame) {
            this.compile(node.expr, frame);
    
            for(var i=0; i<node.ops.length; i++) {
                var n = node.ops[i];
                this.emit(' ' + compareOps[n.type] + ' ');
                this.compile(n.expr, frame);
            }
        },
    
        compileLookupVal: function(node, frame) {
            this.emit('runtime.memberLookup((');
            this._compileExpression(node.target, frame);
            this.emit('),');
            this._compileExpression(node.val, frame);
            this.emit(', env.opts.autoescape)');
        },
    
        _getNodeName: function(node) {
            switch (node.typename) {
                case 'Symbol':
                    return node.value;
                case 'FunCall':
                    return 'the return value of (' + this._getNodeName(node.name) + ')';
                case 'LookupVal':
                    return this._getNodeName(node.target) + '["' +
                           this._getNodeName(node.val) + '"]';
                case 'Literal':
                    return node.value.toString().substr(0, 10);
                default:
                    return '--expression--';
            }
        },
    
        compileFunCall: function(node, frame) {
            // Keep track of line/col info at runtime by settings
            // variables within an expression. An expression in javascript
            // like (x, y, z) returns the last value, and x and y can be
            // anything
            this.emit('(lineno = ' + node.lineno +
                      ', colno = ' + node.colno + ', ');
    
            this.emit('runtime.callWrap(');
            // Compile it as normal.
            this._compileExpression(node.name, frame);
    
            // Output the name of what we're calling so we can get friendly errors
            // if the lookup fails.
            this.emit(', "' + this._getNodeName(node.name).replace(/"/g, '\\"') + '", ');
    
            this._compileAggregate(node.args, frame, '[', '])');
    
            this.emit(')');
        },
    
        compileFilter: function(node, frame) {
            var name = node.name;
            this.assertType(name, nodes.Symbol);
    
            this.emit('env.getFilter("' + name.value + '").call(context, ');
            this._compileAggregate(node.args, frame);
            this.emit(')');
        },
    
        compileFilterAsync: function(node, frame) {
            var name = node.name;
            this.assertType(name, nodes.Symbol);
    
            var symbol = node.symbol.value;
            frame.set(symbol, symbol);
    
            this.emit('env.getFilter("' + name.value + '").call(context, ');
            this._compileAggregate(node.args, frame);
            this.emitLine(', ' + this.makeCallback(symbol));
    
            this.addScopeLevel();
        },
    
        compileKeywordArgs: function(node, frame) {
            var names = [];
    
            lib.each(node.children, function(pair) {
                names.push(pair.key.value);
            });
    
            this.emit('runtime.makeKeywordArgs(');
            this.compileDict(node, frame);
            this.emit(')');
        },
    
        compileSet: function(node, frame) {
            var ids = [];
    
            // Lookup the variable names for each identifier and create
            // new ones if necessary
            lib.each(node.targets, function(target) {
                var name = target.value;
                var id = frame.lookup(name);
    
                if (id === null || id === undefined) {
                    id = this.tmpid();
    
                    // Note: This relies on js allowing scope across
                    // blocks, in case this is created inside an `if`
                    this.emitLine('var ' + id + ';');
                }
    
                ids.push(id);
            }, this);
    
            this.emit(ids.join(' = ') + ' = ');
            this._compileExpression(node.value, frame);
            this.emitLine(';');
    
            lib.each(node.targets, function(target, i) {
                var id = ids[i];
                var name = target.value;
    
                this.emitLine('frame.set("' + name + '", ' + id + ', true);');
    
                // We are running this for every var, but it's very
                // uncommon to assign to multiple vars anyway
                this.emitLine('if(!frame.parent) {');
                this.emitLine('context.setVariable("' + name + '", ' + id + ');');
                if(name.charAt(0) !== '_') {
                    this.emitLine('context.addExport("' + name + '");');
                }
                this.emitLine('}');
            }, this);
        },
    
        compileIf: function(node, frame, async) {
            this.emit('if(');
            this._compileExpression(node.cond, frame);
            this.emitLine(') {');
    
            this.withScopedSyntax(function() {
                this.compile(node.body, frame);
    
                if(async) {
                    this.emit('cb()');
                }
            });
    
            if(node.else_) {
                this.emitLine('}\nelse {');
    
                this.withScopedSyntax(function() {
                    this.compile(node.else_, frame);
    
                    if(async) {
                        this.emit('cb()');
                    }
                });
            } else if(async) {
                this.emitLine('}\nelse {');
                this.emit('cb()');
            }
    
            this.emitLine('}');
        },
    
        compileIfAsync: function(node, frame) {
            this.emit('(function(cb) {');
            this.compileIf(node, frame, true);
            this.emit('})(function() {');
            this.addScopeLevel();
        },
    
        emitLoopBindings: function(node, arr, i, len) {
            var bindings = {
                index: i + ' + 1',
                index0: i,
                revindex: len + ' - ' + i,
                revindex0: len + ' - ' + i + ' - 1',
                first: i + ' === 0',
                last: i + ' === ' + len + ' - 1',
                length: len
            };
    
            for (var name in bindings) {
                this.emitLine('frame.set("loop.' + name + '", ' + bindings[name] + ');');
            }
        },
    
        compileFor: function(node, frame) {
            // Some of this code is ugly, but it keeps the generated code
            // as fast as possible. ForAsync also shares some of this, but
            // not much.
    
            var i = this.tmpid();
            var len = this.tmpid();
            var arr = this.tmpid();
            frame = frame.push();
    
            this.emitLine('frame = frame.push();');
    
            this.emit('var ' + arr + ' = ');
            this._compileExpression(node.arr, frame);
            this.emitLine(';');
    
            this.emit('if(' + arr + ') {');
    
            // If multiple names are passed, we need to bind them
            // appropriately
            if(node.name instanceof nodes.Array) {
                this.emitLine('var ' + i + ';');
    
                // The object could be an arroy or object. Note that the
                // body of the loop is duplicated for each condition, but
                // we are optimizing for speed over size.
                this.emitLine('if(runtime.isArray(' + arr + ')) {'); {
                    this.emitLine('var ' + len + ' = ' + arr + '.length;');
                    this.emitLine('for(' + i + '=0; ' + i + ' < ' + arr + '.length; '
                                  + i + '++) {');
    
                    // Bind each declared var
                    for (var u=0; u < node.name.children.length; u++) {
                        var tid = this.tmpid();
                        this.emitLine('var ' + tid + ' = ' + arr + '[' + i + '][' + u + ']');
                        this.emitLine('frame.set("' + node.name.children[u].value
                                      + '", ' + arr + '[' + i + '][' + u + ']' + ');');
                        frame.set(node.name.children[u].value, tid);
                    }
    
                    this.emitLoopBindings(node, arr, i, len);
                    this.withScopedSyntax(function() {
                        this.compile(node.body, frame);
                    });
                    this.emitLine('}');
                }
    
                this.emitLine('} else {'); {
                    // Iterate over the key/values of an object
                    var key = node.name.children[0];
                    var val = node.name.children[1];
                    var k = this.tmpid();
                    var v = this.tmpid();
                    frame.set(key.value, k);
                    frame.set(val.value, v);
    
                    this.emitLine(i + ' = -1;');
                    this.emitLine('var ' + len + ' = runtime.keys(' + arr + ').length;');
                    this.emitLine('for(var ' + k + ' in ' + arr + ') {');
                    this.emitLine(i + '++;');
                    this.emitLine('var ' + v + ' = ' + arr + '[' + k + '];');
                    this.emitLine('frame.set("' + key.value + '", ' + k + ');');
                    this.emitLine('frame.set("' + val.value + '", ' + v + ');');
    
                    this.emitLoopBindings(node, arr, i, len);
                    this.withScopedSyntax(function() {
                        this.compile(node.body, frame);
                    });
                    this.emitLine('}');
                }
    
                this.emitLine('}');
            }
            else {
                // Generate a typical array iteration
                var v = this.tmpid();
                frame.set(node.name.value, v);
    
                this.emitLine('var ' + len + ' = ' + arr + '.length;');
                this.emitLine('for(var ' + i + '=0; ' + i + ' < ' + arr + '.length; ' +
                              i + '++) {');
                this.emitLine('var ' + v + ' = ' + arr + '[' + i + '];');
                this.emitLine('frame.set("' + node.name.value + '", ' + v + ');');
    
                this.emitLoopBindings(node, arr, i, len);
    
                this.withScopedSyntax(function() {
                    this.compile(node.body, frame);
                });
    
                this.emitLine('}');
            }
    
            this.emitLine('}');
            if (node.else_) {
              this.emitLine('if (!' + len + ') {');
              this.compile(node.else_, frame);
              this.emitLine('}');
            }
    
            this.emitLine('frame = frame.pop();');
        },
    
        _compileAsyncLoop: function(node, frame, parallel) {
            // This shares some code with the For tag, but not enough to
            // worry about. This iterates across an object asynchronously,
            // but not in parallel.
    
            var i = this.tmpid();
            var len = this.tmpid();
            var arr = this.tmpid();
            var asyncMethod = parallel ? 'asyncAll' : 'asyncEach';
            frame = frame.push();
    
            this.emitLine('frame = frame.push();');
    
            this.emit('var ' + arr + ' = ');
            this._compileExpression(node.arr, frame);
            this.emitLine(';');
    
            if(node.name instanceof nodes.Array) {
                this.emit('runtime.' + asyncMethod + '(' + arr + ', ' +
                          node.name.children.length + ', function(');
    
                lib.each(node.name.children, function(name) {
                    this.emit(name.value + ',');
                }, this);
    
                this.emit(i + ',' + len + ',next) {');
    
                lib.each(node.name.children, function(name) {
                    var id = name.value;
                    frame.set(id, id);
                    this.emitLine('frame.set("' + id + '", ' + id + ');');
                }, this);
            }
            else {
                var id = node.name.value;
                this.emitLine('runtime.' + asyncMethod + '(' + arr + ', 1, function(' + id + ', ' + i + ', ' + len + ',next) {');
                this.emitLine('frame.set("' + id + '", ' + id + ');');
                frame.set(id, id);
            }
    
            this.emitLoopBindings(node, arr, i, len);
    
            this.withScopedSyntax(function() {
                var buf;
                if(parallel) {
                    buf = this.tmpid();
                    this.pushBufferId(buf);
                }
    
                this.compile(node.body, frame);
                this.emitLine('next(' + i + (buf ? ',' + buf : '') + ');');
    
                if(parallel) {
                    this.popBufferId();
                }
            });
    
            var output = this.tmpid();
            this.emitLine('}, ' + this.makeCallback(output));
            this.addScopeLevel();
    
            if(parallel) {
                this.emitLine(this.buffer + ' += ' + output + ';');
            }
    
            if (node.else_) {
              this.emitLine('if (!' + arr + '.length) {');
              this.compile(node.else_, frame);
              this.emitLine('}');
            }
    
            this.emitLine('frame = frame.pop();');
        },
    
        compileAsyncEach: function(node, frame) {
            this._compileAsyncLoop(node, frame);
        },
    
        compileAsyncAll: function(node, frame) {
            this._compileAsyncLoop(node, frame, true);
        },
    
        _compileMacro: function(node, frame) {
            var args = [];
            var kwargs = null;
            var funcId = 'macro_' + this.tmpid();
    
            // Type check the definition of the args
            lib.each(node.args.children, function(arg, i) {
                if(i === node.args.children.length - 1 &&
                   arg instanceof nodes.Dict) {
                    kwargs = arg;
                }
                else {
                    this.assertType(arg, nodes.Symbol);
                    args.push(arg);
                }
            }, this);
    
            var realNames = lib.map(args, function(n) { return 'l_' + n.value; });
            realNames.push('kwargs');
    
            // Quoted argument names
            var argNames = lib.map(args, function(n) { return '"' + n.value + '"'; });
            var kwargNames = lib.map((kwargs && kwargs.children) || [],
                                     function(n) { return '"' + n.key.value + '"'; });
    
            // We pass a function to makeMacro which destructures the
            // arguments so support setting positional args with keywords
            // args and passing keyword args as positional args
            // (essentially default values). See runtime.js.
            frame = frame.push();
            this.emitLines(
                'var ' + funcId + ' = runtime.makeMacro(',
                '[' + argNames.join(', ') + '], ',
                '[' + kwargNames.join(', ') + '], ',
                'function (' + realNames.join(', ') + ') {',
                'frame = frame.push();',
                'kwargs = kwargs || {};',
                'if (kwargs.hasOwnProperty("caller")) {',
                'frame.set("caller", kwargs.caller); }'
            );
    
            // Expose the arguments to the template. Don't need to use
            // random names because the function
            // will create a new run-time scope for us
            lib.each(args, function(arg) {
                this.emitLine('frame.set("' + arg.value + '", ' +
                              'l_' + arg.value + ');');
                frame.set(arg.value, 'l_' + arg.value);
            }, this);
    
            // Expose the keyword arguments
            if(kwargs) {
                lib.each(kwargs.children, function(pair) {
                    var name = pair.key.value;
                    this.emit('frame.set("' + name + '", ' +
                              'kwargs.hasOwnProperty("' + name + '") ? ' +
                              'kwargs["' + name + '"] : ');
                    this._compileExpression(pair.value, frame);
                    this.emitLine(');');
                }, this);
            }
    
            var bufferId = this.tmpid();
            this.pushBufferId(bufferId);
    
            this.withScopedSyntax(function () {
              this.compile(node.body, frame);
            });
    
            frame = frame.pop();
            this.emitLine('frame = frame.pop();');
            this.emitLine('return new runtime.SafeString(' + bufferId + ');');
            this.emitLine('});');
            this.popBufferId();
    
            return funcId;
        },
    
        compileMacro: function(node, frame) {
            var funcId = this._compileMacro(node, frame);
    
            // Expose the macro to the templates
            var name = node.name.value;
            frame.set(name, funcId);
    
            if(frame.parent) {
                this.emitLine('frame.set("' + name + '", ' + funcId + ');');
            }
            else {
                if(node.name.value.charAt(0) !== '_') {
                    this.emitLine('context.addExport("' + name + '");');
                }
                this.emitLine('context.setVariable("' + name + '", ' + funcId + ');');
            }
        },
    
        compileCaller: function(node, frame) {
            // basically an anonymous "macro expression"
            this.emit('(function (){');
            var funcId = this._compileMacro(node, frame);
            this.emit('return ' + funcId + ';})()');
        },
    
        compileImport: function(node, frame) {
            var id = this.tmpid();
            var target = node.target.value;
    
            this.emit('env.getTemplate(');
            this._compileExpression(node.template, frame);
            this.emitLine(', false, '+this._templateName()+', ' + this.makeCallback(id));
            this.addScopeLevel();
    
            this.emitLine(id + '.getExported(' +
                (node.withContext ? 'context.getVariables(), frame.push(), ' : '') +
                this.makeCallback(id));
            this.addScopeLevel();
    
            frame.set(target, id);
    
            if(frame.parent) {
                this.emitLine('frame.set("' + target + '", ' + id + ');');
            }
            else {
                this.emitLine('context.setVariable("' + target + '", ' + id + ');');
            }
        },
    
        compileFromImport: function(node, frame) {
            var importedId = this.tmpid();
    
            this.emit('env.getTemplate(');
            this._compileExpression(node.template, frame);
            this.emitLine(', false, '+this._templateName()+', ' + this.makeCallback(importedId));
            this.addScopeLevel();
    
            this.emitLine(importedId + '.getExported(' +
                (node.withContext ? 'context.getVariables(), frame.push(), ' : '') +
                this.makeCallback(importedId));
            this.addScopeLevel();
    
            lib.each(node.names.children, function(nameNode) {
                var name;
                var alias;
                var id = this.tmpid();
    
                if(nameNode instanceof nodes.Pair) {
                    name = nameNode.key.value;
                    alias = nameNode.value.value;
                }
                else {
                    name = nameNode.value;
                    alias = name;
                }
    
                this.emitLine('if(' + importedId + '.hasOwnProperty("' + name + '")) {');
                this.emitLine('var ' + id + ' = ' + importedId + '.' + name + ';');
                this.emitLine('} else {');
                this.emitLine('cb(new Error("cannot import \'' + name + '\'")); return;');
                this.emitLine('}');
    
                frame.set(alias, id);
    
                if(frame.parent) {
                    this.emitLine('frame.set("' + alias + '", ' + id + ');');
                }
                else {
                    this.emitLine('context.setVariable("' + alias + '", ' + id + ');');
                }
            }, this);
        },
    
        compileBlock: function(node, frame) {
            if(!this.isChild) {
                var id = this.tmpid();
    
                this.emitLine('context.getBlock("' + node.name.value + '")' +
                              '(env, context, frame, runtime, ' + this.makeCallback(id));
                this.emitLine(this.buffer + ' += ' + id + ';');
                this.addScopeLevel();
            }
        },
    
        compileSuper: function(node, frame) {
            var name = node.blockName.value;
            var id = node.symbol.value;
    
            this.emitLine('context.getSuper(env, ' +
                          '"' + name + '", ' +
                          'b_' + name + ', ' +
                          'frame, runtime, '+
                          this.makeCallback(id));
            this.emitLine(id + ' = runtime.markSafe(' + id + ');');
            this.addScopeLevel();
            frame.set(id, id);
        },
    
        compileExtends: function(node, frame) {
            if(this.isChild) {
                this.fail('compileExtends: cannot extend multiple times',
                          node.template.lineno,
                          node.template.colno);
            }
    
            var k = this.tmpid();
    
            this.emit('env.getTemplate(');
            this._compileExpression(node.template, frame);
            this.emitLine(', true, '+this._templateName()+', ' + this.makeCallback('parentTemplate'));
    
            this.emitLine('for(var ' + k + ' in parentTemplate.blocks) {');
            this.emitLine('context.addBlock(' + k +
                          ', parentTemplate.blocks[' + k + ']);');
            this.emitLine('}');
    
            this.addScopeLevel();
            this.isChild = true;
        },
    
        compileInclude: function(node, frame) {
            var id = this.tmpid();
            var id2 = this.tmpid();
    
            this.emit('env.getTemplate(');
            this._compileExpression(node.template, frame);
            this.emitLine(', false, '+this._templateName()+', '+ this.makeCallback(id));
            this.addScopeLevel();
    
            this.emitLine(id + '.render(' +
                          'context.getVariables(), frame.push(), ' + this.makeCallback(id2));
            this.emitLine(this.buffer + ' += ' + id2);
            this.addScopeLevel();
        },
    
        compileTemplateData: function(node, frame) {
            this.compileLiteral(node, frame);
        },
    
        compileOutput: function(node, frame) {
            var children = node.children;
            for(var i=0, l=children.length; i<l; i++) {
                // TemplateData is a special case because it is never
                // autoescaped, so simply output it for optimization
                if(children[i] instanceof nodes.TemplateData) {
                    if(children[i].value) {
                        this.emit(this.buffer + ' += ');
                        this.compileLiteral(children[i], frame);
                        this.emitLine(';');
                    }
                }
                else {
                    this.emit(this.buffer + ' += runtime.suppressValue(');
                    this.compile(children[i], frame);
                    this.emit(', env.opts.autoescape);\n');
                }
            }
        },
    
        compileRoot: function(node, frame) {
            if(frame) {
                this.fail('compileRoot: root node can\'t have frame');
            }
    
            frame = new Frame();
    
            this.emitFuncBegin('root');
            this._compileChildren(node, frame);
            if(this.isChild) {
                this.emitLine('parentTemplate.rootRenderFunc(env, context, frame, runtime, cb);');
            }
            this.emitFuncEnd(this.isChild);
    
            // When compiling the blocks, they should all act as top-level code
            this.isChild = false;
    
            var blocks = node.findAll(nodes.Block);
            for(var i=0; i<blocks.length; i++) {
                var block = blocks[i];
                var name = block.name.value;
    
                this.emitFuncBegin('b_' + name);
    
                var tmpFrame = new Frame();
                this.compile(block.body, tmpFrame);
                this.emitFuncEnd();
            }
    
            this.emitLine('return {');
            for(var i=0; i<blocks.length; i++) {
                var block = blocks[i];
                var name = 'b_' + block.name.value;
                this.emitLine(name + ': ' + name + ',');
            }
            this.emitLine('root: root\n};');
        },
    
        compile: function (node, frame) {
            var _compile = this['compile' + node.typename];
            if(_compile) {
                _compile.call(this, node, frame);
            }
            else {
                this.fail('compile: Cannot compile node: ' + node.typename,
                          node.lineno,
                          node.colno);
            }
        },
    
        getCode: function() {
            return this.codebuf.join('');
        }
    });
    
    // var c = new Compiler();
    // var src = '{% asyncEach i in arr %}{{ i }}{% else %}empty{% endeach %}';
    // var ast = transformer.transform(parser.parse(src));
    // nodes.printNodes(ast);
    // c.compile(ast);
    // var tmpl = c.getCode();
    // console.log(tmpl);
    
    module.exports = {
        compile: function(src, asyncFilters, extensions, name, opts) {
            var c = new Compiler(name);
    
            // Run the extension preprocessors against the source.
            if(extensions && extensions.length) {
                for(var i=0; i<extensions.length; i++) {
                    if('preprocess' in extensions[i]) {
                        src = extensions[i].preprocess(src, name);
                    }
                }
            }
    
            c.compile(transformer.transform(parser.parse(src,
                                                         extensions,
                                                         opts),
                                            asyncFilters,
                                            name));
            return c.getCode();
        },
    
        Compiler: Compiler
    };
    
  provide("nunjucks/src/compiler", module.exports);
}(global));

// pakmanager:nunjucks/src/filters
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var lib =  require('nunjucks/src/lib');
    var r =  require('nunjucks/src/runtime');
    
    var filters = {
        abs: function(n) {
            return Math.abs(n);
        },
    
        batch: function(arr, linecount, fill_with) {
            var res = [];
            var tmp = [];
    
            for(var i=0; i<arr.length; i++) {
                if(i % linecount === 0 && tmp.length) {
                    res.push(tmp);
                    tmp = [];
                }
    
                tmp.push(arr[i]);
            }
    
            if(tmp.length) {
                if(fill_with) {
                    for(var i=tmp.length; i<linecount; i++) {
                        tmp.push(fill_with);
                    }
                }
    
                res.push(tmp);
            }
    
            return res;
        },
    
        capitalize: function(str) {
            var ret = str.toLowerCase();
            return r.copySafeness(str, ret.charAt(0).toUpperCase() + ret.slice(1));
        },
    
        center: function(str, width) {
            width = width || 80;
    
            if(str.length >= width) {
                return str;
            }
    
            var spaces = width - str.length;
            var pre = lib.repeat(' ', spaces/2 - spaces % 2);
            var post = lib.repeat(' ', spaces/2);
            return r.copySafeness(str, pre + str + post);
        },
    
        'default': function(val, def) {
            return val ? val : def;
        },
    
        dictsort: function(val, case_sensitive, by) {
            if (!lib.isObject(val)) {
                throw new lib.TemplateError('dictsort filter: val must be an object');
            }
    
            var array = [];
            for (var k in val) {
                // deliberately include properties from the object's prototype
                array.push([k,val[k]]);
            }
    
            var si;
            if (by === undefined || by === 'key') {
                si = 0;
            } else if (by === 'value') {
                si = 1;
            } else {
                throw new lib.TemplateError(
                    'dictsort filter: You can only sort by either key or value');
            }
    
            array.sort(function(t1, t2) {
                var a = t1[si];
                var b = t2[si];
    
                if (!case_sensitive) {
                    if (lib.isString(a)) {
                        a = a.toUpperCase();
                    }
                    if (lib.isString(b)) {
                        b = b.toUpperCase();
                    }
                }
    
                return a > b ? 1 : (a === b ? 0 : -1);
            });
    
            return array;
        },
    
        escape: function(str) {
            if(typeof str === 'string' ||
               str instanceof r.SafeString) {
                return lib.escape(str);
            }
            return str;
        },
    
        safe: function(str) {
            return r.markSafe(str);
        },
    
        first: function(arr) {
            return arr[0];
        },
    
        groupby: function(arr, attr) {
            return lib.groupBy(arr, attr);
        },
    
        indent: function(str, width, indentfirst) {
            width = width || 4;
            var res = '';
            var lines = str.split('\n');
            var sp = lib.repeat(' ', width);
    
            for(var i=0; i<lines.length; i++) {
                if(i === 0 && !indentfirst) {
                    res += lines[i] + '\n';
                }
                else {
                    res += sp + lines[i] + '\n';
                }
            }
    
            return r.copySafeness(str, res);
        },
    
        join: function(arr, del, attr) {
            del = del || '';
    
            if(attr) {
                arr = lib.map(arr, function(v) {
                    return v[attr];
                });
            }
    
            return arr.join(del);
        },
    
        last: function(arr) {
            return arr[arr.length-1];
        },
    
        length: function(arr) {
            return arr !== undefined ? arr.length : 0;
        },
    
        list: function(val) {
            if(lib.isString(val)) {
                return val.split('');
            }
            else if(lib.isObject(val)) {
                var keys = [];
    
                if(Object.keys) {
                    keys = Object.keys(val);
                }
                else {
                    for(var k in val) {
                        keys.push(k);
                    }
                }
    
                return lib.map(keys, function(k) {
                    return { key: k,
                             value: val[k] };
                });
            }
            else if(lib.isArray(val)) {
              return val;
            }
            else {
                throw new lib.TemplateError('list filter: type not iterable');
            }
        },
    
        lower: function(str) {
            return str.toLowerCase();
        },
    
        random: function(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        },
    
        rejectattr: function(arr, attr) {
          return arr.filter(function (item) {
            return !item[attr];
          });
        },
    
        selectattr: function(arr, attr) {
          return arr.filter(function (item) {
            return !!item[attr];
          });
        },
    
        replace: function(str, old, new_, maxCount) {
            if (old instanceof RegExp) {
                return str.replace(old, new_);
            }
    
            var res = str;
            var last = res;
            var count = 1;
            res = res.replace(old, new_);
    
            while(last !== res) {
                if(count >= maxCount) {
                    break;
                }
    
                last = res;
                res = res.replace(old, new_);
                count++;
            }
    
            return r.copySafeness(str, res);
        },
    
        reverse: function(val) {
            var arr;
            if(lib.isString(val)) {
                arr = filters.list(val);
            }
            else {
                // Copy it
                arr = lib.map(val, function(v) { return v; });
            }
    
            arr.reverse();
    
            if(lib.isString(val)) {
                return r.copySafeness(val, arr.join(''));
            }
            return arr;
        },
    
        round: function(val, precision, method) {
            precision = precision || 0;
            var factor = Math.pow(10, precision);
            var rounder;
    
            if(method === 'ceil') {
                rounder = Math.ceil;
            }
            else if(method === 'floor') {
                rounder = Math.floor;
            }
            else {
                rounder = Math.round;
            }
    
            return rounder(val * factor) / factor;
        },
    
        slice: function(arr, slices, fillWith) {
            var sliceLength = Math.floor(arr.length / slices);
            var extra = arr.length % slices;
            var offset = 0;
            var res = [];
    
            for(var i=0; i<slices; i++) {
                var start = offset + i * sliceLength;
                if(i < extra) {
                    offset++;
                }
                var end = offset + (i + 1) * sliceLength;
    
                var slice = arr.slice(start, end);
                if(fillWith && i >= extra) {
                    slice.push(fillWith);
                }
                res.push(slice);
            }
    
            return res;
        },
    
        sort: function(arr, reverse, caseSens, attr) {
            // Copy it
            arr = lib.map(arr, function(v) { return v; });
    
            arr.sort(function(a, b) {
                var x, y;
    
                if(attr) {
                    x = a[attr];
                    y = b[attr];
                }
                else {
                    x = a;
                    y = b;
                }
    
                if(!caseSens && lib.isString(x) && lib.isString(y)) {
                    x = x.toLowerCase();
                    y = y.toLowerCase();
                }
    
                if(x < y) {
                    return reverse ? 1 : -1;
                }
                else if(x > y) {
                    return reverse ? -1: 1;
                }
                else {
                    return 0;
                }
            });
    
            return arr;
        },
    
        string: function(obj) {
            return r.copySafeness(obj, obj);
        },
    
        title: function(str) {
            var words = str.split(' ');
            for(var i = 0; i < words.length; i++) {
                words[i] = filters.capitalize(words[i]);
            }
            return r.copySafeness(str, words.join(' '));
        },
    
        trim: function(str) {
            return r.copySafeness(str, str.replace(/^\s*|\s*$/g, ''));
        },
    
        truncate: function(input, length, killwords, end) {
            var orig = input;
            length = length || 255;
    
            if (input.length <= length)
                return input;
    
            if (killwords) {
                input = input.substring(0, length);
            } else {
                var idx = input.lastIndexOf(' ', length);
                if(idx === -1) {
                    idx = length;
                }
    
                input = input.substring(0, idx);
            }
    
            input += (end !== undefined && end !== null) ? end : '...';
            return r.copySafeness(orig, input);
        },
    
        upper: function(str) {
            return str.toUpperCase();
        },
    
        urlencode: function(obj) {
            var enc = encodeURIComponent;
            if (lib.isString(obj)) {
                return enc(obj);
            } else {
                var parts;
                if (lib.isArray(obj)) {
                    parts = obj.map(function(item) {
                        return enc(item[0]) + '=' + enc(item[1]);
                    })
                } else {
                    parts = [];
                    for (var k in obj) {
                        if (obj.hasOwnProperty(k)) {
                            parts.push(enc(k) + '=' + enc(obj[k]));
                        }
                    }
                }
                return parts.join('&');
            }
        },
    
        urlize: function(str, length, nofollow) {
            if (isNaN(length)) length = Infinity;
    
            var noFollowAttr = (nofollow === true ? ' rel="nofollow"' : '');
    
            // For the jinja regexp, see
            // https://github.com/mitsuhiko/jinja2/blob/f15b814dcba6aa12bc74d1f7d0c881d55f7126be/jinja2/utils.py#L20-L23
            var puncRE = /^(?:\(|<|&lt;)?(.*?)(?:\.|,|\)|\n|&gt;)?$/;
            // from http://blog.gerv.net/2011/05/html5_email_address_regexp/
            var emailRE = /^[\w.!#$%&'*+\-\/=?\^`{|}~]+@[a-z\d\-]+(\.[a-z\d\-]+)+$/i;
            var httpHttpsRE = /^https?:\/\/.*$/;
            var wwwRE = /^www\./;
            var tldRE = /\.(?:org|net|com)(?:\:|\/|$)/;
    
            var words = str.split(/\s+/).filter(function(word) {
              // If the word has no length, bail. This can happen for str with
              // trailing whitespace.
              return word && word.length;
            }).map(function(word) {
              var matches = word.match(puncRE);
    
    
              var possibleUrl = matches && matches[1] || word;
    
    
              // url that starts with http or https
              if (httpHttpsRE.test(possibleUrl))
                return '<a href="' + possibleUrl + '"' + noFollowAttr + '>' + possibleUrl.substr(0, length) + '</a>';
    
              // url that starts with www.
              if (wwwRE.test(possibleUrl))
                return '<a href="http://' + possibleUrl + '"' + noFollowAttr + '>' + possibleUrl.substr(0, length) + '</a>';
    
              // an email address of the form username@domain.tld
              if (emailRE.test(possibleUrl))
                return '<a href="mailto:' + possibleUrl + '">' + possibleUrl + '</a>';
    
              // url that ends in .com, .org or .net that is not an email address
              if (tldRE.test(possibleUrl))
                return '<a href="http://' + possibleUrl + '"' + noFollowAttr + '>' + possibleUrl.substr(0, length) + '</a>';
    
              return word;
    
            });
    
            return words.join(' ');
        },
    
        wordcount: function(str) {
            var words = (str) ? str.match(/\w+/g) : null;
            return (words) ? words.length : null;
        },
    
        'float': function(val, def) {
            var res = parseFloat(val);
            return isNaN(res) ? def : res;
        },
    
        'int': function(val, def) {
            var res = parseInt(val, 10);
            return isNaN(res) ? def : res;
        }
    };
    
    // Aliases
    filters.d = filters['default'];
    filters.e = filters.escape;
    
    module.exports = filters;
    
  provide("nunjucks/src/filters", module.exports);
}(global));

// pakmanager:nunjucks/src/loaders
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  if(typeof window === 'undefined' || window !== this) {
        module.exports =  require('nunjucks/src/node-loaders');
    }
    else {
        module.exports =  require('nunjucks/src/web-loaders');
    }
    
  provide("nunjucks/src/loaders", module.exports);
}(global));

// pakmanager:nunjucks/src/globals
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    function cycler(items) {
        var index = -1;
    
        return {
            current: null,
            reset: function() {
                index = -1;
                this.current = null;
            },
    
            next: function() {
                index++;
                if(index >= items.length) {
                    index = 0;
                }
    
                this.current = items[index];
                return this.current;
            },
        };
    
    }
    
    function joiner(sep) {
        sep = sep || ',';
        var first = true;
    
        return function() {
            var val = first ? '' : sep;
            first = false;
            return val;
        };
    }
    
    var globals = {
        range: function(start, stop, step) {
            if(!stop) {
                stop = start;
                start = 0;
                step = 1;
            }
            else if(!step) {
                step = 1;
            }
    
            var arr = [];
            for(var i=start; i<stop; i+=step) {
                arr.push(i);
            }
            return arr;
        },
    
        // lipsum: function(n, html, min, max) {
        // },
    
        cycler: function() {
            return cycler(Array.prototype.slice.call(arguments));
        },
    
        joiner: function(sep) {
            return joiner(sep);
        }
    }
    
    module.exports = globals;
    
  provide("nunjucks/src/globals", module.exports);
}(global));

// pakmanager:nunjucks/src/environment
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var path = require('path');
    var lib =  require('nunjucks/src/lib');
    var Obj =  require('nunjucks/src/object');
    var lexer =  require('nunjucks/src/lexer');
    var compiler =  require('nunjucks/src/compiler');
    var builtin_filters =  require('nunjucks/src/filters');
    var builtin_loaders =  require('nunjucks/src/loaders');
    var runtime =  require('nunjucks/src/runtime');
    var globals =  require('nunjucks/src/globals');
    var Frame = runtime.Frame;
    
    var Environment = Obj.extend({
        init: function(loaders, opts) {
            // The dev flag determines the trace that'll be shown on errors.
            // If set to true, returns the full trace from the error point,
            // otherwise will return trace starting from Template.render
            // (the full trace from within nunjucks may confuse developers using
            //  the library)
            // defaults to false
            var opts = this.opts = opts || {};
            this.opts.dev = !!opts.dev;
    
            // The autoescape flag sets global autoescaping. If true,
            // every string variable will be escaped by default.
            // If false, strings can be manually escaped using the `escape` filter.
            // defaults to false
            this.opts.autoescape = !!opts.autoescape;
    
            this.opts.trimBlocks = !!opts.trimBlocks;
    
            this.opts.lstripBlocks = !!opts.lstripBlocks;
    
            if(!loaders) {
                // The filesystem loader is only available client-side
                if(builtin_loaders.FileSystemLoader) {
                    this.loaders = [new builtin_loaders.FileSystemLoader('views')];
                }
                else {
                    this.loaders = [new builtin_loaders.WebLoader('/views')];
                }
            }
            else {
                this.loaders = lib.isArray(loaders) ? loaders : [loaders];
            }
    
            this.initCache();
            this.filters = {};
            this.asyncFilters = [];
            this.extensions = {};
            this.extensionsList = [];
    
            for(var name in builtin_filters) {
                this.addFilter(name, builtin_filters[name]);
            }
        },
    
        initCache: function() {
            // Caching and cache busting
            lib.each(this.loaders, function(loader) {
                loader.cache = {};
    
                if(typeof loader.on === 'function') {
                    loader.on('update', function(template) {
                        loader.cache[template] = null;
                    });
                }
            });
        },
    
        addExtension: function(name, extension) {
            extension._name = name;
            this.extensions[name] = extension;
            this.extensionsList.push(extension);
        },
    
        getExtension: function(name) {
            return this.extensions[name];
        },
    
        addGlobal: function(name, value) {
            globals[name] = value;
        },
    
        addFilter: function(name, func, async) {
            var wrapped = func;
    
            if(async) {
                this.asyncFilters.push(name);
            }
            this.filters[name] = wrapped;
        },
    
        getFilter: function(name) {
            if(!this.filters[name]) {
                throw new Error('filter not found: ' + name);
            }
            return this.filters[name];
        },
    
        resolveTemplate: function(loader, parentName, filename) {
            var isRelative = (loader.isRelative && parentName)? loader.isRelative(filename) : false;
            return (isRelative && loader.resolve)? loader.resolve(parentName, filename) : filename;
        },
    
        getTemplate: function(name, eagerCompile, parentName, cb) {
            var that = this;
            var tmpl = null;
            if(name && name.raw) {
                // this fixes autoescape for templates referenced in symbols
                name = name.raw;
            }
    
            if(lib.isFunction(parentName)) {
                cb = parentName;
                parentName = null;
                eagerCompile = eagerCompile || false;
            }
    
            if(lib.isFunction(eagerCompile)) {
                cb = eagerCompile;
                eagerCompile = false;
            }
    
            if(typeof name !== 'string') {
                throw new Error('template names must be a string: ' + name);
            }
    
            for (var i = 0; i < this.loaders.length; i++) {
                var _name = this.resolveTemplate(this.loaders[i], parentName, name);
                tmpl = this.loaders[i].cache[_name];
                if (tmpl) break;
            }
    
            if(tmpl) {
                if(eagerCompile) {
                    tmpl.compile();
                }
    
                if(cb) {
                    cb(null, tmpl);
                }
                else {
                    return tmpl;
                }
            } else {
                var syncResult;
    
                lib.asyncIter(this.loaders, function(loader, i, next, done) {
                    function handle(src) {
                        if(src) {
                            src.loader = loader;
                            done(src);
                        }
                        else {
                            next();
                        }
                    }
    
                    // Resolve name relative to parentName
                    name = that.resolveTemplate(loader, parentName, name);
    
                    if(loader.async) {
                        loader.getSource(name, function(err, src) {
                            if(err) { throw err; }
                            handle(src);
                        });
                    }
                    else {
                        handle(loader.getSource(name));
                    }
                }, function(info) {
                    if(!info) {
                        var err = new Error('template not found: ' + name);
                        if(cb) {
                            cb(err);
                        }
                        else {
                            throw err;
                        }
                    }
                    else {
                        var tmpl = new Template(info.src, this,
                                                info.path, eagerCompile);
    
                        if(!info.noCache) {
                            info.loader.cache[name] = tmpl;
                        }
    
                        if(cb) {
                            cb(null, tmpl);
                        }
                        else {
                            syncResult = tmpl;
                        }
                    }
                }.bind(this));
    
                return syncResult;
            }
        },
    
        express: function(app) {
            var env = this;
    
            function NunjucksView(name, opts) {
                this.name          = name;
                this.path          = name;
                this.defaultEngine = opts.defaultEngine;
                this.ext           = path.extname(name);
                if (!this.ext && !this.defaultEngine) throw new Error('No default engine was specified and no extension was provided.');
                if (!this.ext) this.name += (this.ext = ('.' !== this.defaultEngine[0] ? '.' : '') + this.defaultEngine);
            }
    
            NunjucksView.prototype.render = function(opts, cb) {
              env.render(this.name, opts, cb);
            };
    
            app.set('view', NunjucksView);
        },
    
        render: function(name, ctx, cb) {
            if(lib.isFunction(ctx)) {
                cb = ctx;
                ctx = null;
            }
    
            // We support a synchronous API to make it easier to migrate
            // existing code to async. This works because if you don't do
            // anything async work, the whole thing is actually run
            // synchronously.
            var syncResult = null;
    
            this.getTemplate(name, function(err, tmpl) {
                if(err && cb) {
                    cb(err);
                }
                else if(err) {
                    throw err;
                }
                else {
                    tmpl.render(ctx, cb || function(err, res) {
                        if(err) { throw err; }
                        syncResult = res;
                    });
                }
            });
    
            return syncResult;
        },
    
        renderString: function(src, ctx, opts, cb) {
            if(lib.isFunction(opts)) {
                cb = opts;
                opts = {};
            }
            opts = opts || {};
    
            var tmpl = new Template(src, this, opts.path);
            return tmpl.render(ctx, cb);
        }
    });
    
    var Context = Obj.extend({
        init: function(ctx, blocks) {
            this.ctx = ctx;
            this.blocks = {};
            this.exported = [];
    
            for(var name in blocks) {
                this.addBlock(name, blocks[name]);
            }
        },
    
        lookup: function(name) {
            // This is one of the most called functions, so optimize for
            // the typical case where the name isn't in the globals
            if(name in globals && !(name in this.ctx)) {
                return globals[name];
            }
            else {
                return this.ctx[name];
            }
        },
    
        setVariable: function(name, val) {
            this.ctx[name] = val;
        },
    
        getVariables: function() {
            return this.ctx;
        },
    
        addBlock: function(name, block) {
            this.blocks[name] = this.blocks[name] || [];
            this.blocks[name].push(block);
        },
    
        getBlock: function(name) {
            if(!this.blocks[name]) {
                throw new Error('unknown block "' + name + '"');
            }
    
            return this.blocks[name][0];
        },
    
        getSuper: function(env, name, block, frame, runtime, cb) {
            var idx = lib.indexOf(this.blocks[name] || [], block);
            var blk = this.blocks[name][idx + 1];
            var context = this;
    
            if(idx === -1 || !blk) {
                throw new Error('no super block available for "' + name + '"');
            }
    
            blk(env, context, frame, runtime, cb);
        },
    
        addExport: function(name) {
            this.exported.push(name);
        },
    
        getExported: function() {
            var exported = {};
            for(var i=0; i<this.exported.length; i++) {
                var name = this.exported[i];
                exported[name] = this.ctx[name];
            }
            return exported;
        }
    });
    
    var Template = Obj.extend({
        init: function (src, env, path, eagerCompile) {
            this.env = env || new Environment();
    
            if(lib.isObject(src)) {
                switch(src.type) {
                case 'code': this.tmplProps = src.obj; break;
                case 'string': this.tmplStr = src.obj; break;
                }
            }
            else if(lib.isString(src)) {
                this.tmplStr = src;
            }
            else {
                throw new Error('src must be a string or an object describing ' +
                                'the source');
            }
    
            this.path = path;
    
            if(eagerCompile) {
                lib.withPrettyErrors(this.path,
                                     this.env.dev,
                                     this._compile.bind(this));
            }
            else {
                this.compiled = false;
            }
        },
    
        render: function(ctx, frame, cb) {
            if (typeof ctx === 'function') {
                cb = ctx;
                ctx = {};
            }
            else if (typeof frame === 'function') {
                cb = frame;
                frame = null;
            }
    
            return lib.withPrettyErrors(this.path, this.env.dev, function() {
    
                // Catch compile errors for async rendering
                try {
                    this.compile();
                } catch (e) {
                    if (cb) return cb(e);
                    else throw e;
                }
    
                var context = new Context(ctx || {}, this.blocks);
                var syncResult = null;
    
                this.rootRenderFunc(this.env,
                                    context,
                                    frame || new Frame(),
                                    runtime,
                                    cb || function(err, res) {
                                        if(err) { throw err; }
                                        syncResult = res;
                                    });
    
                return syncResult;
            }.bind(this));
        },
    
    
        getExported: function(ctx, frame, cb) {
            if (typeof ctx === 'function') {
                cb = ctx;
                ctx = {};
            }
    
            if (typeof frame === 'function') {
                cb = frame;
                frame = null;
            }
    
            // Catch compile errors for async rendering
            try {
                this.compile();
            } catch (e) {
                if (cb) return cb(e);
                else throw e;
            }
    
            // Run the rootRenderFunc to populate the context with exported vars
            var context = new Context(ctx || {}, this.blocks);
            this.rootRenderFunc(this.env,
                                context,
                                frame || new Frame(),
                                runtime,
                                function() {
                                    cb(null, context.getExported());
                                });
        },
    
        compile: function() {
            if(!this.compiled) {
                this._compile();
            }
        },
    
        _compile: function() {
            var props;
    
            if(this.tmplProps) {
                props = this.tmplProps;
            }
            else {
                var source = compiler.compile(this.tmplStr,
                                              this.env.asyncFilters,
                                              this.env.extensionsList,
                                              this.path,
                                              this.env.opts);
    
                var func = new Function(source);
                props = func();
            }
    
            this.blocks = this._getBlocks(props);
            this.rootRenderFunc = props.root;
            this.compiled = true;
        },
    
        _getBlocks: function(props) {
            var blocks = {};
    
            for(var k in props) {
                if(k.slice(0, 2) === 'b_') {
                    blocks[k.slice(2)] = props[k];
                }
            }
    
            return blocks;
        }
    });
    
    // test code
    // var src = '{% macro foo() %}{% include "include.html" %}{% endmacro %}{{ foo() }}';
    // var env = new Environment(new builtin_loaders.FileSystemLoader('../tests/templates', true), { dev: true });
    // console.log(env.renderString(src, { name: 'poop' }));
    
    module.exports = {
        Environment: Environment,
        Template: Template
    };
    
  provide("nunjucks/src/environment", module.exports);
}(global));

// pakmanager:nunjucks/src/precompile
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var fs = require('fs');
    var path = require('path');
    var lib =  require('nunjucks/src/lib');
    var compiler =  require('nunjucks/src/compiler');
    var Environment =  require('nunjucks/src/environment').Environment;
    
    function match(filename, patterns) {
        if (!Array.isArray(patterns)) return false;
        return patterns.some(function (pattern) {
            return filename.match(pattern) !== null;
        });
    }
    
    function precompileString(str, opts) {
        opts = opts || {};
        opts.isString = true;
        return precompile(str, opts);
    }
    
    function precompile(input, opts) {
        // The following options are available:
        //
        // * name: name of the template (auto-generated when compiling a directory)
        // * isString: input is a string, not a file path
        // * asFunction: generate a callable function
        // * force: keep compiling on error
        // * env: the Environment to use (gets extensions and async filters from it)
        // * include: which file/folders to include (folders are auto-included, files are auto-excluded)
        // * exclude: which file/folders to exclude (folders are auto-included, files are auto-excluded)
    
        opts = opts || {};
        var env = opts.env || new Environment([]);
        var asyncFilters = env.asyncFilters;
        var extensions = env.extensionsList;
    
        var pathStats = fs.existsSync(input) && fs.statSync(input);
        var output = '';
        var templates = [];
    
        function addTemplates(dir) {
            var files = fs.readdirSync(dir);
    
            for(var i=0; i<files.length; i++) {
                var filepath = path.join(dir, files[i]);
                var subpath = filepath.substr(path.join(input, '/').length);
                var stat = fs.statSync(filepath);
    
                if(stat && stat.isDirectory()) {
                    subpath += '/';
                    if (!match(subpath, opts.exclude)) {
                        addTemplates(filepath);
                    }
                }
                else if(match(subpath, opts.include)) {
                    templates.push(filepath);
                }
            }
        }
    
        if(opts.isString) {
            if(!opts.name) {
                throw new Error('the "name" option is required when ' +
                                'compiling a string');
            }
    
            return _precompile(input,
                               opts.name,
                               env,
                               opts.asFunction);
        }
        else if(pathStats.isFile()) {
            return _precompile(fs.readFileSync(input, 'utf-8'),
                               opts.name || input,
                               env,
                               opts.asFunction);
        }
        else if(pathStats.isDirectory()) {
            addTemplates(input);
    
            for(var i=0; i<templates.length; i++) {
                var name = templates[i].replace(path.join(input, '/'), '');
    
                try {
                    output += _precompile(fs.readFileSync(templates[i], 'utf-8'),
                                          name,
                                          env,
                                          opts.asFunction);
                } catch(e) {
                    if(opts.force) {
                        // Don't stop generating the output if we're
                        // forcing compilation.
                        console.error(e);
                    }
                    else {
                        throw e;
                    }
                }
            }
    
            return output;
        }
    }
    
    function _precompile(str, name, env, asFunction) {
        env = env || new Environment([]);
    
        var asyncFilters = env.asyncFilters;
        var extensions = env.extensionsList;
    
        var out = '(function() {' +
            '(window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})' +
            '["' + name.replace(/\\/g, '/') + '"] = (function() {';
    
        out += lib.withPrettyErrors(
            name,
            false,
            function() {
                return compiler.compile(str,
                                        asyncFilters,
                                        extensions,
                                        name);
            }
        );
        out += '})();\n';
    
        if(asFunction) {
            out += 'return function(ctx, cb) { return nunjucks.render("' + name + '", ctx, cb); }';
        }
    
        out += '})();\n';
        return out;
    }
    
    module.exports = {
        precompile: precompile,
        precompileString: precompileString
    }
    
  provide("nunjucks/src/precompile", module.exports);
}(global));

// pakmanager:nunjucks
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    var lib =  require('nunjucks/src/lib');
    var env =  require('nunjucks/src/environment');
    var compiler =  require('nunjucks/src/compiler');
    var parser =  require('nunjucks/src/parser');
    var lexer =  require('nunjucks/src/lexer');
    var runtime =  require('nunjucks/src/runtime');
    var Loader =  require('nunjucks/src/loader');
    var loaders =  require('nunjucks/src/loaders');
    var precompile =  require('nunjucks/src/precompile');
    
    module.exports = {};
    module.exports.Environment = env.Environment;
    module.exports.Template = env.Template;
    
    module.exports.Loader = Loader;
    module.exports.FileSystemLoader = loaders.FileSystemLoader;
    module.exports.WebLoader = loaders.WebLoader;
    
    module.exports.compiler = compiler;
    module.exports.parser = parser;
    module.exports.lexer = lexer;
    module.exports.runtime = runtime;
    
    // A single instance of an environment, since this is so commonly used
    
    var e;
    module.exports.configure = function(templatesPath, opts) {
        opts = opts || {};
        if(lib.isObject(templatesPath)) {
            opts = templatesPath;
            templatesPath = null;
        }
    
        var noWatch = 'watch' in opts ? !opts.watch : false;
        var loader = loaders.FileSystemLoader || loaders.WebLoader;
        e = new env.Environment(new loader(templatesPath, noWatch), opts);
    
        if(opts && opts.express) {
            e.express(opts.express);
        }
    
        return e;
    };
    
    module.exports.compile = function(src, env, path, eagerCompile) {
        if(!e) {
            module.exports.configure();
        }
        return new module.exports.Template(src, env, path, eagerCompile);
    };
    
    module.exports.render = function(name, ctx, cb) {
        if(!e) {
            module.exports.configure();
        }
    
        return e.render(name, ctx, cb);
    };
    
    module.exports.renderString = function(src, ctx, cb) {
        if(!e) {
            module.exports.configure();
        }
    
        return e.renderString(src, ctx, cb);
    };
    
    if(precompile) {
        module.exports.precompile = precompile.precompile;
        module.exports.precompileString = precompile.precompileString;
    }
    
  provide("nunjucks", module.exports);
}(global));

// pakmanager:wolverinejs/wolv/controllers
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require('fs')
    	, path = require('path')
    	, glob = require('glob')
    	, appRoot = require('app-root-path').path
    	;
    
    
    
    	glob.sync( appRoot + '/app/controllers/**/*.js' ).forEach( function( file ) {
    	
    		var filename = file.substr(0, file.indexOf('.'));
    		var splitname = filename.split('controllers/');
    		var moduleName =  splitname[splitname.length-1];
    		
    		moduleName = moduleName.replace('/', '.');
    	  	exports[moduleName] = require( path.resolve( file ) );
    	});
    
    
    
  provide("wolverinejs/wolv/controllers", module.exports);
}(global));

// pakmanager:wolverinejs/wolv/models
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require('fs')
    	, path = require('path')
    	, glob = require('glob')
    	, appRoot = require('app-root-path').path
    	;
    
    module.exports = function(){
    
    	glob.sync( appRoot + '/app/models/**/*.js' ).forEach( function( file ) {
    	  	require( path.resolve( file ) );
    	});
    
    
    }
  provide("wolverinejs/wolv/models", module.exports);
}(global));

// pakmanager:wolverinejs/wolv/config/routes
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var path = require('path')
      	, appRoot = require('app-root-path');
    
      module.exports = function( app , express , controller ){
      		
      		var router = express.Router();
    		routes = require(appRoot+ '/config/routes')( router  , controller);		
    		app.use(routes);  
      }
  provide("wolverinejs/wolv/config/routes", module.exports);
}(global));

// pakmanager:wolverinejs/wolv/config/index
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var cookieParser = require('cookie-parser')
       , bodyParser = require('body-parser')
       ;
    
    module.exports = function( app ){
    
    	// general configuration 
    	app.use(bodyParser.json());
    	app.use(bodyParser.urlencoded({ extended: false }));
    	app.use(cookieParser());
    
    	
    	
    }	
  provide("wolverinejs/wolv/config/index", module.exports);
}(global));

// pakmanager:wolverinejs/wolv/config/view
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var nunjucks = require('nunjucks')
    	, fs = require('fs')
    	, path = require('path')
    	, appRoot = require('app-root-path').path
    	;
    
    
      module.exports = function( app ,express ){
    
    		// static file 
    		app.use( express.static(path.join( appRoot , 'public')) );
    
    	 
    		var nunjucksEnv = new nunjucks.Environment(
    			 new nunjucks.FileSystemLoader( path.join( appRoot, '/app/views' ) )
    		);
    		nunjucksEnv.express( app );
    
    
    
    
      }
  provide("wolverinejs/wolv/config/view", module.exports);
}(global));

// pakmanager:wolverinejs/wolv/config/http
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var http = require('http');
    
      module.exports = function( app ){
    
    		var port = normalizePort(process.env.PORT || '3000');
    		app.set('port', port);
    		var server = http.createServer(app);
    		server.listen(port);
    		console.log("starting server");
    
    		function normalizePort(val) {
    		  var port = parseInt(val, 10);
    			  if (isNaN(port))  return val;
    			  if (port >= 0)  return port;		  
    		  return false;
    		}
    
      }
    
    
    
    
    
    
    
    
    		
    
    
    
  provide("wolverinejs/wolv/config/http", module.exports);
}(global));

// pakmanager:wolverinejs/wolv/boostrap.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var express = require('express')  
    	, app = express()
    	;
    
    
    
    
    var controller =  require('wolverinejs/wolv/controllers');
    
     require('wolverinejs/wolv/models')();
    
     require('wolverinejs/wolv/config/routes')(app , express , controller);
     require('wolverinejs/wolv/config/index')(app);
     require('wolverinejs/wolv/config/view')(app,express);
     require('wolverinejs/wolv/config/http')(app);
    
    
    
    
    
    
    
    
    
    
  provide("wolverinejs/wolv/boostrap.js", module.exports);
}(global));

// pakmanager:wolverinejs
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports =  require('wolverinejs/wolv/boostrap.js');
    
  provide("wolverinejs", module.exports);
}(global));